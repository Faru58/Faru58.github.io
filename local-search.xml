<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>飞行棋实现</title>
    <link href="/2022/05/06/CSharp/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/05/06/CSharp/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>飞行棋</p><span id="more"></span><p><strong># 实现结果</strong></p><iframe src="//player.bilibili.com/player.html?aid=553774900&bvid=BV17v4y1K7i2&cid=713732660&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace CSharp基础实践教学&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            #region 1 控制台初始化            int w &#x3D; 50;            int h &#x3D; 30;            ConsoleInit(w, h);            #endregion            #region 2 场景选择相关            &#x2F;&#x2F;申明一个 表示场景标识的 变量             E_SceneType nowSceneType &#x3D; E_SceneType.Begin;            while (true)            &#123;                switch (nowSceneType)                &#123;                    case E_SceneType.Begin:                        &#x2F;&#x2F;开始场景逻辑                        Console.Clear();                        &#x2F;&#x2F;来书写 开始场景相关的逻辑即可                        BeginOrEndScene(w, h, ref nowSceneType);                        break;                    case E_SceneType.Game:                        &#x2F;&#x2F;游戏场景逻辑                        Console.Clear();                        &#x2F;&#x2F;通过函数来处理游戏场景的逻辑内容                        GameScene(w, h, ref nowSceneType);                        break;                    case E_SceneType.End:                        &#x2F;&#x2F;结束场景逻辑                        Console.Clear();                        BeginOrEndScene(w, h, ref nowSceneType);                        break;                    default:                        break;                &#125;            &#125;            #endregion        &#125;        #region 1 控制台初始化        static void ConsoleInit(int w, int h)        &#123;            &#x2F;&#x2F;基础设置            &#x2F;&#x2F;光标的隐藏            Console.CursorVisible &#x3D; false;            &#x2F;&#x2F;舞台的大小            Console.SetWindowSize(w, h);            Console.SetBufferSize(w, h);        &#125;        #endregion        #region 3 开始场景逻辑 + 8 结束场景逻辑        static void BeginOrEndScene(int w, int h, ref E_SceneType nowSceneType)        &#123;            Console.ForegroundColor &#x3D; ConsoleColor.White;            Console.SetCursorPosition(nowSceneType &#x3D;&#x3D; E_SceneType.Begin ? w &#x2F; 2 - 3 : w &#x2F; 2 - 4, 8);            Console.Write(nowSceneType &#x3D;&#x3D; E_SceneType.Begin ? &quot;飞行棋&quot; : &quot;游戏结束&quot;);            &#x2F;&#x2F;当前选项的编号            int nowSelIndex &#x3D; 0;            bool isQuitBegin &#x3D; false;            &#x2F;&#x2F;开始场景逻辑处理循环            while (true)            &#123;                Console.SetCursorPosition(nowSceneType &#x3D;&#x3D; E_SceneType.Begin ? w &#x2F; 2 - 4 : w &#x2F; 2 - 5, 13);                Console.ForegroundColor &#x3D; nowSelIndex &#x3D;&#x3D; 0 ? ConsoleColor.Red : ConsoleColor.White;                Console.Write(nowSceneType &#x3D;&#x3D; E_SceneType.Begin ? &quot;开始游戏&quot; : &quot;回到主菜单&quot;);                Console.SetCursorPosition(w &#x2F; 2 - 4, 15);                Console.ForegroundColor &#x3D; nowSelIndex &#x3D;&#x3D; 1 ? ConsoleColor.Red : ConsoleColor.White;                Console.Write(&quot;退出游戏&quot;);                &#x2F;&#x2F;通过ReadKey可以得到一个输入的枚举类型                switch (Console.ReadKey(true).Key)                &#123;                    case ConsoleKey.W:                        --nowSelIndex;                        if (nowSelIndex &lt; 0)                        &#123;                            nowSelIndex &#x3D; 0;                        &#125;                        break;                    case ConsoleKey.S:                        ++nowSelIndex;                        if (nowSelIndex &gt; 1)                        &#123;                            nowSelIndex &#x3D; 1;                        &#125;                        break;                    case ConsoleKey.J:                        if (nowSelIndex &#x3D;&#x3D; 0)                        &#123;                            &#x2F;&#x2F;进入游戏场景                            &#x2F;&#x2F;1 改变当前场景ID                            nowSceneType &#x3D; nowSceneType &#x3D;&#x3D; E_SceneType.Begin ? E_SceneType.Game : E_SceneType.Begin;                            &#x2F;&#x2F;2 退出当前循环                            isQuitBegin &#x3D; true;                        &#125;                        else                        &#123;                            &#x2F;&#x2F;退出游戏                            Environment.Exit(0);                        &#125;                        break;                &#125;                &#x2F;&#x2F;通过标识决定 是否跳出 开始场景的循环                if (isQuitBegin)                &#123;                    break;                &#125;            &#125;        &#125;        #endregion        #region 游戏场景逻辑        static void GameScene(int w, int h, ref E_SceneType nowSceneType)        &#123;            &#x2F;&#x2F;绘制不变的基本信息            DrawWall(w, h);            &#x2F;&#x2F;绘制地图            &#x2F;&#x2F;初始化一张地图             Map map &#x3D; new Map(14, 3, 80);            map.Draw();            &#x2F;&#x2F;绘制玩家            Player player &#x3D; new Player(0, E_PlayerType.Player);            Player computer &#x3D; new Player(0, E_PlayerType.Computer);            DrawPlayer(player, computer, map);            bool isGameOver &#x3D; false;            &#x2F;&#x2F;游戏场景循环            while (true)            &#123;                &#x2F;&#x2F;之后的游戏逻辑                &#x2F;&#x2F;玩家扔色子逻辑                &#x2F;&#x2F;检测输入                &#x2F;&#x2F;Console.ReadKey(true);                &#x2F;&#x2F;&#x2F;&#x2F;扔色子的逻辑                &#x2F;&#x2F;isGameOver &#x3D; RandomMove(w, h, ref player, ref computer, map);                &#x2F;&#x2F;&#x2F;&#x2F;绘制地图                &#x2F;&#x2F;map.Draw();                &#x2F;&#x2F;&#x2F;&#x2F;绘制玩家                &#x2F;&#x2F;DrawPlayer(player, computer, map);                &#x2F;&#x2F;&#x2F;&#x2F;判断是否要结束游戏                &#x2F;&#x2F;if( isGameOver )                &#x2F;&#x2F;&#123;                &#x2F;&#x2F;    &#x2F;&#x2F;卡住程序 让顽疾按任意键                 &#x2F;&#x2F;    Console.ReadKey(true);                &#x2F;&#x2F;    &#x2F;&#x2F;改变场景ID                &#x2F;&#x2F;    nowSceneType &#x3D; E_SceneType.End;                &#x2F;&#x2F;    &#x2F;&#x2F;直接跳出循环                &#x2F;&#x2F;    break;                &#x2F;&#x2F;&#125;                &#x2F;&#x2F;玩家扔色子                if (PlayerRandoMove(w, h, ref player, ref computer, map, ref nowSceneType))                &#123;                    break;                &#125;                &#x2F;&#x2F;电脑扔色子                if (PlayerRandoMove(w, h, ref computer, ref player, map, ref nowSceneType))                &#123;                    break;                &#125;                &#x2F;&#x2F;电脑扔色子逻辑                &#x2F;&#x2F;检测输入                &#x2F;&#x2F;Console.ReadKey(true);                &#x2F;&#x2F;&#x2F;&#x2F;扔色子的逻辑                &#x2F;&#x2F;isGameOver &#x3D; RandomMove(w, h, ref computer, ref player, map);                &#x2F;&#x2F;&#x2F;&#x2F;绘制地图                &#x2F;&#x2F;map.Draw();                &#x2F;&#x2F;&#x2F;&#x2F;绘制玩家                &#x2F;&#x2F;DrawPlayer(player, computer, map);                &#x2F;&#x2F;&#x2F;&#x2F;判断是否要结束游戏                &#x2F;&#x2F;if (isGameOver)                &#x2F;&#x2F;&#123;                &#x2F;&#x2F;    &#x2F;&#x2F;卡住程序 让顽疾按任意键                 &#x2F;&#x2F;    Console.ReadKey(true);                &#x2F;&#x2F;    &#x2F;&#x2F;改变场景ID                &#x2F;&#x2F;    nowSceneType &#x3D; E_SceneType.End;                &#x2F;&#x2F;    &#x2F;&#x2F;直接跳出循环                &#x2F;&#x2F;    break;                &#x2F;&#x2F;&#125;            &#125;        &#125;        static bool PlayerRandoMove(int w, int h, ref Player p, ref Player otherP, Map map, ref E_SceneType nowSceneType)        &#123;            &#x2F;&#x2F;之后的游戏逻辑            &#x2F;&#x2F;玩家扔色子逻辑            &#x2F;&#x2F;检测输入            Console.ReadKey(true);            &#x2F;&#x2F;扔色子的逻辑            bool isGameOver &#x3D; RandomMove(w, h, ref p, ref otherP, map);            &#x2F;&#x2F;绘制地图            map.Draw();            &#x2F;&#x2F;绘制玩家            DrawPlayer(p, otherP, map);            &#x2F;&#x2F;判断是否要结束游戏            if (isGameOver)            &#123;                &#x2F;&#x2F;卡住程序 让顽疾按任意键                 Console.ReadKey(true);                &#x2F;&#x2F;改变场景ID                nowSceneType &#x3D; E_SceneType.End;                &#x2F;&#x2F;直接跳出循环            &#125;            return isGameOver;        &#125;        #endregion        #region 4 绘制不变内容（红墙 提示等等）        static void DrawWall(int w, int h)        &#123;            Console.ForegroundColor &#x3D; ConsoleColor.Red;            &#x2F;&#x2F;画墙            &#x2F;&#x2F;横着的墙            for (int i &#x3D; 0; i &lt; w; i +&#x3D; 2)            &#123;                &#x2F;&#x2F;最上方的墙                Console.SetCursorPosition(i, 0);                Console.Write(&quot;■&quot;);                &#x2F;&#x2F;最下方的墙                Console.SetCursorPosition(i, h - 1);                Console.Write(&quot;■&quot;);                &#x2F;&#x2F;中间的墙                Console.SetCursorPosition(i, h - 6);                Console.Write(&quot;■&quot;);                Console.SetCursorPosition(i, h - 11);                Console.Write(&quot;■&quot;);            &#125;            &#x2F;&#x2F;竖着的墙            for (int i &#x3D; 0; i &lt; h; i++)            &#123;                &#x2F;&#x2F;最左边                Console.SetCursorPosition(0, i);                Console.Write(&quot;■&quot;);                &#x2F;&#x2F;最右边                Console.SetCursorPosition(w - 2, i);                Console.Write(&quot;■&quot;);            &#125;            &#x2F;&#x2F;文字信息            Console.ForegroundColor &#x3D; ConsoleColor.White;            Console.SetCursorPosition(2, h - 10);            Console.Write(&quot;□:普通格子&quot;);            Console.ForegroundColor &#x3D; ConsoleColor.Blue;            Console.SetCursorPosition(2, h - 9);            Console.Write(&quot;‖:暂停，一回合不懂&quot;);            Console.ForegroundColor &#x3D; ConsoleColor.Red;            Console.SetCursorPosition(26, h - 9);            Console.Write(&quot;●:炸弹，倒退5格&quot;);            Console.ForegroundColor &#x3D; ConsoleColor.Yellow;            Console.SetCursorPosition(2, h - 8);            Console.Write(&quot;¤:时空隧道，随机倒退，暂停，换位置&quot;);            Console.ForegroundColor &#x3D; ConsoleColor.Cyan;            Console.SetCursorPosition(2, h - 7);            Console.Write(&quot;★:玩家&quot;);            Console.ForegroundColor &#x3D; ConsoleColor.Magenta;            Console.SetCursorPosition(12, h - 7);            Console.Write(&quot;▲:电脑&quot;);            Console.ForegroundColor &#x3D; ConsoleColor.DarkGreen;            Console.SetCursorPosition(22, h - 7);            Console.Write(&quot;◎:玩家和电脑重合&quot;);            Console.ForegroundColor &#x3D; ConsoleColor.White;            Console.SetCursorPosition(2, h - 5);            Console.Write(&quot;按任意键开始扔色子&quot;);        &#125;        #endregion        #region 7 绘制玩家        static void DrawPlayer(Player player, Player computer, Map map)        &#123;            &#x2F;&#x2F;重合时            if (player.nowIndex &#x3D;&#x3D; computer.nowIndex)            &#123;                &#x2F;&#x2F;得到重合的位置                Grid grid &#x3D; map.grids[player.nowIndex];                Console.SetCursorPosition(grid.pos.x, grid.pos.y);                Console.ForegroundColor &#x3D; ConsoleColor.DarkGreen;                Console.Write(&quot;◎&quot;);            &#125;            &#x2F;&#x2F;不重合的时候            else            &#123;                player.Draw(map);                computer.Draw(map);            &#125;        &#125;        #endregion        #region 8 扔色子 函数        &#x2F;&#x2F;擦除提示的函数        static void ClearInfo(int h)        &#123;            Console.SetCursorPosition(2, h - 5);            Console.Write(&quot;                                   &quot;);            Console.SetCursorPosition(2, h - 4);            Console.Write(&quot;                                   &quot;);            Console.SetCursorPosition(2, h - 3);            Console.Write(&quot;                                   &quot;);            Console.SetCursorPosition(2, h - 2);            Console.Write(&quot;                                   &quot;);        &#125;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 扔色子函数        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;w&quot;&gt;窗口的宽&lt;&#x2F;param&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;h&quot;&gt;窗口的高&lt;&#x2F;param&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;p&quot;&gt;扔色子的对象&lt;&#x2F;param&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;map&quot;&gt;地图信息&lt;&#x2F;param&gt;        &#x2F;&#x2F;&#x2F; &lt;returns&gt;默认返回false 代表没有结束&lt;&#x2F;returns&gt;        static bool RandomMove(int w, int h, ref Player p, ref Player otherP, Map map)        &#123;            &#x2F;&#x2F;擦除之前显示的提示信息            ClearInfo(h);            &#x2F;&#x2F;根据扔色子的玩家类型 决定信息的颜色            Console.ForegroundColor &#x3D; p.type &#x3D;&#x3D; E_PlayerType.Player ? ConsoleColor.Cyan : ConsoleColor.Magenta;            &#x2F;&#x2F;扔色子之前 判断 玩家是否处于暂停状态            if (p.isPause)            &#123;                Console.SetCursorPosition(2, h - 5);                Console.Write(&quot;处于暂停状态，&#123;0&#125;需要暂停一回合&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;你&quot; : &quot;电脑&quot;);                Console.SetCursorPosition(2, h - 4);                Console.Write(&quot;请按任意键，让&#123;0&#125;开始扔色子&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;电脑&quot; : &quot;你&quot;);                &#x2F;&#x2F;停止暂停                p.isPause &#x3D; false;                return false;            &#125;            &#x2F;&#x2F;扔色子目的 是改变 玩家或者电脑的位置  计算位置的变化            &#x2F;&#x2F;扔色子 随机一个1到6的数 加上去            Random r &#x3D; new Random();            int randomNum &#x3D; r.Next(1, 7);            p.nowIndex +&#x3D; randomNum;            &#x2F;&#x2F;打印扔的点数            Console.SetCursorPosition(2, h - 5);            Console.Write(&quot;&#123;0&#125;扔出的点数为:&#123;1&#125;&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;你&quot; : &quot;电脑&quot;, randomNum);            &#x2F;&#x2F;首先判断是否到终点了            if (p.nowIndex &gt;&#x3D; map.grids.Length - 1)            &#123;                p.nowIndex &#x3D; map.grids.Length - 1;                Console.SetCursorPosition(2, h - 4);                if (p.type &#x3D;&#x3D; E_PlayerType.Player)                &#123;                    Console.Write(&quot;恭喜你，你率先到达了终点&quot;);                &#125;                else                &#123;                    Console.Write(&quot;很遗憾，电脑率到达了终点&quot;);                &#125;                Console.SetCursorPosition(2, h - 3);                Console.Write(&quot;请按任意键结束游戏&quot;);                return true;            &#125;            else            &#123;                &#x2F;&#x2F;没有到终点 就判断 当前对象  到了一个怎么样的格子                Grid grid &#x3D; map.grids[p.nowIndex];                switch (grid.type)                &#123;                    case E_Grid_Type.Normal:                        &#x2F;&#x2F;普通格子不用处理                        Console.SetCursorPosition(2, h - 4);                        Console.Write(&quot;&#123;0&#125;到了一个安全位置&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;你&quot; : &quot;电脑&quot;);                        Console.SetCursorPosition(2, h - 3);                        Console.Write(&quot;请按任意键，让&#123;0&#125;开始扔色子&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;电脑&quot; : &quot;你&quot;);                        break;                    case E_Grid_Type.Boom:                        &#x2F;&#x2F;炸弹退格                        p.nowIndex -&#x3D; 5;                        &#x2F;&#x2F;不能比起点还小                        if (p.nowIndex &lt; 0)                        &#123;                            p.nowIndex &#x3D; 0;                        &#125;                        Console.SetCursorPosition(2, h - 4);                        Console.Write(&quot;&#123;0&#125;踩到了炸弹，退后5格&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;你&quot; : &quot;电脑&quot;);                        Console.SetCursorPosition(2, h - 3);                        Console.Write(&quot;请按任意键，让&#123;0&#125;开始扔色子&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;电脑&quot; : &quot;你&quot;);                        break;                    case E_Grid_Type.Pause:                        &#x2F;&#x2F;暂停一回合                        &#x2F;&#x2F;暂停目前 只有加一个对象的暂停标识  才能知道 下一回合它是不是不能扔色子                        &#x2F;&#x2F;下回合要暂停                        p.isPause &#x3D; true;                        Console.SetCursorPosition(2, h - 4);                        Console.Write(&quot;&#123;0&#125;到达了暂停点，你需要暂停一回合&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;你&quot; : &quot;电脑&quot;);                        Console.SetCursorPosition(2, h - 3);                        Console.Write(&quot;请按任意键，让&#123;0&#125;开始扔色子&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;电脑&quot; : &quot;你&quot;);                        break;                    case E_Grid_Type.Tunnel:                        Console.SetCursorPosition(2, h - 4);                        Console.Write(&quot;&#123;0&#125;踩到了时空隧道&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;你&quot; : &quot;电脑&quot;);                        &#x2F;&#x2F;随机                        randomNum &#x3D; r.Next(1, 91);                        &#x2F;&#x2F;触发 倒退                        if (randomNum &lt;&#x3D; 30)                        &#123;                            p.nowIndex -&#x3D; 5;                            if (p.nowIndex &lt; 0)                            &#123;                                p.nowIndex &#x3D; 0;                            &#125;                            Console.SetCursorPosition(2, h - 3);                            Console.Write(&quot;触发倒退5格&quot;);                        &#125;                        &#x2F;&#x2F;触发 暂停                        else if (randomNum &lt;&#x3D; 60)                        &#123;                            p.isPause &#x3D; true;                            Console.SetCursorPosition(2, h - 3);                            Console.Write(&quot;触发暂停一回合&quot;);                        &#125;                        &#x2F;&#x2F;触发换位置                        else                        &#123;                            int temp &#x3D; p.nowIndex;                            p.nowIndex &#x3D; otherP.nowIndex;                            otherP.nowIndex &#x3D; temp;                            Console.SetCursorPosition(2, h - 3);                            Console.Write(&quot;惊喜，惊喜，双方交换位置&quot;);                        &#125;                        Console.SetCursorPosition(2, h - 2);                        Console.Write(&quot;请按任意键，让&#123;0&#125;开始扔色子&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;电脑&quot; : &quot;你&quot;);                        break;                &#125;            &#125;            &#x2F;&#x2F;默认没有结束            return false;        &#125;        #endregion    &#125;    #region 2 场景选择相关    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 游戏场景枚举类型    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_SceneType    &#123;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 开始场景        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Begin,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 游戏场景        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Game,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 结束场景        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        End,    &#125;    #endregion    #region 5 格子结构体和格子枚举    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 格子类型 枚举    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_Grid_Type    &#123;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 普通格子        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Normal,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 炸弹        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Boom,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 暂停        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Pause,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 时空隧道 随机倒退 暂停 换位置        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Tunnel,    &#125;    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 位置信息结构体 包含xy位置    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    struct Vector2    &#123;        public int x;        public int y;        public Vector2(int x, int y)        &#123;            this.x &#x3D; x;            this.y &#x3D; y;        &#125;    &#125;    struct Grid    &#123;        &#x2F;&#x2F;格子的类型        public E_Grid_Type type;        &#x2F;&#x2F;格子的位置        public Vector2 pos;        &#x2F;&#x2F;初始化构造函数        public Grid(int x, int y, E_Grid_Type type)        &#123;            pos.x &#x3D; x;            pos.y &#x3D; y;            this.type &#x3D; type;        &#125;        public void Draw()        &#123;            &#x2F;&#x2F;提出来的目的 就是少写几行代码 因为他们不管哪种类型 都要设置了位置再画            Console.SetCursorPosition(pos.x, pos.y);            switch (type)            &#123;                &#x2F;&#x2F;普通格子 怎么画                case E_Grid_Type.Normal:                    Console.ForegroundColor &#x3D; ConsoleColor.White;                    Console.Write(&quot;□&quot;);                    break;                &#x2F;&#x2F;炸弹 怎么画                case E_Grid_Type.Boom:                    Console.ForegroundColor &#x3D; ConsoleColor.Red;                    Console.Write(&quot;●&quot;);                    break;                &#x2F;&#x2F;暂停 怎么画                case E_Grid_Type.Pause:                    Console.ForegroundColor &#x3D; ConsoleColor.Blue;                    Console.Write(&quot;‖&quot;);                    break;                &#x2F;&#x2F;时空隧道 怎么画                case E_Grid_Type.Tunnel:                    Console.ForegroundColor &#x3D; ConsoleColor.Yellow;                    Console.Write(&quot;¤&quot;);                    break;            &#125;        &#125;    &#125;    #endregion    #region 6 地图结构体    struct Map    &#123;        public Grid[] grids;        &#x2F;&#x2F;初始化中 初始了 各个格子的类型 和 位置        public Map(int x, int y, int num)        &#123;            grids &#x3D; new Grid[num];            &#x2F;&#x2F;用于位置改变计数的变量            &#x2F;&#x2F;表示X变化的次数            int indexX &#x3D; 0;            &#x2F;&#x2F;表示Y变化的次数            int indexY &#x3D; 0;            &#x2F;&#x2F;x的步长            int stepNum &#x3D; 2;            Random r &#x3D; new Random();            int randomNum;            for (int i &#x3D; 0; i &lt; num; i++)            &#123;                &#x2F;&#x2F;应该初始化 格子类型                randomNum &#x3D; r.Next(0, 101);                &#x2F;&#x2F;设置类型 普通格子                &#x2F;&#x2F;有85%几率 是普通自（首尾两个格子 必为普通格子）                if (randomNum &lt; 85 || i &#x3D;&#x3D; 0 || i &#x3D;&#x3D; num - 1)                &#123;                    grids[i].type &#x3D; E_Grid_Type.Normal;                &#125;                &#x2F;&#x2F;有5%的几率 是炸弹                else if (randomNum &gt;&#x3D; 85 &amp;&amp; randomNum &lt; 90)                &#123;                    grids[i].type &#x3D; E_Grid_Type.Boom;                &#125;                &#x2F;&#x2F;有5%的几率 是暂停                else if (randomNum &gt;&#x3D; 90 &amp;&amp; randomNum &lt; 95)                &#123;                    grids[i].type &#x3D; E_Grid_Type.Pause;                &#125;                &#x2F;&#x2F;有5%的几率 是时空隧道                else                &#123;                    grids[i].type &#x3D; E_Grid_Type.Tunnel;                &#125;                &#x2F;&#x2F;位置应该如何设置                grids[i].pos &#x3D; new Vector2(x, y);                &#x2F;&#x2F;每次循环都应该按一定规则去变化位置吧                &#x2F;&#x2F;加十次                if (indexX &#x3D;&#x3D; 10)                &#123;                    y +&#x3D; 1;                    &#x2F;&#x2F;加一次Y记一次数                    ++indexY;                    if (indexY &#x3D;&#x3D; 2)                    &#123;                        &#x2F;&#x2F;y加了2次过后 把x加的次数记0                        indexX &#x3D; 0;                        indexY &#x3D; 0;                        &#x2F;&#x2F;反向步长                        stepNum &#x3D; -stepNum;                    &#125;                &#125;                else                &#123;                    x +&#x3D; stepNum;                    &#x2F;&#x2F;加一次X记一次数                    ++indexX;                &#125;            &#125;        &#125;        public void Draw()        &#123;            for (int i &#x3D; 0; i &lt; grids.Length; i++)            &#123;                grids[i].Draw();            &#125;        &#125;    &#125;    #endregion    #region 7 玩家枚举和玩家结构体    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 玩家类型枚举    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_PlayerType    &#123;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 玩家        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Player,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 电脑        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Computer,    &#125;    struct Player    &#123;        &#x2F;&#x2F;玩家类型        public E_PlayerType type;        &#x2F;&#x2F;当前所在地图哪一个索引的格子        public int nowIndex;        &#x2F;&#x2F;是否暂停的标识        public bool isPause;        public Player(int index, E_PlayerType type)        &#123;            nowIndex &#x3D; index;            this.type &#x3D; type;            isPause &#x3D; false;        &#125;        public void Draw(Map mapInfo)        &#123;            &#x2F;&#x2F;必须要先得到地图 才能够 得到我在地图上的哪一个格子            &#x2F;&#x2F;从传入的地图中 得到 格子信息            Grid grid &#x3D; mapInfo.grids[nowIndex];            &#x2F;&#x2F;设置位置            Console.SetCursorPosition(grid.pos.x, grid.pos.y);            &#x2F;&#x2F;画 设置颜色 设置图标            switch (type)            &#123;                case E_PlayerType.Player:                    Console.ForegroundColor &#x3D; ConsoleColor.Cyan;                    Console.Write(&quot;★&quot;);                    break;                case E_PlayerType.Computer:                    Console.ForegroundColor &#x3D; ConsoleColor.Magenta;                    Console.Write(&quot;▲&quot;);                    break;            &#125;        &#125;    &#125;    #endregion&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSharp入门实践——简易飞行棋</title>
    <link href="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%A3%8B/"/>
    <url>/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%A3%8B/</url>
    
    <content type="html"><![CDATA[<p>控制台实现简易飞行棋</p><span id="more"></span><p><strong># 游戏逻辑流程图</strong><br>游戏逻辑题直接引用唐老狮课程里的流程图</p><p><strong>## 整体逻辑流程图</strong></p><img src="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%A3%8B/%E6%95%B4%E4%BD%93%E9%80%BB%E8%BE%91%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class=""><p><strong>## 开始场景流程图</strong></p><img src="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%A3%8B/%E5%BC%80%E5%A7%8B%E5%9C%BA%E6%99%AF%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class=""><p><strong>## 游戏场景流程图</strong></p><img src="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%A3%8B/%E5%BC%80%E5%A7%8B%E5%9C%BA%E6%99%AF%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class=""><p><strong>## 结束场景流程图</strong></p><img src="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%A3%8B/%E7%BB%93%E6%9D%9F%E5%9C%BA%E6%99%AF%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class=""><p><strong># 代码实现</strong></p><p>寄 不能实现前一个位置消失 结构体还没搞明白</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace CSharp基础实践教学&#123;    #region 格子结构体（写不来，看答案了）    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 格子类型枚举    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_GridType    &#123;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 普通格子        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Normal,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 炸弹        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Bomb,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 暂停        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Pause,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 时空隧道        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Tunnel,    &#125;    &#x2F;&#x2F;看答案的 可记住    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 位置信息结构体 包含x y位置    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    struct Vector2    &#123;        public int x;        public int y;        public Vector2(int x, int y)        &#123;            this.x &#x3D; x; this.y &#x3D; y;        &#125;    &#125;    &#x2F;&#x2F;格子结构体    struct Grid    &#123;        public E_GridType gridType; &#x2F;&#x2F;格子类型        public Vector2 position; &#x2F;&#x2F;格子位置        &#x2F;&#x2F;构造函数  输入格子位置  格子初始化        public Grid(E_GridType gridType, int x, int y)        &#123;            this.gridType &#x3D; gridType;            position.x &#x3D; x;             position.y &#x3D; y;        &#125;        &#x2F;&#x2F;画格子        public void Draw()        &#123;            &#x2F;&#x2F;控制光标位置  打印选项            Console.SetCursorPosition(position.x, position.y);            switch (gridType)            &#123;                &#x2F;&#x2F;普通格子                case E_GridType.Normal:                    Console.ForegroundColor &#x3D; ConsoleColor.White;                    Console.Write(&#39;□&#39;);                    break;                &#x2F;&#x2F;炸弹                case E_GridType.Bomb:                    Console.ForegroundColor &#x3D; ConsoleColor.Blue;                    Console.Write(&quot;‖&quot;);                    break;                &#x2F;&#x2F;暂停                case E_GridType.Pause:                    Console.ForegroundColor &#x3D; ConsoleColor.Red;                    Console.Write(&quot;●&quot;);                    break;                &#x2F;&#x2F;时空隧道                case E_GridType.Tunnel:                    Console.ForegroundColor &#x3D; ConsoleColor.White;                    Console.Write(&quot;¤&quot;);                    break;            &#125;        &#125;    &#125;    #endregion    #region 地图结构体（写不来，看答案了）    struct Map    &#123;        &#x2F;&#x2F;用一个格子结构体数组 表示地图里的所有格子        public Grid[] grids;        &#x2F;&#x2F;地图初始化构造函数        &#x2F;&#x2F;x, y为棋盘起始点        public Map(int x, int y)        &#123;            grids &#x3D; new Grid[84];            Random r &#x3D; new Random();            int randomNum;            for (int i &#x3D; 0; i &lt; 84; i++)            &#123;                &#x2F;&#x2F;应该初始化 格子类型                randomNum &#x3D; r.Next(0, 100);                &#x2F;&#x2F;设置类型 普通格子                &#x2F;&#x2F;有85%几率 是普通格子 (首尾两个格子 必为普通格子)                if(randomNum &lt; 85 || i &#x3D;&#x3D; 0 || i &#x3D;&#x3D; 95)                &#123;                    grids[i].gridType &#x3D; E_GridType.Normal;                &#125;                &#x2F;&#x2F;有5%几率 是炸弹                if (randomNum &gt;&#x3D; 85 &amp;&amp; randomNum &lt; 90)                &#123;                    grids[i].gridType &#x3D; E_GridType.Bomb;                &#125;                &#x2F;&#x2F;有5%几率 是暂停                if (randomNum &gt;&#x3D; 90 &amp;&amp; randomNum &lt; 95)                &#123;                    grids[i].gridType &#x3D; E_GridType.Pause;                &#125;                &#x2F;&#x2F;有5%几率 是时空隧道                if (randomNum &gt;&#x3D; 95 &amp;&amp; randomNum &lt; 100)                &#123;                    grids[i].gridType &#x3D; E_GridType.Tunnel;                &#125;                &#x2F;&#x2F;设置位置                grids[i].position &#x3D; new Vector2(x, y);                &#x2F;&#x2F;每次循环都应该一定规则去变化位置(每次少4个步长)                if( i &lt;&#x3D; 12 || (i &gt; 56 &amp;&amp; i &lt;&#x3D; 64)  )                &#123;                    y++;                &#125;                else if( (i &gt; 12 &amp;&amp; i &lt;&#x3D; 30) || (i &gt; 64 &amp;&amp; i &lt;&#x3D; 74) )                &#123;                    x +&#x3D; 2;                &#125;                else if( (i &gt; 30 &amp;&amp; i &lt;&#x3D; 42) || (i &gt; 74 &amp;&amp; i &lt;&#x3D; 78) )                &#123;                    y--;                &#125;                else if(( i &gt; 42 &amp;&amp; i &lt;&#x3D; 56) || (i &gt; 78 &amp;&amp; i &lt;&#x3D; 84) )                &#123;                    x -&#x3D; 2;                &#125;            &#125;        &#125;        public void Draw()        &#123;            for (int i &#x3D; 0; i &lt; grids.Length; i++)            &#123;                grids[i].Draw();            &#125;        &#125;    &#125;    #endregion    #region 玩家结构体    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 玩家类型    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_PlayerType    &#123;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 玩家        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        You,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 电脑        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        PC,    &#125;    struct Player    &#123;        public E_PlayerType playerType;        &#x2F;&#x2F;当前位置索引        public int nowIndex;        &#x2F;&#x2F;玩家初始化构造函数        public Player(E_PlayerType playerType, ref int nowIndex)        &#123;            this.playerType &#x3D; playerType;            this.nowIndex &#x3D; nowIndex;        &#125;        &#x2F;&#x2F;画玩家和电脑格子的逻辑 用索引得到所在地图上格子        public void DrawMove( Map mapinfo )        &#123;            &#x2F;&#x2F;从传入的地图得到格子信息            Grid grid &#x3D; mapinfo.grids[nowIndex];            &#x2F;&#x2F;先控制光标位置            Console.SetCursorPosition(grid.position.x, grid.position.y);            &#x2F;&#x2F;判断是画玩家还是电脑            switch(playerType)            &#123;                &#x2F;&#x2F;画玩家                case E_PlayerType.You:                    Console.ForegroundColor &#x3D; ConsoleColor.Cyan;                    Console.WriteLine(&quot;★&quot;);                    break;                case E_PlayerType.PC:                    Console.ForegroundColor &#x3D; ConsoleColor.Magenta;                    Console.WriteLine(&quot;▲&quot;);                    break;            &#125;        &#125;    &#125;    #endregion    internal class Program    &#123;        &#x2F;&#x2F;判断玩家和电脑是否重叠        static void DrawPlayer(Player you, Player PC, Map map)        &#123;            &#x2F;&#x2F;重合的话 Player结构体外部处理            if(you.nowIndex &#x3D;&#x3D; PC.nowIndex)            &#123;                &#x2F;&#x2F;得到重合的位置                Grid grid &#x3D; map.grids[you.nowIndex];                Console.SetCursorPosition(grid.position.x, grid.position.y);                Console.ForegroundColor &#x3D; ConsoleColor.Green;                Console.WriteLine(&quot;◎&quot;);            &#125;            &#x2F;&#x2F;不重合的话 Player结构体内部处理             else            &#123;                you.DrawMove(map);                PC.DrawMove(map);            &#125;        &#125;         static void Main(string[] args)        &#123;            #region 控制台基础设置            &#x2F;&#x2F;控制台大小设置  w表示宽  h表示高            int w &#x3D; 50;            int h &#x3D; 30;            ConsoleInit(w, h);            #endregion            #region 实现多个场景的转换            &#x2F;&#x2F;定义场景ID  初始从开始场景开始            &#x2F;&#x2F;开始场景为0  游戏场景为1  结束场景为2            int nowScene &#x3D; 0; ;            &#x2F;&#x2F;玩家获胜或者电脑获胜的信息            string gameOverInfo;            &#x2F;&#x2F;整体游戏逻辑死循环            while (true)            &#123;                &#x2F;&#x2F;用不同场景ID  进行不同的场景逻辑                &#x2F;&#x2F;用switch实现场景的转换                switch (nowScene)                &#123;                    &#x2F;&#x2F;开始场景                    case 0:                        &#x2F;&#x2F;实现开始场景逻辑                        #region 开始场景逻辑                        &#x2F;&#x2F;清空控制台  以后续添加文字与游戏                        Console.Clear();                        &#x2F;&#x2F;控制光标位置  打印标题                        Console.SetCursorPosition(w &#x2F; 2 - 5, 8);                        Console.Write(&quot;飞行棋小游戏&quot;);                        &#x2F;&#x2F;事先定义想要选择的选项ID 默认初始选择第一个选项(开始游戏)                        &#x2F;&#x2F;开始游戏为0  退出游戏为1                        int nowSelIndex &#x3D; 0;                        &#x2F;&#x2F;开始场景逻辑死循环                        while(true)                        &#123;                            #region 开始场景生成逻辑                                                        &#x2F;&#x2F;控制光标位置  打印选项                            Console.SetCursorPosition(w &#x2F; 2 - 3, 13);                            &#x2F;&#x2F;根据现在选中的选项改变选项的颜色(改变光标前景色)                            &#x2F;&#x2F;选中为红色 未选中为白色                            Console.ForegroundColor &#x3D; nowSelIndex &#x3D;&#x3D; 0 ? ConsoleColor.Red : ConsoleColor.White;                            Console.Write(&quot;开始游戏&quot;);                            &#x2F;&#x2F;逻辑同上                            Console.SetCursorPosition(w &#x2F; 2 - 3, 15);                            Console.ForegroundColor &#x3D; nowSelIndex &#x3D;&#x3D; 1 ? ConsoleColor.Red : ConsoleColor.White;                            Console.Write(&quot;退出游戏&quot;);                            &#x2F;&#x2F;定义玩家输入w为向上选择  输入s为向下选择  输入j为确定选择                            Console.SetCursorPosition(w &#x2F; 2 - 5, 20);                            Console.ForegroundColor &#x3D; ConsoleColor.Yellow;                            Console.Write(&quot;按w向上选择&quot;);                            Console.SetCursorPosition(w &#x2F; 2 - 5, 22);                            Console.ForegroundColor &#x3D; ConsoleColor.Yellow;                            Console.Write(&quot;按s向下选择&quot;);                            Console.SetCursorPosition(w &#x2F; 2 - 3, 24);                            Console.ForegroundColor &#x3D; ConsoleColor.Yellow;                            Console.Write(&quot;按j确定&quot;);                            #endregion                            #region 开始场景跳转逻辑                            &#x2F;&#x2F;因为break只能跳出最近的switch(即下文跳转场景的)  而为结束开始场景逻辑                              &#x2F;&#x2F;需要定义一个标识判断是否跳出开始场景逻辑死循环                            bool isQuitWhile &#x3D; false;                            &#x2F;&#x2F;获取玩家输入  且不显示玩家的输入                            char input &#x3D; Console.ReadKey(true).KeyChar;                            &#x2F;&#x2F;根据玩家输入  转换选中选项  与  确定选择                            switch(input)                            &#123;                                &#x2F;&#x2F;按w的逻辑  大小写Ww均可                                case &#39;W&#39;:                                case &#39;w&#39;:                                    &#x2F;&#x2F;实际上就是让选项ID变为0                                    --nowSelIndex;                                    &#x2F;&#x2F;且若已经是0 不能再减                                    if(nowSelIndex &lt; 0)                                    &#123;                                        nowSelIndex &#x3D; 0;                                    &#125;                                    break;                                &#x2F;&#x2F;按s的逻辑  大小写Ss均可                                case &#39;S&#39;:                                case &#39;s&#39;:                                    &#x2F;&#x2F;实际上就是让选项ID变为0                                    ++nowSelIndex;                                    &#x2F;&#x2F;且若已经是1 不能再加                                    if (nowSelIndex &gt; 1)                                    &#123;                                        nowSelIndex &#x3D; 1;                                    &#125;                                    break;                                &#x2F;&#x2F;按j的逻辑  大小写Jj均可                                case &#39;J&#39;:                                case &#39;j&#39;:                                                                       &#x2F;&#x2F;判断是进入哪个场景                                    &#x2F;&#x2F;进入游戏场景                                    if( nowSelIndex &#x3D;&#x3D; 0)                                    &#123;                                        &#x2F;&#x2F;将场景ID变为1                                        nowScene &#x3D; 1;                                        &#x2F;&#x2F;确定选择后就要进入其他场景  故必须跳出开始场景的死循环                                        &#x2F;&#x2F;即要使判断跳出标识置为true                                        isQuitWhile &#x3D; true;                                    &#125;                                    &#x2F;&#x2F;退出游戏                                    else if(nowSelIndex &#x3D;&#x3D; 1)                                    &#123;                                        &#x2F;&#x2F;关闭控制台(也不需要跳出循环了)                                        Environment.Exit(0);                                    &#125;                                    break;                            &#125;                            &#x2F;&#x2F;若isQuitWhile为true  则跳出开始场景循环                            if (isQuitWhile)                            &#123;                                break;                            &#125;                                #endregion                        &#125;                        #endregion                        break;                    &#x2F;&#x2F;游戏场景                    case 1:                        &#x2F;&#x2F;实现游戏场景逻辑                        #region 游戏场景逻辑                        #region 参数设置                        Console.Clear();                        &#x2F;&#x2F;退出while的标识                        bool isQuitGameWhile &#x3D; false;                        &#x2F;&#x2F;定义骰子的随机数                        Random d &#x3D; new Random();                        int dice;                        &#x2F;&#x2F;设置一个计数位选择是玩家动还是电脑动                        int count &#x3D; 0;                        &#x2F;&#x2F;设置玩家和电脑所在的格数 初始化为0                        int numYou &#x3D; 0;                        int numPC &#x3D; 0;                        &#x2F;&#x2F;设置玩家变量 电脑变量                        Player you &#x3D; new Player(E_PlayerType.You, ref numYou);                        Player PC &#x3D; new Player(E_PlayerType.PC, ref numPC);                        #endregion                        #region 红色墙壁                        DrawWall(w, h);                        #endregion                        #region 绘制棋盘                        Map map &#x3D; new Map(6, 3);                        map.Draw();                        #endregion                        #region 静态信息栏(每种格子类型的含义)                        Console.SetCursorPosition(2, h - 10);                        Console.ForegroundColor &#x3D; ConsoleColor.White;                        Console.WriteLine(&quot;□:普通格子&quot;);                        Console.SetCursorPosition(2, h - 9);                        Console.ForegroundColor &#x3D; ConsoleColor.Blue;                        Console.WriteLine(&quot;‖:暂停,一回合不动&quot;);                        Console.SetCursorPosition(26, h - 9);                        Console.ForegroundColor &#x3D; ConsoleColor.Red;                        Console.WriteLine(&quot;●:炸弹,倒退5格&quot;);                        Console.SetCursorPosition(2, h - 8);                        Console.ForegroundColor &#x3D; ConsoleColor.White;                        Console.WriteLine(&quot;¤:时空隧道,随机倒退,暂停,换位置&quot;);                        Console.SetCursorPosition(2, h - 7);                        Console.ForegroundColor &#x3D; ConsoleColor.Cyan;                        Console.WriteLine(&quot;★:玩家&quot;);                        Console.SetCursorPosition(12, h - 7);                        Console.ForegroundColor &#x3D; ConsoleColor.Magenta;                        Console.WriteLine(&quot;▲:电脑&quot;);                        Console.SetCursorPosition(22, h - 7);                        Console.ForegroundColor &#x3D; ConsoleColor.Green;                        Console.WriteLine(&quot;◎:玩家与电脑重合&quot;);                        #endregion                        #region 动态信息栏(你走几步 电脑走几步)                        Console.SetCursorPosition(2, h - 5);                        Console.ForegroundColor &#x3D; ConsoleColor.White;                        Console.WriteLine(&quot;按任意键开始扔骰子&quot;);                        #endregion                        &#x2F;&#x2F;先打印起始位置                        DrawPlayer(you, PC, map);                        &#x2F;&#x2F;玩家 电脑 是否暂停                        bool youPause &#x3D; false;                        bool PCPause &#x3D; false;                        &#x2F;&#x2F;游戏场景死循环 专门用来检测 玩家输入相关循环                        while (true)                        &#123;                                                            &#x2F;&#x2F;每次输入                            Console.ReadKey(true);                            dice &#x3D; d.Next(1, 7);                            if(youPause)                            &#123;                                &#x2F;&#x2F;玩家暂停一回合 让电脑走                                youPause &#x3D; false;                                count &#x3D; 1;                            &#125;                            if (PCPause)                            &#123;                                &#x2F;&#x2F;电脑暂停一回合 让玩家走                                PCPause &#x3D; false;                                count &#x3D; 0;                            &#125;                            switch (count)                            &#123;                                &#x2F;&#x2F;玩家移动                                case 0:                                    you.nowIndex +&#x3D; dice;                                    &#x2F;&#x2F;玩家的格子先超出地图数                                     if(you.nowIndex &gt; 83)                                    &#123;                                        gameOverInfo &#x3D; &quot;玩家获胜&quot;;                                        isQuitGameWhile &#x3D; true;                                        nowScene &#x3D; 2;                                        break;                                    &#125;                                    Grid grid1 &#x3D; map.grids[you.nowIndex];                                    switch (grid1.gridType)                                    &#123;                                        case E_GridType.Normal:                                            &#x2F;&#x2F;普通格子  切换到电脑移动                                            count++;                                            break;                                        case E_GridType.Bomb:                                            &#x2F;&#x2F;炸弹倒退5格                                            you.nowIndex -&#x3D; 5;                                            &#x2F;&#x2F;不能退出起点                                            if(you.nowIndex &lt; 0)                                            &#123;                                                you.nowIndex &#x3D; 0;                                            &#125;                                            break;                                        case E_GridType.Pause:                                            &#x2F;&#x2F;暂停一回合                                            youPause &#x3D; true;                                            break;                                        case E_GridType.Tunnel:                                            &#x2F;&#x2F;随机 倒退 暂停 和电脑交换位置                                            dice &#x3D; d.Next(1, 91);                                            if(dice &lt; 30) &#x2F;&#x2F;倒退                                            &#123;                                                you.nowIndex -&#x3D; 5;                                            &#125;                                            else if(dice &gt;&#x3D; 30 &amp;&amp; dice &lt;60) &#x2F;&#x2F;暂停                                            &#123;                                                youPause &#x3D; true;                                            &#125;                                            else &#x2F;&#x2F;和电脑交换位置                                            &#123;                                                int t &#x3D; you.nowIndex;                                                you.nowIndex &#x3D; PC.nowIndex;                                                PC.nowIndex &#x3D; t;                                            &#125;                                            break;                                    &#125;                                    DrawPlayer(you, PC, map);                                    &#x2F;&#x2F;切换到电脑移动                                                                    break;                                &#x2F;&#x2F;电脑移动                                case 1:                                    PC.nowIndex +&#x3D; dice;                                    if (PC.nowIndex &gt; 83)                                    &#123;                                        gameOverInfo &#x3D; &quot;电脑获胜&quot;;                                        isQuitGameWhile &#x3D; true;                                        nowScene &#x3D; 2;                                        break;                                    &#125;                                    DrawPlayer(you, PC, map);                                    Grid grid2 &#x3D; map.grids[PC.nowIndex];                                    switch (grid2.gridType)                                    &#123;                                        case E_GridType.Normal:                                            &#x2F;&#x2F;普通格子  切换到玩家移动                                            count--;                                            break;                                        case E_GridType.Bomb:                                            &#x2F;&#x2F;炸弹倒退5格                                            PC.nowIndex -&#x3D; 5;                                            &#x2F;&#x2F;不能退出起点                                            if (PC.nowIndex &lt; 0)                                            &#123;                                                PC.nowIndex &#x3D; 0;                                            &#125;                                            break;                                        case E_GridType.Pause:                                            &#x2F;&#x2F;暂停一回合                                            PCPause &#x3D; true;                                            break;                                        case E_GridType.Tunnel:                                            &#x2F;&#x2F;随机 倒退 暂停 和电脑交换位置                                            dice &#x3D; d.Next(1, 91);                                            if (dice &lt; 30) &#x2F;&#x2F;倒退                                            &#123;                                                PC.nowIndex -&#x3D; 5;                                            &#125;                                            else if (dice &gt;&#x3D; 30 &amp;&amp; dice &lt; 60) &#x2F;&#x2F;暂停                                            &#123;                                                PCPause &#x3D; true;                                            &#125;                                            else &#x2F;&#x2F;和电脑交换位置                                            &#123;                                                int t &#x3D; you.nowIndex;                                                you.nowIndex &#x3D; PC.nowIndex;                                                PC.nowIndex &#x3D; t;                                            &#125;                                            break;                                    &#125;                                    break;                            &#125;                                                        if (isQuitGameWhile)                            &#123;                                break;                            &#125;                        &#125;                        #endregion                            break;                    &#x2F;&#x2F;结束场景                    case 2:                        &#x2F;&#x2F;实现结束场景逻辑                        #region 结束场景逻辑                        &#x2F;&#x2F;清空控制台  以后续添加文字与游戏                        Console.Clear();                        &#x2F;&#x2F;控制光标位置  打印标题                        Console.SetCursorPosition(w &#x2F; 2 - 3, 8);                        Console.Write(&quot;Gameover&quot;);                        &#x2F;&#x2F;可变内容的显示 根据失败或成功 显示内容不同                        Console.ForegroundColor &#x3D; ConsoleColor.Green;                        Console.SetCursorPosition(w &#x2F; 2 - 4, 6);                                                &#x2F;&#x2F;事先定义想要选择的选项ID  默认初始选择第一个选项(重新开始)                        &#x2F;&#x2F;(重新开始为0  退出游戏为1)                        int nowSelEndIndex &#x3D; 0;                        &#x2F;&#x2F;开始场景逻辑死循环                        while (true)                        &#123;                            #region 结束场景生成逻辑                            &#x2F;&#x2F;控制光标位置  打印选项                            Console.SetCursorPosition(w &#x2F; 2 - 3, 13);                            &#x2F;&#x2F;根据现在选中的选项改变选项的颜色(改变光标前景色)                            &#x2F;&#x2F;选中为红色 未选中为白色                            Console.ForegroundColor &#x3D; nowSelEndIndex &#x3D;&#x3D; 0 ? ConsoleColor.Red : ConsoleColor.White;                            Console.Write(&quot;重新开始&quot;);                            &#x2F;&#x2F;逻辑同上                            Console.SetCursorPosition(w &#x2F; 2 - 3, 15);                            Console.ForegroundColor &#x3D; nowSelEndIndex &#x3D;&#x3D; 1 ? ConsoleColor.Red : ConsoleColor.White;                            Console.Write(&quot;退出游戏&quot;);                            &#x2F;&#x2F;定义玩家输入w为向上选择  输入s为向下选择  输入j为确定选择                            Console.SetCursorPosition(w &#x2F; 2 - 5, 20);                            Console.ForegroundColor &#x3D; ConsoleColor.Yellow;                            Console.Write(&quot;按w向上选择&quot;);                            Console.SetCursorPosition(w &#x2F; 2 - 5, 22);                            Console.ForegroundColor &#x3D; ConsoleColor.Yellow;                            Console.Write(&quot;按s向下选择&quot;);                            Console.SetCursorPosition(w &#x2F; 2 - 3, 24);                            Console.ForegroundColor &#x3D; ConsoleColor.Yellow;                            Console.Write(&quot;按j确定&quot;);                            #endregion                            #region 结束场景跳转逻辑                            &#x2F;&#x2F;因为break只能跳出最近的switch(即下文跳转场景的)  而为结束开始场景逻辑                              &#x2F;&#x2F;需要定义一个标识判断是否跳出开始场景逻辑死循环                            bool isQuitEndWhile &#x3D; false;                            &#x2F;&#x2F;获取玩家输入  且不显示玩家的输入                            char input &#x3D; Console.ReadKey(true).KeyChar;                            &#x2F;&#x2F;根据玩家输入  转换选中选项  与  确定选择                            switch (input)                            &#123;                                &#x2F;&#x2F;按w的逻辑  大小写Ww均可                                case &#39;W&#39;:                                case &#39;w&#39;:                                    &#x2F;&#x2F;实际上就是让选项ID变为0                                    --nowSelEndIndex;                                    &#x2F;&#x2F;且若已经是0 不能再减                                    if (nowSelEndIndex &lt; 0)                                    &#123;                                        nowSelEndIndex &#x3D; 0;                                    &#125;                                    break;                                &#x2F;&#x2F;按s的逻辑  大小写Ss均可                                case &#39;S&#39;:                                case &#39;s&#39;:                                    &#x2F;&#x2F;实际上就是让选项ID变为0                                    ++nowSelEndIndex;                                    &#x2F;&#x2F;且若已经是1 不能再加                                    if (nowSelEndIndex &gt; 1)                                    &#123;                                        nowSelEndIndex &#x3D; 1;                                    &#125;                                    break;                                &#x2F;&#x2F;按j的逻辑  大小写Jj均可                                case &#39;J&#39;:                                case &#39;j&#39;:                                    &#x2F;&#x2F;判断是进入哪个场景                                    &#x2F;&#x2F;进入游戏场景                                    if (nowSelEndIndex &#x3D;&#x3D; 0)                                    &#123;                                        &#x2F;&#x2F;将场景ID变为1                                        nowScene &#x3D; 1;                                        &#x2F;&#x2F;确定选择后就要进入其他场景  故必须跳出开始场景的死循环                                        &#x2F;&#x2F;即要使判断跳出标识置为true                                        isQuitEndWhile &#x3D; true;                                    &#125;                                    &#x2F;&#x2F;退出游戏                                    else if (nowSelEndIndex &#x3D;&#x3D; 1)                                    &#123;                                        &#x2F;&#x2F;关闭控制台(也不需要跳出循环了)                                        Environment.Exit(0);                                    &#125;                                    break;                            &#125;                            &#x2F;&#x2F;若isQuitEndWhile为true  则跳出结束场景循环                            if (isQuitEndWhile)                            &#123;                                break;                            &#125;                            #endregion                        &#125;                        #endregion                        break;                &#125;            &#125;            #endregion        &#125;        #region 控制台基础设置        static void ConsoleInit(int w, int h)        &#123;            &#x2F;&#x2F;隐藏光标            Console.CursorVisible &#x3D; false;            &#x2F;&#x2F;设置舞台（控制台）大小            Console.SetWindowSize(w, h);            &#x2F;&#x2F;设置缓冲区大小            Console.SetBufferSize(w, h);        &#125;        #endregion        #region 红色墙壁        static void DrawWall(int w, int h)        &#123;            &#x2F;&#x2F;设置颜色为红色            Console.ForegroundColor &#x3D; ConsoleColor.Red;            &#x2F;&#x2F;画墙            &#x2F;&#x2F;上方墙 下方墙 中间墙1 中间墙2            for (int i &#x3D; 0; i &lt;&#x3D; w - 2; i +&#x3D; 2)            &#123;                Console.SetCursorPosition(i, 0); &#x2F;&#x2F;上方墙                Console.Write(&#39;■&#39;);                Console.SetCursorPosition(i, h - 1); &#x2F;&#x2F;下方墙                Console.Write(&#39;■&#39;);                Console.SetCursorPosition(i, h - 11); &#x2F;&#x2F;中间墙1                Console.Write(&#39;■&#39;);                Console.SetCursorPosition(i, h - 6); &#x2F;&#x2F;中间墙2                Console.Write(&#39;■&#39;);            &#125;            &#x2F;&#x2F;左边墙 右边墙            for (int i &#x3D; 0; i &lt;&#x3D; h - 1; i++)            &#123;                Console.SetCursorPosition(0, i); &#x2F;&#x2F;左边墙                Console.Write(&#39;■&#39;);                Console.SetCursorPosition(w - 2, i); &#x2F;&#x2F;右边墙                Console.Write(&#39;■&#39;);            &#125;        &#125;        #endregion    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSharp入门总结</title>
    <link href="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/"/>
    <url>/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>入门总结</p><span id="more"></span><img src="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/summary.png" class="">]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSharp基础总结</title>
    <link href="/2022/05/04/CSharp/CSharp%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"/>
    <url>/2022/05/04/CSharp/CSharp%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>基础总结</p><span id="more"></span><img src="/2022/05/04/CSharp/CSharp%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/summary.png" class="">]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>选择排序</title>
    <link href="/2022/05/04/CSharp/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/05/04/CSharp/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>2022.5.4</p><span id="more"></span><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>重点知识点：<br><strong>选择排序</strong><br>1.基本概念： 新建中间商 遍历依次比较找出极值 放入目标位置<br>2.套路写法：两层循环（外层轮数 内层寻找 初始索引 记录极值）<br>3.优化： 已经完成比较的不参与比较  加一个bool标识判断是否已经有序</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><img src="/2022/05/04/CSharp/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/exam.png" class=""><p>以下是答案：</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson14_选择排序练习题&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;选择排序练习题&quot;);            #region 练习题1               &#x2F;&#x2F;生成随机数组            Random r &#x3D; new Random();            int[] arr &#x3D; new int[20];            for (int i &#x3D; 0; i &lt; arr.Length; i++)            &#123;                arr[i] &#x3D; r.Next(0, 101);            &#125;            &#x2F;&#x2F;选择排序升序排序            Console.WriteLine(&quot;选择排序升序排序结果:&quot;);            for (int m &#x3D; 0; m &lt; arr.Length; m++)            &#123;                int index &#x3D; 0;                int temp;                for (int n &#x3D; 0; n &lt; arr.Length - m; n++)                &#123;                    if (arr[index] &lt; arr[n])                    &#123;                        index &#x3D; n;                    &#125;                &#125;                if(index !&#x3D; arr.Length - m -1 )                &#123;                    temp &#x3D; arr[index];                    arr[index] &#x3D; arr[arr.Length - m - 1];                    arr[arr.Length - m - 1] &#x3D; temp;                &#125;            &#125;            for (int i &#x3D; 0; i &lt; arr.Length; i++)            &#123;                Console.Write(arr[i] + &quot; &quot;);            &#125;            &#x2F;&#x2F;中间间隔            Console.WriteLine();            Console.WriteLine(&quot;*************&quot;);            &#x2F;&#x2F;冒泡排序降序排序            Console.WriteLine(&quot;选择排序降序排序结果:&quot;);            for (int m &#x3D; 0; m &lt; arr.Length; m++)            &#123;                int index &#x3D; 0;                int temp;                for (int n &#x3D; 0; n &lt; arr.Length - m; n++)                &#123;                    if (arr[index] &gt; arr[n])                    &#123;                        index &#x3D; n;                    &#125;                &#125;                if (index !&#x3D; arr.Length - m - 1)                &#123;                    temp &#x3D; arr[index];                    arr[index] &#x3D; arr[arr.Length - m - 1];                    arr[arr.Length - m - 1] &#x3D; temp;                &#125;            &#125;            for (int i &#x3D; 0; i &lt; arr.Length; i++)            &#123;                Console.Write(arr[i] + &quot; &quot;);            &#125;            #endregion        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>冒泡排序</title>
    <link href="/2022/05/04/CSharp/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/05/04/CSharp/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>2022.5.4</p><span id="more"></span><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>重点知识点：<br><strong>冒泡排序</strong><br>1.基本概念： “无序”数组中两两相邻的数不断比较与交换直到“有序”<br>2.套路写法：两层循环（外层轮数 内层比较 满足则交换）<br>3.优化： 已经完成比较的不参与比较  加一个bool标识判断是否已经有序</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><img src="/2022/05/04/CSharp/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/exam.png" class=""><p>以下是答案：</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson13_冒泡排序练习题&#123;    internal class Program    &#123;        #region 练习题2        &#x2F;&#x2F;冒泡排序函数        static void PaiXu( int[] arr, bool upDown)        &#123;            &#x2F;&#x2F;小优化 在循环外声明变量 可以提高一些性能            bool isSort;            int temp;            for (int m &#x3D; 0; m &lt; arr.Length; m++)            &#123;                isSort &#x3D; false;                for (int n &#x3D; 0; n &lt; arr.Length - 1 - m; n++)                &#123;                    if(upDown)                    &#123;                        if (arr[n] &gt; arr[n + 1])                        &#123;                            isSort &#x3D; true;                            temp &#x3D; arr[n];                            arr[n] &#x3D; arr[n + 1];                            arr[n + 1] &#x3D; temp;                        &#125;                    &#125;                    else                    &#123;                        if (arr[n] &lt; arr[n + 1])                        &#123;                            isSort &#x3D; true;                            temp &#x3D; arr[n];                            arr[n] &#x3D; arr[n + 1];                            arr[n + 1] &#x3D; temp;                        &#125;                    &#125;                &#125;                if (!isSort)                &#123;                    break;                &#125;            &#125;            if (upDown)            &#123;                Console.WriteLine(&quot;冒泡排序升序排序结果:&quot;);            &#125;            else            &#123;                Console.WriteLine(&quot;冒泡排序降序排序结果:&quot;);            &#125;            for (int i &#x3D; 0; i &lt; arr.Length; i++)            &#123;                            Console.Write(arr[i] + &quot; &quot;);            &#125;        &#125;        #endregion        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;冒泡排序练习题&quot;);            #region 练习题1            &#x2F;&#x2F;判断是否已经有序 标识符            bool isSort &#x3D; false;            &#x2F;&#x2F;生成随机数组            Random r &#x3D; new Random();            int[] arr1 &#x3D; new int[20];            for (int i &#x3D; 0; i &lt; arr1.Length; i++)            &#123;                arr1[i] &#x3D; r.Next(0, 101);            &#125;            &#x2F;&#x2F;冒泡排序升序排序            Console.WriteLine(&quot;冒泡排序升序排序结果:&quot;);            for(int m &#x3D; 0; m &lt; arr1.Length; m++)            &#123;                isSort &#x3D; false;                for(int n &#x3D; 0; n &lt; arr1.Length - 1 - m; n++)                &#123;                    if(arr1[n] &gt; arr1[n + 1])                    &#123;                        isSort &#x3D; true;                        int temp &#x3D; arr1[n];                        arr1[n] &#x3D; arr1[n + 1];                        arr1[n + 1] &#x3D; temp;                    &#125;                &#125;                if( !isSort )                &#123;                    break;                &#125;            &#125;            for(int i &#x3D; 0; i &lt; arr1.Length; i++)            &#123;                Console.Write(arr1[i] + &quot; &quot;);            &#125;            &#x2F;&#x2F;中间间隔            Console.WriteLine();            Console.WriteLine(&quot;*************&quot;);            &#x2F;&#x2F;冒泡排序降序排序            Console.WriteLine(&quot;冒泡排序降序排序结果:&quot;);            for (int m &#x3D; 0; m &lt; arr1.Length; m++)            &#123;                isSort &#x3D; false;                for (int n &#x3D; 0; n &lt; arr1.Length - 1 - m; n++)                &#123;                    if (arr1[n] &lt; arr1[n + 1])                    &#123;                        isSort &#x3D; true;                        int temp &#x3D; arr1[n];                        arr1[n] &#x3D; arr1[n + 1];                        arr1[n + 1] &#x3D; temp;                    &#125;                &#125;                if (!isSort)                &#123;                    break;                &#125;            &#125;            for (int i &#x3D; 0; i &lt; arr1.Length; i++)            &#123;                Console.Write(arr1[i] + &quot; &quot;);            &#125;            #endregion            &#x2F;&#x2F;中间间隔            Console.WriteLine();            Console.WriteLine(&quot;*************&quot;);            #region 练习题2            &#x2F;&#x2F;生成数组            int[] arr2 &#x3D; new int[20];            for (int i &#x3D; 0; i &lt; arr2.Length; i++)            &#123;                arr2[i] &#x3D; r.Next(0, 101);            &#125;            &#x2F;&#x2F;true代表升序排序 false代表降序排序            PaiXu( arr2, true);            &#x2F;&#x2F;中间间隔            Console.WriteLine();            Console.WriteLine(&quot;*************&quot;);            PaiXu( arr2, false);            #endregion        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构体</title>
    <link href="/2022/05/03/CSharp/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <url>/2022/05/03/CSharp/%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<p>2022.5.3</p><span id="more"></span><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>重点知识点：<br><strong>结构体</strong><br>1.概念： 结构体 struct 是变量和函数的集合 用来表示特定的数据集合<br>2.访问修饰符：用来修饰变量和方法  public-&gt;外部可以调用   private-&gt;只能内部调用   不写默认private<br>3.构造函数：没有返回值 函数名和结构体名相同 可以重载 主要是帮助我们快速初始化结构体对象</p><p>注意：<br>1.在结构体中声明的变量不能初始化  只能在外部或者函数中赋值（初始化）<br>2.在结构体中声明的函数 不用加static</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><img src="/2022/05/03/CSharp/%E7%BB%93%E6%9E%84%E4%BD%93/exam.png" class=""><p>以下是答案：</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson12_结构体练习题&#123;    #region 练习题1    struct Student    &#123;               public string name;        public bool sex;        public int age;        public int lesson;        public string major;        public Student(string name, bool sex, int age, int lesson, string major)        &#123;            this.name &#x3D; name;                       this.sex &#x3D; sex;            this.age &#x3D; age;            this.lesson &#x3D; lesson;            this.major &#x3D; major;        &#125;        public void Information()        &#123;            Console.WriteLine(&quot;学员姓名&#123;0&#125;,性别&#123;1&#125;,年龄&#123;2&#125;,班级&#123;3&#125;,专业&#123;4&#125;&quot;, name, age, age, lesson, major);        &#125;    &#125;    #endregion    #region 练习题2    &#x2F;&#x2F;他们都是访问修饰符 用来修饰变量和方法    &#x2F;&#x2F;private 只能内部调用    &#x2F;&#x2F;public  外部可以调用    #endregion    #region 练习题3    struct Rectangular    &#123;        public int x;        public int y;        public Rectangular(int x, int y)        &#123;            this.x &#x3D; x;            this.y &#x3D; y;        &#125;        public void Information()        &#123;            Console.WriteLine(&quot;矩形的长为&#123;0&#125;,宽为&#123;1&#125;,面积为&#123;2&#125;,周长为&#123;3&#125;&quot;, x, y, x * y, 2 *(x + y));        &#125;    &#125;    #endregion    #region 练习题4    struct PlayerInfo    &#123;        public string name;        public E_Occupation occupation;                public PlayerInfo(string name, E_Occupation occupation)        &#123;            this.name &#x3D; name;            this.occupation &#x3D; occupation;                &#125;        public void AttackInformation()        &#123;            string o &#x3D; &quot;&quot;;            string s &#x3D; &quot;&quot;;            switch (occupation)            &#123;                case E_Occupation.Warrior:                    o &#x3D; &quot;战士&quot;;                    s &#x3D; &quot;冲锋&quot;;                    break;                case E_Occupation.Hunter:                    o &#x3D; &quot;猎人&quot;;                    s &#x3D; &quot;假死&quot;;                    break;                case E_Occupation.Witch:                    o &#x3D; &quot;法师&quot;;                    s &#x3D; &quot;奥术冲击&quot;;                    break;            &#125;            Console.WriteLine(&quot;&#123;0&#125;&#123;1&#125;施放了&#123;2&#125;&quot;, o, name, s);        &#125;    &#125;    enum E_Occupation    &#123;        Warrior,        Hunter,        Witch,    &#125;    #endregion    #region 练习题5    struct Monster    &#123;        public string name;        public int atk;        public Monster(string name)        &#123;            this.name &#x3D; name;            Random r &#x3D; new Random();            atk &#x3D; r.Next( 10, 30 );        &#125;        public void Atk()        &#123;            Console.WriteLine(&quot;&#123;0&#125;的攻击力是&#123;1&#125;&quot;, name, atk);        &#125;    &#125;    #endregion    #region 练习题7    struct UltraMan    &#123;        public string name;        public int atk;        public int def;        public int hp;        public UltraMan(string name, int atk, int def, int hp)        &#123;            this.name &#x3D; name;            this.atk &#x3D; atk;            this.def &#x3D; def;            this.hp &#x3D; hp;                   &#125;        &#x2F;&#x2F;结构体是值类型 想要在函数内部改变值类型信息 外部受影响 一定要用ref或out        public void Attack(ref Boss monster)        &#123;            &#x2F;&#x2F;奥特曼打怪兽的逻辑            monster.hp -&#x3D; atk - monster.def;            Console.WriteLine(&quot;&#123;0&#125;攻击了&#123;1&#125;，造成了&#123;2&#125;点伤害，&#123;1&#125;剩余血量&#123;3&#125;&quot;, name, monster.name, atk - monster.def, monster.hp);        &#125;    &#125;    struct Boss    &#123;        public string name;        public int atk;        public int def;        public int hp;        public Boss(string name, int atk, int def, int hp)        &#123;            this.name &#x3D; name;            this.atk &#x3D; atk;            this.def &#x3D; def;            this.hp &#x3D; hp;        &#125;        public void Attack(ref UltraMan Tiga)        &#123;            &#x2F;&#x2F;怪兽打奥特曼的逻辑            Tiga.hp -&#x3D; atk - Tiga.def;            Console.WriteLine(&quot;&#123;0&#125;攻击了&#123;1&#125;，造成了&#123;2&#125;点伤害，&#123;1&#125;剩余血量&#123;3&#125;&quot;, name, Tiga.name, atk - Tiga.def, Tiga.hp);        &#125;    &#125;    #endregion    internal class Program    &#123;                        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;结构体练习题&quot;);            #region 练习题1            Student s1 &#x3D; new Student(&quot;季宝&quot;, true, 23, 2, &quot;微电子&quot;);            Student s2 &#x3D; new Student(&quot;大逼&quot;, true, 23, 2, &quot;网安&quot;);            s1.Information();            s2.Information();            #endregion            #region 练习题3            Rectangular r1 &#x3D; new Rectangular (5, 4);            r1.Information();            #endregion            #region 练习题4            Console.Write(&quot;请输入玩家名字：&quot;);            string name &#x3D; Console.ReadLine();            Console.Write(&quot;请选择你的职业：（0战士，1猎人，2法师）&quot;);            try             &#123;                E_Occupation o &#x3D; (E_Occupation)int.Parse(Console.ReadLine());                PlayerInfo p1 &#x3D; new PlayerInfo(name ,o);                p1.AttackInformation();            &#125;            catch            &#123;                Console.WriteLine(&quot;请输入数字&quot;);            &#125;            #endregion            #region 练习题6            &#x2F;&#x2F;声明Monster数组            Monster[] monsters &#x3D; new Monster[10];            for (int i &#x3D; 0; i &lt; monsters.Length; i++)            &#123;                monsters[i] &#x3D; new Monster(&quot;怪兽&quot; + i);                monsters[i].Atk();            &#125;            #endregion            #region 练习题7            UltraMan Tiga &#x3D; new UltraMan(&quot;迪迦&quot;, 10, 5, 100);            Boss boss &#x3D; new Boss(&quot;哥斯拉&quot;, 8, 4, 100);            while(true)            &#123;                Tiga.Attack(ref boss);                if( boss.hp &lt;&#x3D; 0)                &#123;                    Console.WriteLine(&quot;迪迦胜利&quot;);                    break;                &#125;                boss.Attack(ref Tiga);                if (Tiga.hp &lt;&#x3D; 0)                &#123;                    Console.WriteLine(&quot;哥斯拉胜利&quot;);                    break;                &#125;                Console.WriteLine(&quot;按任意键继续&quot;);                Console.ReadKey(true);            &#125;            #endregion        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>递归函数</title>
    <link href="/2022/05/03/CSharp/%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/"/>
    <url>/2022/05/03/CSharp/%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>2022.5.3</p><span id="more"></span><h1 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h1><p>重点知识点：<br><strong>递归函数</strong><br>概念： 让函数自己调用自己<br>注意：<br>一个正确的递归函数<br>1.必须有结束调用的条件<br>2.用于条件判断的 这个条件必须改变 能够打到停止的目的</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><img src="/2022/05/03/CSharp/%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/exam.png" class=""><div class="code-wrapper"><pre><code class="csharp">using System;namespace Lesson11_递归函数练习题&#123;    internal class Program    &#123;        #region 练习题1        static void ZeroTen(int a)        &#123;            if(a &gt; 10)            &#123;                return;            &#125;            Console.WriteLine(a);            ZeroTen(++a);        &#125;        #endregion        #region 练习题2        static int Factorial(int a)        &#123;            if(a == 1)            &#123;                return 1;            &#125;            return a * Factorial(--a);//--a应写在后面, 或用a - 1            //若是 Factorial(--a) * a ,后面的a是已经减掉的a,得不到正确结果        &#125;        #endregion        #region 练习题3        static long SumFactorial(int a)        &#123;            if(a == 1)            &#123;                return 1;            &#125;            return Factorial(a) + SumFactorial(--a);        &#125;        #endregion        #region 练习题4        //自己写的        static double ZhuganLength1(int a)        &#123;            if(a == 0)            &#123;                return 100;            &#125;            return 0.5 * ZhuganLength1(--a);        &#125;        //答案        //一是长度 二是天数        static void ZhuganLength2(double length, int day = 0)        &#123;            length /= 2;            ++day;            //第十天砍了后的长度            if (day == 10)            &#123;                Console.WriteLine(&quot;第十天砍后竹竿长&#123;0&#125;米&quot;, length);                return;            &#125;                        ZhuganLength2(length, day);        &#125;        #endregion        #region 练习题5        //看答案的 想不出来短路怎么写        static bool PrintNum(int a)        &#123;            Console.WriteLine(a);                       return a == 200 || PrintNum(a + 1);             //逻辑短路，若逻辑或前面的为真，不执行逻辑或后面的        &#125;                #endregion        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;递归函数练习题&quot;);            //ZeroTen(0);            Console.WriteLine(Factorial(5));            Console.WriteLine(SumFactorial(10));            Console.WriteLine(ZhuganLength1(10));            ZhuganLength2(100, 0);            PrintNum(1);        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏设想(更新中)</title>
    <link href="/2022/05/03/%E9%A1%B9%E7%9B%AE/%E6%B8%B8%E6%88%8F%E8%AE%BE%E6%83%B3-%E6%9B%B4%E6%96%B0%E4%B8%AD/"/>
    <url>/2022/05/03/%E9%A1%B9%E7%9B%AE/%E6%B8%B8%E6%88%8F%E8%AE%BE%E6%83%B3-%E6%9B%B4%E6%96%B0%E4%B8%AD/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="085b8f3c7f5217256b375c6ae6075e8a8adae91a0ade8f8a94c33da807588fd2">1432a7b75e994fca526a11f4c4c29edb5d95ddd08071f06d8e2b1881f40addc49717d4ad2129bf03f288d888dddd593047eece5bda476a758cc60ea414b92c2fde57109810737be6114d7bc1b6b7562288492faa485ce10d9f6299e57b851357b155e4efdd34cbdd97c62497dc707a8984ec16459a2b29863b8efb819d6be55fee9506e4cffd6a89bbbd6344b2f51a0b1deb0385f3209dfde7e16b2730acd43ef49c7653d1401cc12f99952648c7e9fac2e3d036f71ac2a224d882c9eb52b53e8ce41ad4adcb845a1ece03152a88f6b9b4a60f385b7cd2bb197f64876a288ef21ea0f1cd6c1413b5bb87c41430ede2ee3757bf646cb9be07686a61467b31f274ec251a3402c81ab754e4f64b4371f59d3e48b066a9d4374932d26748038e8972751dbd5ccf58182e5c1ffdd89532c2b4d16f4e9e2f1d2ca1aff8bf2b9f1a02ec8cb9b08156183203b1e6d5d9e33805bdfdcf86d2d455b22f3cf0c5256eeeba4ecd62b87719f83f61c86654cd68f2d2cca26593c99c9d37ac15226c4abb48fd006cebb943c3977b2e1e46f10646380aed592825f2f183df4476ec6f707913e8fe88cf823b72bf2aec4dc26fc020a783d26174557db927ca6c764208fa1f0de861d954ea17ba42cba643a0d82b2a34bbe7d1add7f69f822495de81deabf3f37c59366a1ad681568c2d6c73d0fbbe10b4f00148cd62c7e8c8ca89963dfdd89ea0201c6163f7a9d843737c71d4c25a133621e9b429eac7b530ca1162fa2a9c8f83a78239efbf362a28152fd1812b3bd1306bc1ce235d6944e5c6352f6a6d6d14cda004f50ae8f27c35d7eb6ebe68e6246b1766d92f34bbd91f1aafd140c0bdc584aa53d91b49fc7bde567c308953bb3021801af6fcec8d469dd0f7c38b11f9383c63f733c54f7ec71d8221103ac971dd97a1510cb199dad83bda9253e38f3f945571</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">要密码，快滚.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数重载</title>
    <link href="/2022/05/03/CSharp/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/"/>
    <url>/2022/05/03/CSharp/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<p>2022.5.2</p><span id="more"></span><h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><p>重点知识点：<br><strong>函数重载</strong><br>概念： 同一个语句块中，函数名相同，参数数量、类型、顺序不同的函数 就称为函数重载<br>注意： 和返回值无关<br>作用： 一般用来处理不同参数的同一类型的逻辑处理</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><img src="/2022/05/03/CSharp/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/exam.jpg" class=""><p>以下是答案：</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson10_函数重载练习题&#123;    internal class Program    &#123;        #region 练习题1        static int CompareNum(int a, int b)        &#123;            return a &gt; b ? a : b;        &#125;        static float CompareNum(float a, float b)        &#123;            return a &gt; b ? a : b;        &#125;        static double CompareNum(double a, double b)        &#123;            return a &gt; b ? a : b;        &#125;        #endregion        #region 练习题2        static int CompareArray(int[] arr)        &#123;            int max &#x3D; arr[0];            for (int i &#x3D; 1; i &lt; arr.Length; i++)            &#123;                if (arr[i] &gt; max)                    max &#x3D; arr[i];            &#125;            return max;        &#125;        static float CompareArray(float[] arr)        &#123;            float max &#x3D; arr[0];            for (int i &#x3D; 1; i &lt; arr.Length; i++)            &#123;               if (arr[i] &gt; max)                   max &#x3D; arr[i];            &#125;            return max;        &#125;        static double CompareArray(double[] arr)        &#123;            double max &#x3D; arr[0];            for (int i &#x3D; 1; i &lt; arr.Length; i++)            &#123;                f (arr[i] &gt; max)                   max &#x3D; arr[i];            &#125;            return max;        &#125;        #endregion        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;函数重载练习题&quot;);            #region 练习题1            Console.WriteLine(CompareNum(5, 7));            Console.WriteLine(CompareNum(10.9f, 4.5f));            Console.WriteLine(CompareNum(20.975, 100.45));            #endregion            #region 练习题2            int[] arrInt &#x3D; &#123; 1, 4, 5, 8, 6 &#125;;            Console.WriteLine(CompareArray(arrInt));            float[] arrFloat &#x3D; &#123; 2.1f, 4.5f, 5.9f, 8.1f, 5.8f &#125;;            Console.WriteLine(CompareArray(arrFloat));            double[] arrDouble &#x3D; &#123; 1.2, 4.5, 5.8, 8.4, 6.6, 8.5 &#125;;            Console.WriteLine(CompareArray(arrDouble));            #endregion        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>变长参数和参数默认值</title>
    <link href="/2022/05/02/CSharp/%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC/"/>
    <url>/2022/05/02/CSharp/%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>2022.5.2</p><span id="more"></span><h1 id="变长参数和参数默认值"><a href="#变长参数和参数默认值" class="headerlink" title="变长参数和参数默认值"></a>变长参数和参数默认值</h1><p>重点知识点：<br><strong>1 变长参数关键字 params</strong><br>作用： 可以传入n个同类型参数 n可以是0<br>注意：<br>    1.params 后面必须是数组 意味着只能是同一类型的可变参数<br>    2.变长参数只能有一个<br>    3.必须在所有参数后面写变长参数</p><p><strong>2 参数默认值（可选参数）</strong><br>作用：可以给参数默认值 使用时可以不传参 不传用默认的 传了用传的<br>注意：<br>    1.可选参数可以有多个<br>    2.正常参数必须写在可选参数前面，可选参数只能写在所有参数的后面</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><img src="/2022/05/02/CSharp/%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC/exam.jpg" class=""><p>以下是答案：</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson9_变长参数和参数默认值练习题&#123;    internal class Program    &#123;        #region 练习题1        static void SumAndAvg(params int[] arr)        &#123;            int sum &#x3D; 0;            for (int i &#x3D; 0; i &lt; arr.Length; i++)            &#123;                sum +&#x3D; arr[i];            &#125;            double avg &#x3D; sum &#x2F; (double)arr.Length;            Console.WriteLine(&quot;它们的和为&#123;0&#125;,平均数为&#123;1&#125;&quot;, sum, avg);        &#125;        #endregion        #region 练习题2        static void OddEven(params int[] arr)        &#123;            int odd &#x3D; 0, even &#x3D; 0;            for (int i &#x3D; 0; i &lt; arr.Length; i++)            &#123;                if(arr[i] % 2 &#x3D;&#x3D; 0)                &#123;                    even +&#x3D; arr[i];                &#125;                else                &#123;                    odd +&#x3D; arr[i];                &#125;            &#125;            Console.WriteLine(&quot;奇数和为&#123;0&#125;,偶数和为&#123;1&#125;&quot;, odd, even);        &#125;        #endregion        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;变长参数和参数默认值练习题&quot;);            #region 练习题1            SumAndAvg(5, 9, 11, 52);            #endregion            #region 练习题2            OddEven(10, 11, 12);            #endregion        &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ref和out</title>
    <link href="/2022/05/02/CSharp/ref%E5%92%8Cout/"/>
    <url>/2022/05/02/CSharp/ref%E5%92%8Cout/</url>
    
    <content type="html"><![CDATA[<p>2022.5.1</p><span id="more"></span><p>#ref和out</p><p>重点知识点：<br>1.ref和out的作用: 解决值类型和引用类型 在函数内部 改值 或者 重新声明 能够影响外部传入的变量 让其也被修改<br>2.使用上: 就是在声明参数的时候 前面加上ref和out的 关键字即可 使用时同上<br>3.区别：<br> 1.ref传入的变量必须初始化  out不用<br> 2.out传入的变量必须在内部赋值  ref不用</p><p>#练习题</p><img src="/2022/05/02/CSharp/ref%E5%92%8Cout/exam.jpg" class=""><p>以下是答案：</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">static bool Login(int user, int key, ref string info)    &#123;        if(user == 0)        &#123;            //用户名正确的逻辑            if(key == 0)            &#123;                //用户名正确且密码正确的逻辑                info = &quot;登录成功&quot;;            &#125;            else            &#123;                //密码错误的逻辑                info = &quot;密码错误&quot;;                return false;            &#125;        &#125;        else        &#123;            //用户名错误的逻辑            info = &quot;用户名错误&quot;;            return false;        &#125;               return true;    &#125;static void Main(string[] args)    &#123;        Console.WriteLine(&quot;请输入用户名和密码&quot;);            int user = int.Parse(Console.ReadLine());            int key = int.Parse(Console.ReadLine());            string info = &quot;&quot;; //ref需要初始化            while (!Login(user, key, ref info)) //若登录失败继续尝试            &#123;                Console.WriteLine(info); //登录失败直接进入循环 打印登陆失败                Console.WriteLine(&quot;请输入用户名和密码&quot;);                user = int.Parse(Console.ReadLine()); //不需要再声明                key = int.Parse(Console.ReadLine());            &#125;            Console.WriteLine(info);    &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
