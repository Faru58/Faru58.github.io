<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CSharp入门实践——简易飞行棋</title>
    <link href="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%A3%8B/"/>
    <url>/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%A3%8B/</url>
    
    <content type="html"><![CDATA[<p>控制台实现简易飞行棋</p><span id="more"></span><p><strong># 游戏逻辑流程图</strong><br>游戏逻辑题直接引用唐老狮课程里的流程图</p><p><strong>## 整体逻辑流程图</strong></p><img src="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%A3%8B/%E6%95%B4%E4%BD%93%E9%80%BB%E8%BE%91%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class=""><p><strong>## 开始场景流程图</strong></p><img src="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%A3%8B/%E5%BC%80%E5%A7%8B%E5%9C%BA%E6%99%AF%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class=""><p><strong>## 游戏场景流程图</strong></p><img src="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%A3%8B/%E5%BC%80%E5%A7%8B%E5%9C%BA%E6%99%AF%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class=""><p><strong>## 结束场景流程图</strong></p><img src="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%A3%8B/%E7%BB%93%E6%9D%9F%E5%9C%BA%E6%99%AF%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class=""><p><strong># 代码实现（更新中）</strong></p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSharp入门总结</title>
    <link href="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/"/>
    <url>/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>入门总结</p><span id="more"></span><img src="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/summary.png" class="">]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSharp基础总结</title>
    <link href="/2022/05/04/CSharp/CSharp%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"/>
    <url>/2022/05/04/CSharp/CSharp%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>基础总结</p><span id="more"></span><img src="/2022/05/04/CSharp/CSharp%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/summary.png" class="">]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>选择排序</title>
    <link href="/2022/05/04/CSharp/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/05/04/CSharp/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>2022.5.4</p><span id="more"></span><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>重点知识点：<br><strong>选择排序</strong><br>1.基本概念： 新建中间商 遍历依次比较找出极值 放入目标位置<br>2.套路写法：两层循环（外层轮数 内层寻找 初始索引 记录极值）<br>3.优化： 已经完成比较的不参与比较  加一个bool标识判断是否已经有序</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><img src="/2022/05/04/CSharp/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/exam.png" class=""><p>以下是答案：</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson14_选择排序练习题&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;选择排序练习题&quot;);            #region 练习题1               &#x2F;&#x2F;生成随机数组            Random r &#x3D; new Random();            int[] arr &#x3D; new int[20];            for (int i &#x3D; 0; i &lt; arr.Length; i++)            &#123;                arr[i] &#x3D; r.Next(0, 101);            &#125;            &#x2F;&#x2F;选择排序升序排序            Console.WriteLine(&quot;选择排序升序排序结果:&quot;);            for (int m &#x3D; 0; m &lt; arr.Length; m++)            &#123;                int index &#x3D; 0;                int temp;                for (int n &#x3D; 0; n &lt; arr.Length - m; n++)                &#123;                    if (arr[index] &lt; arr[n])                    &#123;                        index &#x3D; n;                    &#125;                &#125;                if(index !&#x3D; arr.Length - m -1 )                &#123;                    temp &#x3D; arr[index];                    arr[index] &#x3D; arr[arr.Length - m - 1];                    arr[arr.Length - m - 1] &#x3D; temp;                &#125;            &#125;            for (int i &#x3D; 0; i &lt; arr.Length; i++)            &#123;                Console.Write(arr[i] + &quot; &quot;);            &#125;            &#x2F;&#x2F;中间间隔            Console.WriteLine();            Console.WriteLine(&quot;*************&quot;);            &#x2F;&#x2F;冒泡排序降序排序            Console.WriteLine(&quot;选择排序降序排序结果:&quot;);            for (int m &#x3D; 0; m &lt; arr.Length; m++)            &#123;                int index &#x3D; 0;                int temp;                for (int n &#x3D; 0; n &lt; arr.Length - m; n++)                &#123;                    if (arr[index] &gt; arr[n])                    &#123;                        index &#x3D; n;                    &#125;                &#125;                if (index !&#x3D; arr.Length - m - 1)                &#123;                    temp &#x3D; arr[index];                    arr[index] &#x3D; arr[arr.Length - m - 1];                    arr[arr.Length - m - 1] &#x3D; temp;                &#125;            &#125;            for (int i &#x3D; 0; i &lt; arr.Length; i++)            &#123;                Console.Write(arr[i] + &quot; &quot;);            &#125;            #endregion        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>冒泡排序</title>
    <link href="/2022/05/04/CSharp/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/05/04/CSharp/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>2022.5.4</p><span id="more"></span><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>重点知识点：<br><strong>冒泡排序</strong><br>1.基本概念： “无序”数组中两两相邻的数不断比较与交换直到“有序”<br>2.套路写法：两层循环（外层轮数 内层比较 满足则交换）<br>3.优化： 已经完成比较的不参与比较  加一个bool标识判断是否已经有序</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><img src="/2022/05/04/CSharp/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/exam.png" class=""><p>以下是答案：</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson13_冒泡排序练习题&#123;    internal class Program    &#123;        #region 练习题2        &#x2F;&#x2F;冒泡排序函数        static void PaiXu( int[] arr, bool upDown)        &#123;            &#x2F;&#x2F;小优化 在循环外声明变量 可以提高一些性能            bool isSort;            int temp;            for (int m &#x3D; 0; m &lt; arr.Length; m++)            &#123;                isSort &#x3D; false;                for (int n &#x3D; 0; n &lt; arr.Length - 1 - m; n++)                &#123;                    if(upDown)                    &#123;                        if (arr[n] &gt; arr[n + 1])                        &#123;                            isSort &#x3D; true;                            temp &#x3D; arr[n];                            arr[n] &#x3D; arr[n + 1];                            arr[n + 1] &#x3D; temp;                        &#125;                    &#125;                    else                    &#123;                        if (arr[n] &lt; arr[n + 1])                        &#123;                            isSort &#x3D; true;                            temp &#x3D; arr[n];                            arr[n] &#x3D; arr[n + 1];                            arr[n + 1] &#x3D; temp;                        &#125;                    &#125;                &#125;                if (!isSort)                &#123;                    break;                &#125;            &#125;            if (upDown)            &#123;                Console.WriteLine(&quot;冒泡排序升序排序结果:&quot;);            &#125;            else            &#123;                Console.WriteLine(&quot;冒泡排序降序排序结果:&quot;);            &#125;            for (int i &#x3D; 0; i &lt; arr.Length; i++)            &#123;                            Console.Write(arr[i] + &quot; &quot;);            &#125;        &#125;        #endregion        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;冒泡排序练习题&quot;);            #region 练习题1            &#x2F;&#x2F;判断是否已经有序 标识符            bool isSort &#x3D; false;            &#x2F;&#x2F;生成随机数组            Random r &#x3D; new Random();            int[] arr1 &#x3D; new int[20];            for (int i &#x3D; 0; i &lt; arr1.Length; i++)            &#123;                arr1[i] &#x3D; r.Next(0, 101);            &#125;            &#x2F;&#x2F;冒泡排序升序排序            Console.WriteLine(&quot;冒泡排序升序排序结果:&quot;);            for(int m &#x3D; 0; m &lt; arr1.Length; m++)            &#123;                isSort &#x3D; false;                for(int n &#x3D; 0; n &lt; arr1.Length - 1 - m; n++)                &#123;                    if(arr1[n] &gt; arr1[n + 1])                    &#123;                        isSort &#x3D; true;                        int temp &#x3D; arr1[n];                        arr1[n] &#x3D; arr1[n + 1];                        arr1[n + 1] &#x3D; temp;                    &#125;                &#125;                if( !isSort )                &#123;                    break;                &#125;            &#125;            for(int i &#x3D; 0; i &lt; arr1.Length; i++)            &#123;                Console.Write(arr1[i] + &quot; &quot;);            &#125;            &#x2F;&#x2F;中间间隔            Console.WriteLine();            Console.WriteLine(&quot;*************&quot;);            &#x2F;&#x2F;冒泡排序降序排序            Console.WriteLine(&quot;冒泡排序降序排序结果:&quot;);            for (int m &#x3D; 0; m &lt; arr1.Length; m++)            &#123;                isSort &#x3D; false;                for (int n &#x3D; 0; n &lt; arr1.Length - 1 - m; n++)                &#123;                    if (arr1[n] &lt; arr1[n + 1])                    &#123;                        isSort &#x3D; true;                        int temp &#x3D; arr1[n];                        arr1[n] &#x3D; arr1[n + 1];                        arr1[n + 1] &#x3D; temp;                    &#125;                &#125;                if (!isSort)                &#123;                    break;                &#125;            &#125;            for (int i &#x3D; 0; i &lt; arr1.Length; i++)            &#123;                Console.Write(arr1[i] + &quot; &quot;);            &#125;            #endregion            &#x2F;&#x2F;中间间隔            Console.WriteLine();            Console.WriteLine(&quot;*************&quot;);            #region 练习题2            &#x2F;&#x2F;生成数组            int[] arr2 &#x3D; new int[20];            for (int i &#x3D; 0; i &lt; arr2.Length; i++)            &#123;                arr2[i] &#x3D; r.Next(0, 101);            &#125;            &#x2F;&#x2F;true代表升序排序 false代表降序排序            PaiXu( arr2, true);            &#x2F;&#x2F;中间间隔            Console.WriteLine();            Console.WriteLine(&quot;*************&quot;);            PaiXu( arr2, false);            #endregion        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构体</title>
    <link href="/2022/05/03/CSharp/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <url>/2022/05/03/CSharp/%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<p>2022.5.3</p><span id="more"></span><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>重点知识点：<br><strong>结构体</strong><br>1.概念： 结构体 struct 是变量和函数的集合 用来表示特定的数据集合<br>2.访问修饰符：用来修饰变量和方法  public-&gt;外部可以调用   private-&gt;只能内部调用   不写默认private<br>3.构造函数：没有返回值 函数名和结构体名相同 可以重载 主要是帮助我们快速初始化结构体对象</p><p>注意：<br>1.在结构体中声明的变量不能初始化  只能在外部或者函数中赋值（初始化）<br>2.在结构体中声明的函数 不用加static</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><img src="/2022/05/03/CSharp/%E7%BB%93%E6%9E%84%E4%BD%93/exam.png" class=""><p>以下是答案：</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson12_结构体练习题&#123;    #region 练习题1    struct Student    &#123;               public string name;        public bool sex;        public int age;        public int lesson;        public string major;        public Student(string name, bool sex, int age, int lesson, string major)        &#123;            this.name &#x3D; name;                       this.sex &#x3D; sex;            this.age &#x3D; age;            this.lesson &#x3D; lesson;            this.major &#x3D; major;        &#125;        public void Information()        &#123;            Console.WriteLine(&quot;学员姓名&#123;0&#125;,性别&#123;1&#125;,年龄&#123;2&#125;,班级&#123;3&#125;,专业&#123;4&#125;&quot;, name, age, age, lesson, major);        &#125;    &#125;    #endregion    #region 练习题2    &#x2F;&#x2F;他们都是访问修饰符 用来修饰变量和方法    &#x2F;&#x2F;private 只能内部调用    &#x2F;&#x2F;public  外部可以调用    #endregion    #region 练习题3    struct Rectangular    &#123;        public int x;        public int y;        public Rectangular(int x, int y)        &#123;            this.x &#x3D; x;            this.y &#x3D; y;        &#125;        public void Information()        &#123;            Console.WriteLine(&quot;矩形的长为&#123;0&#125;,宽为&#123;1&#125;,面积为&#123;2&#125;,周长为&#123;3&#125;&quot;, x, y, x * y, 2 *(x + y));        &#125;    &#125;    #endregion    #region 练习题4    struct PlayerInfo    &#123;        public string name;        public E_Occupation occupation;                public PlayerInfo(string name, E_Occupation occupation)        &#123;            this.name &#x3D; name;            this.occupation &#x3D; occupation;                &#125;        public void AttackInformation()        &#123;            string o &#x3D; &quot;&quot;;            string s &#x3D; &quot;&quot;;            switch (occupation)            &#123;                case E_Occupation.Warrior:                    o &#x3D; &quot;战士&quot;;                    s &#x3D; &quot;冲锋&quot;;                    break;                case E_Occupation.Hunter:                    o &#x3D; &quot;猎人&quot;;                    s &#x3D; &quot;假死&quot;;                    break;                case E_Occupation.Witch:                    o &#x3D; &quot;法师&quot;;                    s &#x3D; &quot;奥术冲击&quot;;                    break;            &#125;            Console.WriteLine(&quot;&#123;0&#125;&#123;1&#125;施放了&#123;2&#125;&quot;, o, name, s);        &#125;    &#125;    enum E_Occupation    &#123;        Warrior,        Hunter,        Witch,    &#125;    #endregion    #region 练习题5    struct Monster    &#123;        public string name;        public int atk;        public Monster(string name)        &#123;            this.name &#x3D; name;            Random r &#x3D; new Random();            atk &#x3D; r.Next( 10, 30 );        &#125;        public void Atk()        &#123;            Console.WriteLine(&quot;&#123;0&#125;的攻击力是&#123;1&#125;&quot;, name, atk);        &#125;    &#125;    #endregion    #region 练习题7    struct UltraMan    &#123;        public string name;        public int atk;        public int def;        public int hp;        public UltraMan(string name, int atk, int def, int hp)        &#123;            this.name &#x3D; name;            this.atk &#x3D; atk;            this.def &#x3D; def;            this.hp &#x3D; hp;                   &#125;        &#x2F;&#x2F;结构体是值类型 想要在函数内部改变值类型信息 外部受影响 一定要用ref或out        public void Attack(ref Boss monster)        &#123;            &#x2F;&#x2F;奥特曼打怪兽的逻辑            monster.hp -&#x3D; atk - monster.def;            Console.WriteLine(&quot;&#123;0&#125;攻击了&#123;1&#125;，造成了&#123;2&#125;点伤害，&#123;1&#125;剩余血量&#123;3&#125;&quot;, name, monster.name, atk - monster.def, monster.hp);        &#125;    &#125;    struct Boss    &#123;        public string name;        public int atk;        public int def;        public int hp;        public Boss(string name, int atk, int def, int hp)        &#123;            this.name &#x3D; name;            this.atk &#x3D; atk;            this.def &#x3D; def;            this.hp &#x3D; hp;        &#125;        public void Attack(ref UltraMan Tiga)        &#123;            &#x2F;&#x2F;怪兽打奥特曼的逻辑            Tiga.hp -&#x3D; atk - Tiga.def;            Console.WriteLine(&quot;&#123;0&#125;攻击了&#123;1&#125;，造成了&#123;2&#125;点伤害，&#123;1&#125;剩余血量&#123;3&#125;&quot;, name, Tiga.name, atk - Tiga.def, Tiga.hp);        &#125;    &#125;    #endregion    internal class Program    &#123;                        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;结构体练习题&quot;);            #region 练习题1            Student s1 &#x3D; new Student(&quot;季宝&quot;, true, 23, 2, &quot;微电子&quot;);            Student s2 &#x3D; new Student(&quot;大逼&quot;, true, 23, 2, &quot;网安&quot;);            s1.Information();            s2.Information();            #endregion            #region 练习题3            Rectangular r1 &#x3D; new Rectangular (5, 4);            r1.Information();            #endregion            #region 练习题4            Console.Write(&quot;请输入玩家名字：&quot;);            string name &#x3D; Console.ReadLine();            Console.Write(&quot;请选择你的职业：（0战士，1猎人，2法师）&quot;);            try             &#123;                E_Occupation o &#x3D; (E_Occupation)int.Parse(Console.ReadLine());                PlayerInfo p1 &#x3D; new PlayerInfo(name ,o);                p1.AttackInformation();            &#125;            catch            &#123;                Console.WriteLine(&quot;请输入数字&quot;);            &#125;            #endregion            #region 练习题6            &#x2F;&#x2F;声明Monster数组            Monster[] monsters &#x3D; new Monster[10];            for (int i &#x3D; 0; i &lt; monsters.Length; i++)            &#123;                monsters[i] &#x3D; new Monster(&quot;怪兽&quot; + i);                monsters[i].Atk();            &#125;            #endregion            #region 练习题7            UltraMan Tiga &#x3D; new UltraMan(&quot;迪迦&quot;, 10, 5, 100);            Boss boss &#x3D; new Boss(&quot;哥斯拉&quot;, 8, 4, 100);            while(true)            &#123;                Tiga.Attack(ref boss);                if( boss.hp &lt;&#x3D; 0)                &#123;                    Console.WriteLine(&quot;迪迦胜利&quot;);                    break;                &#125;                boss.Attack(ref Tiga);                if (Tiga.hp &lt;&#x3D; 0)                &#123;                    Console.WriteLine(&quot;哥斯拉胜利&quot;);                    break;                &#125;                Console.WriteLine(&quot;按任意键继续&quot;);                Console.ReadKey(true);            &#125;            #endregion        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>递归函数</title>
    <link href="/2022/05/03/CSharp/%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/"/>
    <url>/2022/05/03/CSharp/%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>2022.5.3</p><span id="more"></span><h1 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h1><p>重点知识点：<br><strong>递归函数</strong><br>概念： 让函数自己调用自己<br>注意：<br>一个正确的递归函数<br>1.必须有结束调用的条件<br>2.用于条件判断的 这个条件必须改变 能够打到停止的目的</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><img src="/2022/05/03/CSharp/%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/exam.png" class=""><div class="code-wrapper"><pre><code class="csharp">using System;namespace Lesson11_递归函数练习题&#123;    internal class Program    &#123;        #region 练习题1        static void ZeroTen(int a)        &#123;            if(a &gt; 10)            &#123;                return;            &#125;            Console.WriteLine(a);            ZeroTen(++a);        &#125;        #endregion        #region 练习题2        static int Factorial(int a)        &#123;            if(a == 1)            &#123;                return 1;            &#125;            return a * Factorial(--a);//--a应写在后面, 或用a - 1            //若是 Factorial(--a) * a ,后面的a是已经减掉的a,得不到正确结果        &#125;        #endregion        #region 练习题3        static long SumFactorial(int a)        &#123;            if(a == 1)            &#123;                return 1;            &#125;            return Factorial(a) + SumFactorial(--a);        &#125;        #endregion        #region 练习题4        //自己写的        static double ZhuganLength1(int a)        &#123;            if(a == 0)            &#123;                return 100;            &#125;            return 0.5 * ZhuganLength1(--a);        &#125;        //答案        //一是长度 二是天数        static void ZhuganLength2(double length, int day = 0)        &#123;            length /= 2;            ++day;            //第十天砍了后的长度            if (day == 10)            &#123;                Console.WriteLine(&quot;第十天砍后竹竿长&#123;0&#125;米&quot;, length);                return;            &#125;                        ZhuganLength2(length, day);        &#125;        #endregion        #region 练习题5        //看答案的 想不出来短路怎么写        static bool PrintNum(int a)        &#123;            Console.WriteLine(a);                       return a == 200 || PrintNum(a + 1);             //逻辑短路，若逻辑或前面的为真，不执行逻辑或后面的        &#125;                #endregion        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;递归函数练习题&quot;);            //ZeroTen(0);            Console.WriteLine(Factorial(5));            Console.WriteLine(SumFactorial(10));            Console.WriteLine(ZhuganLength1(10));            ZhuganLength2(100, 0);            PrintNum(1);        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏设想(更新中)</title>
    <link href="/2022/05/03/%E9%A1%B9%E7%9B%AE/%E6%B8%B8%E6%88%8F%E8%AE%BE%E6%83%B3-%E6%9B%B4%E6%96%B0%E4%B8%AD/"/>
    <url>/2022/05/03/%E9%A1%B9%E7%9B%AE/%E6%B8%B8%E6%88%8F%E8%AE%BE%E6%83%B3-%E6%9B%B4%E6%96%B0%E4%B8%AD/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="085b8f3c7f5217256b375c6ae6075e8a8adae91a0ade8f8a94c33da807588fd2">1432a7b75e994fca526a11f4c4c29edb5d95ddd08071f06d8e2b1881f40addc49717d4ad2129bf03f288d888dddd593047eece5bda476a758cc60ea414b92c2fde57109810737be6114d7bc1b6b7562288492faa485ce10d9f6299e57b851357b155e4efdd34cbdd97c62497dc707a8984ec16459a2b29863b8efb819d6be55fee9506e4cffd6a89bbbd6344b2f51a0b1deb0385f3209dfde7e16b2730acd43ef49c7653d1401cc12f99952648c7e9fac2e3d036f71ac2a224d882c9eb52b53e8ce41ad4adcb845a1ece03152a88f6b9b4a60f385b7cd2bb197f64876a288ef21ea0f1cd6c1413b5bb87c41430ede2ee3757bf646cb9be07686a61467b31f274ec251a3402c81ab754e4f64b4371f59d3e48b066a9d4374932d26748038e8972751dbd5ccf58182e5c1ffdd89532c2b4d16f4e9e2f1d2ca1aff8bf2b9f1a02ec8cb9b08156183203b1e6d5d9e33805bdfdcf86d2d455b22f3cf0c5256eeeba4ecd62b87719f83f61c86654cd68f2d2cca26593c99c9d37ac15226c4abb48fd006cebb943c3977b2e1e46f10646380aed592825f2f183df4476ec6f707913e8fe88cf823b72bf2aec4dc26fc020a783d26174557db927ca6c764208fa1f0de861d954ea17ba42cba643a0d82b2a34bbe7d1add7f69f822495de81deabf3f37c59366a1ad681568c2d6c73d0fbbe10b4f00148cd62c7e8c8ca89963dfdd89ea0201c6163f7a9d843737c71d4c25a133621e9b429eac7b530ca1162fa2a9c8f83a78239efbf362a28152fd1812b3bd1306bc1ce235d6944e5c6352f6a6d6d14cda004f50ae8f27c35d7eb6ebe68e6246b1766d92f34bbd91f1aafd140c0bdc584aa53d91b49fc7bde567c308953bb3021801af6fcec8d469dd0f7c38b11f9383c63f733c54f7ec71d8221103ac971dd97a1510cb199dad83bda9253e38f3f945571</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">要密码，快滚.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数重载</title>
    <link href="/2022/05/03/CSharp/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/"/>
    <url>/2022/05/03/CSharp/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<p>2022.5.2</p><span id="more"></span><h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><p>重点知识点：<br><strong>函数重载</strong><br>概念： 同一个语句块中，函数名相同，参数数量、类型、顺序不同的函数 就称为函数重载<br>注意： 和返回值无关<br>作用： 一般用来处理不同参数的同一类型的逻辑处理</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><img src="/2022/05/03/CSharp/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/exam.jpg" class=""><p>以下是答案：</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson10_函数重载练习题&#123;    internal class Program    &#123;        #region 练习题1        static int CompareNum(int a, int b)        &#123;            return a &gt; b ? a : b;        &#125;        static float CompareNum(float a, float b)        &#123;            return a &gt; b ? a : b;        &#125;        static double CompareNum(double a, double b)        &#123;            return a &gt; b ? a : b;        &#125;        #endregion        #region 练习题2        static int CompareArray(int[] arr)        &#123;            int max &#x3D; arr[0];            for (int i &#x3D; 1; i &lt; arr.Length; i++)            &#123;                if (arr[i] &gt; max)                    max &#x3D; arr[i];            &#125;            return max;        &#125;        static float CompareArray(float[] arr)        &#123;            float max &#x3D; arr[0];            for (int i &#x3D; 1; i &lt; arr.Length; i++)            &#123;               if (arr[i] &gt; max)                   max &#x3D; arr[i];            &#125;            return max;        &#125;        static double CompareArray(double[] arr)        &#123;            double max &#x3D; arr[0];            for (int i &#x3D; 1; i &lt; arr.Length; i++)            &#123;                f (arr[i] &gt; max)                   max &#x3D; arr[i];            &#125;            return max;        &#125;        #endregion        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;函数重载练习题&quot;);            #region 练习题1            Console.WriteLine(CompareNum(5, 7));            Console.WriteLine(CompareNum(10.9f, 4.5f));            Console.WriteLine(CompareNum(20.975, 100.45));            #endregion            #region 练习题2            int[] arrInt &#x3D; &#123; 1, 4, 5, 8, 6 &#125;;            Console.WriteLine(CompareArray(arrInt));            float[] arrFloat &#x3D; &#123; 2.1f, 4.5f, 5.9f, 8.1f, 5.8f &#125;;            Console.WriteLine(CompareArray(arrFloat));            double[] arrDouble &#x3D; &#123; 1.2, 4.5, 5.8, 8.4, 6.6, 8.5 &#125;;            Console.WriteLine(CompareArray(arrDouble));            #endregion        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>变长参数和参数默认值</title>
    <link href="/2022/05/02/CSharp/%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC/"/>
    <url>/2022/05/02/CSharp/%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>2022.5.2</p><span id="more"></span><h1 id="变长参数和参数默认值"><a href="#变长参数和参数默认值" class="headerlink" title="变长参数和参数默认值"></a>变长参数和参数默认值</h1><p>重点知识点：<br><strong>1 变长参数关键字 params</strong><br>作用： 可以传入n个同类型参数 n可以是0<br>注意：<br>    1.params 后面必须是数组 意味着只能是同一类型的可变参数<br>    2.变长参数只能有一个<br>    3.必须在所有参数后面写变长参数</p><p><strong>2 参数默认值（可选参数）</strong><br>作用：可以给参数默认值 使用时可以不传参 不传用默认的 传了用传的<br>注意：<br>    1.可选参数可以有多个<br>    2.正常参数必须写在可选参数前面，可选参数只能写在所有参数的后面</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><img src="/2022/05/02/CSharp/%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC/exam.jpg" class=""><p>以下是答案：</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson9_变长参数和参数默认值练习题&#123;    internal class Program    &#123;        #region 练习题1        static void SumAndAvg(params int[] arr)        &#123;            int sum &#x3D; 0;            for (int i &#x3D; 0; i &lt; arr.Length; i++)            &#123;                sum +&#x3D; arr[i];            &#125;            double avg &#x3D; sum &#x2F; (double)arr.Length;            Console.WriteLine(&quot;它们的和为&#123;0&#125;,平均数为&#123;1&#125;&quot;, sum, avg);        &#125;        #endregion        #region 练习题2        static void OddEven(params int[] arr)        &#123;            int odd &#x3D; 0, even &#x3D; 0;            for (int i &#x3D; 0; i &lt; arr.Length; i++)            &#123;                if(arr[i] % 2 &#x3D;&#x3D; 0)                &#123;                    even +&#x3D; arr[i];                &#125;                else                &#123;                    odd +&#x3D; arr[i];                &#125;            &#125;            Console.WriteLine(&quot;奇数和为&#123;0&#125;,偶数和为&#123;1&#125;&quot;, odd, even);        &#125;        #endregion        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;变长参数和参数默认值练习题&quot;);            #region 练习题1            SumAndAvg(5, 9, 11, 52);            #endregion            #region 练习题2            OddEven(10, 11, 12);            #endregion        &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ref和out</title>
    <link href="/2022/05/02/CSharp/ref%E5%92%8Cout/"/>
    <url>/2022/05/02/CSharp/ref%E5%92%8Cout/</url>
    
    <content type="html"><![CDATA[<p>2022.5.1</p><span id="more"></span><p>#ref和out</p><p>重点知识点：<br>1.ref和out的作用: 解决值类型和引用类型 在函数内部 改值 或者 重新声明 能够影响外部传入的变量 让其也被修改<br>2.使用上: 就是在声明参数的时候 前面加上ref和out的 关键字即可 使用时同上<br>3.区别：<br> 1.ref传入的变量必须初始化  out不用<br> 2.out传入的变量必须在内部赋值  ref不用</p><p>#练习题</p><img src="/2022/05/02/CSharp/ref%E5%92%8Cout/exam.jpg" class=""><p>以下是答案：</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">static bool Login(int user, int key, ref string info)    &#123;        if(user == 0)        &#123;            //用户名正确的逻辑            if(key == 0)            &#123;                //用户名正确且密码正确的逻辑                info = &quot;登录成功&quot;;            &#125;            else            &#123;                //密码错误的逻辑                info = &quot;密码错误&quot;;                return false;            &#125;        &#125;        else        &#123;            //用户名错误的逻辑            info = &quot;用户名错误&quot;;            return false;        &#125;               return true;    &#125;static void Main(string[] args)    &#123;        Console.WriteLine(&quot;请输入用户名和密码&quot;);            int user = int.Parse(Console.ReadLine());            int key = int.Parse(Console.ReadLine());            string info = &quot;&quot;; //ref需要初始化            while (!Login(user, key, ref info)) //若登录失败继续尝试            &#123;                Console.WriteLine(info); //登录失败直接进入循环 打印登陆失败                Console.WriteLine(&quot;请输入用户名和密码&quot;);                user = int.Parse(Console.ReadLine()); //不需要再声明                key = int.Parse(Console.ReadLine());            &#125;            Console.WriteLine(info);    &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
