<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>委托</title>
    <link href="/2022/06/02/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E5%A7%94%E6%89%98/"/>
    <url>/2022/06/02/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E5%A7%94%E6%89%98/</url>
    
    <content type="html"><![CDATA[<p>委托</p><span id="more"></span><h1 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>委托是函数（方法）的容器，可以理解为表示函数（方法）的变量类型，可以用来存储、传递函数（方法）<br>委托本质是一个类，用来定义函数（方法）的类型（返回值和参数的类型）<br>不同的函数（方法）必须对应各自“格式”一致的委托</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>关键字： delegate</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>访问修饰符 delegate 返回值 委托名(参数列表);<br>可以声明在namespace和class语句块中 更多的写在namespace中<br>    函数声明语法前 + delegate</p><h3 id="定义自定义委托"><a href="#定义自定义委托" class="headerlink" title="定义自定义委托"></a>定义自定义委托</h3><p>访问修饰符默认不写为public 在别的命名空间中也能使用<br>private 其他命名空间就不能使用了<br>一般使用public<br>同一个命名空间中委托不能重名</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">delegate void MyFun();delegate int MyFun2(int value);</code></pre></div><h3 id="使用定义好的委托"><a href="#使用定义好的委托" class="headerlink" title="使用定义好的委托"></a>使用定义好的委托</h3><p>委托变量是函数的容器</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">static void Fun()&#123;    Console.WriteLine(&quot;&quot;);&#125;MyFun f &#x3D; new MyFun(Fun);f.Invoke();MyFun f2 &#x3D; Fun;f2();</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">static int Fun2(int value)&#123;    return value;&#125;MyFun2 f3 &#x3D; new MyFun2(Fun2);f3.Invoke();MyFun2 f4 &#x3D; Fun2;f4(1);</code></pre></div><p>委托常用在：<br>1.作为类的成员<br>2.作为函数的参数</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Test&#123;    public MyFun fun;    public MyFun2 fun2;    public void TestFun( MyFun fun, MyFun2 fun2 )    &#123;        &#x2F;&#x2F;先处理一些别的逻辑 当这些逻辑处理完了 再执行传入的函数        &#x2F;&#x2F;        &#x2F;&#x2F;fun();        &#x2F;&#x2F;fun2(i);        this.fun &#x3D; fun;        this.fun2 &#x3D; fun2;    &#125;&#125;Test t &#x3D; new Test();t.TestFun(Fun, Fun2);</code></pre></div><h2 id="委托变量可以存储多个函数（多播函数）"><a href="#委托变量可以存储多个函数（多播函数）" class="headerlink" title="委托变量可以存储多个函数（多播函数）"></a>委托变量可以存储多个函数（多播函数）</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">MyFun ff &#x3D; Fun;if( ff !&#x3D; null )&#123;    ff();&#125;</code></pre></div><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public void AddFun( MyFun fun, MyFun2 fun2 )&#123;    this.fun +&#x3D; fun;    this.fun2 +&#x3D; fun2;&#125;</code></pre></div><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public void RemoveFun( MyFun fun, MyFun2 fun2 )&#123;    this.fun -&#x3D; fun;    this.fun2 -&#x3D; fun2;&#125;</code></pre></div><h2 id="系统定义好的委托"><a href="#系统定义好的委托" class="headerlink" title="系统定义好的委托"></a>系统定义好的委托</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;无参无返回值Action action &#x3D; Fun;action +&#x3D; Fun;action();</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;支持泛型的 可以让返回值和参数可变Func&lt;string&gt; funcString &#x3D; Fun4;Func&lt;int&gt; funcInt &#x3D; Fun5;</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;可以传n个参数的 系统提供1-16个参数Action&lt;int, string, bool&gt; action &#x3D; Fun;</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;可以传n个参数的 有返回值的Func&lt;int, int&gt; func2 &#x3D; Fun;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/06/02/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E5%A7%94%E6%89%98/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson12_委托&#123;    abstract class Person    &#123;        public abstract void Eat();    &#125;    class Mother : Person    &#123;        public Action beginEat;        public override void Eat()        &#123;            Console.WriteLine(&quot;妈妈吃饭&quot;);        &#125;        public void Cook()        &#123;            Console.WriteLine(&quot;妈妈做饭&quot;);            &#x2F;&#x2F;执行委托函数            if(beginEat !&#x3D; null)            &#123;                beginEat();            &#125;        &#125;    &#125;    class Father : Person    &#123;        public override void Eat()        &#123;            Console.WriteLine(&quot;爸爸吃饭&quot;);        &#125;    &#125;    class Child : Person    &#123;        public override void Eat()        &#123;            Console.WriteLine(&quot;孩子吃饭&quot;);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Mother mother &#x3D; new Mother();            Father father &#x3D; new Father();            Child child &#x3D; new Child();            mother.beginEat +&#x3D; father.Eat;            mother.beginEat +&#x3D; child.Eat;            mother.beginEat +&#x3D; mother.Eat;            mother.Cook();        &#125;    &#125;&#125;</code></pre></div><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson12_委托&#123;    class Monster    &#123;        public Action&lt;Monster&gt; die;        public int money &#x3D; 10;        public void Dead()        &#123;            if (die !&#x3D; null)            &#123;                die(this);            &#125;            &#x2F;&#x2F;一般情况下 委托关联的函数 有加就有减 或直接清空            die &#x3D; null;        &#125;    &#125;    class Player    &#123;        private int nowMoney &#x3D; 0;        public void MonsterDie( Monster monster )        &#123;            nowMoney +&#x3D; monster.money;            Console.WriteLine(&quot;当前面板显示&#123;0&#125;钱&quot;, nowMoney);        &#125;    &#125;    class Panel    &#123;        private int nowMoney &#x3D; 0;        public void MonsterDie( Monster monster )        &#123;            nowMoney +&#x3D; monster.money;            Console.WriteLine(&quot;当前面板显示&#123;0&#125;钱&quot;, nowMoney);        &#125;    &#125;    class Achievement    &#123;        private int nowKill&#x3D; 0;        public void MonsterDie(Monster monster)        &#123;            nowKill++;            Console.WriteLine(&quot;当前击杀&#123;0&#125;怪物&quot;, nowKill);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Monster monster &#x3D; new Monster();            Player player &#x3D; new Player();            Panel panel &#x3D; new Panel();            Achievement achievement &#x3D; new Achievement();            monster.die +&#x3D; player.MonsterDie;            monster.die +&#x3D; panel.MonsterDie;            monster.die +&#x3D; achievement.MonsterDie;            monster.Dead();        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年6月2日</title>
    <link href="/2022/06/02/diary/2022.6/2022%E5%B9%B46%E6%9C%882%E6%97%A5/"/>
    <url>/2022/06/02/diary/2022.6/2022%E5%B9%B46%E6%9C%882%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="3f674ad1b1e9b354278eab65484b8a1b0b0b8aeb35a855e16af5d253931f279a">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50d4c0829a8a79ea3b44ecdd1bc8d55452b7de7125734c0d2f68e9acbe835a2e34a1f614394817bb7248cdc1e6c40213ba3798cf05ca05426e08e085f3a3a174480e8d0711d74f00da9cd7d69e81ddc13e6db9dc927147744dc7258eb6756e9f776e37134ce5c84ce19e26dc72cd50460187110ce2b49999aa7de8e37d420426c1</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>泛型栈和队列</title>
    <link href="/2022/06/01/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E6%B3%9B%E5%9E%8B%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <url>/2022/06/01/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E6%B3%9B%E5%9E%8B%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>泛型栈和队列</p><span id="more"></span><h1 id="泛型栈和队列"><a href="#泛型栈和队列" class="headerlink" title="泛型栈和队列"></a>泛型栈和队列</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System.Collections.Generic;    Stack&lt;int&gt; stack &#x3D; new Stack&lt;int&gt;();    Queue&lt;int&gt; queue &#x3D; new Queue&lt;int&gt;();</code></pre></div><p>具体方法与Stack和Queue一样</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/06/01/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E6%B3%9B%E5%9E%8B%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/exam.png" class=""><p>普通线性表：数组，list，linkedlist<br>数组：固定不变的一组数据<br>list：经常改变，经常通过下标查找<br>linkedlist：不确定长度的，经常临时插入改变，查找不多</p><p>先进后出：Stack<br>对于一些可以利用先进后出存储特点的逻辑<br>比如：UI面板显隐规则</p><p>先进先出：Queue<br>对于一些可以利用先进先出存储特点的逻辑<br>比如：消息队列，有了就往里放，然后依次处理</p><p>键值对：Dictionary<br>需要频繁查找的，有对应关系的数据<br>比如一些数据存储，ID对应数据内容<br>道具ID - 道具信息<br>怪物ID - 怪物对象<br>等等</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LinkedList</title>
    <link href="/2022/06/01/CSharp/CSharp%E8%BF%9B%E9%98%B6/LinkedList/"/>
    <url>/2022/06/01/CSharp/CSharp%E8%BF%9B%E9%98%B6/LinkedList/</url>
    
    <content type="html"><![CDATA[<p>LinkedList</p><span id="more"></span><h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>List是一个C#为我们封装好的类，<br>它的本质是一个可变类型的泛型双向链表。</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System.Collections.Generic;    LinkedList&lt;类型&gt; linkedlist &#x3D; new LinkedList&lt;类型&gt;();</code></pre></div><p>两个类： 链表本身LinkedList   链表节点类LinkedListNode</p><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;在链表尾部添加节点linkedlist.AddLast(类型);&#x2F;&#x2F;在链表头部添加节点linkedlist.AddFirst(类型);&#x2F;&#x2F;在某一个节点后添加节点LinkedListNode&lt;类型&gt; node &#x3D; LinkedList.Find(类型);node.AddAfter(类型);&#x2F;&#x2F;在某一个节点前添加节点LinkedListNode&lt;类型&gt; node &#x3D; LinkedList.Find(类型);node.AddBefore(类型);</code></pre></div><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;移除头节点linkedlist.RemoveFirst();&#x2F;&#x2F;移除尾节点linkedlist.RemoveLast();&#x2F;&#x2F;移除指定节点linkedlist.Remove(类型);&#x2F;&#x2F;清空链表linkedlist.Clear();</code></pre></div><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;查询头节点LinkedListNode&lt;类型&gt; first &#x3D; LinkedList.First;&#x2F;&#x2F;查询尾节点LinkedListNode&lt;类型&gt; last &#x3D; LinkedList.Last;&#x2F;&#x2F;找到指定值的节点（无法通过下标找，只能遍历查找）LinkedListNode&lt;类型&gt; node &#x3D; LinkedList.Find(类型);&#x2F;&#x2F;判断是否存在 boollinkedlist.Contains(类型)</code></pre></div><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;直接改指定位置的元素LinkedListNode&lt;类型&gt; node &#x3D; LinkedList.Find(类型);node.value &#x3D; 类型;</code></pre></div><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;数组长度list.Count&#x2F;&#x2F;数组容量list.Capacity&#x2F;&#x2F;foreach遍历foreach (类型 item in linkedlist)&#123;    &#x2F;&#x2F;直接取value    Console.WriteLine(item);&#125;&#x2F;&#x2F;从头到尾遍历LinkedListNode&lt;类型&gt; nowNode &#x3D; LinkedList.First;while( nowNode !&#x3D; null )&#123;    Console.WriteLine(nowNode.value);    nowNode &#x3D; nowNode.Next;&#125;&#x2F;&#x2F;从尾到头遍历LinkedListNode&lt;类型&gt; nowNode &#x3D; LinkedList.Last;while( nowNode !&#x3D; null )&#123;    Console.WriteLine(nowNode.value);    nowNode &#x3D; nowNode.Previous;&#125;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/06/01/CSharp/CSharp%E8%BF%9B%E9%98%B6/LinkedList/exam.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;namespace Lesson10_LinkedList&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            LinkedList&lt;int&gt; list &#x3D; new LinkedList&lt;int&gt;();            Random r &#x3D; new Random();            for (int i &#x3D; 0; i &lt; 10; i++)            &#123;                list.AddLast(r.Next(100));            &#125;            &#x2F;&#x2F;正向遍历            LinkedListNode&lt;int&gt; node &#x3D; list.First;            while (node !&#x3D; null)            &#123;                Console.Write(node.Value + &quot; &quot;);                node &#x3D; node.Next;            &#125;            Console.WriteLine(&quot;&quot;);            &#x2F;&#x2F;反向遍历            node &#x3D; list.Last;            while (node !&#x3D; null)            &#123;                Console.Write(node.Value + &quot; &quot;);                node &#x3D; node.Previous;            &#125;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>顺序存储和链式存储</title>
    <link href="/2022/06/01/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%92%8C%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    <url>/2022/06/01/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%92%8C%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<p>顺序存储和链式存储</p><span id="more"></span><h1 id="顺序存储和链式存储"><a href="#顺序存储和链式存储" class="headerlink" title="顺序存储和链式存储"></a>顺序存储和链式存储</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>线性表是一种数据结构，是由n个具有相同特效的数据元素的有限序列<br>比如数组、ArrayList、Stack、Queue、链表等等</p><p>顺序存储和链式存储 是数据结构中的两种存储结构</p><h2 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h2><p>数组、ArrayList、Stack、Queue、List 等<br>但 数组、Stack、Queue的 组织规则不同</p><p>顺序存储：<br>用一组<strong>地址连续</strong>的存储单元一次存储线性表的各个数据元素</p><h2 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h2><p>单向链表、双向链表、循环链表 等</p><p>链式存储（又称链接存储）：<br>用一组任意的存储单元存储线性表中的各个数据元素</p><h2 id="单向链表实现"><a href="#单向链表实现" class="headerlink" title="单向链表实现"></a>单向链表实现</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class LinkedNode&lt;T&gt;&#123;    public T value;    public LinkedNode&lt;T&gt; nextNode;    public LinkedNode(T value)    &#123;        this.value &#x3D; value;    &#125;&#125;class LinkedList&lt;T&gt;&#123;    public LinkedNode&lt;T&gt; head;    public LinkedNode&lt;T&gt; tail;    public void Add(T value)    &#123;        LinkedNode&lt;T&gt; node &#x3D; new LinkedNode&lt;T&gt;(value);        if(head &#x3D;&#x3D; null)        &#123;            head &#x3D; node;            tail &#x3D; node;        &#125;        else        &#123;            tail.nextNode &#x3D; node;            tail &#x3D; node;        &#125;    &#125;    public void Remove(T value)    &#123;        if(head &#x3D;&#x3D; null)        &#123;            return;        &#125;        else if(head.value.Equals(value))        &#123;            head &#x3D; head.nextNode;            &#x2F;&#x2F;如果头节点变空，那说明只有一个节点，尾结点也要空            if(head &#x3D;&#x3D; null)            &#123;                tail &#x3D; null;            &#125;            return;        &#125;        LinkedNode&lt;T&gt; node &#x3D; head;        while(node.nextNode !&#x3D; null)        &#123;            if(node.value.Equals(value))            &#123;                node.nextNode &#x3D; node.nextNode.nextNode;                break;            &#125;            node &#x3D; node.nextNode;        &#125;    &#125;&#125;</code></pre></div><h2 id="顺序存储和链式存储的优缺点"><a href="#顺序存储和链式存储的优缺点" class="headerlink" title="顺序存储和链式存储的优缺点"></a>顺序存储和链式存储的优缺点</h2><p>增：链式存储 计算上 优于 顺序存储 （中间插入时链式不用想顺序一样去移动位置）<br>删：链式存储 计算上 优于 顺序存储 （中间删除时链式不用想顺序一样去移动位置）<br>查：顺序存储 使用上 优于 链式存储 （数组可以直接通过下标得到元素，链式需要遍历）<br>改：顺序存储 使用上 优于 链式存储 （数组可以直接通过下标得到元素，链式需要遍历）</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/06/01/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%92%8C%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><p>数组、栈、队列、链表、树、图、堆、散列表</p><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><p>顺序存储：<br>用一组<strong>地址连续</strong>的存储单元一次存储线性表的各个数据元素<br>链式存储（又称链接存储）：<br>用一组任意的存储单元存储线性表中的各个数据元素</p><h2 id="题3"><a href="#题3" class="headerlink" title="题3"></a>题3</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson9_顺序存储和链式存储&#123;    class LinkedNode&lt;T&gt;    &#123;        public T value;        public LinkedNode&lt;T&gt; nextNode;        public LinkedNode&lt;T&gt; frontNode;        public LinkedNode(T value)        &#123;            this.value &#x3D; value;        &#125;    &#125;    class LinkedList&lt;T&gt;    &#123;        private int count &#x3D; 0;        private LinkedNode&lt;T&gt; head;        private LinkedNode&lt;T&gt; tail;        public int Count            &#123; get &#123; return count; &#125; &#125;        public LinkedNode&lt;T&gt; Head            &#123; get &#123; return head; &#125; &#125;        public LinkedNode&lt;T&gt; Tail            &#123; get &#123; return tail; &#125; &#125;        public void Add(T value)        &#123;            LinkedNode&lt;T&gt; node &#x3D; new LinkedNode&lt;T&gt;(value);            if(head &#x3D;&#x3D; null)            &#123;                head &#x3D; node;                tail &#x3D; node;            &#125;            else            &#123;                &#x2F;&#x2F;连到尾部                tail.nextNode &#x3D; node;                &#x2F;&#x2F;双向连前面                node.frontNode &#x3D; tail;                tail &#x3D; node;            &#125;            ++count;        &#125;        public void RemoveAt(int index)        &#123;            LinkedNode&lt;T&gt; tempNode &#x3D; head;            int tempCount &#x3D; 0;            &#x2F;&#x2F;判断有没有头            if (head &#x3D;&#x3D; null)            &#123;                Console.WriteLine(&quot;链表为空，无法删除&quot;);                return;            &#125;            &#x2F;&#x2F;判断是否越界            if (index &gt;&#x3D; count)            &#123;                Console.WriteLine(&quot;只有&#123;0&#125;个节点&quot;, count);                return;            &#125;            else if(index &lt; 0)            &#123;                Console.WriteLine(&quot;请输入正确的正整数&quot;);                return;            &#125;            else            &#123;                for (int i &#x3D; 0; i &lt; index; i++)                &#123;                    tempNode &#x3D; tempNode.nextNode;                &#125;                if (tempNode &#x3D;&#x3D; head)                &#123;                    head &#x3D; tempNode.nextNode;                    head.frontNode &#x3D; null;                &#125;                else if (tempNode &#x3D;&#x3D; tail)                &#123;                    tail &#x3D; tempNode.frontNode;                    tail.nextNode &#x3D; null;                &#125;                else                &#123;                    &#x2F;&#x2F;删除的节点的前一个节点连着后一个节点                    tempNode.frontNode.nextNode &#x3D; tempNode.nextNode;                    &#x2F;&#x2F;删除的节点的后一个节点连着前一个节点                    tempNode.nextNode.frontNode &#x3D; tempNode.frontNode;                &#125;                --count;                &#x2F;&#x2F;while(true)                &#x2F;&#x2F;&#123;                &#x2F;&#x2F;    if(tempCount &#x3D;&#x3D; index)                &#x2F;&#x2F;    &#123;                &#x2F;&#x2F;        if(tempNode.frontNode !&#x3D; null)                &#x2F;&#x2F;        &#123;                &#x2F;&#x2F;            tempNode.frontNode.nextNode &#x3D; tempNode.nextNode;                &#x2F;&#x2F;        &#125;                &#x2F;&#x2F;        if (tempNode.nextNode !&#x3D; null)                &#x2F;&#x2F;        &#123;                &#x2F;&#x2F;            tempNode.nextNode.frontNode &#x3D; tempNode.frontNode;                &#x2F;&#x2F;        &#125;                &#x2F;&#x2F;        if(index &#x3D;&#x3D; 0)                &#x2F;&#x2F;        &#123;                &#x2F;&#x2F;            head &#x3D; head.nextNode;                &#x2F;&#x2F;        &#125;                &#x2F;&#x2F;        if(index &#x3D;&#x3D; count - 1)                &#x2F;&#x2F;        &#123;                &#x2F;&#x2F;            tail &#x3D; tail.frontNode;                &#x2F;&#x2F;        &#125;                &#x2F;&#x2F;        break;                &#x2F;&#x2F;        --count;                &#x2F;&#x2F;    &#125;                &#x2F;&#x2F;    tempNode &#x3D; tempNode.nextNode;                &#x2F;&#x2F;    tempCount++;                &#x2F;&#x2F;&#125;            &#125;                    &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            LinkedList&lt;int&gt; list &#x3D; new LinkedList&lt;int&gt;();            list.Add(1);            list.Add(2);            list.Add(3);            list.Add(4);            LinkedNode&lt;int&gt; node &#x3D; list.Head;            &#x2F;&#x2F;正向遍历            while(node !&#x3D; null)            &#123;                Console.Write(node.value);                node &#x3D; node.nextNode;            &#125;            Console.WriteLine(&quot;&quot;);            &#x2F;&#x2F;反向遍历            node &#x3D; list.Tail;            while (node !&#x3D; null)            &#123;                Console.Write(node.value);                node &#x3D; node.frontNode;            &#125;            Console.WriteLine(&quot;&quot;);            list.RemoveAt(1);            &#x2F;&#x2F;正向遍历            node &#x3D; list.Head;            while (node !&#x3D; null)            &#123;                Console.Write(node.value);                node &#x3D; node.nextNode;            &#125;            Console.WriteLine(&quot;&quot;);            &#x2F;&#x2F;反向遍历            node &#x3D; list.Tail;            while (node !&#x3D; null)            &#123;                Console.Write(node.value);                node &#x3D; node.frontNode;            &#125;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年6月1日</title>
    <link href="/2022/06/01/diary/2022.6/2022%E5%B9%B46%E6%9C%881%E6%97%A5/"/>
    <url>/2022/06/01/diary/2022.6/2022%E5%B9%B46%E6%9C%881%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="5b54890c877d7b4c0f134a3f6c9e3be8b1c68ba90b800d2c13ca744db55132c1">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50b288bc91ee7b4bdb0528294bd9891ed4e409f14cf933b3be0b9fc9aaa1127d0592710b8aba39567caf477fd33ada3322a3e50913d027fe793d26756bc8710000dce524e22ef4104a15af2aeced7c161268c42285e78963783c5da734de84db4b66ad5254bf41b3c0bad15602f75507a2f3c98a52118cd630e22fa1654ced68f214106ac154ec270047ed4b38c04efd8dd3246b44eeae22d2199ab8265ad71c93f5429825116d700a5baf1b7140c39154f732fb5e75a6f3f17d5752bef961631e45f82dc61e133a8abf73fafb64c64b26d7958f9c3a235f4c934048a23c048f99c4836fed46a1d365ba46b2ebfc8f57bc750bc8a15aedcc328208bf6ad1385e098974c3c6629b42172b4b15951a075d87cb5676841be2c2a332272a167aec189f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dictionary</title>
    <link href="/2022/05/31/CSharp/CSharp%E8%BF%9B%E9%98%B6/Dictionary/"/>
    <url>/2022/05/31/CSharp/CSharp%E8%BF%9B%E9%98%B6/Dictionary/</url>
    
    <content type="html"><![CDATA[<p>Dictionary</p><span id="more"></span><h1 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h1><p>Dictionary可理解为拥有泛型的Hashtable<br>它也是基于键的哈希代码组织起来的 键&#x2F;值对<br>键&#x2F;值对类型从Hashtable的object类型变为了可以自己指定的泛型</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System.Collections.Generic;    Dictionary&lt;键类型, 值类型&gt; dictionary &#x3D; new Dictionary&lt;键类型, 值类型&gt;();</code></pre></div><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;往表中加一对(键, 值)dictionary.Add(键类型的对象, 值类型的对象);&#x2F;&#x2F;不能有相同键</code></pre></div><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;只能通过键去删除dictionary.Remove(键类型的对象); &#x2F;&#x2F;键&#x2F;&#x2F;删除不存在的键不会报错也不能删除&#x2F;&#x2F;清空dictionary.Clear();</code></pre></div><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;通过键查看对应的值，找不到会报错dictionary[键类型的对象]; &#x2F;&#x2F;键&#x2F;&#x2F;查看元素是否存在hashtable中(bool)dictionary.ContainsKey(键类型的对象); &#x2F;&#x2F;键dictionary.ContainsValue(值类型的对象); &#x2F;&#x2F;值</code></pre></div><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><p>只能改键对应的值内容，无法修改键</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">dictionary[键类型的对象] &#x3D; 新的值类型的对象;</code></pre></div><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;键值对的对数dictionary.Count&#x2F;&#x2F;迭代器遍历所有的键foreach (键类型 item in dictionary.Keys)&#123;    Console.WriteLine(&quot;&#123;0&#125;:&#123;1&#125;&quot;, item, dictionary[item]);&#125;&#x2F;&#x2F;迭代器遍历所有的值foreach (值类型 item in dictionary.Values)&#123;    Console.WriteLine(item);&#125;&#x2F;&#x2F;迭代器遍历所有的键值对foreach (KeyValuePair&lt;键类型, 值类型&gt; item in dictionary)&#123;    Console.WriteLine(&quot;&#123;0&#125;:&#123;1&#125;&quot;, item.Key, item.Value);&#125;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/31/CSharp/CSharp%E8%BF%9B%E9%98%B6/Dictionary/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;namespace Lesson8_Dictionary&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            try            &#123;                Console.WriteLine(&quot;请输入一个三位以内的数&quot;);                Console.WriteLine(GetInfo(int.Parse(Console.ReadLine())));            &#125;            catch            &#123;                Console.WriteLine(&quot;请输入正确的数字&quot;);            &#125;        &#125;        static string GetInfo(int num)        &#123;            Dictionary&lt;int, string&gt; dic &#x3D; new Dictionary&lt;int, string&gt;();            dic.Add(0, &quot;零&quot;);            dic.Add(1, &quot;壹&quot;);            dic.Add(2, &quot;贰&quot;);            dic.Add(3, &quot;叁&quot;);            dic.Add(4, &quot;肆&quot;);            dic.Add(5, &quot;伍&quot;);            dic.Add(6, &quot;陆&quot;);            dic.Add(7, &quot;柒&quot;);            dic.Add(8, &quot;捌&quot;);            dic.Add(9, &quot;玖&quot;);            string str &#x3D; &quot;&quot;;            int b &#x3D; num &#x2F; 100;            if (b !&#x3D; 0)            &#123;                str +&#x3D; dic[b];            &#125;            int s &#x3D; num % 100 &#x2F; 10;            if(str !&#x3D; &quot;&quot; || s !&#x3D; 0)            &#123;                str +&#x3D; dic[s];            &#125;            int g &#x3D; num % 10;            str +&#x3D; dic[g];            return str;        &#125;    &#125;&#125;</code></pre></div><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;namespace Lesson8_Dictionary&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Dictionary&lt;char, int&gt; dic &#x3D; new Dictionary&lt;char, int&gt;();            string str &#x3D; &quot;Welcome to Unity World!&quot;;            str &#x3D; str.ToLower();            for (int i &#x3D; 0; i &lt; str.Length; i++)            &#123;                if( dic.ContainsKey(str[i]))                &#123;                    dic[str[i]]++;                &#125;                else                &#123;                    dic.Add(str[i], 1);                &#125;                &#125;            foreach (char item in dic.Keys)            &#123;                Console.WriteLine(&quot;字母&#123;0&#125;出现了&#123;1&#125;次&quot;, item, dic[item]);            &#125;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>List</title>
    <link href="/2022/05/31/CSharp/CSharp%E8%BF%9B%E9%98%B6/List/"/>
    <url>/2022/05/31/CSharp/CSharp%E8%BF%9B%E9%98%B6/List/</url>
    
    <content type="html"><![CDATA[<p>List</p><span id="more"></span><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>List是一个C#为我们封装好的类，<br>它的本质是一个可变类型的泛型数组。</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System.Collections.Generic;    List&lt;类型&gt; list &#x3D; new List&lt;类型&gt;();</code></pre></div><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;增加一个元素list.Add(类型);&#x2F;&#x2F;批量增加，把另一个list容器中的元素加到后面list.AddRange(另一个list);</code></pre></div><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;移出指定元素，从头找，找到删array.Remove(元素);&#x2F;&#x2F;移除指定位置元素array.RemoveAt(索引值);&#x2F;&#x2F;清空数组array.Clear();</code></pre></div><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;得到指定位置的元素Console.WriteLine(list[0]);&#x2F;&#x2F;查询元素是否存在array.Contains(元素); &#x2F;&#x2F;存在为真,不存在为假&#x2F;&#x2F;正向查找元素位置,正向第一个找到的位置array.IndexOf(元素); &#x2F;&#x2F;返回索引值,没找到返回-1 &#x2F;&#x2F;正向查找元素位置,反向第一个找到的位置array.LastIndexOf(元素); &#x2F;&#x2F;返回索引值,没找到返回-1 </code></pre></div><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;直接改指定位置的元素array[索引值] &#x3D; 元素;</code></pre></div><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;数组长度list.Count&#x2F;&#x2F;数组容量list.Capacity&#x2F;&#x2F;遍历for( i &#x3D; 0; i &lt; list.Count; i++ )&#123;    &#x2F;&#x2F;需要的逻辑&#125;&#x2F;&#x2F;迭代器遍历 把array里的元素放到item里foreach (object item in list)&#123;    &#x2F;&#x2F;需要的逻辑 &#125;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/31/CSharp/CSharp%E8%BF%9B%E9%98%B6/List/exam.png" class=""><h1 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h1><p>ArrayList是一个object类型的数组，会出现装箱拆箱<br>List是一个泛型类，会直接定好类型，不会出现装箱拆箱</p><h1 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h1><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;namespace Lesson7_List&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            List&lt;int&gt; list &#x3D; new List&lt;int&gt;();            list.Add(10);            list.Add(9);            list.Add(8);            list.Add(7);            list.Add(6);            list.Add(5);            list.Add(4);            list.Add(3);            list.Add(2);            list.Add(1);            list.RemoveAt(4);            foreach (int i in list)            &#123;                Console.WriteLine(i);            &#125;        &#125;    &#125;&#125;</code></pre></div><h1 id="题3"><a href="#题3" class="headerlink" title="题3"></a>题3</h1><p>子类默认先调用父类的无参构造函数</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;namespace Lesson7_List&#123;    abstract class Monster    &#123;        &#x2F;&#x2F;静态列表 不会改变        public static List&lt;Monster&gt; monsters &#x3D; new List&lt;Monster&gt;();        public Monster()        &#123;            monsters.Add(this);        &#125;        abstract public void Atk();    &#125;    class Boss : Monster    &#123;        public override void Atk()        &#123;            Console.WriteLine(&quot;Boss攻击&quot;);        &#125;    &#125;    class Goblin : Monster    &#123;        public override void Atk()        &#123;            Console.WriteLine(&quot;Goblin攻击&quot;);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Boss boss1 &#x3D; new Boss();            Boss boss2 &#x3D; new Boss();            Goblin goblin1 &#x3D; new Goblin();            Goblin goblin2 &#x3D; new Goblin();            for (int i &#x3D; 0; i &lt; Monster.monsters.Count; i++)            &#123;                Monster.monsters[i].Atk();            &#125;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月31日</title>
    <link href="/2022/05/31/diary/2022.5/2022%E5%B9%B45%E6%9C%8831%E6%97%A5/"/>
    <url>/2022/05/31/diary/2022.5/2022%E5%B9%B45%E6%9C%8831%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="7449399fa491da47b53a9a8ef770f67540731192631d3816acb044e49da245c4">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50827eb88e76e5b7252b59da810bd88ec56cd6c3cb9fc41f65ff8e1abf03c11befacc8d888eca9bd903a440117993f3ffca1c7c27b8ef3de34b11171a3e22e0e849759db59eda7d3700424065de857d38619c04cb29e5bdbafa8a9ccfab2abf7697e68e4d07b390519ff2db96b518cecd2dd153a877347bed9a2101ba3c35786e85060b92a7290f80801954c041c7696d482ebfacc1255d0eff23b99d3a2b407b9a7afc97f69087aa51181af537f37d6a266326a27d74b24e15c15a34882d324bf0fa6f42cb57f9ecb8ab5b93cb3a8dfc4550add626eb44d970f99cf45e9e62eea9b175cf0b3f2327ed3a2590d34a41d02fb326ff05db6e728955e5040c759af581f61f5ae18693c44d57ab90dbf91044fb5acbb5963d9b7c28dcda2b3d04081355dcb5956c8799bfad85c7ceeb204f4e017e93307a9689df2bbbcc7268e8690d384b914d9fb2773d8323866f80c534d28c5fec04875abd9a4d2b7f2547e85295c16b1382807ae696a9f51092d99002e55610ac1f449f605878beb5749d6b9adfb</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>泛型约束</title>
    <link href="/2022/05/30/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F/"/>
    <url>/2022/05/30/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F/</url>
    
    <content type="html"><![CDATA[<p>泛型约束</p><span id="more"></span><h1 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>让泛型的类型有一定的限制<br>关键字：where<br>泛型约束共有6种<br>1.值类型                            where 泛型字母:struct<br>2.引用类型                          where 泛型字母:class<br>3.存在无参公共构造函数               where 泛型字母:new()<br>4.某个类本身或者其派生类             where 泛型字母:类名<br>5.某个接口的派生类型                 where 泛型字母:接口名<br>6.另一个泛型类型本身或者派生类型      where 泛型字母:另一个泛型字母</p><p>where 泛型字母:(约束的类型)</p><h2 id="各个泛型约束"><a href="#各个泛型约束" class="headerlink" title="各个泛型约束"></a>各个泛型约束</h2><p>1.值类型约束</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Test1&lt;T&gt; where T:struct&#123;    public T value;    public void TestFun&lt;K&gt;(K k) where K:struct    &#123;    &#125;&#125;&#x2F;&#x2F;int 和 float 都是struct类型（值类型，初值不能为空）Test1&lt;int&gt; t1 &#x3D; new Test1&lt;int&gt;();t1.TestFun&lt;float&gt;(1.3f);</code></pre></div><p>2.引用类型约束</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Test2&lt;T&gt; where T:class&#123;    public T value;    public void TestFun&lt;K&gt;(K k) where K:class    &#123;    &#125;&#125;&#x2F;&#x2F;Random 和 object 都是class类型Test2&lt;Random&gt; t2 &#x3D; new Test2&lt;Random&gt;();t2.TestFun&lt;object&gt;(new object());</code></pre></div><p>3.存在无参公共构造函数约束（非抽象类）</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Test3&lt;T&gt; where T:new()&#123;    public T value;    public void TestFun&lt;K&gt;(K k) where K:new()    &#123;    &#125;&#125;class Test1&#123;&#125;class Test2&#123;    public Test2(int a)    &#123;    &#125;&#125;&#x2F;&#x2F;Test1可以（有公共无参构造函数） Test2不行（公共有参、私有无参、抽象类都不行）Test3&lt;Test1&gt; t3 &#x3D; new Test3&lt;Test1&gt;();</code></pre></div><p>4.某个类本身或者其派生类 约束</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Test4&lt;T&gt; where T:Test1&#123;    public T value;    public void TestFun&lt;K&gt;(K k) where K:Test1    &#123;    &#125;&#125;class Test3 : Test1&#123;&#125;&#x2F;&#x2F;Test1可以（类） Test3可以（派生类） Test2不行Test4&lt;Test1&gt; t4 &#x3D; new Test4&lt;Test1&gt;();Test4&lt;Test3&gt; t4 &#x3D; new Test4&lt;Test3&gt;();</code></pre></div><p>5.某个接口的派生类型约束</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">interface IFly&#123;&#125;class Test4 : IFly&#123;&#125;class Test5&lt;T&gt; where T:IFly&#123;    public T value;    public void TestFun&lt;K&gt;(K k) where K:IFly    &#123;    &#125;&#125;&#x2F;&#x2F;IFly可以（接口） Test4可以（派生类） Test5&lt;IFly&gt; t5 &#x3D; new Test5&lt;IFly&gt;();t5.value &#x3D; new Test4(); &#x2F;&#x2F;里式替换Test4&lt;Test4&gt; t5 &#x3D; new Test4&lt;Test4&gt;();</code></pre></div><p>6.另一个泛型类型本身或者派生类型约束</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;T要么是U,要么是U的派生类型class Test6&lt;T,U&gt; where T:U&#123;    public T value;    public void TestFun&lt;K,V&gt;(K k) where K:V    &#123;    &#125;&#125;&#x2F;&#x2F;Test4是IFly的派生类型 Test6&lt;Test4, IFly&gt; t6 &#x3D; new Test6&lt;Test4, IFly&gt;();</code></pre></div><h2 id="约束的组合使用"><a href="#约束的组合使用" class="headerlink" title="约束的组合使用"></a>约束的组合使用</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Test7&lt;T&gt; where T:class, new()&#123;&#125;</code></pre></div><h2 id="多个泛型有约束"><a href="#多个泛型有约束" class="headerlink" title="多个泛型有约束"></a>多个泛型有约束</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Test8&lt;T,K&gt; where T:class, new() where K:struct&#123;    &#125;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/30/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson6_泛型约束&#123;    class SingleBase&lt;T&gt; where T : new()    &#123;        private static T instance &#x3D; new T();        public static T Instance        &#123;            get &#123; return instance; &#125;        &#125;    &#125;    &#x2F;&#x2F;继承的子类一定要有公共无参构造函数    class GameMgr : SingleBase&lt;GameMgr&gt;    &#123;        public int value &#x3D; 10;    &#125;    class Test    &#123;        private static Test instance &#x3D; new Test();        private Test()        &#123;        &#125;        public static Test Instance        &#123;            get            &#123;                return instance;            &#125;        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            GameMgr.Instance.value &#x3D; 10;        &#125;    &#125;&#125;</code></pre></div><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson6_泛型约束&#123;    class ArrayList&lt;T&gt;    &#123;        private T[] array;        private int count;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 获取已存数量        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        public int Count        &#123;            get &#123; return count; &#125;        &#125;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 获取容量        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        public int Capacity &#123; get &#123; return array.Length; &#125; &#125;        public ArrayList()        &#123;            count &#x3D; 0;            &#x2F;&#x2F;一开始的容量为16            array &#x3D; new T[16];        &#125;        &#x2F;&#x2F;增        public void Add(T value)        &#123;            &#x2F;&#x2F;判断是否需要扩容            if(count &gt;&#x3D; Capacity)            &#123;                T[] newArray &#x3D; new T[Capacity &lt;&lt; 1];                for (int i &#x3D; 0; i &lt; Capacity; i++)                &#123;                    newArray[i] &#x3D; array[i];                &#125;                array &#x3D; newArray;            &#125;            &#x2F;&#x2F;不需要扩容            array[count++] &#x3D; value;        &#125;        &#x2F;&#x2F;删        public void Remove(T value)        &#123;            int index &#x3D; -1;            for (int i &#x3D; 0; i &lt; Count; i++)            &#123;                &#x2F;&#x2F;因为不是所有的类型都重载了&#x3D;&#x3D;,所以无法用&#x3D;&#x3D;判断                if(value.Equals(array[i]))                &#123;                    index &#x3D; i;                    break;                &#125;            &#125;            if(index !&#x3D; -1)            &#123;                for (int i &#x3D; index; i &lt; Count; i++)                &#123;                    array[i] &#x3D; array[i + 1];                &#125;                array[Count] &#x3D; default(T);                --count;            &#125;        &#125;        &#x2F;&#x2F;查        public void RemoveAt(int index)        &#123;            if(index &lt; 0 || index &gt;&#x3D; Count)            &#123;                return;            &#125;            for (int i &#x3D; index; i &lt; Count; i++)            &#123;                array[i] &#x3D; array[i + 1];            &#125;            array[Count] &#x3D; default(T);            --count;        &#125;        &#x2F;&#x2F;改        public T this[int index]        &#123;            get             &#123;                if (index &lt; 0 || index &gt;&#x3D; Count)                &#123;                    return default(T);                &#125;                return array[index];             &#125;            set             &#123;                if (index &lt; 0 || index &gt;&#x3D; Count)                &#123;                    return;                &#125;                array[index] &#x3D; value;             &#125;        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            ArrayList&lt;int&gt; array &#x3D; new ArrayList&lt;int&gt;();            Console.WriteLine(&quot;&#123;0&#125;,&#123;1&#125;&quot;, array.Count, array.Capacity);            array.Add(1);            array.Add(2);            array.Add(3);            Console.WriteLine(&quot;&#123;0&#125;,&#123;1&#125;&quot;, array.Count, array.Capacity);            Console.WriteLine(array[1]);            Console.WriteLine(array[-1]);            array.RemoveAt(0);            Console.WriteLine(&quot;&#123;0&#125;,&#123;1&#125;&quot;, array.Count, array.Capacity);            for (int i &#x3D; 0; i &lt; array.Count; i++)            &#123;                Console.WriteLine(array[i]);            &#125;            Console.WriteLine(array[0]);            array[0] &#x3D; 5;            Console.WriteLine(array[0]);        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>泛型</title>
    <link href="/2022/05/30/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E6%B3%9B%E5%9E%8B/"/>
    <url>/2022/05/30/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>泛型</p><span id="more"></span><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>泛型实现了类型参数化，打到代码重用的目的<br>通过类型参数化来实现同一份代码上操作多种类型</p><p>泛型相当于类型占位符<br>定义类或方法时使用替代符代表变量类型<br>当真正使用类或者方法时再具体指定类型</p><h2 id="泛型分类"><a href="#泛型分类" class="headerlink" title="泛型分类"></a>泛型分类</h2><p>泛型类和泛型接口<br>基本语法：</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class 类名&lt;泛型占位字符&gt;interface 接口名&lt;泛型占位字符&gt;</code></pre></div><p>泛型函数<br>基本语法：</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">函数名&lt;泛型占位字符&gt;(参数列表)</code></pre></div><p><strong>注意：</strong><br>泛型占位字母可以有多个，用逗号分开</p><h2 id="泛型分类实例"><a href="#泛型分类实例" class="headerlink" title="泛型分类实例"></a>泛型分类实例</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class TestClass&lt;T&gt;&#123;    public T value;&#125;class TestClass&lt;T1,T2,K,M,Key&gt;&#123;    &#x2F;&#x2F;每个占位符&#125;TestClass&lt;int&gt; t &#x3D; new TestClass&lt;int&gt;();</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">interface TestInterface&lt;T&gt;&#123;    T value    &#123;        get;        set;    &#125;&#125;class Test : TestInterface&lt;int&gt;&#123;    public int value    &#123;        get;        set;    &#125;&#125;</code></pre></div><h2 id="泛型方法实例"><a href="#泛型方法实例" class="headerlink" title="泛型方法实例"></a>泛型方法实例</h2><h3 id="普通类中的泛型方法"><a href="#普通类中的泛型方法" class="headerlink" title="普通类中的泛型方法"></a>普通类中的泛型方法</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Test2&#123;    public void TestFun&lt;T&gt;( T value )    &#123;        Console.WriteLine(value);    &#125;&#125;Test2 test2 &#x3D; new Test2();test2.TestFun&lt;string&gt;(&quot;123123&quot;);</code></pre></div><h3 id="泛型类中的泛型方法"><a href="#泛型类中的泛型方法" class="headerlink" title="泛型类中的泛型方法"></a>泛型类中的泛型方法</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Test2&lt;T&gt;&#123;    public T value;    &#x2F;&#x2F;这不是一个泛型方法，因为T是泛型类声明的时候就指定，在使用这个函数的时候不能动态的改变T    public void TestFun(T t)    &#123;    &#125;    &#x2F;&#x2F;这是一个泛型方法，T已经被泛型类使用，泛型方法中不能用T    public void TestFun&lt;K&gt;( K value )    &#123;        Console.WriteLine(value);    &#125;&#125;Test2 test2 &#x3D; new Test2();test2.TestFun&lt;string&gt;(&quot;123123&quot;);</code></pre></div><h2 id="泛型的作用"><a href="#泛型的作用" class="headerlink" title="泛型的作用"></a>泛型的作用</h2><p>1.不同类型对象的相同逻辑处理就可以选择泛型<br>2.使用泛型可以一定程度避免装箱拆箱</p><p>举例：优化ArrayList</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class ArrayList&lt;T&gt;&#123;    private T[] array;    public void Add(T value)    &#123;    &#125;    public void Remove(T value)    &#123;    &#125;&#125;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/30/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E6%B3%9B%E5%9E%8B/exam.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson5_泛型&#123;    class Type    &#123;        public void WhatType&lt;T&gt; ()        &#123;            if (typeof(T) &#x3D;&#x3D; typeof(int))            &#123;                Console.WriteLine(&quot;整形, 4字节&quot;);            &#125;            else if(typeof(T) &#x3D;&#x3D; typeof(char))            &#123;                Console.WriteLine(&quot;字符, 1字节&quot;);            &#125;            else if (typeof(T) &#x3D;&#x3D; typeof(float))            &#123;                Console.WriteLine(&quot;单精度浮点数, 8字节&quot;);            &#125;            else if (typeof(T) &#x3D;&#x3D; typeof(string))            &#123;                Console.WriteLine(&quot;字符串, 不定字节数&quot;);            &#125;            else            &#123;                Console.WriteLine(&quot;其他类型&quot;);            &#125;        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Type type &#x3D; new Type();            type.WhatType&lt;int&gt;();        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月30日</title>
    <link href="/2022/05/30/diary/2022.5/2022%E5%B9%B45%E6%9C%8830%E6%97%A5/"/>
    <url>/2022/05/30/diary/2022.5/2022%E5%B9%B45%E6%9C%8830%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="7f50a5faf5aa1f555cc0cc3f0e02ec71225da4aee28e2835c2827c7bbedea88f">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50fdd0ca3edc57389bd0e88084b7db2023162afbff53542a89ea79d2bc20a5a460011d779c4a734dae53a0a6590315caa329d41c248858e3439fdfd312079e72ef1122dd3ff3bfdede7e6ce61a85d23b4c6692b6fa4af166de9c4417b8d7ad1606ec540046038eef308ceaf01891fdfbab76bda4bb18d8e952487d4a7b87a5eefbc8cd39cbed02db97b1a54e4a16c6de7955b581a7ae02c259c4fd3194960312e821d0fecde17294e971a68fc8aee2e0638a8e7f0aec2eda62332b823239b70693805e230f376ba3b89130043136bbc9835019b11fd2b1a19d07ca789db8b95bd011333e271235931f70c46c9a8d2e40417072fc2628ccaddc7c78f0ade743d8b4528f2897a19675751e65a9a3e17be9ae4b0795dcb8d54571540fef72b98c76deeaa7f94ce5780c1bbba1b6127c5b675ad755a7df02902fdb41d1b71cf28824c6f081d371e6023848fcd0abcb1ae7656ecb16af96c2b601e74c497dbd0fc3150d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月29日</title>
    <link href="/2022/05/30/diary/2022.5/2022%E5%B9%B45%E6%9C%8829%E6%97%A5/"/>
    <url>/2022/05/30/diary/2022.5/2022%E5%B9%B45%E6%9C%8829%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="0e17085469af6251ac8009fe38cf278000804a29448ff6133bbc02d73d404fd3">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe500369424d0a5d6c91d4929760e488202cf5c260e28b2f7c911f78a16a927e3650be915fff1bb966a7bd9cfa54e7b9bd19abcfcba2f73f70df369bf026f9d13f79f742032eeded394a91a966c343c200c92dc11231e1f605e089d8dc4eeabbca8ae5c0dcbfaf3c5388017f3a408ccc37225cf18c56e419046b4254225c1172e2ff26abfb9f4b7abc732b519e0841e6d6c369a55d1c9996698e241aff4e9af9fbbf345aed4a3a88b92c4192e88a4fea449e199a6324b34199688aa619aca3954ce29f7c7806f7ff91bf82b2c7b320cd049dbabd1822f8e43c4a8d71f7899070a5b7d18900014341ea8ef4852e047a6c6fab3188ad5f9565a2738686832e1ad7e3faab53fa161a517765df3e968d8606bb059bdd9254b9cb4a69ddbce52aecb20c848a03e1743313edc92c2a89aa6387208ebb9e2ddf6ba9056b1f0880fcdacc7752b2e5d17ee5c867b3bde97741e7093364ffabfac9c9aa7bcddc130db77a9363f7126b613b86b3375d0e5d34630249c3e870ded3a07152675953028c4568b91a0e53b7e232ef1f4f31cce705aad189273a914974a701d258745997e5f45f68aed38e3558c5719de77eddf994ed79af6685</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hashtable</title>
    <link href="/2022/05/28/CSharp/CSharp%E8%BF%9B%E9%98%B6/Hashtable/"/>
    <url>/2022/05/28/CSharp/CSharp%E8%BF%9B%E9%98%B6/Hashtable/</url>
    
    <content type="html"><![CDATA[<p>Hashtable</p><span id="more"></span><h1 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h1><p>Hashtable(又称散列表)，表示根据键的哈希代码进行组织的<strong>键&#x2F;值对</strong>的集合。<br>它的主要作用是提高数据查询的效率<br>使用键来访问集合中的元素(object类型)</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System.Collections;    Hashtable hashtable &#x3D; new Hashtable();</code></pre></div><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;往表中加一对(键, 值)hashtable.Add(object, object);&#x2F;&#x2F;不能有相同键</code></pre></div><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;只能通过键去删除hashtable.Remove(object); &#x2F;&#x2F;键&#x2F;&#x2F;删除不存在的键不会报错也不能删除&#x2F;&#x2F;清空hashtable.Clear();</code></pre></div><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;通过键查看对应的值，找不到会返回空hashtable[object]; &#x2F;&#x2F;键&#x2F;&#x2F;查看元素是否存在hashtable中(bool)hashtable.Contains(object); &#x2F;&#x2F;键 hashtable.ContainsKey(object); &#x2F;&#x2F;键hashtable.ContainsValue(object); &#x2F;&#x2F;值</code></pre></div><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><p>只能改键对应的值内容，无法修改键</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">hashtable[object] &#x3D; new object;</code></pre></div><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;键值对的对数hashtable.Count&#x2F;&#x2F;迭代器遍历所有的键foreach (object item in hashtable.Keys)&#123;    &#x2F;&#x2F;需要的逻辑 &#125;&#x2F;&#x2F;迭代器遍历所有的值foreach (object item in hashtable.Values)&#123;    &#x2F;&#x2F;需要的逻辑 &#125;&#x2F;&#x2F;迭代器遍历所有的键值对foreach (DictionaryEntry item in hashtable)&#123;    &#x2F;&#x2F;需要的逻辑 &#125;&#x2F;&#x2F;迭代器遍历法IDictionaryEnumerator myEnumerator &#x3D; hashtable.GetEnumerator();bool flag &#x3D; myEnumerator.MoveNext();while (flag)&#123;    Console.WriteLine(&quot;键&#x3D;&#123;0&#125;，值&#x3D;&#123;1&#125;&quot;, myEnumerator.Key, myEnumerator.Value);    flag &#x3D; myEnumerator.MoveNext();&#125;</code></pre></div><h2 id="装箱拆箱"><a href="#装箱拆箱" class="headerlink" title="装箱拆箱"></a>装箱拆箱</h2><p>hashtable本质上是一个有特殊存储规则的object数组<br>由于用万物之父object来存储数据，自然存在装箱拆箱。<br>当往其中进行值类型存储时即为装箱，当将值类型对象取出来时即为拆箱</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/28/CSharp/CSharp%E8%BF%9B%E9%98%B6/Hashtable/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><p>存的是一对键&#x2F;值，他们都是object类型</p><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections;namespace Lesson4_Hashtable&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;怪物管理器&quot;);            Hashtable hashtable &#x3D; new Hashtable();            string name;            int index &#x3D; 0;                                    while (true)            &#123;                Console.WriteLine(&quot;按q进入创建怪兽模式，按w进入移出怪兽模式，按r退出商店，按a打印现在有的怪兽&quot;);                switch (Console.ReadKey(true).Key)                &#123;                    case ConsoleKey.Q:                        Console.WriteLine(&quot;按e可以退出模式&quot;);                        while (true)                        &#123;                            Console.WriteLine(&quot;请输入怪兽名以创建：&quot;);                            name &#x3D; Console.ReadLine();                            hashtable.Add(name, index++);                            if (Console.ReadKey(true).Key &#x3D;&#x3D; ConsoleKey.E)                            &#123;                                break;                            &#125;                        &#125;                        break;                    case ConsoleKey.W:                        Console.WriteLine(&quot;按e可以退出模式&quot;);                        while (true)                        &#123;                            Console.WriteLine(&quot;请输入想要删除的怪兽：&quot;);                            name &#x3D; Console.ReadLine();                            hashtable.Remove(name);                            if (Console.ReadKey(true).Key &#x3D;&#x3D; ConsoleKey.E)                            &#123;                                break;                            &#125;                        &#125;                        break;                    case ConsoleKey.A:                        NowMonster(hashtable);                        break;                    case ConsoleKey.R:                        Environment.Exit(0);                        break;                &#125;            &#125;        &#125;        static void NowMonster(Hashtable hashtable)        &#123;            IDictionaryEnumerator myEnumerator &#x3D; hashtable.GetEnumerator();            bool flag &#x3D; myEnumerator.MoveNext();            while (flag)            &#123;                Console.WriteLine(&quot;怪兽：&#123;0&#125;，ID&#x3D;&#123;1&#125;&quot;, myEnumerator.Key, myEnumerator.Value);                flag &#x3D; myEnumerator.MoveNext();            &#125;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Queue</title>
    <link href="/2022/05/28/CSharp/CSharp%E8%BF%9B%E9%98%B6/Queue/"/>
    <url>/2022/05/28/CSharp/CSharp%E8%BF%9B%E9%98%B6/Queue/</url>
    
    <content type="html"><![CDATA[<p>Queue</p><span id="more"></span><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p>Queue是C#已经封装好的一个类<br>它的本质是一个object类型的数组,只是封装了特殊的存储规则</p><p>Queue是队列存储容器，<br>队列是一种<strong>先进先出</strong>的数据结构，<br>先存入的数据先获取，后存入的数据后获取</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System.Collections;    Queue queue &#x3D; new Queue();</code></pre></div><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;往队列中存储一个元素queue.Enqueue(object);</code></pre></div><h2 id="取"><a href="#取" class="headerlink" title="取"></a>取</h2><p>队列里不存在删除的概念</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;取出先加入队列的元素object &#x3D; queue.Dequeue();</code></pre></div><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><p>队列无法查看指定位置的元素，只能查看最后加入队列的内容</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;查看最后加入队列的元素object &#x3D; queue.Peek();&#x2F;&#x2F;查看元素是否存在队列中(bool)stack.Contains(object);</code></pre></div><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><p>队列无法改变其中元素，它只能进出队列，但可以清空</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;清空栈stack.Clear();</code></pre></div><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>由于队列里面没有提供索引器来中括号访问的接口，所以无法用for直接进行循环遍历</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;栈长度queue.Count&#x2F;&#x2F;迭代器遍历 顺序栈顶到栈底foreach (object item in queue)&#123;    &#x2F;&#x2F;需要的逻辑 &#125;&#x2F;&#x2F;将栈转换为object数组 顺序栈顶到栈底object[] array &#x3D; queue.ToArray();for( i &#x3D; 0; i &lt; array.Length; i++ )&#123;    &#x2F;&#x2F;需要的逻辑 &#125;&#x2F;&#x2F;循环出列while( queue.Count &gt; 0 )&#123;    object q &#x3D; queue.Dequeue();    Console.WriteLine(q);&#125;Console.WriteLine( queue.Count );</code></pre></div><h2 id="装箱拆箱"><a href="#装箱拆箱" class="headerlink" title="装箱拆箱"></a>装箱拆箱</h2><p>queue本质上是一个有特殊存储规则的object数组<br>由于用万物之父object来存储数据，自然存在装箱拆箱。<br>当往其中进行值类型存储时即为装箱，当将值类型对象取出来时即为拆箱</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">int i &#x3D; 1;queue.Enqueue(i); &#x2F;&#x2F;装箱i &#x3D; (int)queue.Dequeue(); &#x2F;&#x2F;拆箱</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/28/CSharp/CSharp%E8%BF%9B%E9%98%B6/Queue/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><p>先进先出</p><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections;namespace Lesson3_Queue&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Queue queue &#x3D; new Queue();            Console.WriteLine(&quot;请输入你要存储的消息：&quot;);            Input(queue);            Console.WriteLine(&quot;\n已保存您的消息，按回车为您播放\n&quot;);            if( Console.ReadKey(true).Key &#x3D;&#x3D; ConsoleKey.Enter )            &#123;                Output(queue);                Console.WriteLine(&quot;\n已播放完所有您的消息&quot;);                Environment.Exit(0);            &#125;        &#125;        static void Input(Queue queue)        &#123;            object message;            &#x2F;&#x2F;输入10个数停止输入（可以拓展为特殊指令停止输入）            while ((string)(message &#x3D; Console.ReadLine()) !&#x3D; &quot;end&quot;)            &#123;                queue.Enqueue(message);            &#125;        &#125;        static void Output(Queue queue)        &#123;            int updateIndex &#x3D; 0;            while (queue.Count &gt; 0)            &#123;                if (updateIndex++ &#x3D;&#x3D; 500000000)                &#123;                    object q &#x3D; queue.Dequeue();                    Console.WriteLine(q);                    updateIndex &#x3D; 0;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月28日</title>
    <link href="/2022/05/28/diary/2022.5/2022%E5%B9%B45%E6%9C%8828%E6%97%A5/"/>
    <url>/2022/05/28/diary/2022.5/2022%E5%B9%B45%E6%9C%8828%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="84dcb4d42cb9297933669081676b69219e36aa1385f41d37ab53ac4e791d5f6e">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50fdd0ca3edc57389bd0e88084b7db2023864dedcaf29722604466ff56cd1351098391ce02fc05a8d8d5df856d96ca7afe1aee599b47e793590800307447ea37035438f56b30fce5371015d90e9b5283da6b2f2a12ea95f71ccfb89fae65db3524fd4e696adea04efb147fbe8dd0a251a0f0e0aade4a59b33ed6cc4fb6c85862e21e1bd2883d0342693ea1658a84ec69a8e001b9f38ecaf5619391fb8ebff1bc983179255323c94e6f64b0e17b0cb4ab310e9a6be85fa95a081cdde4012672884c3633bdade2bc543b95e7c33d1ac46c586453b834661df1cecc017a3369374519297722edc11d71d205d3b1170c9c42738687e7d9e38c1bcb946131e45cc5291fff1883706597a816269c4700c277bf261ec19290a85f8feddace418a18b75d2c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Stack</title>
    <link href="/2022/05/27/CSharp/CSharp%E8%BF%9B%E9%98%B6/Stack/"/>
    <url>/2022/05/27/CSharp/CSharp%E8%BF%9B%E9%98%B6/Stack/</url>
    
    <content type="html"><![CDATA[<p>Stack</p><span id="more"></span><h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><p>Stack是C#已经封装好的一个类<br>它的本质是一个object类型的数组,只是封装了特殊的存储规则</p><p>Stack是一个栈存储容器，栈是一种<strong>先进后出</strong>的数据结构<br>先存入的数据（栈底）后获取，后存入的数据（栈顶）先获取</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System.Collections;    Stack stack &#x3D; new Stack();</code></pre></div><h2 id="增-压栈"><a href="#增-压栈" class="headerlink" title="增(压栈)"></a>增(压栈)</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;往栈顶压入一个元素stack.Push(object);</code></pre></div><h2 id="取-弹栈"><a href="#取-弹栈" class="headerlink" title="取(弹栈)"></a>取(弹栈)</h2><p>栈里不存在删除的概念</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;弹出栈顶元素object &#x3D; stack.Pop();</code></pre></div><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><p>栈无法查看指定位置的元素，只能查看栈顶的内容</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;查看栈顶的内容(并不弹出来)object &#x3D; stack.Peek();&#x2F;&#x2F;查看元素是否存在与栈中(bool)stack.Contains(object);</code></pre></div><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><p>栈无法改变其中元素，它只能压和弹，但可以清空</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;清空栈stack.Clear();</code></pre></div><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>由于栈里面没有提供索引器来中括号访问的接口，所以无法用for直接进行循环遍历</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;栈长度stack.Count&#x2F;&#x2F;迭代器遍历 顺序栈顶到栈底foreach (object item in stack)&#123;    &#x2F;&#x2F;需要的逻辑 &#125;&#x2F;&#x2F;将栈转换为object数组 顺序栈顶到栈底object[] array &#x3D; stack.ToArray();for( i &#x3D; 0; i &lt; array.Length; i++ )&#123;    &#x2F;&#x2F;需要的逻辑 &#125;&#x2F;&#x2F;循环弹栈while( stack.Count &gt; 0 )&#123;    object o &#x3D; stack.Pop();    Console.WriteLine(o);&#125;Console.WriteLine(stack.Count);</code></pre></div><h2 id="装箱拆箱"><a href="#装箱拆箱" class="headerlink" title="装箱拆箱"></a>装箱拆箱</h2><p>stack本质上是一个有特殊存储规则的object数组<br>由于用万物之父object来存储数据，自然存在装箱拆箱。<br>当往其中进行值类型存储时即为装箱，当将值类型对象取出来时即为拆箱</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">int i &#x3D; 1;stack.Push(i); &#x2F;&#x2F;装箱i &#x3D; (int)stack.Pop(); &#x2F;&#x2F;拆箱</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/27/CSharp/CSharp%E8%BF%9B%E9%98%B6/Stack/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><p>先进后出</p><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections;namespace Lesson2_Stack&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            while (true)            &#123;                Console.Write(&quot;请输入一个十进制数: &quot;);                uint num &#x3D; uint.Parse(Console.ReadLine());                Console.Write(&quot;转换成的二进制数: &quot;);                Calc(num);                Console.WriteLine(&quot;\n&quot;);            &#125;                    &#125;        static void Calc(uint num)        &#123;            Stack stack &#x3D; new Stack();            while(num &gt; 1)            &#123;                stack.Push(num % 2);                num &#x2F;&#x3D; 2;                if(num &#x3D;&#x3D; 1)                &#123;                    stack.Push(num);                    break;                &#125;            &#125;            while(stack.Count &gt; 0)            &#123;                Console.Write(stack.Pop());            &#125;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArrayList</title>
    <link href="/2022/05/27/CSharp/CSharp%E8%BF%9B%E9%98%B6/ArrayList/"/>
    <url>/2022/05/27/CSharp/CSharp%E8%BF%9B%E9%98%B6/ArrayList/</url>
    
    <content type="html"><![CDATA[<p>ArrayList</p><span id="more"></span><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><p>ArrayList是C#已经封装好的一个类<br>它的本质是一个object类型的数组</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System.Collections;    ArrayList array &#x3D; new ArrayList();</code></pre></div><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;增加一个元素array.Add(object);&#x2F;&#x2F;批量增加，把另一个list容器中的元素加到后面array.AddRange(array2);&#x2F;&#x2F;插入元素array.Insert(索引值, object); &#x2F;&#x2F;在该位置插入想要插入的元素</code></pre></div><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;移出指定元素，从头找，找到删array.Remove(object);&#x2F;&#x2F;移除指定位置元素array.RemoveAt(索引值);&#x2F;&#x2F;清空数组array.Clear();</code></pre></div><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;得到指定位置的元素Console.WriteLine(array[0]);&#x2F;&#x2F;查询元素是否存在array.Contains(object); &#x2F;&#x2F;存在为真,不存在为假&#x2F;&#x2F;正向查找元素位置,正向第一个找到的位置array.IndexOf(object); &#x2F;&#x2F;返回索引值,没找到返回-1 &#x2F;&#x2F;正向查找元素位置,反向第一个找到的位置array.LastIndexOf(object); &#x2F;&#x2F;返回索引值,没找到返回-1 </code></pre></div><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;直接改指定位置的元素array[索引值] &#x3D; object;</code></pre></div><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;数组长度array.Count&#x2F;&#x2F;数组容量array.Capacity&#x2F;&#x2F;遍历for( i &#x3D; 0; i &lt; array.Count; i++ )&#123;    &#x2F;&#x2F;需要的逻辑&#125;&#x2F;&#x2F;迭代器遍历 把array里的元素放到item里foreach (object item in array)&#123;    &#x2F;&#x2F;需要的逻辑 &#125;</code></pre></div><h2 id="装箱拆箱"><a href="#装箱拆箱" class="headerlink" title="装箱拆箱"></a>装箱拆箱</h2><p>ArrayList本质上是一个可以自动扩容的object数组<br>由于用万物之父object来存储数据，自然存在装箱拆箱。<br>当往其中进行值类型存储时即为装箱，当将值类型对象取出来时即为拆箱<br>ArrayList尽量少用</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">int i &#x3D; 1;array[0] &#x3D; i; &#x2F;&#x2F;装箱i &#x3D; (int)array[0]; &#x2F;&#x2F;拆箱</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/27/CSharp/CSharp%E8%BF%9B%E9%98%B6/ArrayList/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><p>ArrayList就是一个可以自动扩容的object类型的数组</p><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections;namespace Lesson1_ArrayList&#123;    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 道具种类    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_ItemType    &#123;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 回血药        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        HpRecovery,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 回蓝药        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        MpRecovery,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 复活药        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Revival,    &#125;    class BagManagement    &#123;        &#x2F;&#x2F;初始金币100        private int money &#x3D; 100;        &#x2F;&#x2F;道具        private ArrayList items &#x3D; new ArrayList();        public BagManagement()        &#123;            items.Clear();        &#125;        &#x2F;&#x2F;购买道具方法        public void BuyItem(Item i)        &#123;            if((money - i.price) &gt; 0 )            &#123;                items.Add(i);                money -&#x3D; i.price;                Console.WriteLine(&quot;购买成功\n&quot;);            &#125;            else            &#123;                Console.WriteLine(&quot;金币不够，购买失败\n&quot;);            &#125;                      &#125;        &#x2F;&#x2F;卖出道具方法        public void SellItem(Item i)        &#123;            if(items.Contains(i))            &#123;                items.Remove(i);                money +&#x3D; i.price;                Console.WriteLine(&quot;出售成功\n&quot;);            &#125;            else            &#123;                Console.WriteLine(&quot;出售失败\n&quot;);            &#125;                    &#125;        &#x2F;&#x2F;显示道具方法        public void MyBag()        &#123;            if(items.Count &gt; 0)            &#123;                for (int i &#x3D; 0; i &lt; items.Count; i++)                &#123;                    (items[i] as Item).Show();                 &#125;                Console.WriteLine(&quot;现在还有&#123;0&#125;金币\n&quot;, money);            &#125;            else            &#123;                Console.WriteLine(&quot;背包为空&quot;);            &#125;        &#125;    &#125;    abstract class Item    &#123;        abstract public void Show();        protected E_ItemType type;        public int price;    &#125;    class HpRecovery : Item    &#123;        public HpRecovery()        &#123;            type &#x3D; E_ItemType.HpRecovery;            price &#x3D; 20;        &#125;        public override void Show()        &#123;            Console.Write(&quot;回血药*1,&quot;);        &#125;    &#125;    class MpRecovery : Item    &#123;        public MpRecovery()        &#123;            type &#x3D; E_ItemType.MpRecovery;            price &#x3D; 10;        &#125;        public override void Show()        &#123;            Console.Write(&quot;回蓝药*1,&quot;);        &#125;    &#125;    class Revival : Item    &#123;        public Revival()        &#123;            type &#x3D; E_ItemType.Revival;            price &#x3D; 50;        &#125;        public override void Show()        &#123;            Console.Write(&quot;复活药*1,&quot;);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Item hpRecovery &#x3D; new HpRecovery();            Item mpRecovery &#x3D; new MpRecovery();            Item Revival &#x3D; new Revival();            BagManagement bagManagement &#x3D; new BagManagement();            Console.WriteLine(&quot;进入商店，店里有回血药（20金币）、回蓝药（10金币）、复活药（50）金币&quot;);                        Console.WriteLine(&quot;&quot;);            while (true)            &#123;                                try                &#123;                    Console.WriteLine(&quot;按q进入购买模式，按w进入出售模式，按e显示背包，按r退出商店&quot;);                    switch (Console.ReadKey(true).Key)                    &#123;                        case ConsoleKey.Q:                            Console.WriteLine(&quot;按a选择回血药，按s选择回蓝药，按d选择复活药&quot;);                            try                            &#123;                                switch (Console.ReadKey(true).Key)                                &#123;                                    case ConsoleKey.A:                                        bagManagement.BuyItem(hpRecovery);                                        break;                                    case ConsoleKey.S:                                        bagManagement.BuyItem(mpRecovery);                                        break;                                    case ConsoleKey.D:                                        bagManagement.BuyItem(Revival);                                        break;                                &#125;                            &#125;                            catch &#123; Console.WriteLine(&quot;请输入正确指令\n&quot;); &#125;                            break;                                                case ConsoleKey.W:                            Console.WriteLine(&quot;按a选择回血药，按s选择回蓝药，按d选择复活药&quot;);                            try                            &#123;                                switch (Console.ReadKey(true).Key)                                &#123;                                    case ConsoleKey.A:                                        bagManagement.SellItem(hpRecovery);                                        break;                                    case ConsoleKey.S:                                        bagManagement.SellItem(mpRecovery);                                        break;                                    case ConsoleKey.D:                                        bagManagement.SellItem(Revival);                                        break;                                &#125;                            &#125;                            catch &#123; Console.WriteLine(&quot;请输入正确指令\n&quot;); &#125;                            break;                        case ConsoleKey.E:                            bagManagement.MyBag();                            break;                        case ConsoleKey.R:                            Environment.Exit(0);                            break;                    &#125;                &#125;                catch                &#123;                    Console.WriteLine(&quot;请输入正确指令\n&quot;);                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月27日</title>
    <link href="/2022/05/27/diary/2022.5/2022%E5%B9%B45%E6%9C%8827%E6%97%A5/"/>
    <url>/2022/05/27/diary/2022.5/2022%E5%B9%B45%E6%9C%8827%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="19eaac3c558563ac3af9f901fbf434cc87472ac4271f9c84aa9c8aeeed19ea94">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50c3ac06e6f61fe5887c5b94f65bc78d9466e9c645746ff39fd7764c28fce597a98ef90554385047c8cd380b682d6c36897f111398d792cdf413d3724f0b3487b0d6c4344fdea739a201a15a25e426c48d5f58a20be69bf7d5d8fdd3d0b29ac505df147cdb70bc846113e18e84488305fcab0663b1022f9a134ccc50d562126a63efa205176ddcd837c2d5cd028bf0f2c9f315b524ec0219c08e2dd2ab834e25a4cdad9856964c3048f23fe4e5cc167a37f7c0fae660b9368142d8c848302b5e47d2385eb03c1027fd0cb6e360cd685a4a23ef151e8eaef04ece2dbf4a7e839871</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月26</title>
    <link href="/2022/05/26/diary/2022.5/2022%E5%B9%B45%E6%9C%8826%E6%97%A5/"/>
    <url>/2022/05/26/diary/2022.5/2022%E5%B9%B45%E6%9C%8826%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="a2e468b686d8665f8e4c121eb76bfdc32a3a832dd2f9982da2724c5e78f5e301">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe503619eff7dff6c9b0a85b11a78d93a4051b73d5cd83ebaf35cca5f7643c01abda1af045ea1c1ff179d55eb176e39c95b89f9034bb22a2efc5e4681e7a90646ea4225c005fc0d268cc385e70989933570cc98084e852ec61a8c366e1263c5c896005d2f3251fe37e12578d87a35051b87e1270628f468f5dc8e2570a56e45e9da1444974c84bb000c1b4c091028d2f91620b9fe921f41e5649f05126b8bcdc79c24e2a09c085eb575624c728a388e8fec04d41180b0ba2457b8d47425aecfcd977824db8af4da012a172771720551eacecf8fcd6a892394469f352268d4850de353f2e2fb8cdaae4539ab2bafbbd8adf14758e80b47fedf19533238130a017f31113453ea7b7c1d90d9ab8db545318bf33e92d0d40e88232cdcc1842b14370357e7b3f355e16b80b5f265a3b3391be0a7f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月25日</title>
    <link href="/2022/05/25/diary/2022.5/2022%E5%B9%B45%E6%9C%8825%E6%97%A5/"/>
    <url>/2022/05/25/diary/2022.5/2022%E5%B9%B45%E6%9C%8825%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="e3ceef968f0f28d3f1dd370815788b715c166c276dd39cfbf4d5cd992f210444">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50b9d57857458f6060ad6c9d0947720f2b81966f40a7c8271e7fa31bf05b458e7d5d118009571b608c05167d793a08f412e353aacf5e3e7e9d45bebcd350706970eabdf3e2d7dfb0ffc06ab2719c2acd8a9ff01f455bdf04170a047042455ff83032bf53eabb6ccfed8e48036fa66d621d18ae7e241616c3019fc71f043b6be4461162938138e51cafa90933700a85c22ef29ca91578ee48e4c50f4019f090e479f125a34e04fe1d9ecf2bf102003a9c105535757cfad837d6f5f4b70b9552a614</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贪吃蛇实现</title>
    <link href="/2022/05/24/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E8%B4%AA%E5%90%83%E8%9B%87%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/05/24/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E8%B4%AA%E5%90%83%E8%9B%87%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>贪吃蛇实现</p><span id="more"></span><p>试着在工程里实现多脚本，一个类一个脚本</p><p>UML类图：面向对象程序开发时理清对象关系，养成面向对象编程习惯<br>关联，直接关联，聚合，依赖关系，复合</p><h1 id="七大原则："><a href="#七大原则：" class="headerlink" title="七大原则："></a>七大原则：</h1><p>总体要实现<strong>高内聚，低耦合</strong><br>使程序模块的可重用性、移植性增强</p><h2 id="高内聚，低耦合："><a href="#高内聚，低耦合：" class="headerlink" title="高内聚，低耦合："></a>高内聚，低耦合：</h2><p>1.类的角度：减少类内部，对其他类的调用<br>2.功能块的角度：减少模块之间的交互复杂度</p><h2 id="单一职责原则（SPR-Single-Responsibility-Principle）"><a href="#单一职责原则（SPR-Single-Responsibility-Principle）" class="headerlink" title="单一职责原则（SPR-Single Responsibility Principle）"></a>单一职责原则（SPR-Single Responsibility Principle）</h2><p>类被修改的概率很大，因此应该专注于单一的功能。<br>如果把多个功能放在同一个类中，功能之间就形成了关联，改变其中一个功能，有可能中止另一个功能</p><h2 id="开闭原则（OCP-Open-Closed-Principle）"><a href="#开闭原则（OCP-Open-Closed-Principle）" class="headerlink" title="开闭原则（OCP-Open Closed Principle）"></a>开闭原则（OCP-Open Closed Principle）</h2><p>对扩展开放，对修改关闭<br>拓展开放：模块的行为可以被拓展从而满足新的需求<br>修改关闭：不允许修改模块的源代码（或尽量使修改最小化）</p><h2 id="里式替换原则（LSP-Liskov-Substitution-Principle）"><a href="#里式替换原则（LSP-Liskov-Substitution-Principle）" class="headerlink" title="里式替换原则（LSP-Liskov Substitution Principle）"></a>里式替换原则（LSP-Liskov Substitution Principle）</h2><p>任何父类出现的地方，子类都可以代替</p><h2 id="依赖倒转原则（DIP-Dependence-Inversion-Principle）"><a href="#依赖倒转原则（DIP-Dependence-Inversion-Principle）" class="headerlink" title="依赖倒转原则（DIP-Dependence Inversion Principle）"></a>依赖倒转原则（DIP-Dependence Inversion Principle）</h2><p>要依赖于抽象（接口），不要依赖于具体的实现</p><h2 id="迪米特原则（LoD-Law-of-Demeter）"><a href="#迪米特原则（LoD-Law-of-Demeter）" class="headerlink" title="迪米特原则（LoD-Law of Demeter）"></a>迪米特原则（LoD-Law of Demeter）</h2><p>又称最小知识原则<br>一个对象应该对其他对象尽可能少的了解<br>一个对象中的成员，要尽可能少的直接和其他类建立关系，目的是降低耦合性</p><h2 id="接口分离原则（ISP-Interface-Segregation-Principle）"><a href="#接口分离原则（ISP-Interface-Segregation-Principle）" class="headerlink" title="接口分离原则（ISP-Interface Segregation Principle）"></a>接口分离原则（ISP-Interface Segregation Principle）</h2><p>一个接口不需要提供太多的行为，一个接口应该尽量只提供一个对外的功能，让别人去选择需要实现什么样的行为，而不是把所有的行为封装到一个接口里</p><h2 id="合成复用原则（CRP-Composite-Reuse-Principle）"><a href="#合成复用原则（CRP-Composite-Reuse-Principle）" class="headerlink" title="合成复用原则（CRP-Composite Reuse Principle）"></a>合成复用原则（CRP-Composite Reuse Principle）</h2><p>尽量使用对象组合，而不是继承来达到复用的目的<br>继承是强耦合，组合关系是弱耦合<br>注意：不能盲目的使用合成复用原则，要在遵循迪米特原则的前提下</p><p>在开始做项目之前，整理UML类图时，<br>先按自己的想法把需要的类整理出来<br>再基于七大法则去优化整理自己的设计<br>最后，具体问题具体分析，面向对象的编程能力提升是需要经验积累的。</p><h1 id="贪吃蛇"><a href="#贪吃蛇" class="headerlink" title="贪吃蛇"></a>贪吃蛇</h1><h2 id="Scene"><a href="#Scene" class="headerlink" title="Scene"></a>Scene</h2><h3 id="ISceneUpdate"><a href="#ISceneUpdate" class="headerlink" title="ISceneUpdate"></a>ISceneUpdate</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 贪吃蛇.Scene&#123;    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 场景更新接口    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    internal interface ISceneUpdate    &#123;        void Update();    &#125;&#125;</code></pre></div><h3 id="BeginOrEndBaseScene"><a href="#BeginOrEndBaseScene" class="headerlink" title="BeginOrEndBaseScene"></a>BeginOrEndBaseScene</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 贪吃蛇.Scene&#123;    &#x2F;&#x2F;抽象基类    abstract class BeginOrEndBaseScene:ISceneUpdate    &#123;        protected int nowSelIndex;        protected string strTitle;        protected string strOne;        public abstract void EnterJDoSomething();        public void Update()        &#123;            Console.ForegroundColor &#x3D; ConsoleColor.White;            &#x2F;&#x2F;显示标题            Console.SetCursorPosition( Game.w &#x2F; 2 - strTitle.Length, 5);            Console.WriteLine(strTitle);            &#x2F;&#x2F;显示下方选项            Console.SetCursorPosition(Game.w &#x2F; 2 - strOne.Length, 8);            Console.ForegroundColor &#x3D; nowSelIndex &#x3D;&#x3D; 0 ? ConsoleColor.Red : ConsoleColor.White;            Console.WriteLine(strOne);            Console.SetCursorPosition(Game.w &#x2F; 2 - 4, 10);            Console.ForegroundColor &#x3D; nowSelIndex &#x3D;&#x3D; 1 ? ConsoleColor.Red : ConsoleColor.White;            Console.WriteLine(&quot;结束游戏&quot;);            &#x2F;&#x2F;检测输入            switch(Console.ReadKey(true).Key)            &#123;                case ConsoleKey.W:                    --nowSelIndex;                    if(nowSelIndex &lt; 0)                    &#123;                        nowSelIndex &#x3D; 0;                    &#125;                    break;                case ConsoleKey.S:                    ++nowSelIndex;                    if (nowSelIndex &gt; 1)                    &#123;                        nowSelIndex &#x3D; 1;                    &#125;                    break;                case ConsoleKey.J:                    EnterJDoSomething();                    break;            &#125;        &#125;    &#125;&#125;</code></pre></div><h3 id="BeginScene"><a href="#BeginScene" class="headerlink" title="BeginScene"></a>BeginScene</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 贪吃蛇.Scene&#123;    internal class BeginScene:BeginOrEndBaseScene    &#123;        public BeginScene()        &#123;            strTitle &#x3D; &quot;贪吃蛇&quot;;            strOne &#x3D; &quot;开始游戏&quot;;        &#125;        public override void EnterJDoSomething()        &#123;            if(nowSelIndex &#x3D;&#x3D; 0)            &#123;                Game.ChangeScene(E_SceneType.Game);            &#125;            else            &#123;                Environment.Exit(0);            &#125;        &#125;    &#125;&#125;</code></pre></div><h3 id="EndScene"><a href="#EndScene" class="headerlink" title="EndScene"></a>EndScene</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 贪吃蛇.Scene&#123;    internal class EndScene : BeginOrEndBaseScene    &#123;        public EndScene()        &#123;            strTitle &#x3D; &quot;结束游戏&quot;;            strOne &#x3D; &quot;回到开始界面&quot;;        &#125;        public override void EnterJDoSomething()        &#123;            if (nowSelIndex &#x3D;&#x3D; 0)            &#123;                Game.ChangeScene(E_SceneType.Begin);            &#125;            else            &#123;                Environment.Exit(0);            &#125;        &#125;    &#125;&#125;</code></pre></div><h3 id="GameScene"><a href="#GameScene" class="headerlink" title="GameScene"></a>GameScene</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using 贪吃蛇.Snake;namespace 贪吃蛇.Scene&#123;    class GameScene: ISceneUpdate    &#123;        MapObject map;        SnakeObject snake;        Food food;        &#x2F;&#x2F;延迟计数        int updateIndex &#x3D; 0;        public GameScene()        &#123;            map &#x3D; new MapObject();            snake &#x3D; new SnakeObject(40, 10);            food &#x3D; new Food(snake);            map.Draw();        &#125;        public void Update()        &#123;            if (updateIndex % 5555 &#x3D;&#x3D; 0)            &#123;                food.Draw();                snake.Move();                snake.Draw();                &#x2F;&#x2F;检测是否撞墙                if (snake.CheckEnd(map))                &#123;                    &#x2F;&#x2F;结束逻辑                    Game.ChangeScene(E_SceneType.End);                &#125;                snake.CheckEatFood(food);                updateIndex &#x3D; 0;            &#125;            ++updateIndex;            &#x2F;&#x2F;在控制台中 检测玩家输入 让程序不被检测卡主            &#x2F;&#x2F;判断 有没有键盘输入 如果有 才为true            if (Console.KeyAvailable)            &#123;                &#x2F;&#x2F;检测输入输出 不能再 间隔帧里面去处理 应该每次都检测 这样才准确                switch (Console.ReadKey(true).Key)                &#123;                    case ConsoleKey.W:                        snake.ChangeDir(E_MoveDir.Up);                        break;                    case ConsoleKey.A:                        snake.ChangeDir(E_MoveDir.Left);                        break;                    case ConsoleKey.S:                        snake.ChangeDir(E_MoveDir.Down);                        break;                    case ConsoleKey.D:                        snake.ChangeDir(E_MoveDir.Right);                        break;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div><h3 id="Game"><a href="#Game" class="headerlink" title="Game"></a>Game</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 贪吃蛇.Scene&#123;    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 场景类型枚举    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_SceneType    &#123;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 开始场景        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Begin,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 游戏场景        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Game,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 结束场景        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        End,    &#125;    class Game    &#123;        &#x2F;&#x2F;游戏窗口宽高        public const int w &#x3D; 80;        public const int h &#x3D; 20;        &#x2F;&#x2F;当前选中的场景        public static ISceneUpdate nowScene;        &#x2F;&#x2F;初始化的方法        public Game()        &#123;            Console.CursorVisible &#x3D; false;            Console.SetWindowSize(w, h);            Console.SetBufferSize(w, h);            ChangeScene(E_SceneType.Begin);        &#125;        &#x2F;&#x2F;游戏开始的方法        public void Start()        &#123;            &#x2F;&#x2F;游戏主循环 负责游戏场景的更新            while(true)            &#123;                &#x2F;&#x2F;判断当前游戏场景不为空 就更新                if(nowScene !&#x3D; null)                &#123;                    nowScene.Update();                &#125;            &#125;        &#125;        &#x2F;&#x2F;切换场景的方法        public static void ChangeScene(E_SceneType type)        &#123;            &#x2F;&#x2F;切场景之前，应该清空上一个场景的内容            Console.Clear();            switch (type)            &#123;                case E_SceneType.Begin:                    nowScene &#x3D; new BeginScene();                    break;                case E_SceneType.Game:                    nowScene &#x3D; new GameScene();                    break;                case E_SceneType.End:                    nowScene &#x3D; new EndScene();                    break;            &#125;        &#125;    &#125;&#125;</code></pre></div><h2 id="Snake"><a href="#Snake" class="headerlink" title="Snake"></a>Snake</h2><h3 id="IDraw"><a href="#IDraw" class="headerlink" title="IDraw"></a>IDraw</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 贪吃蛇.Snake&#123;    interface IDraw    &#123;        void Draw();    &#125;&#125;</code></pre></div><p>结构体</p><h3 id="Position"><a href="#Position" class="headerlink" title="Position"></a>Position</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 贪吃蛇.Snake&#123;    struct Position    &#123;        public int x;        public int y;        public Position(int x, int y)        &#123;            this.x &#x3D; x;            this.y &#x3D; y;        &#125;        &#x2F;&#x2F;贪吃蛇中存在位置的比较(头和身体、事物、墙比较)        public static bool operator &#x3D;&#x3D;(Position p1, Position p2)        &#123;            if(p1.x &#x3D;&#x3D; p2.x &amp;&amp; p1.y &#x3D;&#x3D; p2.y)            &#123;                return true;            &#125;            else            &#123;                return false;            &#125;               &#125;        public static bool operator !&#x3D;(Position p1, Position p2)        &#123;            if (p1.x &#x3D;&#x3D; p2.x &amp;&amp; p1.y &#x3D;&#x3D; p2.y)            &#123;                return false;            &#125;            else            &#123;                return true;            &#125;        &#125;    &#125;&#125;</code></pre></div><h3 id="GameObject"><a href="#GameObject" class="headerlink" title="GameObject"></a>GameObject</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 贪吃蛇.Snake&#123;    abstract class GameObject:IDraw    &#123;        &#x2F;&#x2F;继承接口后，把接口中的行为、编程、抽象行为供子类去实现        &#x2F;&#x2F;因为是抽象行为，所以子类中是必须去实现        abstract public void Draw();        public Position pos;    &#125;&#125;</code></pre></div><h3 id="SnakeBody"><a href="#SnakeBody" class="headerlink" title="SnakeBody"></a>SnakeBody</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 贪吃蛇.Snake&#123;    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 蛇身体类型    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_SnakeBody_Type    &#123;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 蛇头        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Head,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 蛇躯        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Body,    &#125;    class SnakeBody:GameObject    &#123;        private E_SnakeBody_Type type;        public SnakeBody(E_SnakeBody_Type type, int x, int y)        &#123;            this.type &#x3D; type;            this.pos &#x3D; new Position(x, y);        &#125;        public override void Draw()        &#123;            Console.SetCursorPosition(pos.x, pos.y);            Console.ForegroundColor &#x3D; type &#x3D;&#x3D; E_SnakeBody_Type.Head ? ConsoleColor.Yellow : ConsoleColor.Green;            Console.Write(type &#x3D;&#x3D; E_SnakeBody_Type.Head ? &quot;●&quot; : &quot;◎&quot;);        &#125;    &#125;&#125;</code></pre></div><h3 id="Wall"><a href="#Wall" class="headerlink" title="Wall"></a>Wall</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 贪吃蛇.Snake&#123;    internal class Wall : GameObject    &#123;        public Wall(int x, int y)        &#123;            pos &#x3D; new Position(x, y);        &#125;        public override void Draw()        &#123;            Console.SetCursorPosition(pos.x, pos.y);            Console.ForegroundColor &#x3D; ConsoleColor.Red;            Console.WriteLine(&quot;■&quot;);        &#125;    &#125;&#125;</code></pre></div><h3 id="MapObject"><a href="#MapObject" class="headerlink" title="MapObject"></a>MapObject</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using 贪吃蛇.Scene;namespace 贪吃蛇.Snake&#123;    class MapObject : IDraw    &#123;        public Wall[] walls;                public MapObject()        &#123;            walls &#x3D; new Wall[ Game.w + (Game.h - 3) * 2 ];            int index &#x3D; 0;            for (int i &#x3D; 0; i &lt; Game.w; i +&#x3D; 2)            &#123;                &#x2F;&#x2F;上面的墙                walls[index++] &#x3D; new Wall(i, 0);            &#125;            for (int i &#x3D; 0; i &lt; Game.w; i +&#x3D; 2)            &#123;                &#x2F;&#x2F;下面的墙                walls[index++] &#x3D; new Wall(i, Game.h - 2);            &#125;            for (int i &#x3D; 1; i &lt; Game.h - 2; i++)            &#123;                &#x2F;&#x2F;左边的墙                walls[index++] &#x3D; new Wall(0, i);            &#125;            for (int i &#x3D; 1; i &lt; Game.h - 2; i++)            &#123;                &#x2F;&#x2F;右边的墙                walls[index++] &#x3D; new Wall(Game.w - 2, i);            &#125;        &#125;        public void Draw()        &#123;            for (int i &#x3D; 0; i &lt; walls.Length; i++)            &#123;                walls[i].Draw();            &#125;        &#125;    &#125;&#125;</code></pre></div><h3 id="Food"><a href="#Food" class="headerlink" title="Food"></a>Food</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using 贪吃蛇.Scene;namespace 贪吃蛇.Snake&#123;    class Food:GameObject    &#123;        public Food(SnakeObject snake)        &#123;            RandomPos(snake);        &#125;        public override void Draw()        &#123;            Console.SetCursorPosition(pos.x, pos.y);            Console.ForegroundColor &#x3D; ConsoleColor.Cyan;            Console.Write(&quot;¤&quot;);        &#125;        &#x2F;&#x2F;随机位置的行为 行为 和蛇的位置 有关系 有了蛇再来考虑        public void RandomPos(SnakeObject snake)        &#123;            &#x2F;&#x2F;随机位置            Random r &#x3D; new Random();            int x &#x3D; r.Next(2, Game.w &#x2F; 2 - 1) * 2;            int y &#x3D; r.Next(1, Game.h - 4);            pos &#x3D; new Position(x, y);            &#x2F;&#x2F;得到蛇            &#x2F;&#x2F;如果重合 就会进if语句            if (snake.CheckSamePos(pos))            &#123;                RandomPos(snake);            &#125;        &#125;    &#125;&#125;</code></pre></div><h3 id="SnakeObject"><a href="#SnakeObject" class="headerlink" title="SnakeObject"></a>SnakeObject</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 贪吃蛇.Snake&#123;    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 蛇的移动方向    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_MoveDir    &#123;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 向上        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Up,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 向下        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Down,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 向左        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Left,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 向右        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Right,    &#125;    class SnakeObject : IDraw    &#123;        SnakeBody[] bodys;        &#x2F;&#x2F;记录蛇的长度        int nowNum;        &#x2F;&#x2F;定义初始移动方向        E_MoveDir dir;        &#x2F;&#x2F;构造函数定义蛇        public SnakeObject(int x, int y)        &#123;            &#x2F;&#x2F;粗暴定义，最多100            bodys &#x3D; new SnakeBody[200];            &#x2F;&#x2F;蛇头            bodys[0] &#x3D; new SnakeBody(E_SnakeBody_Type.Head, x, y);            &#x2F;&#x2F;之后身子从1开始            nowNum &#x3D; 1;            dir &#x3D; E_MoveDir.Right;        &#125;        &#x2F;&#x2F;蛇绘制        public void Draw()        &#123;            for (int i &#x3D; 0; i &lt; nowNum; i++)            &#123;                bodys[i].Draw();            &#125;        &#125;        &#x2F;&#x2F;蛇移动        public void Move()        &#123;            &#x2F;&#x2F;移动前,擦除最后一个位置            SnakeBody lastBody &#x3D; bodys[nowNum - 1];            Console.SetCursorPosition(lastBody.pos.x, lastBody.pos.y);            Console.Write(&quot;  &quot;);            &#x2F;&#x2F;在蛇头移动之前 从蛇尾开始 不停的 让后一个的位置 等于前一个的位置            for (int i &#x3D; nowNum - 1; i &gt; 0; i--)            &#123;                bodys[i].pos &#x3D; bodys[i - 1].pos;            &#125;            &#x2F;&#x2F;再动            switch (dir)            &#123;                case E_MoveDir.Up:                    --bodys[0].pos.y;                    break;                case E_MoveDir.Down:                    ++bodys[0].pos.y;                    break;                case E_MoveDir.Left:                    bodys[0].pos.x -&#x3D; 2;                    break;                case E_MoveDir.Right:                    bodys[0].pos.x +&#x3D; 2;                    break;            &#125;        &#125;        &#x2F;&#x2F;蛇改变移动方向        public void ChangeDir(E_MoveDir dir)        &#123;            &#x2F;&#x2F;只有头时，可以随意移动；有身体时，不能向相反方向移动            &#x2F;&#x2F;判断何时不能转向            if (dir &#x3D;&#x3D; this.dir ||                nowNum &gt; 1 &amp;&amp;                (this.dir &#x3D;&#x3D; E_MoveDir.Up &amp;&amp; dir &#x3D;&#x3D; E_MoveDir.Down ||                this.dir &#x3D;&#x3D; E_MoveDir.Left &amp;&amp; dir &#x3D;&#x3D; E_MoveDir.Right ||                this.dir &#x3D;&#x3D; E_MoveDir.Down &amp;&amp; dir &#x3D;&#x3D; E_MoveDir.Up ||                this.dir &#x3D;&#x3D; E_MoveDir.Right &amp;&amp; dir &#x3D;&#x3D; E_MoveDir.Left)            )            &#123;                return;            &#125;            this.dir &#x3D; dir;        &#125;        &#x2F;&#x2F;蛇吃食物        public void CheckEatFood(Food food)        &#123;            if (bodys[0].pos &#x3D;&#x3D; food.pos)            &#123;                &#x2F;&#x2F;吃到了 就应该让食物 位置再随机 增加蛇身体的长度                food.RandomPos(this);                &#x2F;&#x2F;长身体                AddBody();            &#125;        &#125;        &#x2F;&#x2F;蛇增加长度(与删除类似)        private void AddBody()        &#123;            SnakeBody frontBody &#x3D; bodys[nowNum - 1];            &#x2F;&#x2F;先长             bodys[nowNum] &#x3D; new SnakeBody(E_SnakeBody_Type.Body, frontBody.pos.x, frontBody.pos.y);            &#x2F;&#x2F;再加长度            nowNum++;        &#125;        &#x2F;&#x2F;定义一个判断是否重合的方法用于食物        public bool CheckSamePos(Position p)        &#123;            for (int i &#x3D; 0; i &lt; nowNum; i++)            &#123;                if (bodys[i].pos &#x3D;&#x3D; p)                &#123;                    return true;                &#125;            &#125;            return false;        &#125;        &#x2F;&#x2F;蛇死亡（蛇头碰到墙壁或者身体）        public bool CheckEnd(MapObject map)        &#123;            &#x2F;&#x2F;是否和墙体位置重合            for (int i &#x3D; 0; i &lt; map.walls.Length; i++)            &#123;                if (bodys[0].pos &#x3D;&#x3D; map.walls[i].pos)                &#123;                    return true;                &#125;            &#125;            &#x2F;&#x2F;是否碰到身体            for (int i &#x3D; 1; i &lt; nowNum; i++)            &#123;                if (bodys[0].pos &#x3D;&#x3D; bodys[i].pos)                &#123;                    return true;                &#125;            &#125;            return false;        &#125;    &#125;&#125;</code></pre></div><h2 id="Program"><a href="#Program" class="headerlink" title="Program"></a>Program</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using 贪吃蛇.Scene;namespace 贪吃蛇&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            Game game &#x3D; new Game();            game.Start();        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月24日</title>
    <link href="/2022/05/24/diary/2022.5/2022%E5%B9%B45%E6%9C%8824%E6%97%A5/"/>
    <url>/2022/05/24/diary/2022.5/2022%E5%B9%B45%E6%9C%8824%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="e025f354054dbf333c6c0e34d1ee3890a2cb2413017d2d7f935e1e598332fbba">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50fdd0ca3edc57389bd0e88084b7db20233010ae8a9f793a5fe132f7bcb6ccd39c344c655e0b5e7c424921b90eaa4ed9b05a1b02186b2a24baf684db4aff7c42132fc7a33d8f8a40db72a2c74a06e881fd7dd850006f54959146afd38c673ccc662c808ebd8fb1df6e33e386d017d4d5cb43ba0e72d34c511aa3d14632da3d611b92b72505c71e90f551aff6f154e64c3d8e2677147a6d306e4110043dfd9ecc3b726102a2762e2c7a4b198d46bef3dbe42139b0d06fa841494a5e449aa992a516c3385ba8c8764faba82213fe718901c5c90516328d779d287a494b52b8ffa5599d717c02179f201eb400323b7b126ba5e9197fde3e30f30929e275acbc025c258be40585e29444283a2ab5b8a459380e2644beca9e7e6cdc89935898b40309479e1968036347b0554be89d3717882cdc4c9aa072b6aea27ddb846c2827bfafdbb65f35ac5d0fc3f3b1eaa339f9a8e9266723dce6d933b1839dc2b35fc643e436dbb84402adab4d784e1dc8ba47d5829942e2ff0d4335c766248a7f4371677be042c0ea44ea84b1fe726c37ef043b7328273dfe69b94902acdf92f59412c450db072d765a336da4dc16e27e9e519446c61588c0ae1fd1cedd5135d40ae3ea596cb45f5d43eca1aa6b7b92ee68ae5cdc9e3c71e106b25c15f7ff71e8f3b636a19a87f48f17c6c71507bb9abb4214e4516b0e8776298f1436f1b65b234a31f8758dfba0bb9f27c574f8eb268538eb1a706b06932332a27a64f86aded4377272a1a68cca0f218210389916aaa70a81d6bbf3354bd7ce1eed4c686f9695a14c39652871b777f6ac8e63b752f81585215f31269729cf3b4069d3ba35a036183becc78e8aeff27f62b154c370e6777fe21c918e7e79361ccda3655d5c5b4b49c60dcc211ade1ce3f7813e95acdee4269f6f978afeecaa6d58410f872bc03229c1373cd83478477603990949506acdbbe2273afa85bf3eeb7d3225390e372096b5017c0016c6b1711efb1a83c88b5d65544494ebe4ebf97b1549635c367c8b5b607bb7f1fd04fdf28f3fa74b5d1d1a022bbb7286a01105d542396461149ffeabffef03f9195d0a842459c43588a8a6abd5929826cc6536093b66592dcb13f1810c05e8101f1a0733da939cb1f7bd850fff84fb25c2443f642f09cfe04ff6f46700cab2723b970b31de4618194d28c4169b8b45af2796942067289a47686ad871ad0dbb8d2ea6704409971336287f1073bdab37366a4f29fb3ed81e2e3986da4098df77f3b8d32dd015f3782271214de0314df39887bbd21761e2fb14841741c5210c36ffd793b0b2946c309e79db45ac70827618b8c3b1e5be81bea4fd63a2f042d0577d3294d6a89ac17e2292c73901ecab5b883ffc7656540b870a6572cc26e3f429335cb4c1637ca13c3f847e837e7776d466eb6dc635a66ed0e1901050204715df37</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>抽象类和接口的区别</title>
    <link href="/2022/05/23/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/05/23/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>抽象类和接口的区别</p><span id="more"></span><h1 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h1><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><p>1.都可以被继承<br>2.都可以被实例化<br>3.都可以包含方法声明<br>4.子类必须是实现未实现的方法<br>5.都遵循里式替换原则</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>1.抽象类中可以有构造函数；接口不能<br>2.抽象类只能备单一继承；接口类可以被继承多个<br>3.抽象类中可以有成员变量；接口中不能<br>4.抽象类中可以声明成员方法，虚方法，抽象方法，静态方法；接口中只能声明没有实现的抽象方法<br>5.抽象类方法可以使用访问修饰符；接口中建议不写，默认public</p><h2 id="如何选择抽象类和接口"><a href="#如何选择抽象类和接口" class="headerlink" title="如何选择抽象类和接口"></a>如何选择抽象类和接口</h2><p>表示对象的用抽象类（动物等），表示行为拓展的用接口（飞翔等）<br>不同对象拥有的共同行为，我们往往可以使用接口来实现</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月23日</title>
    <link href="/2022/05/23/diary/2022.5/2022%E5%B9%B45%E6%9C%8823%E6%97%A5/"/>
    <url>/2022/05/23/diary/2022.5/2022%E5%B9%B45%E6%9C%8823%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="638f7a94ae9f94bd977cbdbc5d29c560c560ead633262ea8e276a739e991176a">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50c8bc290f7583a7ed781da721f0adc73ccebdd6e51127fd5055d63ed9483b654136048faba7cf5273ddbf55c1c792351d3a5445e28648adfc311760c649dfa9d6cf4ec3ced3274cd0a77f0c6d97ae266d8eb322573d38c79dcd925eb1023941a3597f2757d301258715bd3581dadfb5f7f0e63bc4bbeadcffb6daaae98457a8053699b8393abaec0f9fb4695f30a2f904869c5bc0803f61cbed0d1b7596578defb2054ca325fc36cba335ca364ae68ba135d7146e7b46f6839726c3bb46e77ed0f5af1de6007d85396215f6a5c86694de52936e28a470900976f79ec0483ed885b44068612035cdad1a005122e1246a8f8664f6ec50ee51bde518d1ba5d6a6d6b952807d224a0a5bd57d7b26284be865d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构体和类的区别</title>
    <link href="/2022/05/23/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94/%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/05/23/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94/%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>结构体和类的区别</p><span id="more"></span><h1 id="结构体和类的区别"><a href="#结构体和类的区别" class="headerlink" title="结构体和类的区别"></a>结构体和类的区别</h1><h2 id="区别概述"><a href="#区别概述" class="headerlink" title="区别概述"></a>区别概述</h2><p>结构体和类最大的区别是在存储空间上的，因为结构体是值，类是引用，<br>因此他们的存储位置一个在栈上，一个在堆上，</p><p>结构体和类在使用上很类似，结构体甚至可以用面向对象的思想来形容一类对象。<br>结构体具备着面向对象思想中封装的特性，但是他不具备继承和多态的特性，因此大大减少了它的使用频率。<br>由于结构体不具备继承的特性，所以它不能够使用protected保护访问修饰符。</p><h2 id="细节区别"><a href="#细节区别" class="headerlink" title="细节区别"></a>细节区别</h2><p>1.结构体是值类型，类是引用类型<br>2.结构体存在栈中，类存在栈中<br>3.结构体成员不能使用protected访问修饰符，而类可以<br>4.结构体成员变量声明不能指定初始值，而类可以<br>5.结构体不能声明无参的构造函数，而类可以<br>6.结构体声明有参构造函数后，无参构造函数不会被顶掉<br>7.结构体不能声明构析函数，而类可以<br>8.结构体不能被继承，而类可以<br>9.结构体需要在构造函数中初始化所有成员变量，而类随意<br>10.结构体不能被静态static修饰（不存在静态结构体），而类可以<br>11.结构体不能在内部声明和自己一样的结构体变量，而类可以</p><h2 id="结构体的特别之处"><a href="#结构体的特别之处" class="headerlink" title="结构体的特别之处"></a>结构体的特别之处</h2><p>结构体可以继承接口<br>因为接口是行为的抽象</p><h2 id="如何选择结构体和类"><a href="#如何选择结构体和类" class="headerlink" title="如何选择结构体和类"></a>如何选择结构体和类</h2><p>1.想要用继承和多态时，直接淘汰结构体，比如玩家、怪物等等<br>2.对象是数据集合时，优先考虑结构体，比如位置、坐标等等<br>3.从值类型和引用类型赋值时的区别上去考虑，比如经常被赋值传递的对象，并且改变赋值对象，原对象不想跟着变化时，就用结构体，比如坐标、向量、旋转等等</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stringBuilder</title>
    <link href="/2022/05/23/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94/stringBulider/"/>
    <url>/2022/05/23/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94/stringBulider/</url>
    
    <content type="html"><![CDATA[<p>stringBuilder</p><span id="more"></span><h1 id="stringBuilder"><a href="#stringBuilder" class="headerlink" title="stringBuilder"></a>stringBuilder</h1><p>C#提供的一个用于处理字符串的公共类<br>主要解决的问题：<br>修改字符串而不创建新的对象，需要频繁修改和拼接字符串可以使用它，可以提升性能<br>使用前 需要引用命名空间 using System.Text;</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>直接指明内容</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">StringBuilder str &#x3D; new StringBuilder(&quot;内容&quot;);StringBuilder str &#x3D; new StringBuilder(&quot;内容&quot;, 容量大小);</code></pre></div><h2 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h2><p>StringBuilder存在一个容量的问题，每次往里面增加时，会自动扩容</p><p>获得容量</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">StringBuilder str &#x3D; new StringBuilder(&quot;内容&quot;);str.Capacity;</code></pre></div><h2 id="增删查改替换"><a href="#增删查改替换" class="headerlink" title="增删查改替换"></a>增删查改替换</h2><p>增</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">str.Append(&quot;要增加的内容&quot;);str.AppendFormat(&quot;&#123;0&#125;&#123;1&#125;&quot;, 内容1, 内容2);</code></pre></div><p>插入</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">str.Insert(插入的位置, &quot;内容&quot;); &#x2F;&#x2F;插在前面</code></pre></div><p>删</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">str.Remove(开始删的位置, 删的数量);</code></pre></div><p>查</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">str.clear();</code></pre></div><p>查</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Console.WriteLine(str[1]);</code></pre></div><p>改</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">str[0] &#x3D; &#39;A&#39;; &#x2F;&#x2F;string不能这样改 StringBuilder可以这样改</code></pre></div><p>替换</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">str.Replace(&quot;你想改的字符&quot;, &quot;你想改成的字符&quot;);</code></pre></div><p>重新赋值 StringBuilder</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">str.clear(); &#x2F;&#x2F;先清空&#x2F;&#x2F;再赋值</code></pre></div><p>判断字符串是否相等</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">if( str.Equals(&quot;想要判断是否相等的字符串&quot;) )</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/23/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94/stringBulider/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><p>1.string相对于stringbuilder更容易产生垃圾 每次修改拼接都会产生垃圾<br>2.string相对stringbuilder更加灵活 因为它提供了更多的方法供使用<br>如何选择：<br>需要频繁修改拼接的字符串可以用stringbuilder<br>需要使用string独特的一些方法来处理一些特殊逻辑时可以使用string</p><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><p>内存优化实际上是两个问题：<br>1.如何节约内存<br>2.如何尽量少的GC</p><p>解决方法：<br>1.少new对象，少产生垃圾<br>2.合理使用static<br>3.合理使用string和stringbuilder</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>string</title>
    <link href="/2022/05/22/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94/string/"/>
    <url>/2022/05/22/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94/string/</url>
    
    <content type="html"><![CDATA[<p>string</p><span id="more"></span><h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><h2 id="字符串指定位置获取"><a href="#字符串指定位置获取" class="headerlink" title="字符串指定位置获取"></a>字符串指定位置获取</h2><p>字符串本质是char数组</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">string str &#x3D; &quot;唐老狮&quot;;Console.WriteLine(str[0]); &#x2F;&#x2F;打印“唐”</code></pre></div><p>可以转换化为char数组</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">char[] chars &#x3D; str.ToCharArray();Console.WriteLine(chars[1]); &#x2F;&#x2F;打印“老”</code></pre></div><h2 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h2><p>Format(); 后接变长参数</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">string str &#x3D; string.Format(&quot;&#123;0&#125;&#123;1&#125;&quot;, 1, 3333);Console.WriteLine(str); &#x2F;&#x2F;打印13333</code></pre></div><h2 id="正向查找字符位置"><a href="#正向查找字符位置" class="headerlink" title="正向查找字符位置"></a>正向查找字符位置</h2><p>IndexOf(); 返回字符位置</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">string str &#x3D; &quot;我是唐老狮！&quot;;int index &#x3D; str.IndexOf(&quot;唐&quot;);Console.WriteLine(index); &#x2F;&#x2F;打印1</code></pre></div><p> 若没找到则返回-1</p><h2 id="反向查找指定字符串位置"><a href="#反向查找指定字符串位置" class="headerlink" title="反向查找指定字符串位置"></a>反向查找指定字符串位置</h2><p>LastIndexOf(); 反向查找并返回字符串位置(字符串第一个字符的位置)</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">string str &#x3D; &quot;我是唐老狮唐老狮&quot;;int index &#x3D; str.IndexOf(&quot;唐老狮&quot;);Console.WriteLine(index); &#x2F;&#x2F;打印5</code></pre></div><p> 若没找到则返回-1</p><h2 id="移除指定位置后的字符"><a href="#移除指定位置后的字符" class="headerlink" title="移除指定位置后的字符"></a>移除指定位置后的字符</h2><p>Remove();  </p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">string str &#x3D; &quot;我是唐老狮唐老狮&quot;;str.Remove(4);  &#x2F;&#x2F;移除4及之后的字符，不会改变原字符串Console.WriteLine(str); &#x2F;&#x2F;打印不变str &#x3D; str.Remove(4);Console.WriteLine(str); &#x2F;&#x2F;打印0-3 “我是唐老”&#x2F;&#x2F;重载 Remove(参数1, 参数2);&#x2F;&#x2F;参数1，开始位置；参数2，字符个数str &#x3D; str.Remove(1, 1);Console.WriteLine(str); &#x2F;&#x2F;打印 “我唐老”</code></pre></div><h2 id="替换指定字符串"><a href="#替换指定字符串" class="headerlink" title="替换指定字符串"></a>替换指定字符串</h2><p>Replace();</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">string str &#x3D; &quot;我是唐老狮唐老狮&quot;;&#x2F;&#x2F;参数一：原字符串；参数2：新字符串str &#x3D; str.Replace(&quot;唐老狮&quot;, &quot;老炮儿&quot;);Console.WriteLine(str); &#x2F;&#x2F;打印“我是老炮儿老炮儿”</code></pre></div><h2 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h2><p>ToUpper();<br>ToLower();</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">string str &#x3D; &quot;asdfasd&quot;;str &#x3D; str.ToUpper(str);Console.WriteLine(str); &#x2F;&#x2F;打印ASDFASD&#x2F;&#x2F;ToLower同理</code></pre></div><h2 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h2><p>Substring();</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">string str &#x3D; &quot;唐老狮唐老狮&quot;;&#x2F;&#x2F;截取从指定位置开始之后的字符str &#x3D; str.Substring(2);Console.WriteLine(str); &#x2F;&#x2F;打印“狮唐老狮”&#x2F;&#x2F;截取从指定位置开始数量为（参数2）的字符 不能超过总长度str &#x3D; str.Substring(2, 2);Console.WriteLine(str); &#x2F;&#x2F;打印“老狮”</code></pre></div><h2 id="字符串切割"><a href="#字符串切割" class="headerlink" title="字符串切割"></a>字符串切割</h2><p>Split();</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">string str &#x3D; &quot;1,2,3,5,6,7,8&quot;;&#x2F;&#x2F;截取从指定位置开始之后的字符string[] strs &#x3D; str.Split(&#39;,&#39;);for ( i &#x3D; 0; i &lt; strs.Length; i++)&#123;    Console.WriteLine(str[i]); &#x2F;&#x2F;打印1\n2\n...&#125;&#x2F;&#x2F;截取从指定位置开始数量为（参数2）的字符 不能超过总长度str &#x3D; str.Substring(2, 2);Console.WriteLine(str); &#x2F;&#x2F;打印“老狮”</code></pre></div><p> 用于商业游戏配置表</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/22/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94/string/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><p>截取：Substring(参数1);    Substring(参数1, 参数2);<br>替换：Replace(参数1);   Replace(参数1, 参数2);</p><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson23_面向对象相关string&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            string str &#x3D; &quot;1|2|3|4|5|6|7&quot;;            string[] strs &#x3D; str.Split(&#39;|&#39;);            str &#x3D; &quot;&quot;;            for (int i &#x3D; 0; i &lt; strs.Length; i++)            &#123;                str +&#x3D; int.Parse(strs[i]) + 1;                if(i !&#x3D; strs.Length - 1)                &#123;                    str +&#x3D; &quot;|&quot;;                &#125;            &#125;            Console.WriteLine(str);        &#125;    &#125;&#125;</code></pre></div><h2 id="题3"><a href="#题3" class="headerlink" title="题3"></a>题3</h2><p>实际上没有区别<br>后者是前者的别名，是程序的关键字<br>String,Int32,Int64,Int16是大的结构体名</p><h2 id="题4"><a href="#题4" class="headerlink" title="题4"></a>题4</h2><p>str &#x3D; null    str2 &#x3D; str<br>这两句没有分配新的堆空间<br>故分配了3个新的堆空间</p><h2 id="题5"><a href="#题5" class="headerlink" title="题5"></a>题5</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson23_面向对象相关string&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;请输入字符串：&quot;);            string str &#x3D; Console.ReadLine();            Console.WriteLine(&quot;反转后的字符串为&quot;);            Reverse(ref str);            Console.WriteLine(str);        &#125;        static void Reverse(ref string str)        &#123;            char[] chars &#x3D; str.ToCharArray();            for (int i &#x3D; 0; i &lt; chars.Length &#x2F; 2; i++)            &#123;                chars[i] &#x3D; (char)(chars[i] + chars[chars.Length - 1 - i]);                chars[chars.Length - 1 - i] &#x3D; (char)(chars[i] - chars[chars.Length - 1 - i]);                chars[i] &#x3D; (char)(chars[i] - chars[chars.Length - 1 - i]);            &#125;            str &#x3D; new string(chars);        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月22日</title>
    <link href="/2022/05/22/diary/2022.5/2022%E5%B9%B45%E6%9C%8822%E6%97%A5/"/>
    <url>/2022/05/22/diary/2022.5/2022%E5%B9%B45%E6%9C%8822%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="4bf608d527a714cdcb55e31925104e25accff7c324af28273fa302865fc865c4">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe505a9ab9e5fb3a8e410d273b8e352ade6990d1ff7f62c3ddfbd1c033abc6958b9bfd385d52cdf1f16001b7f535a7e7d181d1cd83d3db5f03181aa9c4716ca261f7bf645e5c5030f5939dcaac3178fec1960a039b96f77f0cf0f996554b407a6e954aca401f1c91349e68487bc6311a347a3b821abaa1568d869c69f007421db9749127761b0a24e67f89d1846a2484c091991dce8db5a15afe57141906d9a189f80d052b6dc75d441f4df553eafc7f4a143d249eafda1f243dee68f523cd4f8b60fa3ada6f66970216886c108246d43e3fcad05eda685b271b49e3f35bc0074c59b30ea8aa35328c5d319125444d43c19f87f4f9696b8821dfafb6be6be9c1128c2a237aea22532d6fbf42aaae3308b2e637508ceb4e4bec1630e79b457492732643ce4bf5621801a0093f5486ae185c7a576c695a850d00eec4d322c58e50dfd4991ff1590d509271c8013076dc225de45a0c09d573551cb1846bb4181c31c6942a2c437dad7787f26d1df6195ec8e72bf0fa2c389085a74e09fc0f58cb5d376d2820c171ad5d07e6a43fb822e391f5a56830c1778f51f7d9436f40e7683c885bce548704c3cea02b9f9f2a3ab169e99b92070a2a5a0103b5498b301af52b16cd8772766494802ac57495fc024b4be6a0</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>万物之父中的方法</title>
    <link href="/2022/05/22/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94/%E4%B8%87%E7%89%A9%E4%B9%8B%E7%88%B6%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/2022/05/22/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94/%E4%B8%87%E7%89%A9%E4%B9%8B%E7%88%B6%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>万物之父中的方法</p><span id="more"></span><h1 id="万物之父中的方法"><a href="#万物之父中的方法" class="headerlink" title="万物之父中的方法"></a>万物之父中的方法</h1><img src="/2022/05/22/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94/%E4%B8%87%E7%89%A9%E4%B9%8B%E7%88%B6%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/object.png" class=""><h2 id="object中的静态方法"><a href="#object中的静态方法" class="headerlink" title="object中的静态方法"></a>object中的静态方法</h2><p>静态方法 <strong>Equals</strong> 判断两个对象是否相等<br>最终的判断权交给左侧对象的Equals方法<br>值类型 和 引用类型 都会按照左侧对象Equals方法的规则来进行比较<br>值类型比较值<br>引用类型比较指向的地址</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Console.WriteLine(Object.Equals(1, 1)); &#x2F;&#x2F;打印trueTest t1 &#x3D; new Test();Test t2 &#x3D; new Test();Console.WriteLine(Object.Equals(t1, t2)); &#x2F;&#x2F;打印falseTest t3 &#x3D; t1;Console.WriteLine(Object.Equals(t1, t3)); &#x2F;&#x2F;打印true</code></pre></div><p>静态方法 <strong>ReferenceEquals</strong><br>比较两个对象是否是相同的引用，主要是用来比较引用类型的对象<br>值类型对象返回值始终是false</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Console.WriteLine(Object.ReferenceEquals(t1, t2)); &#x2F;&#x2F;打印false</code></pre></div><p>注意：object可不写</p><h2 id="object中的成员方法"><a href="#object中的成员方法" class="headerlink" title="object中的成员方法"></a>object中的成员方法</h2><p>普通方法 GetType<br>该方法在反射相关知识点中是非常重要的方法<br>主要作用是获取对象运行时的类型Type,结合反射相关知识点可以做很多关于对象的操作</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Test t &#x3D; new Test();Type type &#x3D; t.GetType();</code></pre></div><p>普通方法 MemberwiseClone<br>该方法用于获取对象的浅拷贝对象，口语化的意思就是会返回一个新的对象<br>但是新对象中的引用变量会和老对象中一致</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Test&#123;    public int i &#x3D; 1;    public Test2 test2 &#x3D; new Test2();    public Test Clone()    &#123;        return MemberwiseClone() as Test;    &#125;&#125;class Test2&#123;    public int i &#x3D; 2;&#125;internal class Program&#123;    static void Main(string[] args)    &#123;        Test t &#x3D; new Test();        Test t2 &#x3D; t.Clone();        Console.WriteLine(&quot;对象克隆后&quot;);        Console.WriteLine(&quot;t.i &#x3D; &quot; + t.i); &#x2F;&#x2F;1        Console.WriteLine(&quot;t.test2.i &#x3D; &quot; + t.test2.i); &#x2F;&#x2F;2        Console.WriteLine(&quot;t2.i &#x3D; &quot; + t2.i); &#x2F;&#x2F;1        Console.WriteLine(&quot;t2.test2.i &#x3D; &quot; + t2.test2.i); &#x2F;&#x2F;2        t2.i &#x3D; 20;        t2.test2.i &#x3D; 21;        Console.WriteLine(&quot;改变克隆体信息后&quot;);        Console.WriteLine(&quot;t.i &#x3D; &quot; + t.i); &#x2F;&#x2F;1        Console.WriteLine(&quot;t.test2.i &#x3D; &quot; + t.test2.i); &#x2F;&#x2F;21        Console.WriteLine(&quot;t2.i &#x3D; &quot; + t2.i); &#x2F;&#x2F;20        Console.WriteLine(&quot;t2.test2.i &#x3D; &quot; + t2.test2.i); &#x2F;&#x2F;21        &#x2F;&#x2F;值类型拷贝值，引用类型拷贝地址    &#125;&#125;</code></pre></div><h2 id="object中的虚方法"><a href="#object中的虚方法" class="headerlink" title="object中的虚方法"></a>object中的虚方法</h2><p>虚方法 <strong>Equals</strong><br>默认是西安还是比较两者是否为同一个引用，即相当于ReferenceEquals<br>但是微软在所有值类型的基类System.ValueType中重写了该方法，用来比较值相等<br>可以重写，定义自己的比较相等的规则</p><p>虚方法 <strong>GetHashCode</strong><br>该方法是获取对象的哈希码<br>（一种通过算法算出的，表示对象的唯一编码，不同对象哈希码有可能一样，具体值根据哈希算法决定）<br>可以重写，但极少</p><p>虚方法 <strong>ToString</strong><br>该方法用于返回当前对象代表的字符串，可以重写<br>调用打印方法时，默认使用的就是对象的ToString方法后打印出来的内容</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/22/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94/%E4%B8%87%E7%89%A9%E4%B9%8B%E7%88%B6%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson22_万物之父中的方法&#123;    class Player    &#123;        public string name &#x3D; &quot;大逼&quot;;        public int Hp &#x3D; 100;        public int Atk &#x3D; 1000;        public int Def &#x3D; 10000;        public int EvasionRate &#x3D; 5;        public void Property()        &#123;            Console.WriteLine(&quot;玩家&#123;0&#125;,血量&#123;1&#125;,攻击力&#123;2&#125;,防御力&#123;3&#125;,闪避率&#123;4&#125;%&quot;, name, Hp, Atk, Def, EvasionRate);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Player player &#x3D; new Player();            player.Property();        &#125;    &#125;&#125;</code></pre></div><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson22_万物之父中的方法&#123;    class Monster    &#123;        public string name &#x3D; &quot;大逼&quot;;        public int Hp &#x3D; 100;        public int Atk &#x3D; 1000;        public int Def &#x3D; 10000;        public int EvasionRate &#x3D; 5;        public void Property()        &#123;            Console.WriteLine(&quot;玩家&#123;0&#125;,血量&#123;1&#125;,攻击力&#123;2&#125;,防御力&#123;3&#125;,闪避率&#123;4&#125;%&quot;, name, Hp, Atk, Def, EvasionRate);        &#125;        public Monster Clone()        &#123;            return MemberwiseClone() as Monster;        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Monster mA &#x3D; new Monster();            Monster mB &#x3D; mA.Clone();            mB.Atk &#x3D; 500;            mB.Def &#x3D; 5000;            mB.Hp &#x3D; 50;            mA.Property();            mB.Property();        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>命名空间</title>
    <link href="/2022/05/21/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
    <url>/2022/05/21/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p>命名空间</p><span id="more"></span><h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>命名空间是用来组织和重用代码的<br>作用：<br>就像是一个工具包，类就像是一件一件的工具，都是声明在命名空间中的</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">namespace 命名空间名&#123;    class 类名    &#123;    &#125;    class 类名    &#123;    &#125;&#125;</code></pre></div><p>1.可以写成分部形式（同名写多个）以继承<br>2.但在同一命名空间中不能有同名类</p><h2 id="不同命名空间中相互使用，需要引用命名空间或指明出处"><a href="#不同命名空间中相互使用，需要引用命名空间或指明出处" class="headerlink" title="不同命名空间中相互使用，需要引用命名空间或指明出处"></a>不同命名空间中相互使用，需要引用命名空间或指明出处</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;引用命名空间using 命名空间名&#x2F;&#x2F;可以使用该命名空间里的类&#x2F;&#x2F;指明出处命名空间名.类名 &#x3D; new 命名空间名.类名();</code></pre></div><h2 id="不同命名空间中允许有同名类"><a href="#不同命名空间中允许有同名类" class="headerlink" title="不同命名空间中允许有同名类"></a>不同命名空间中允许有同名类</h2><p>在调用同名类时不仅需要引用命名空间，还需要指明出处以实例化</p><h2 id="命名空间可以包裹命名空间"><a href="#命名空间可以包裹命名空间" class="headerlink" title="命名空间可以包裹命名空间"></a>命名空间可以包裹命名空间</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">namespace MyGame&#123;    namespace UI    &#123;        class Image        &#123;        &#125;    &#125;    namespace Game    &#123;        class Image        &#123;                    &#125;    &#125;&#125;&#x2F;&#x2F;调用using MyGame.UI;MyGame.UI.Image img &#x3D; new MyGame.UI.Image();</code></pre></div><h2 id="关于修饰类的访问修饰符"><a href="#关于修饰类的访问修饰符" class="headerlink" title="关于修饰类的访问修饰符"></a>关于修饰类的访问修饰符</h2><p>public - 命名空间中的类 默认为public<br>internal - 只能在该程序集（工程）中使用<br>abstract - 抽象类<br>sealed - 密封类<br>partial - 分部类</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/21/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><p>using可以调用该命名空间中的类，以及类中的方法</p><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using UI;using Graph;namespace UI&#123;    class Image    &#123;            &#125;&#125;namespace Graph&#123;    class Image    &#123;    &#125;&#125;namespace Lesson21_命名空间&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            UI.Image image &#x3D; new UI.Image();            Graph.Image image1 &#x3D; new Graph.Image();        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>密封函数</title>
    <link href="/2022/05/21/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%A4%9A%E6%80%81/%E5%AF%86%E5%B0%81%E5%87%BD%E6%95%B0/"/>
    <url>/2022/05/21/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%A4%9A%E6%80%81/%E5%AF%86%E5%B0%81%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>密封函数</p><span id="more"></span><h1 id="密封函数"><a href="#密封函数" class="headerlink" title="密封函数"></a>密封函数</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>用密封关键字sealed修饰的重写函数<br>作用：让虚方法或者抽象方法之后不能再被重写<br>特点：和override一起出现，不能写在abstract和virtual前</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月21日</title>
    <link href="/2022/05/21/diary/2022.5/2022%E5%B9%B45%E6%9C%8821%E6%97%A5/"/>
    <url>/2022/05/21/diary/2022.5/2022%E5%B9%B45%E6%9C%8821%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="25294449ad5488957ea695c17d0a15bdcae6240f381af4f590fa2131155ecccd">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50016237ab31399f3751c3548491ff8ed0c7517623ada711016ab0ae6da5280084fac8481a0de647ac2a1aac4d29092ab5c8a931972e1bbbd81a8f6e12576ef2be5c58eb692ba2fa896bc13446fb79173797e6addac0ceb52997a9145cf705168b3ebf7ad7b966557db6d276313b29f4882f2c466d2fdf819aa8578ab8226e1828be6ef6735bbf5310168b73763c451a5a0430473271182256454830cba5d299eb6c421d4ecc76d64b584a9f34d0f35eee8f22f2f1d1bd73eb38e39a46f3b892b1d9a27d08cb3090f42085ef2b815d7093e52b696c5c16bb4e23dee4dab55fc9b1335d6929ceaed121f8804226572b01caf71f87b46f2eb7469bba734972a300e9806c77d4bc8b28433568e4e81dd7aaf0540c0afdcf2042671d330db204845a599ba583186539e10380ba6db2ec9726a97bdb7797db4e62a68816cafa759f42520f2a12af1e13acded044b19e1359e17595071343cec63c29c94a263661d6722ec793955c049ac4ff430325d916d452d257830d702c26a9fc80b8b66ee1aee4a4feab3de1e4f0ae939d2552a471e7def37e7f64203384a08e3fb80b13a254876021666a071578565068c29491c6e03b0d38a513ee119226ee71604c9ad087a32fb2f5af1bb3b48fa6d4fb87d37edabdd522f51a327c26b383dc249344728c7e9ee92ee95e081b679b93aa5146d9abfb07a8c5f0ad5b7c3219bb605f2c5b5644a785077efacf1e8cf727e206ae3dec8c893846781fd8150304f7af96fb2b03d8e9b42b8e558279ff8c484e5c72d05c1919dc2e94a01e96e6bcdf70c79b176ac1a6b32e20ac2c7da6ad89b0961939cdef6b3dcfb6b575549908a970c7906711fe7c431ec0fb4770ad7d3767f7131446693310274e6f89da7d380b621bb848b5bf2f17cc38f944393dde3ee81f6095953688f59dff53b6c156bd0ea5e36d1ad292804a37434614357e382b47444190e6f791092aed5d0f393f94e87c12548256f6d22f98ed5e16c9839cefcba4cc249e08e98feb0844f8df4c8f40eda5688f141c008f9596eb9d835186c4e8d1af2c7474a70b1fed2e649b460812bb960ccb91738920d67a87dd045e22d8d48163f551d1b18b3e33ca837ca2c2e060a9568071088b938977d094c1bf77c64f90aa7f81a7276183f6886bcdbd702fae7e0e5ca926ade21ca03632cdfa3ac46718c6e8b5c0cfc3a1c05839e686c9c292ba399e458b1028ae6232dde4450c0b91a3a8a29f1e9112458500767a98eb065b2b96fad368f8783b9c196fb6a6ba1d96329cc04ae9fd6fb56a78ff11f226e25260fc959211df02e75820963478fee3fb842d1dd8c64e9d5ee858543419b4ee2d9e6412274b4cb530dbc02454baf4faf8e6b6e4378f7217f2f4dfda463178e168a2f752373313e8aaeec9fea07e3e57a28105a0e14060e6e62f11208a90fd5e0f8d896f950fe1a1c932a81b9f3f1ab2dee07ce0d3a6f9b197a0210db27ba3487a83624240fbc623a6610c1353049cf98f657a21afe78fe1edca0b850643e7349aa71524394cc55684a6069c691b1ef1083d4103b3e6ced984ef3fbb3305037349862d24f9f86336d29d16ffb4aad2f4667f4710b61365e6effc99e014044995fa4d31f0cd5c5ca24201db45bd1d8a764e6adc59693bc865deded1877fb0e0d814af586beac151bde53d72f13e5a2741b4d3bf6df948c23dd26d5eab68d324bc834ca3c59d32b93d71c53453756fa6ef166ca1d3218d4876a12d62ca433695ac0cd83cd4ac7073df4685143450d4a21b4c47b3881a0b9a74d125f6a540950aa98bcd32c753f7570a6adf728b9e4412aa7dcb8df59a6a764e61b0df145b1b469eb2ed612c4a546c249f3a14dec68d456d28fc8a085cd2133529d9d5107406fbb93badf656a357ac7e1913ea88850b50f66d68f07c6048bb6f42b0c2591ebbcb2ee5887e21ee48b73ff4597781ab4200ebbd84d6b18aa9c1eff6f889b4fcc5c6563d5d9f2eeae46aec89e95a7c9ed1067716d2f4d88875ee55a2f691cb7128d94f141b7a3ddcff50362dd7c22bad4f10dde9a925d0ae6b4fcf0a71ef5ddad81d9be2c1ba6a62bef673d8664ac7c85717775f50f7ae8f5a7e58ca6e824ce0ae55e56a3ee039c303d07c8b6caa5cd71b30b6a61fbcef6b123f6130bc73fe41e16f7d5e2e7310791af690047446a72e72648c11baabdb1868aa54801379f5c0869c2076a870d6234df742c4ac4fc6fa011bdcf93076828d0cdc1187d36d7105b55df6fdb4c07d73bed0ead660ab76c454108190cc3c91259937df90f4834d26b9ef60c1d6849981c1f3e498f7b9ca606b01254f9c47a335f95050266652ff19475c0c346b4a2c03c21d605efdca2c784f7f89d502555d52312cbe2b8178716ef970ba35c49bf5d87d7592958a0457964ad4a3cff1638b5d53b923b6be81531e13c37b9df5165e2c04a1</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月20日</title>
    <link href="/2022/05/19/diary/2022.5/2022%E5%B9%B45%E6%9C%8820%E6%97%A5/"/>
    <url>/2022/05/19/diary/2022.5/2022%E5%B9%B45%E6%9C%8820%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="8fac42808f01149c878ef2f2d7020868436faa65251f25dd5bb26ca1d1e26bba">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50477ff5b269e8ceb0cdcb67073e2e8fa77eb849c556241cfdc6a563d0301ed1d839b944fae7507f15d160de0be980dd1aba9380a4a321b232853b5e08ca31a843573f053791cd1802b784a9e046f70f255a43bca196e25c5f09a0970e507017aee56824e0c2bb418dcb3b5c3e7142b0f32af66cc08ff563c957652db3928e55d98acec026a987db89a5e6e9ea1c98db0f86e0b8b53e55eee67ec2ee0efdb101b2a6d66f6b58c4490983dc7efba61056a9caa977a39fd79c919506d628ad4134882428c79e23591122352382cca2cb9976ac48290e98e71fcbccaeacc401b00f3c3e48b31d522b62549550a3f0548d7a25</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口</title>
    <link href="/2022/05/19/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%A4%9A%E6%80%81/%E6%8E%A5%E5%8F%A3/"/>
    <url>/2022/05/19/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%A4%9A%E6%80%81/%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<p>接口</p><span id="more"></span><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>接口是行为的抽象规范，也是一种自定义类型<br>用于存储不同类的对象之间相同的方法<br>关键字：interface</p><p>声明规范：<br>1.不包含成员变量<br>2.只包含方法、属性、索引器、事件<br>3.成员不能被实现<br>4.成员可以不用写访问修饰符（默认public），不能是private<br>5.接口不能继承类，但是可以继承另一个接口</p><p>使用规范：<br>1.类可以继承多个接口<br>2.类继承接口后，必须实现接口中所有成员</p><h2 id="接口的声明及使用"><a href="#接口的声明及使用" class="headerlink" title="接口的声明及使用"></a>接口的声明及使用</h2><p>一句话记忆：接口是抽象行为的“基类”<br>接口命名规范：帕斯卡命名法前加I</p><p>接口用来继承：<br>1.类可以继承一个类,n个接口<br>2.继承了接口后,必须实现其中的内容,并且必须是public的<br>3.实现的接口函数,可以加virtual再写在子类里重写<br>4.接口也遵循里式替换原则</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;interface 接口名interface IFly&#123;    &#x2F;&#x2F;方法    void Fly();    &#x2F;&#x2F;属性    string Name    &#123;        get; &#x2F;&#x2F;不能有语句块,即默认自动属性        set;    &#125;    &#x2F;&#x2F;索引器    int this[int index]    &#123;        get;        set;    &#125;    &#x2F;&#x2F;事件    event Action doSomething;&#125; class Animal&#123;&#125;&#x2F;&#x2F;1.类可以继承一个类,n个接口class Person : Animal, Ifly&#123;    &#x2F;&#x2F;2.继承了接口后,必须实现其中的内容,并且必须是public的    &#x2F;&#x2F;3.实现的接口函数,可以加virtual再写在子类里重写    public virtual void Fly()    &#123;    &#125;    public string Name    &#123;        get;        set;    &#125;    public int this[int index]    &#123;        get;        set;    &#125;    public event Action doSomething;&#125;internal class Program&#123;    static void Main(string[] args)    &#123;        &#x2F;&#x2F;4.接口也遵循里式替换原则        IFly f &#x3D; new Person();        &#x2F;&#x2F;注意 IFly f &#x3D; new IFly();是错误的,接口是不能实例化的    &#125;&#125;</code></pre></div><h2 id="接口可以继承接口"><a href="#接口可以继承接口" class="headerlink" title="接口可以继承接口"></a>接口可以继承接口</h2><p>接口继承接口时,不需要实现<br>带类继承接口后,类自己要去实现所有内容</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">interface IWalk&#123;    void Walk();&#125;interface IMove : IWalk&#123;&#125;class Test: IMove&#123;    public void Walk();&#125;</code></pre></div><h2 id="显示实现接口"><a href="#显示实现接口" class="headerlink" title="显示实现接口"></a>显示实现接口</h2><p>当一个类继承两个接口,但是接口中存在着同名方法时<br>注意：显示实现接口时,不能写访问修饰符</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">interface IAtk&#123;    void Atk();&#125;interface ISuperAtk&#123;    void Atk();&#125;class Player : IAtk, ISuperAtk&#123;    &#x2F;&#x2F;显示实现接口,就是用接口名.行为名来实现    void IAtk.Atk()    &#123;            &#125;    void ISuperAtk.Atk()    &#123;    &#125;&#125;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/19/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%A4%9A%E6%80%81/%E6%8E%A5%E5%8F%A3/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson19_接口&#123;    interface IRegister    &#123;        void Register();    &#125;    class Person : IRegister    &#123;        public void Register()        &#123;            Console.WriteLine(&quot;个人请到派出所登记&quot;);        &#125;    &#125;    class Car : IRegister    &#123;        public void Register()        &#123;            Console.WriteLine(&quot;车辆请到车管所登记&quot;);        &#125;    &#125;    class House : IRegister    &#123;        public void Register()        &#123;            Console.WriteLine(&quot;房子请到房管局登记&quot;);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            &#x2F;&#x2F;可用数组实例化            IRegister p &#x3D; new Person();            p.Register();            IRegister c &#x3D; new Car();            c.Register();            IRegister h &#x3D; new House();            h.Register();        &#125;    &#125;&#125;</code></pre></div><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson19_接口&#123;    &#x2F;&#x2F;定义三个接口 1.飞 2.游泳    &#x2F;&#x2F;定义一个鸟类(因为鸟类都能走，走就不用接口)    &#x2F;&#x2F;飞    interface IFly    &#123;        void Fly();    &#125;    &#x2F;&#x2F;游泳    interface ISwim    &#123;        void Swim();    &#125;    &#x2F;&#x2F;鸟类，鸟类都能走，用抽象类及抽象方法    abstract class Bird    &#123;        public abstract void Walk();    &#125;    &#x2F;&#x2F;麻雀，能飞，不能游泳    class Sparrow : Bird, IFly    &#123;        public void Fly()        &#123;            Console.WriteLine(&quot;麻雀能飞&quot;);        &#125;        public override void Walk()        &#123;            Console.WriteLine(&quot;麻雀能走&quot;);        &#125;    &#125;    &#x2F;&#x2F;鸵鸟，不能飞，不能游泳    class Ostrich : Bird    &#123;        public override void Walk()        &#123;            Console.WriteLine(&quot;鸵鸟能走&quot;);        &#125;    &#125;    &#x2F;&#x2F;企鹅，不能飞，能游泳    class Penguin : Bird, ISwim    &#123;        public void Swim()        &#123;            Console.WriteLine(&quot;企鹅能游泳&quot;);        &#125;        public override void Walk()        &#123;            Console.WriteLine(&quot;企鹅能走&quot;);        &#125;    &#125;    &#x2F;&#x2F;鹦鹉，能飞，不能游泳    class Parrot : Bird, IFly    &#123;        public void Fly()        &#123;            Console.WriteLine(&quot;鹦鹉能飞&quot;);        &#125;        public override void Walk()        &#123;            Console.WriteLine(&quot;鹦鹉能走&quot;);        &#125;    &#125;    &#x2F;&#x2F;天鹅，能飞，能游泳    class Swan : Bird, IFly, ISwim    &#123;        public void Fly()        &#123;            Console.WriteLine(&quot;天鹅能飞&quot;);        &#125;        public void Swim()        &#123;            Console.WriteLine(&quot;天鹅能游泳&quot;);        &#125;        public override void Walk()        &#123;            Console.WriteLine(&quot;天鹅能走&quot;);        &#125;    &#125;    &#x2F;&#x2F;直升机    class Helicopter : IFly    &#123;        public void Fly()        &#123;            Console.WriteLine(&quot;直升机能飞&quot;);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            &#x2F;&#x2F;请自行实例化            Swan swan &#x3D; new Swan();            swan.Swim();            swan.Walk();            swan.Fly();        &#125;    &#125;&#125;</code></pre></div><h2 id="题3"><a href="#题3" class="headerlink" title="题3"></a>题3</h2><p><strong>本题关键：</strong><br>    public IUSB usb; </p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson19_接口&#123;    &#x2F;&#x2F;定义接口 USB接口    interface IUSB    &#123;        void ReadData();    &#125;    &#x2F;&#x2F;存储设备类,插在USB接口上可以读取设备名    class StorageDevice : IUSB    &#123;        public string name;        public StorageDevice(string name)        &#123;            this.name &#x3D; name;        &#125;        public void ReadData()        &#123;            Console.WriteLine(&quot;&#123;0&#125;正在传输数据&quot;, name);        &#125;    &#125;    &#x2F;&#x2F;MP3属于播放设备    class Mp3 : IUSB    &#123;        public void ReadData()        &#123;            Console.WriteLine(&quot;MP3正在传输数据&quot;);        &#125;    &#125;    &#x2F;&#x2F;用于实例化的电脑类,它有一个USB接口    class Computer    &#123;        &#x2F;&#x2F;声明一个接口成员，用于接口对接        public IUSB usb;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Computer computer &#x3D; new Computer();            StorageDevice mhd &#x3D; new StorageDevice(&quot;移动硬盘&quot;);            StorageDevice usbd &#x3D; new StorageDevice(&quot;U盘&quot;);            Mp3 mp3 &#x3D; new Mp3();            &#x2F;&#x2F;USB接移动硬盘            computer.usb &#x3D; mhd;            computer.usb.ReadData();            &#x2F;&#x2F;USB接U盘            computer.usb &#x3D; usbd;            computer.usb.ReadData();            &#x2F;&#x2F;USB接MP3            computer.usb &#x3D; mp3;            computer.usb.ReadData();        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>抽象类和抽象函数</title>
    <link href="/2022/05/19/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%A4%9A%E6%80%81/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%87%BD%E6%95%B0/"/>
    <url>/2022/05/19/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%A4%9A%E6%80%81/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>抽象类和抽象函数</p><span id="more"></span><h1 id="抽象类和抽象函数"><a href="#抽象类和抽象函数" class="headerlink" title="抽象类和抽象函数"></a>抽象类和抽象函数</h1><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>概念：<br>被抽象关键字abstract修饰的类<br>不希望被实例化的对象,相对比较抽象的类可以使用抽象类（水果等）</p><p>特点：<br>1.不能被实例化的类，但遵循里式替换原则（用父类容器装子类）<br>2.可以包含抽象方法<br>3.继承抽象类必须重写其抽象方法</p><h2 id="抽象函数"><a href="#抽象函数" class="headerlink" title="抽象函数"></a>抽象函数</h2><p>又称 纯虚方法<br>用abstract关键字修饰的方法</p><p>特点：<br>1.只能在抽象类中声明<br>2.没有方法体<br>3.不能是私有的<br>4.继承后必须实现 用override重写</p><p><strong>虚方法</strong>和<strong>抽象方法</strong>的异同：<br>相同点：<br>可以无限被子类重写<br>不同点：<br>1.<strong>抽象方法</strong>需要调用,必须用public或protected修饰,不能有函数体,只能在子类里override重写；<strong>虚方法</strong>一定有函数体,且里面可写可不写逻辑<br>2.<strong>抽象方法</strong>继承后必须实现；<strong>虚方法</strong>是子类里选择性实现的</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">abstract class Fruits&#123;    public string name;    &#x2F;&#x2F;因为抽象函数需要调用,必须用public或protected修饰    &#x2F;&#x2F;不能有函数体,只能在子类里override重写    abstract public void Bad();        public virtual void Test()    &#123;        &#x2F;&#x2F;虚方法一定有函数体,且里面可写可不写逻辑    &#125;&#125;class Apple : Fruits&#123;    &#x2F;&#x2F;虚方法是子类里选择性实现的    &#x2F;&#x2F;抽象方法继承后必须实现    public override void Bad()    &#123;        Console.WriteLine(&quot;苹果坏了&quot;);    &#125;&#125;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/19/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%A4%9A%E6%80%81/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%87%BD%E6%95%B0/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson18_抽象类和抽象函数&#123;    abstract class Animals    &#123;        abstract public void Speak();        &#125;    class People : Animals    &#123;        public override void Speak()        &#123;            Console.WriteLine(&quot;人叫&quot;);        &#125;    &#125;    class Dog : Animals    &#123;        public override void Speak()        &#123;            Console.WriteLine(&quot;狗叫&quot;);        &#125;    &#125;    class Cat : Animals    &#123;        public override void Speak()        &#123;            Console.WriteLine(&quot;猫叫&quot;);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Animals p &#x3D; new People();            p.Speak();            Animals d &#x3D; new Dog();            d.Speak();            Animals c &#x3D; new Cat();            c.Speak();        &#125;    &#125;&#125;</code></pre></div><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson18_抽象类和抽象函数&#123;    &#x2F;&#x2F;图形    abstract class Figure    &#123;        &#x2F;&#x2F;求面积        public abstract void Area();        &#x2F;&#x2F;求周长        public abstract void Perimeter();    &#125;    &#x2F;&#x2F;矩形    class Rectangular : Figure    &#123;        public int l;        public int w;        public Rectangular(int l, int w)        &#123;            this.l &#x3D; l;            this.w &#x3D; w;        &#125;        public override void Area()        &#123;            int s &#x3D; l * w;            Console.WriteLine(&quot;该矩形面积为&#123;0&#125;&quot;, s);        &#125;        public override void Perimeter()        &#123;            int c &#x3D; 2 * (l + w);            Console.WriteLine(&quot;该矩形周长为&#123;0&#125;&quot;, c);        &#125;    &#125;    &#x2F;&#x2F;矩形    class Square : Figure    &#123;        public int a;        public Square(int a)        &#123;            this.a &#x3D; a;        &#125;        public override void Area()        &#123;            int s &#x3D; a * a;            Console.WriteLine(&quot;该矩形面积为&#123;0&#125;&quot;, s);        &#125;        public override void Perimeter()        &#123;            int c &#x3D; 4 * a;            Console.WriteLine(&quot;该矩形周长为&#123;0&#125;&quot;, c);        &#125;    &#125;    &#x2F;&#x2F;圆形    class Circular : Figure    &#123;        public int r;        const float PI &#x3D; 3.1415926f;        public Circular(int r)        &#123;            this.r &#x3D; r;        &#125;        public override void Area()        &#123;            float s &#x3D; PI * r * r;            Console.WriteLine(&quot;该矩形面积为&#123;0&#125;&quot;, s);        &#125;        public override void Perimeter()        &#123;            float c &#x3D; 2 * r * PI;            Console.WriteLine(&quot;该矩形周长为&#123;0&#125;&quot;, c);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Figure r &#x3D; new Rectangular(2, 4);            r.Area();            r.Perimeter();            Figure s &#x3D; new Square(3);            s.Area();            s.Perimeter();            Figure c &#x3D; new Circular(5);            c.Area();            c.Perimeter();        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月19日</title>
    <link href="/2022/05/19/diary/2022.5/2022%E5%B9%B45%E6%9C%8819%E6%97%A5/"/>
    <url>/2022/05/19/diary/2022.5/2022%E5%B9%B45%E6%9C%8819%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="48556d71d8baf9e68f43b7588c0eaf2aa69ecb7fe05f9935211d77410ad8902c">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe507ad714b7d694638672ec89b6453f8a870b5aca629534dc9939024c47076fc51e739c6387f33ebf795ff8acfead750237dcc49917e7acc0ab1df7fa7d157ab40c60b4bd8d422cbc1a057c36715f8088e56f9a264298ce83d6a007eeb71f75eb25a79dab4cbe562ae542922a7cf369024d8217443f1445c3bf334157b3307265385f3c8e05c937977d5736dca1a94106d6366f4c9c7a60df78b9792646bc04efd2825fe45d9a0406c8f8dad3a49806d31918518ee754b8c1bb0963f861c62de92c1a82d5315ee20303e27032803a397fb7503caad7342a564396a134a24bba157a3bc47aa1db6cde81d43f49c1dbf2168409bba3be47e5de6d5dae9ef14fd96865b6c9ef2a47a9644abf121805c9e297fb093c75f68142b456ff6b8b6b11e157230f1d44f077ae942b1c5cb22c20a0cc5e51e6b83e775114368182356a827862f6263957cbf7725c29debaca3c57a27f52f48985792213cbadfb50f404c552f3830127c7aa7e86841c3e84f4f092bda3b8abca508fab6469573dede8c5c38f3dd1398f0e7c3a86ed3802abc8a26550161f7c114dda137c0a7205d1fa677e7d6e2a6f2237c09507e8afa5ad7c3eef4feb768ae2b5d5fc973fec0300c1246fc5d959c5306c32bb025c6edd7b9f5dfdd82b61c61b9820a8d57b50b7da20a132c7eb7bbcdf9998baa361b79abc7238f7b8de27</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VOB</title>
    <link href="/2022/05/18/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%A4%9A%E6%80%81/vob/"/>
    <url>/2022/05/18/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%A4%9A%E6%80%81/vob/</url>
    
    <content type="html"><![CDATA[<p>VOB</p><span id="more"></span><h1 id="VOB"><a href="#VOB" class="headerlink" title="VOB"></a>VOB</h1><h2 id="多态的概念"><a href="#多态的概念" class="headerlink" title="多态的概念"></a>多态的概念</h2><p>多态： 字面意思“多种状态”<br>让继&#x3D;继承同一父类的子类们，在执行相同方法时有不同表现（状态）</p><p>主要目的：<br>同一父类的对象 执行相同行为（方法）有不同的表现</p><p>解决的问题：<br>让同一个对象有唯一行为的特征</p><h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2><p>使同一种方法在不同对象下有不同表现</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Father&#123;    public void SpeakName()    &#123;        Console.WriteLine(&quot;Father的方法&quot;);    &#125;&#125;class Son : Father&#123;    public new void SpeakName()    &#123;        Console.WriteLine(&quot;Son的方法&quot;);    &#125;&#125;internal class Program&#123;    static void Main(string[] args)    &#123;        Father f &#x3D; new Son();        f.SpeakName(); &#x2F;&#x2F;打印Father的方法        (f as Son).SpeakName(); &#x2F;&#x2F;打印Son的方法    &#125;&#125;</code></pre></div><h2 id="多态的实现"><a href="#多态的实现" class="headerlink" title="多态的实现"></a>多态的实现</h2><p>函数重载 就是一种编译时的多态</p><p>运行时的多态：<br>(VOB, 抽象函数, 接口)<br>V:  virtual 虚函数<br>O:  override 重写<br>B:  base 父类</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class GameObject&#123;    public string name;    public GameObject(string name)    &#123;        this.name &#x3D; name;    &#125;    &#x2F;&#x2F;虚函数 可以被子类重写    public virtual void Atk()    &#123;        Console.WriteLine(&quot;游戏对象进行攻击&quot;);    &#125;&#125;class Player : GameObject&#123;    public Player(string name): base (name)    &#123;    &#125;    public override void Atk()    &#123;        &#x2F;&#x2F;base代表父类,可以通过base来保留父类的行为        base.Atk();        Console.WriteLine(&quot;玩家对象进行攻击&quot;);    &#125;&#125;internal class Program&#123;    static void Main(string[] args)    &#123;        GameObject p &#x3D; new Player(&quot;大逼&quot;);        p.Atk(); &#x2F;&#x2F;先打印父类行为&quot;游戏对象进行攻击&quot;,再打印子类行为&quot;玩家对象进行攻击&quot;    &#125;&#125;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/18/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%A4%9A%E6%80%81/vob/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson17_VOB&#123;    &#x2F;&#x2F;鸭子    class Duck    &#123;        public virtual void Quack()        &#123;            Console.WriteLine(&quot;真的鸭子嘎嘎叫&quot;);        &#125;    &#125;        &#x2F;&#x2F;木头鸭子    class WoodDuck : Duck    &#123;        public override void Quack()        &#123;            Console.WriteLine(&quot;木头鸭子吱吱叫&quot;);        &#125;    &#125;    &#x2F;&#x2F;木头鸭子    class RubberDuck : Duck    &#123;        public override void Quack()        &#123;            Console.WriteLine(&quot;橡皮鸭子唧唧叫&quot;);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Duck d &#x3D; new Duck();            d.Quack();            Duck wd &#x3D; new WoodDuck();            wd.Quack();            Duck rd &#x3D; new RubberDuck();            rd.Quack();        &#125;    &#125;&#125;</code></pre></div><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson17_VOB&#123;    &#x2F;&#x2F;员工    class Worker    &#123;        public virtual void ClockIn()        &#123;            Console.WriteLine(&quot;员工9点打卡&quot;);        &#125;    &#125;        &#x2F;&#x2F;经理    class Manager : Worker    &#123;        public override void ClockIn()        &#123;            Console.WriteLine(&quot;经理10点打卡&quot;);        &#125;    &#125;    &#x2F;&#x2F;程序员    class Programmer : Worker    &#123;        public override void ClockIn()        &#123;            Console.WriteLine(&quot;程序员不打卡&quot;);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Worker w &#x3D; new Worker();            w.ClockIn();            Worker m &#x3D; new Manager();            m.ClockIn();            Worker p &#x3D; new Programmer();            p.ClockIn();        &#125;    &#125;&#125;</code></pre></div><h2 id="题3"><a href="#题3" class="headerlink" title="题3"></a>题3</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson17_VOB&#123;    &#x2F;&#x2F;图形    class Figure    &#123;        &#x2F;&#x2F;求面积        public virtual void Area()        &#123;                    &#125;        &#x2F;&#x2F;求周长        public virtual void Perimeter()        &#123;                    &#125;    &#125;        &#x2F;&#x2F;矩形    class Rectangular : Figure    &#123;        public int l;        public int w;        public Rectangular(int l, int w)        &#123;            this.l &#x3D; l;            this.w &#x3D; w;        &#125;        public override void Area()        &#123;            int s &#x3D; l * w;            Console.WriteLine(&quot;该矩形面积为&#123;0&#125;&quot;, s);        &#125;        public override void Perimeter()        &#123;            int c &#x3D; 2 * ( l + w );            Console.WriteLine(&quot;该矩形周长为&#123;0&#125;&quot;, c);        &#125;    &#125;    &#x2F;&#x2F;矩形    class Square : Figure    &#123;        public int a;        public Square(int a)        &#123;            this.a &#x3D; a;        &#125;        public override void Area()        &#123;            int s &#x3D; a * a;            Console.WriteLine(&quot;该矩形面积为&#123;0&#125;&quot;, s);        &#125;        public override void Perimeter()        &#123;            int c &#x3D; 4 * a;            Console.WriteLine(&quot;该矩形周长为&#123;0&#125;&quot;, c);        &#125;    &#125;    &#x2F;&#x2F;圆形    class Circular : Figure    &#123;        public int r;        const float PI &#x3D; 3.1415926f;        public Circular(int r)        &#123;            this.r &#x3D; r;        &#125;        public override void Area()        &#123;            float s &#x3D; PI * r * r;            Console.WriteLine(&quot;该矩形面积为&#123;0&#125;&quot;, s);        &#125;        public override void Perimeter()        &#123;            float c &#x3D; 2 * r * PI;            Console.WriteLine(&quot;该矩形周长为&#123;0&#125;&quot;, c);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Figure r &#x3D; new Rectangular(2, 4);            r.Area();            r.Perimeter();            Figure s &#x3D; new Square(3);            s.Area();            s.Perimeter();             Figure c &#x3D; new Circular(5);            c.Area();            c.Perimeter();        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月18日</title>
    <link href="/2022/05/18/diary/2022.5/2022%E5%B9%B45%E6%9C%8818%E6%97%A5/"/>
    <url>/2022/05/18/diary/2022.5/2022%E5%B9%B45%E6%9C%8818%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="a1e0b094e8144ae808b5fe252e93194749f564d6cb90a8ab16d5e443fa35d2ed">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50fdd0ca3edc57389bd0e88084b7db20234a98291e286b22bc2d9be6b79caf6bf12130a2f5b91531b1c2ee2bef6a4ff1d8c15e8e38553d8e073e69dc788ad2d52a364479e47d567e379b2b5f22a15dd3f53ed0be8d7b7ac692e45812a8642a5013db4da0a2531fb7bef6e2a9fa0e5e808ed727a568dad693f59ed95f6ffe6a7e24ff2ff6967f54ab0f69c8ca23b9c98cd27e876da11d20abca0ca2c245ef90e43ffd9ec833befc129cff54213bf9b7cfa3977a914f7d9c895a44811d12494185a208b05934c2fbe11794024a855b1b8292dffc89e2a5223cda59d9991ef84a05ccb27919e2f95988af7f72a28fc191be507b43da1f47428a47453e846a14cd1e274f02e6ca983f88f4f142e3f2c9343f8075ff1934c861f87ea7a678a7981bc3c19514cae9fa3af4887d16a7da8a568d4fad930f4542bbdf796c578ba19a225b1572572d7dab49843e81a4b6da463d56ed423f11995ab1abf487a51498cff56ad2e6f9ff0b0e53eb19dbf206b70a912c27d680af9d0c42942630d7bf9d507a864f56fd77d1c8d95c0d7ac0629d30dd043d8d6d97a1949c6438f14d3bd667abca6308f4aebc2ccf7a60ac066aad0d1b8e61c929f1b90e970bd20ab752a60425808eb43f6e8e7aef4cb262d4f692ff6a18130ce4cc70e193fd803a9bda42e65a615af7749a391ffd7463696f01b30bb24fa4d9e17ff89549deb07cce53e04e2327172d96fb48ee090e7f34a68a2913bbe2e2a45e95d83d217c7a020ac19ae25559a80f7bcba224f98cce420a63cf3f3292efa71df421d973aba683f860011ee439bee17318f3d49c44da527a6081446bd5e7ece325cf6dd36007629d6e5b095276e3c060ed84fd29830a39aa86a4fd681b3a0491e85bf9f48d0946d71f31ec446342e5792898853d2db62eae8ca66ee2d66176d9352f14780f1801d3bcd9550aae1cc988a96f89805bf6406739bea117900d35834cfc0e8e30de1edf7ff16353ea599f5bf118128db41e7fa6e5947794915fb94a564ce80f9332061b5d8d3eb44caaa8d7d9648e0d1feff08e6711c7fc625661e19f1b42bc19638b8c5a0e28ba2b9523010163f111a7321002c5f5bef758114ffbb1b459e49dfbbb3198c0514b830fbea234508b2a242682d2739da6138e7afe3d13b7f79d97b78e65821f024a6820f8fa65e9e4e9f2984c59a3877023b2ef7d56bc0b3b018ea5bffdbe47b41a4c3cc5165b8067e63fcc8ab842353c385c42eb6c4d86d5bc52f55303f4b1ae4b5f7b8384e2f36ab3b6804427a8abadc8a054754579e3ab6449264f1bdd54125de4f1</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月17日</title>
    <link href="/2022/05/17/diary/2022.5/2022%E5%B9%B45%E6%9C%8817%E6%97%A5/"/>
    <url>/2022/05/17/diary/2022.5/2022%E5%B9%B45%E6%9C%8817%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="18704ebd8b16e1e9d2ad672a38c56040c3530adf64cbb4ba074124c2c9298010">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50fdd0ca3edc57389bd0e88084b7db2023f42eee7650a2032f2b23d7fd0fc253e4226e332027f8095b3a83a4b6176d19d0e1c37b7629e1188d5ac39265ba057e9e1cf18cfe6a7cd96bc3f0901e5db825e9e3f9dbae55f8c66f0ba77b55c50cd309ebcff3e2b6613838ec0a63d0d269441e6bee4ac22ccbb92c2f0cba5b4d195235fc0d1b9f47d5ec7245165cdd15ea9b4a8e6a6472bc511d383f802ed4a5eaf65df3b2528fb45c1e45df243eeb9a98e204775e74bd28b5ff42eeba70b1553e5c75f79e45e2dc818d428521c8ba05d608c96c63632d35f3813c9e8c0867f10f6ba4e2ddb54996ee938beac164f268acc5fd0b444f866bb27bd1c7fffcf4c41eb9407ac14b8c3bd9924dd726607fe2ece45b0aaed379d5aac22bb0e62c6874c4807341a7fb6b3ed22521331f28fafb35c1683e91f33e21d08a7a9fd5d68ab5953690f2294c0cd7152964996a673d7c7b88367ede816d7a6cbdb44b48c4fda4ad489955eb35c717be379f8ca429b15cfaf20c1c1f2f847a82e5519fb9fc4b888024a7a3b87ce5b60f43196a55ff1273e05e4ac26ec482932bc0d61d0c3872efad7b493030cda9a722ad0cd5a956e0883bbb626d9eebb84abbe197885dbd61725dcfa5d47fb2220147677d3b9254f2b8b3af50bb20e941d583ff887a901f1e7b95202a4fed455b6637d1fc89c6b7da80cce79f7131102cf2dd99e95dfaf625d973f63196dee5026d286da82794f1166a43ae014901c4e13422c935fd4d0d9caa72e161ac49c38493761807c49d2aeddfa01036af2d7d1a1c196ba83a311f7443eeb964</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>密封类</title>
    <link href="/2022/05/17/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E5%AF%86%E5%B0%81%E7%B1%BB/"/>
    <url>/2022/05/17/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E5%AF%86%E5%B0%81%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>密封类</p><span id="more"></span><h1 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>密封类：使用sealed密封关键字修饰的类<br>作用：让类无法再被继承</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">sealed class 类名</code></pre></div><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>不允许最底层子类被继承，保证程序的规范性、结构性、安全性</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/17/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E5%AF%86%E5%B0%81%E7%B1%BB/exam.png" class=""><p>没设置自定义乘客数量、途径站点数</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson16_密封类&#123;    sealed class Carrier    &#123;        &#x2F;&#x2F;两站间隔1km        int s &#x3D; 1000;        &#x2F;&#x2F;载具速度        int speed;        &#x2F;&#x2F;最大速度100m&#x2F;min        int speedMax &#x3D; 100;        &#x2F;&#x2F;最大可乘10人,包含司机        int maxNumber &#x3D; 10;                &#x2F;&#x2F;上车人数        public int onNum &#x3D; 0;        &#x2F;&#x2F;下车人数        public int offNum &#x3D; 0;        &#x2F;&#x2F;乘客数组        public bool[] passengers &#x3D; new bool[10];        &#x2F;&#x2F;上下车人数的随机数,载具速度的随机数        Random r &#x3D; new Random();        &#x2F;&#x2F;逻辑上先上车再下车        &#x2F;&#x2F;上车 + 下车        public void GetOnOff(ref int nowNum)        &#123;             &#x2F;&#x2F;上车人数不能超过总人数            onNum &#x3D; r.Next(10 - nowNum);            Console.Write(&quot;上车&#123;0&#125;人  &quot;, onNum);            for (int i &#x3D; nowNum; i &lt; nowNum + onNum; i++)            &#123;                passengers[i] &#x3D; true;            &#125;            &#x2F;&#x2F;下车人数不能超过原已上车人数            offNum &#x3D; r.Next(nowNum);             Console.Write(&quot;下车&#123;0&#125;人  &quot;, offNum);            for (int i &#x3D; nowNum + onNum - 1; i &gt;&#x3D; nowNum + onNum - offNum; i--)            &#123;                passengers[i] &#x3D; false;            &#125;            &#x2F;&#x2F;更新已上车人数            nowNum &#x3D; nowNum + onNum - offNum;        &#125;        &#x2F;&#x2F;行驶 打印多久到下一站 按任意键到下一站        public void Drive()        &#123;            &#x2F;&#x2F;载具速度            speed &#x3D; r.Next(50, speedMax + 1);            Console.WriteLine(&quot;耗时&#123;0&#125;分钟,到达下一站&quot;, s&#x2F;speed);                &#125;        &#x2F;&#x2F;车祸        public void Accident()        &#123;            Console.WriteLine(&quot;很不幸,发生了车祸&quot;);            Environment.Exit(0);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            &#x2F;&#x2F;定义一个随机数,判断是否车祸            Random r &#x3D; new Random();            &#x2F;&#x2F;默认一开始没人上车,即乘客全为false            Carrier c &#x3D; new Carrier();            &#x2F;&#x2F;已上车人数 初始为0            int nowNum &#x3D; 0;            &#x2F;&#x2F;计数到站数,设一共10站            int set &#x3D; 0;            for (int i &#x3D; 0; i &lt; c.passengers.Length; i++)            &#123;                c.passengers[i] &#x3D; false;            &#125;            Console.WriteLine(&quot;现在从始发站开始出发,车上无乘客&quot;);            while(true)            &#123;                Console.WriteLine(&quot;请按任意键前往下一站&quot;);                Console.WriteLine(&quot;&quot;);                Console.ReadKey(true);                                &#x2F;&#x2F;95%的概率正常行驶,5%的概率出车祸                if ( r.Next(101) &lt;&#x3D; 95 )                &#123;                    c.Drive();                    c.GetOnOff(ref nowNum);                    Console.WriteLine(&quot;现在车上有&#123;0&#125;人&quot;, nowNum);                    set++;                &#125;                else                &#123;                    c.Accident();                &#125;                if( set &#x3D;&#x3D; 10 )                &#123;                    Console.WriteLine(&quot;\n已到达终点站&quot;);                    Environment.Exit(0);                &#125;            &#125;         &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>万物之父和装箱拆箱</title>
    <link href="/2022/05/17/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E4%B8%87%E7%89%A9%E4%B9%8B%E7%88%B6%E5%92%8C%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1/"/>
    <url>/2022/05/17/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E4%B8%87%E7%89%A9%E4%B9%8B%E7%88%B6%E5%92%8C%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1/</url>
    
    <content type="html"><![CDATA[<p>万物之父和装箱拆箱</p><span id="more"></span><h1 id="万物之父和装箱拆箱"><a href="#万物之父和装箱拆箱" class="headerlink" title="万物之父和装箱拆箱"></a>万物之父和装箱拆箱</h1><h2 id="万物之父"><a href="#万物之父" class="headerlink" title="万物之父"></a>万物之父</h2><p>关键字： object<br>概念： object是所有类型的基类，它是一个类（引用类型）<br>作用：<br>1.可以利用里式替换原则，用object容器装所有对象<br>2.可以用来表示不确定类型，作为函数参数类型</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Father&#123;&#125;class Son : Father&#123;    public void Speak()    &#123;    &#125;&#125;internal class Program&#123;    static void Main(string[] args)    &#123;        Father f &#x3D; new Son();        if( f is Son )        &#123;            ( f as Son ).Speak();        &#125;        &#x2F;&#x2F;引用类型        object o &#x3D; new Son();        if( o is Son )        &#123;            (o as Son ).Speak();        &#125;        &#x2F;&#x2F;值类型        object o2 &#x3D; 1;        &#x2F;&#x2F;用强转进行数值使用        int i &#x3D; (int)o2;        &#x2F;&#x2F;特殊的string类型        object o3 &#x3D; &quot;123123&quot;;        string s &#x3D; o3 as string; &#x2F;&#x2F;o3.ToString();        &#x2F;&#x2F;数组类型        object o4 &#x3D; new int[10];        int[] arr &#x3D; o4 as int[]; &#x2F;&#x2F;(int[])o4;    &#125;&#125;</code></pre></div><h2 id="拆箱装箱"><a href="#拆箱装箱" class="headerlink" title="拆箱装箱"></a>拆箱装箱</h2><p>发生条件：<br>装箱： object中存入值类型<br>拆箱： object转为值类型</p><p>装箱：<br>把值类型用引用类型存储<br>栈内存会迁移到堆内存中</p><p>拆箱：<br>把引用类型存储的值类型取出来<br>堆内存会迁移到栈内存中</p><p>好处：不确定类型时可以方便参数的存储和传递<br>坏处：存在内存迁移，增加性能消耗</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">internal class Program&#123;    static void Main(string[] args)    &#123;        &#x2F;&#x2F;装箱        object v &#x3D; 3;        &#x2F;&#x2F;拆箱        int intValue &#x3D; (int)v;        &#x2F;&#x2F;传入object类数组        TestFun(1, 1.5f , 2, &quot;123&quot;, new int[10]);    &#125;    static void TestFun( params object[] array )    &#123;    &#125;&#125;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/17/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E4%B8%87%E7%89%A9%E4%B9%8B%E7%88%B6%E5%92%8C%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><p>装箱： object中存入值类型；把值类型用引用类型存储；栈内存会迁移到堆内存中<br>拆箱： object转为值类型；把引用类型存储的值类型取出来；堆内存会迁移到栈内存中</p><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">internal class Program&#123;    &#x2F;&#x2F;装箱    object v &#x3D; 3;    &#x2F;&#x2F;拆箱    int intValue &#x3D; (int)v;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>继承中的构造函数</title>
    <link href="/2022/05/16/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <url>/2022/05/16/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>继承中的构造函数</p><span id="more"></span><h1 id="继承中的构造函数"><a href="#继承中的构造函数" class="headerlink" title="继承中的构造函数"></a>继承中的构造函数</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>特点：</strong><br>当声明一个子类对象时<br>先执行父类的构造函数<br>再执行子类的构造函数</p><p><strong>注意：</strong><br>1.父类的无参构造 很重要<br>2.子类可以通过base关键字 代表父类 调用父类构造</p><h2 id="继承中构造函数的执行顺序"><a href="#继承中构造函数的执行顺序" class="headerlink" title="继承中构造函数的执行顺序"></a>继承中构造函数的执行顺序</h2><p>1.父类的父类的构造函数<br>2.父类的构造函数<br>3.子类的构造函数<br>即<strong>从高到低依次调用</strong></p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class GameObject&#123;    public GameObject()    &#123;        Console.WriteLine(&quot;GameObject的构造函数&quot;);    &#125;&#125;class Player : GameObject&#123;    public Player()    &#123;        Console.WriteLine(&quot;Player的构造函数&quot;);    &#125;&#125;class MainPlayer : Player&#123;    public MainPlayer()    &#123;        Console.WriteLine(&quot;MainPlayer的构造函数&quot;);    &#125;&#125;internal class Program&#123;    static void Main(string[] args)    &#123;        MainPlayer mp &#x3D; new MainPlayer();    &#125;&#125;</code></pre></div><h2 id="父类的无参构造函数很重要"><a href="#父类的无参构造函数很重要" class="headerlink" title="父类的无参构造函数很重要"></a>父类的无参构造函数很重要</h2><p>重点：<br>无参构造函数会被有参构造函数顶替</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Father&#123;    public Father(int i)    &#123;        Console.WriteLine(&quot;Father构造函数&quot;);    &#125;&#125;class Son : Father&#123;    &#x2F;&#x2F;默认调用父类的无参构造函数，但父类中无参构造函数被顶替，所以报错&#125;internal class Program&#123;    static void Main(string[] args)    &#123;        Son s &#x3D; new Son();    &#125;&#125;</code></pre></div><h2 id="通过base调用制定父类构造"><a href="#通过base调用制定父类构造" class="headerlink" title="通过base调用制定父类构造"></a>通过base调用制定父类构造</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Father&#123;    public Father(int i)    &#123;        Console.WriteLine(&quot;Father构造函数&quot;);    &#125;&#125;class Son : Father&#123;    public Son(int i) : base(i)    &#123;        Console.WriteLine(&quot;Son一个参数的构造函数&quot;);    &#125;    public Son(int i, string str) : this (i)    &#x2F;&#x2F;this其实是先调用base(i),是一种间接的方式;如果用base会直接执行父类构造函数    &#123;        Console.WriteLine(&quot;Son两个参数的构造函数&quot;);    &#125;&#125;internal class Program&#123;    static void Main(string[] args)    &#123;        Son s1 &#x3D; new Son(1, &quot;123&quot;);    &#125;&#125;</code></pre></div><p>注意：<br>this和base的区别<br>this:自己的另一个对应构造函数<br>base:父类的对应构造函数</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/16/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/exam.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson14_继承中的构造函数&#123;    enum E_TypeOfWork    &#123;        Programmer,        Planner,        Artist,    &#125;    enum E_WorkContent    &#123;        program,        plan,        paint,    &#125;    class Worker    &#123;        public E_TypeOfWork typeOfWork;        public E_WorkContent workContent;        public Worker(E_TypeOfWork typeOfWork, E_WorkContent workContent)        &#123;            Console.WriteLine(&quot;我是打工人&quot;);        &#125;    &#125;        class Programmer : Worker    &#123;        public Programmer(E_TypeOfWork typeOfWork, E_WorkContent workContent) : base(typeOfWork, workContent)        &#123;            Console.WriteLine(&quot;&#123;0&#125; is &#123;1&#125;ing&quot;, typeOfWork, workContent);        &#125;    &#125;    class Planner : Worker    &#123;        public Planner(E_TypeOfWork typeOfWork, E_WorkContent workContent) : base(typeOfWork, workContent)        &#123;            Console.WriteLine(&quot;&#123;0&#125; is &#123;1&#125;ing&quot;, typeOfWork, workContent);        &#125;    &#125;    class Artist : Worker    &#123;        public Artist(E_TypeOfWork typeOfWork, E_WorkContent workContent) : base(typeOfWork, workContent)        &#123;            Console.WriteLine(&quot;&#123;0&#125; is &#123;1&#125;ing&quot;, typeOfWork, workContent);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Programmer programmer &#x3D; new Programmer(E_TypeOfWork.Programmer, E_WorkContent.program);             Planner planner &#x3D; new Planner(E_TypeOfWork.Planner, E_WorkContent.plan);            Artist artist &#x3D; new Artist(E_TypeOfWork.Artist, E_WorkContent.paint);        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>里式替换原则</title>
    <link href="/2022/05/16/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E9%87%8C%E5%BC%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/"/>
    <url>/2022/05/16/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E9%87%8C%E5%BC%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<p>里式替换原则</p><span id="more"></span><h1 id="里式替换原则"><a href="#里式替换原则" class="headerlink" title="里式替换原则"></a>里式替换原则</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>任何父类出现的地方，子类都可以替代</p><p><strong>重点</strong><br>语法表现： 父类容器装子类对象，因为子类对象包含了父类的所有内容</p><p><strong>作用</strong><br>方便进行对象存储和管理</p><h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class GameObject&#123;&#125;class Player : GameObject&#123;    public void PlayerAtk()    &#123;        Console.WriteLine(&quot;玩家攻击&quot;);    &#125;&#125;class Monster : GameObject&#123;    public void MonsterAtk()    &#123;        Console.WriteLine(&quot;怪物攻击&quot;);    &#125;&#125;class Boss : GameObject&#123;    public void BossAtk()    &#123;        Console.WriteLine(&quot;Boss攻击&quot;);    &#125;&#125;internal class Program&#123;    static void Main(string[] args)    &#123;        &#x2F;&#x2F;里式替换原则 用父类容器 装载子类对象        GameObject player &#x3D; new Player();        GameObject monster &#x3D; new Monster();        GameObject boss &#x3D; new Boss();        GameObject[] objects &#x3D; new GameObject[] &#123; new Player(), new Monster(), new Boss() &#125;;                &#x2F;&#x2F;此时player对象中不存在Playeratk的方法，因为player是在父类容器GameObject中，而GameObject中没有Playeratk的方法        &#x2F;&#x2F;即父类容器装载子类对象不能直接使用子类中的方法    &#125;&#125;</code></pre></div><h2 id="is和as"><a href="#is和as" class="headerlink" title="is和as"></a>is和as</h2><p><strong>基本概念</strong><br>is : 判断一个对象是否是指定类对象<br>返回值： bool 是为true 不是为false</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">if(player is Player)&#123;&#125;else if (player is Monster)&#123;&#125;</code></pre></div><p>as : 将一个对象转换为指定类对象<br>返回值： 指定类型对象<br>成功返回指定类型对象，失败返回null</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Player p &#x3D; player as Player; &#x2F;&#x2F;成功 p 是PlayerPlayer p &#x3D; monster as Player; &#x2F;&#x2F;失败 p &#x3D; null</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">if(player is Player)&#123;    &#x2F;&#x2F;Player p &#x3D; player as Player;    &#x2F;&#x2F;p.Playatk();    (player as Player).PlayerAtk();    &#x2F;&#x2F;上面两种等价&#125;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/16/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E9%87%8C%E5%BC%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><p>is是判断该对象是不是这个类，返回的是bool值<br>as是将该对象转换为指定类型，成功则转换成功，失败则将该对象变为null</p><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson13_里式替换原则&#123;    class Monster    &#123;    &#125;    class Boss : Monster    &#123;        public void Skill()        &#123;            Console.WriteLine(&quot;Boss释放技能&quot;);        &#125;    &#125;    class Goblin : Monster    &#123;        public void Atk()        &#123;            Console.WriteLine(&quot;哥布林攻击&quot;);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Monster[] monsters &#x3D; new Monster[10];            Random rand &#x3D; new Random();            for (int i &#x3D; 0; i &lt; monsters.Length; i++)            &#123;                if(rand.Next(1,101) &lt;&#x3D; 50)                &#123;                    monsters[i] &#x3D; new Boss();                &#125;                else                &#123;                    monsters[i] &#x3D; new Goblin();                &#125;            &#125;            for (int i &#x3D; 0; i &lt; monsters.Length; i++)            &#123;                if(monsters[i] is Boss)                &#123;                    (monsters[i] as Boss).Skill();                &#125;                else if(monsters[i] is Goblin)                &#123;                    (monsters[i] as Goblin).Atk();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div><h2 id="题3"><a href="#题3" class="headerlink" title="题3"></a>题3</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson13_里式替换原则&#123;    &#x2F;&#x2F;玩家类    class Player    &#123;        public void SwitchWeapon(int k)        &#123;            Player[] weapons &#x3D; new Player[4] &#123; new SMG(), new Shotgun(), new Pistol(), new Dagger() &#125;;            if (weapons[k] is SMG)            &#123;                (weapons[k] as SMG).Print();            &#125;            else if (weapons[k] is Shotgun)            &#123;                (weapons[k] as Shotgun).Print();            &#125;            else if (weapons[k] is Pistol)            &#123;                (weapons[k] as Pistol).Print();            &#125;            else if (weapons[k] is Dagger)            &#123;                (weapons[k] as Dagger).Print();            &#125;        &#125;    &#125;    &#x2F;&#x2F;冲锋枪类    class SMG : Player    &#123;        public void Print()        &#123;            Console.WriteLine(&quot;你现在手持冲锋枪&quot;);        &#125;    &#125;    &#x2F;&#x2F;霰弹枪类    class Shotgun : Player    &#123;        public void Print()        &#123;            Console.WriteLine(&quot;你现在手持霰弹枪&quot;);        &#125;    &#125;    &#x2F;&#x2F;手枪类    class Pistol : Player    &#123;        public void Print()        &#123;            Console.WriteLine(&quot;你现在手持手枪&quot;);        &#125;    &#125;    &#x2F;&#x2F;匕首类    class Dagger : Player    &#123;        public void Print()        &#123;            Console.WriteLine(&quot;你现在手持匕首&quot;);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Player p &#x3D; new Player();            &#x2F;&#x2F;默认匕首            p.SwitchWeapon(3);            Console.WriteLine(&quot;按1(冲锋枪),2(霰弹枪),3(手枪),4(匕首)进行切枪&quot; + &quot; &quot; + &quot;按q退出程序&quot;);            while (true)            &#123;                char cmd &#x3D; Console.ReadKey(true).KeyChar;                try                 &#123;                    if(cmd !&#x3D; &#39;q&#39;)                    &#123;                        p.SwitchWeapon(Convert.ToInt32(cmd - &#39;0&#39;) - 1);                    &#125;                    else                    &#123;                        Environment.Exit(0);                    &#125;                &#125;                catch                &#123;                    Console.WriteLine(&quot;请输入正确指令&quot;);                &#125;                           &#125;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月16日</title>
    <link href="/2022/05/16/diary/2022.5/2022%E5%B9%B45%E6%9C%8816%E6%97%A5/"/>
    <url>/2022/05/16/diary/2022.5/2022%E5%B9%B45%E6%9C%8816%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="8ff5085b02db703695eb0573d5e2395718f232387ff5a7bcffab20389c364185">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe505b803b8feaab671cea5ab5e4652ea6c36a02f1947ad70fc2430bd172aca29c6de61259f12fbbd1a4855621ddc3d9d79291f362396f3716bf88727952e141b19141594a62e1e2a1cfce1049c766c052e9189ec318c83d4889671d1206c52a37e925512f04d7e6cf54ff03f5a54a66e4d0f1771bd9a0aa9e6e12bde83af7c4521de6822c6a3c85521d8406e4ee55cc09630a7a3b945f25dbcd29f27aeaa1955a761710f18fbc6df5b1461fe1d5e9ff92b8445f70ec9d16c48ae8eab299ea194cb155a5dbb022d2862dbaabc2f3e4554310341b80c0e38ad644bef9f30ce6c9862b12efd2953531245df513c5ea1e5c94483495f72abfdb32eeec3a1bec1e7f82612dadd133fe3bc11200d8944b1abf9ad0ffba36bc6025ad69f3988ab774dbe96e8d090740736b887dc8998511d9063c9605290758a36a4f6160c28f2e6cc61b2e213a6d6b9ec204ab8d0c2ec0799e9c2677eadc39875b2e663f17c41b31bc971117b9a800d3087acdd0d368d71e4393cb</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月15日</title>
    <link href="/2022/05/15/diary/2022.5/2022%E5%B9%B45%E6%9C%8815%E6%97%A5/"/>
    <url>/2022/05/15/diary/2022.5/2022%E5%B9%B45%E6%9C%8815%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="829ded19b386609cf9ac49cbf1c44b2b04da821bfccef03a6e2c685585e6e71c">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe5016a4faf8194f2f8aa9b1a6144f7333a3892e1f4a31a2d18309e56f20249bd16769e464f7d6eb4a6e4fab04466bd357c63e94ff3c847c3aecee23dd98d9231033f5cf1745aa32f0f11f3731764b767d424ac8e92d145e3b510d2ad55a0294a4cd5d617e36d2284f04ec73f005e7f9611edd4dc41b9fe47cf734c8432125ca2590cee134ac84e982742ceb768e2d0b46d6f68f55bf42afa3adc8113d1c7dcf90cd726885350ddbaa3dd0f3f4e47bc8e6ce71ebbcddee631d3a847d5b94fdf47b7eae9909ede14e84c594d26966b216134c28a72f32366189176140edf5f011107352fcef378e49c52c2f8634d4ceb69ea17eacd5c048fafe1a5ed420aadffa07682696725fa3297c629086715f33d0dfeda09df377c955a225eb8f1bf0be1aa8e377fb0d26fd960c67b6e405a1bde81c51c54cc246071d139ad9f772292fc0260a3d7ab2d9a0c1e545bca15aa7e8537ff71b7ca315bcc1a07aae28f38d577044add5bc085f924bc8b84659dd5fd7cad2ca1588d2a3fc18e5c6659d8dfc4fbb657d6af886ec46f678329afb02a95781c497363c9e0f5b0aa42abbaaf228ef4667d9d5b4fdb4483291c18d999d01718a6f50a85e66bb5e9572ec80da526bee47f920f74ffc4d34d5e0aea04f883ca9b87c231a6c158ea694c2fd9402477c370dee9067d57b934831465f9c4a06e041c7a4e74e04cda4ff80dbe1b730d430c0bad17fc92e2ecc1ef39d60707c523253a050ed1e8609e6cd446778ef9177c15d21cbabc53cef4802f4f22081c8725229a160c3844026dc7262dae8cd0d424306c117c63e98e7542e46002c688f6209043df006d8f2520374946c69590dfe8bd09179572178ee2922783b1e3fabfe43c9aa4750ce54b82ddf39a6233e8c3848b7157825ac303cb81c187e655f37ad05c0f29591027b97f499838cfaf900f752fb4fcadb1942c980476a6d7347c7fe5006e51db3b3c4e601b2f81c939a1958611635f29c2e79d3ba4925a61a69644bed421abef71a39c70e57f3b16f47a5fb85254caa8a602004c6e01d70c63abaf69146a6243882c0cc089b60d764e83d96ac561778711086d1dd7c3f3a3b88d2ec61fb15c2cfc94c68eda9882facb8564ac3949c1145e133e4eb3d4feed6cd809a1f7e7a690d2cfddc19fea4323a107f12975738b2f4ad9d66700b06ca3028706b150318e5802e0175f7022224b9fde1f682fe18ac0f8bc03fee8ef646ca3dbe86367bc1473a17cfdd92d2f66206bc85cdcda7379e45385cbeedfb11987dabc13fb4cd1946f926d03256f0ba26a8f7ed320a2e293a1a222bedf2dde4df4e9afb694fcd4130075c0e9057bc9e7d9f456bc917eec3c8418643f198517ee42fb5b2766c483884d2c21316c4101bba7eb18f0f664c6b52b743217cbb2841c8217e85edb64fff4dbc2675438c138a709a27e5b4d3e214f342e80c3fe12612c775eb35af60812ab78bc5937232116cc0213ce918ab795751af0a40cdd88edb39485100cce6a4af3ee73206065e209eb62cb2f33cbbf34cd061ff68ce136ad467c6863ca6528cc5cd66b11d960a91242d9e1c772699bf2910f3ab77782fe39826e701df2001f30d529b0cf44b4eaaa0011ea88c2eeb85410a60e0d10f215871042cb1b9aed53bb50ad265e2a27139c3e35b1d48e164089d501238a78ff71e86baa180d50ebc88d1d28e09c9153e91a8e837819def61873f41dcaecc3908eac609be37d31975c35ed7b18271e8222c1b8591697310a0db730ad7a7f0227009d827653828c4f36e2b3eb3d658fcbb178e97abc960152228787fd6fb6fe84cb172ea669d1d53efe52f2cce4630cb39c0fda09dc0042ce238133b2eac4eae6107edfbe0b2528013fc7356b63a22cec41e3f466cb2c9e6b8844dafd3aa79234f0f2009463f3471c4d8c5dde2602db028b62998e338afa1f18c28f84ac7789f9a8ebd60dd90045a0cdb45df6984dcda44e2e5f5e923dbabed5cde3e986f77c2968414236383715ef0b20386b1a14c47ba289a3b71647c5cfdbe816ae0c1bf75da080719b6fae2fcfa7b8fcffece1c3771dbfc2d4ac16490c5fec57e07c6488058a8e6636fb1205fd450c4fc195218774497759f86ecb9d177613550359f29ca09e16241559385d710397ab7f7edfa3c65fc974c4be19951dda2a361a58faaf18eb0157dd6f4b3d5913916e8e848f665a816ac6cd4f43a38e6872e1dc5b8d3972daa05107b4a2efd6a4dd9eeb1413b6783a6d81d6587267ab625a04ad4317d3a54c06ab31a632699e27ad109be508037ef5b34dffc376122954d493e5aad2653d11b56f7929050ba6a954c641be9f82c8c0fbed2c1211a7025f1edb5737aabbab7175419f5d52befe987c4d0fb43b04849f4e727446d891953cdd7f4b444a19e516db931198efbe5629f652fe953e1585a4a7311acdecac62e330e280b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月14日</title>
    <link href="/2022/05/14/diary/2022.5/2022%E5%B9%B45%E6%9C%8814%E6%97%A5/"/>
    <url>/2022/05/14/diary/2022.5/2022%E5%B9%B45%E6%9C%8814%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="0d2d3e74c0b88ce0e89374106356adaec4166149c0b200bfcae26f6136b84842">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50eab5a83f549bec176812e5d10b67ba0dcb7ab007c94ce139a456f545dfed2122acee6f64839288f02efb7a0ade81be20e4fcb98a37a126e8c08d3745c9a2c29c5ba00cf3b5d1957d413586b65b4c4ce75dbf344e86c5e5ea5c6ab445d806a2c8516e4b35b8cf1cafbd1ad726fe8c3ef0cd0b399e88e11bf157ec758812cbfe7c43a1221624af8d9cf5aef115f882d51e9d5156e17b1ef31b936994250fa210514b10fd98ddd056e583b10505eada21a85658b5a84db87e7b04735f8dfa27de28576898d03ea61ce2a2e0347248a524f15b85f0228ca1d6e442359173862bb1b2a7521af6b0051d12c0e9903863e9bfcd536f6ab37f0bd9e7f2f5f76578ccc02b780c72109f9b4bd4b2727eb5b4de1270428b49f32edd5387fd3a770463524b7ae3f8f923a0ef0819f1e76f60e6d1a71dbf8814667f68956269c37c16de288a96b64333959bb2db4d4cdb8a64c80082b61c7d457e8cd3385dcca90f4da4064b53879151466b3e9a6dd6835129a0fecd22</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>继承的基本规则</title>
    <link href="/2022/05/14/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99/"/>
    <url>/2022/05/14/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99/</url>
    
    <content type="html"><![CDATA[<p>继承的基本规则</p><span id="more"></span><h1 id="继承的基本规则"><a href="#继承的基本规则" class="headerlink" title="继承的基本规则"></a>继承的基本规则</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>一个类A继承一个类B<br>类A将会继承类B的所有成员<br>类A将拥有类B的所有特征和行为</p><p><strong>被继承的类：</strong><br><em>父类</em> &#x2F; 基类 &#x2F; 超类 </p><p><strong>继承的类：</strong><br><em>子类</em> &#x2F; 派生类</p><p>子类可以有自己的特征和行为</p><p><strong>特点：</strong><br>1.单根性：子类只能有一个父类<br>2.传递性：子类可以简介继承父类的父类</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class 类名 : 被继承的类名&#123;&#125;</code></pre></div><img src="/2022/05/14/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99/%E6%A0%91%E7%8A%B6%E5%9B%BE.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;老师类class Teacher&#123;    &#x2F;&#x2F;姓名    public string name;    &#x2F;&#x2F;职工号    public int number;    &#x2F;&#x2F;介绍名字    public void SpeakName()    &#123;        Console.WriteLine(name);    &#125;&#125;&#x2F;&#x2F;教学老师类 作为 老师类的 子类class TeachingTeacher : Teacher&#123;    &#x2F;&#x2F;科目    public string subject;    &#x2F;&#x2F;介绍科目    public void SpeakSubject()    &#123;        Console.WriteLine(subject + &quot;老师&quot;);    &#125;&#125;&#x2F;&#x2F;语文老师类 class ChineseTeacher : TeachingTeacher&#123;&#125;internal class Program&#123;    static void Main(string[] args)    &#123;        TeachingTeacher tt &#x3D; new TeachingTeacher();        tt.name &#x3D; &quot;季宝&quot;;        tt.number &#x3D; 1;        tt.SpeakName();        tt.subject &#x3D; &quot;Unity&quot;;        tt.SpeakSubject();    &#125;&#125;</code></pre></div><h2 id="访问修饰符的影响"><a href="#访问修饰符的影响" class="headerlink" title="访问修饰符的影响"></a>访问修饰符的影响</h2><p>public - 公共 内外部访问<br>private - 私有 内部访问（子类不能访问）<br>protected - 保护 内部和子类访问<br>internal - 内部的 只有在同一个程序集的文件中，内部类型或者是成员才可以访问</p><h2 id="子类和父类的同名成员"><a href="#子类和父类的同名成员" class="headerlink" title="子类和父类的同名成员"></a>子类和父类的同名成员</h2><p><strong>概念：</strong><br>C#中允许子类存在和父类同名的成员<br>但 极不建议使用</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public new string name;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/14/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99/exam.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson12_继承的基本规则&#123;    &#x2F;&#x2F;人类类    class Person    &#123;        public string name;        public int age;        public void Speak()        &#123;            Console.WriteLine(&quot;我是&quot; + name);        &#125;    &#125;    &#x2F;&#x2F;战士类    class Warrior : Person    &#123;        public void Attack()        &#123;            Console.WriteLine(&quot;wslnm&quot;);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Warrior warrior &#x3D; new Warrior();            warrior.name &#x3D; &quot;大逼&quot;;            warrior.Speak();             warrior.Attack();        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内部类和分部类</title>
    <link href="/2022/05/13/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%88%86%E9%83%A8%E7%B1%BB/"/>
    <url>/2022/05/13/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%88%86%E9%83%A8%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>内部类和分部类</p><span id="more"></span><h1 id="内部类和分部类"><a href="#内部类和分部类" class="headerlink" title="内部类和分部类"></a>内部类和分部类</h1><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p><strong>基本概念：</strong><br>在一个类中再声明一个类</p><p><strong>特点：</strong><br>使用时要用包裹者点出自己</p><p><strong>作用：</strong><br>亲密关系的表现</p><p><strong>注意：</strong><br>访问修饰符作用很大</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Person &#123;     public int age;     public string name;     public Body body;     public class Body     &#123;         Arm leftArm;         Arm rightArm;         &#x2F;&#x2F;class在内部类里默认private         class Arm         &#123;         &#125;     &#125;      &#125; internal class Program &#123;     static void Main(string[] args)     &#123;         Person p &#x3D; new Person();         Person.Body body &#x3D; new Person.Body();         &#x2F;&#x2F;Person.Body.Arm arm &#x3D; new Person.Body.Arm(); 会报错     &#125; &#125;</code></pre></div><h2 id="分部类"><a href="#分部类" class="headerlink" title="分部类"></a>分部类</h2><p><strong>基本概念：</strong><br>把一个类分成几部分声明</p><p><strong>关键字</strong> <em>partial</em></p><p><strong>作用：</strong><br>1.分布描述一个类<br>2.增加程序的拓展性</p><p><strong>注意：</strong><br>1.分部类可以写在多个脚本文件中<br>2.分部类的访问修饰符要一致<br>3.分部类中不能有重复成员</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">partial class Student&#123;    public bool sex;    public string name;&#125;&#x2F;&#x2F;一个类 分开写partial class Student&#123;    public int number;    public void Speak(string str)    &#123;    &#125;&#125;internal class Program&#123;    static void Main(string[] args)    &#123;        Student student &#x3D; new Student();        student.Speak(string.Empty);    &#125;&#125;</code></pre></div><h2 id="分部方法"><a href="#分部方法" class="headerlink" title="分部方法"></a>分部方法</h2><p><strong>基本概念：</strong><br>将方法的声明和实现分离</p><p><strong>特点：</strong><br>1.不能加访问修饰符  默认private<br>2.只能在分部类中声明<br>3.返回值只能是void<br>4.可以有参数  不能用out关键字</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;声明和实现分到两个分部类里面    partial class Student    &#123;        public bool sex;        public string name;        &#x2F;&#x2F;声明        partial void Speak();    &#125;    &#x2F;&#x2F;一个类 分开写    partial class Student    &#123;        public int number;        &#x2F;&#x2F;实现        partial void Speak()        &#123;            &#x2F;&#x2F;实现逻辑        &#125;    &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运算符重载</title>
    <link href="/2022/05/13/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    <url>/2022/05/13/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<p>运算符重载</p><span id="more"></span><h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>让自定义类和结构体，能够使用运算符<br>关键词 <em>operator</em></p><p><strong>特点：</strong><br>1.一定是一个公共的静态方法<br>2.返回值写在operator前面<br>3.逻辑处理自定义</p><p><strong>作用：</strong><br>让自定义类和结构体对象可以进行运算</p><p><strong>注意：</strong><br>1.条件运算符需要成对实现<br>2.一个符号可以多个重载<br>3.不能使用ref和out</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Point&#123;    public int x;    public int y;    &#x2F;&#x2F;重载+号    public static Point operator +(Point p1, Point p2)    &#x2F;&#x2F;public static 返回类型 operator 运算符(参数列表)    &#123;        Point p &#x3D; new Point();        p.x &#x3D; p1.x + p2.x;        p.y &#x3D; p1.y + p2.y;        return p;    &#125;    &#x2F;&#x2F;+号多个重载    public static Point operator +(Point p1, int value)    &#x2F;&#x2F;public static 返回类型 operator 运算符(参数列表)    &#123;        Point p &#x3D; new Point();        p.x &#x3D; p1.x + value;        p.y &#x3D; p1.y + value;        return p;    &#125;&#125;internal class Program&#123;    static void Main(string[] args)    &#123;        Point p1 &#x3D; new Point();        p1.x &#x3D; 1;        p1.y &#x3D; 1;        Point p2 &#x3D; new Point();        p2.x &#x3D; 2;        p2.y &#x3D; 2;        Point p3 &#x3D; p1 + p2;        Console.WriteLine(&quot;(&#123;0&#125;,&#123;1&#125;)&quot;, p3.x, p3.y);        Point p4 &#x3D; p3 + 2; &#x2F;&#x2F;顺序不能错 一定是先Point类,再int类        Console.WriteLine(&quot;(&#123;0&#125;,&#123;1&#125;)&quot;, p4.x, p4.y);    &#125;&#125;</code></pre></div><h2 id="可重载和不可重载的运算符"><a href="#可重载和不可重载的运算符" class="headerlink" title="可重载和不可重载的运算符"></a>可重载和不可重载的运算符</h2><h3 id="可重载运算符"><a href="#可重载运算符" class="headerlink" title="可重载运算符"></a>可重载运算符</h3><p><strong>算术运算符</strong></p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">+ - * &#x2F; %  ++ --注意: 符号需要两个参数还是一个参数</code></pre></div><p><strong>逻辑运算符</strong></p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;!(逻辑非) &#x2F;&#x2F;注意： &amp;&amp;(逻辑与)和||(逻辑或)不允许重载</code></pre></div><p><strong>位运算符</strong></p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">| &amp; ^ ~ &lt;&lt; &gt;&gt;&#x2F;&#x2F;注意: 符号需要两个参数还是一个参数</code></pre></div><p><strong>条件运算符</strong></p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;&gt; &lt; &#x3D;&gt; &lt;&#x3D; &#x3D;&#x3D; !&#x3D;&#x2F;&#x2F;注意：&#x2F;&#x2F;1.返回值一般是bool值，也可以是其他的&#x2F;&#x2F;2.相关符号必须配对实现(实现了&gt;，就要同时实现&lt;)</code></pre></div><h3 id="不可重载运算符"><a href="#不可重载运算符" class="headerlink" title="不可重载运算符"></a>不可重载运算符</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;逻辑与  &amp;&amp; &#x2F;&#x2F;逻辑或  || &#x2F;&#x2F;索引符  [] &#x2F;&#x2F;强转运算符  () &#x2F;&#x2F;    特殊运算符：&#x2F;&#x2F;    点  .   &#x2F;&#x2F;    三目运算符  ? :   &#x2F;&#x2F;    赋值符号  &#x3D;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/13/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson10_运算符重载&#123;    class Vector2    &#123;        public int x;        public int y;        &#x2F;&#x2F;重载&#x3D;&#x3D;号        public static bool operator &#x3D;&#x3D;(Vector2 v1, Vector2 v2)        &#123;            return v1.x &#x3D;&#x3D; v2.x &amp;&amp; v1.y &#x3D;&#x3D; v2.y;        &#125;        public static bool operator !&#x3D;(Vector2 v1, Vector2 v2)        &#123;            return !(v1.x &#x3D;&#x3D; v2.x &amp;&amp; v1.y &#x3D;&#x3D; v2.y);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Vector2 v1 &#x3D; new Vector2();            v1.x &#x3D; 1;            v1.y &#x3D; 1;            Vector2 v2 &#x3D; new Vector2();            v2.x &#x3D; 1;            v2.y &#x3D; 1;            Console.WriteLine(v1 &#x3D;&#x3D; v2);             &#125;    &#125;&#125;</code></pre></div><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson10_运算符重载&#123;    class Vector3    &#123;        public int x;        public int y;        public int z;        &#x2F;&#x2F;重载&#x3D;&#x3D;号        public static Vector3 operator +(Vector3 v1, Vector3 v2)        &#123;            Vector3 v &#x3D; new Vector3();            v.x &#x3D; v1.x + v2.x;            v.y &#x3D; v1.y + v2.y;            v.z &#x3D; v1.z + v2.z;            return v;        &#125;        public static Vector3 operator -(Vector3 v1, Vector3 v2)        &#123;            Vector3 v &#x3D; new Vector3();            v.x &#x3D; v1.x - v2.x;            v.y &#x3D; v1.y - v2.y;            v.z &#x3D; v1.z - v2.z;            return v;        &#125;        public static Vector3 operator *(Vector3 v1, int num)        &#123;            Vector3 v &#x3D; new Vector3();            v.x &#x3D; v1.x * num;            v.y &#x3D; v1.y * num;            v.z &#x3D; v1.z * num;            return v;        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Vector3 v1 &#x3D; new Vector3();            v1.x &#x3D; 1;            v1.y &#x3D; 1;            v1.z &#x3D; 1;            Vector3 v2 &#x3D; new Vector3();            v2.x &#x3D; 2;            v2.y &#x3D; 3;            v2.z &#x3D; 4;            int num &#x3D; 8;            Vector3 v3 &#x3D; v1 + v2;            Vector3 v4 &#x3D; v2 - v1;            Vector3 v5 &#x3D; v2 * num;            Console.WriteLine(&quot;(&#123;0&#125;,&#123;1&#125;,&#123;2&#125;)&quot;, v3.x, v3.y, v3.z);            Console.WriteLine(&quot;(&#123;0&#125;,&#123;1&#125;,&#123;2&#125;)&quot;, v4.x, v4.y, v4.z);            Console.WriteLine(&quot;(&#123;0&#125;,&#123;1&#125;,&#123;2&#125;)&quot;, v5.x, v5.y, v5.z);        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月13日</title>
    <link href="/2022/05/13/diary/2022.5/2022%E5%B9%B45%E6%9C%8813%E6%97%A5/"/>
    <url>/2022/05/13/diary/2022.5/2022%E5%B9%B45%E6%9C%8813%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="fbbcf625d92544d5df3d44ac542131102feb9fbd15ca0852893ab5901da2fb32">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe506e3bbc3039a6aa643d94bba3c0a5944c3000ff7fa000df3927de73467607197ccec9c66374b92e0f81e072804d501535ac8a7eee38888c5007151c617ed82a1c690e4dc1ef4fb47045f82e89006f717a7fb19e7fefab38085a7c62a562c58058bf9d677ec961e8e15822a354247ec0e624c42d79405ffe28ce71a51aacae688bb936e022fecfb2ecfc36563a50b5f41e97ba7f934c2ca7f5542947fb8d4a938ae8944e924ee5988f12041e8d0a3d134c4a4682d64469a108efbd6aa9dcff6427a92707e97e5beffd53d975af6795abf99626a3245a0775a6b35f8ed7fb4bfa3f30463a3dba02cc1ee1c56eefbc194d89d375241ac45a8092772f7db8b0384232e7162edb46f6c33c653599b2a8128c2e5d223148acbe13645425ee432503346889e5e855cfd087ec0bc1b7b454da62c9a90b1fc994336a1cbc735840d8c98ee5c179c40db6109dbb0c123c5888ddfbe715d767a27721a0bbb9ee40f78c73cff0ee758852160fce56837f4a32e03a7ae9e7b3398acb7478f0a4bf9d7a7c7f1ae3cab150d6706b3859ddac575996a5721ffd7b3930bde3c123bba298a1c6fa98fface1bd4ed49ec04c0241982205786343795dd0482c0d4c80b5691109ca44c4b07d3185f743ec26540bb02060a8126e26f279136fa6f1c74ed4bc41e95b9e434537275a52003e00fd238ef9cb11ea6d459f4c21295d76ab8eebd82be04c1a8d2ef5c46043ff2055d7a45099e20ba75faaf138b11b17b64d0a4b28ba720dca9f1ba7ce739caa825bb45f67b2640ba0abb60d53b70937bdc4bf79f7d76e32dc7fbc0dd50acb69f5af9b7b94b60d5177c23cb9efa1340dc928b561ed3148271b6d878faf99333dbaa728d3faca0d734dc24fd63928bca1d918a25f3f1ff289ba1b2d4a3009ebb7d9d6b6bb8b11792514e5961223a2f8a7c6aa0de8a4073023b171622416a26a79947fa1dd6a4d9c885223d70a243a9e8417c84b7db48fcbf5dfdadc</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拓展方法</title>
    <link href="/2022/05/12/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95/"/>
    <url>/2022/05/12/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>拓展方法</p><span id="more"></span><h1 id="拓展方法"><a href="#拓展方法" class="headerlink" title="拓展方法"></a>拓展方法</h1><p><strong>基本概念：</strong><br>为现有<strong>非静态</strong>的变量类型 添加新方法</p><p><strong>作用：</strong><br>1.提升程序拓展性<br>2.不需要在对象中重新写方法<br>3.不需要继承来添加方法<br>4.为别人封装的类型写额外的方法</p><p><strong>特点：</strong><br>1.一定是写在静态类中<br>2.一定是一个静态函数<br>3.第一个参数为拓展目标<br>4.第一个参数用this修饰</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;声明static class Tools&#123;    &#x2F;&#x2F;访问修饰符 static 返回值 函数名(this 拓展类名 参数名, 参数类型 参数名, 参数类型 参数名, ......)    public static void SpeakValue(this int value)    &#x2F;&#x2F;为int拓展了一个成员方法    &#x2F;&#x2F;成员方法 是需要实例化对象后 才能使用的    &#x2F;&#x2F;value 代表使用该方法的 实例化对象    &#123;        &#x2F;&#x2F;拓展的方法的逻辑        Console.WriteLine(&quot;为int拓展的方法&quot; + value);    &#125;    public static void SpeakStringInfo(this string str, string str2, string str3)    &#x2F;&#x2F;为string拓展了一个成员方法    &#x2F;&#x2F;str 代表使用该方法的 实例化对象    &#x2F;&#x2F;str2, str3 代表传进去的参数    &#123;        Console.WriteLine(&quot;为string拓展的方法&quot;);        Console.WriteLine(&quot;调用方法的对象&quot; + str);        Console.WriteLine(&quot;传的参数&quot; + str2 + str3);    &#125;&#125;&#x2F;&#x2F;使用internal class Program&#123;    static void Main(string[] args)    &#123;        &#x2F;&#x2F;i就是int这一拓展类 实例化的对象        int i &#x3D; 10;        i.SpeakValue();        &#x2F;&#x2F;str就是string这一拓展类 实例化的对象        string str &#x3D; &quot;000&quot;;        str.SpeakStringInfo(&quot;111&quot;, &quot;222&quot;);    &#125;&#125;</code></pre></div><h2 id="为自定义的类型拓展方法"><a href="#为自定义的类型拓展方法" class="headerlink" title="为自定义的类型拓展方法"></a>为自定义的类型拓展方法</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;声明static class Tools&#123;    public static void Fun3(this Test t)    &#x2F;&#x2F;为Test类的t拓展了一个成员方法    &#123;        Console.WriteLine(&quot;为test拓展的方法&quot;);    &#125;&#125;class Test&#123;    public int i &#x3D; 10;    public void Fun1()    &#123;        Console.WriteLine(&quot;123&quot;);    &#125;    public void Fun2()    &#123;        Console.WriteLine(&quot;456&quot;);    &#125;&#125;&#x2F;&#x2F;使用internal class Program&#123;    static void Main(string[] args)    &#123;        Test t &#x3D; new Test();        t.Fun3();    &#125;&#125;</code></pre></div><p><strong>注意：</strong><br>拓展方法名若和原有方法名相同，会默认使用原有方法名</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/12/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson9_拓展方法&#123;    &#x2F;&#x2F;为整形拓展一个求平方的方法    static class Tools    &#123;        &#x2F;&#x2F;平方返回值int        public static int Square(this int value)        &#123;            return value * value;        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Console.Write(&quot;请输入一个整数：&quot;);            int i &#x3D; int.Parse(Console.ReadLine());            Console.WriteLine(&quot;它的平方是&#123;0&#125;&quot;, i.Square());        &#125;    &#125;&#125;</code></pre></div><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson9_拓展方法&#123;    &#x2F;&#x2F;声明一个玩家类    &#x2F;&#x2F;因为没写敌人，逻辑写的简单点    class Player    &#123;        public string Name &#123; get; set; &#125;        public int Hp &#123; get; set; &#125;        public int Atk &#123; get; set; &#125;        public int Def &#123; get; set; &#125;        &#x2F;&#x2F;攻击方法        public void Attack()        &#123;            &#x2F;&#x2F;攻击能提升气势，增加攻击力            Atk +&#x3D; 1;        &#125;        &#x2F;&#x2F;移动方法        public void Move()        &#123;            &#x2F;&#x2F;移动就会找到宝箱打开，要么获得武器，要么获得防具            Random r &#x3D; new Random();            &#x2F;&#x2F;一半概率为武器            if(r.Next(1, 101) &lt;&#x3D; 50)            &#123;                Atk +&#x3D; 50;            &#125;            &#x2F;&#x2F;一半概率为防具            else            &#123;                Def +&#x3D; 50;            &#125;        &#125;        &#x2F;&#x2F;受伤方法        public void Injured()        &#123;            &#x2F;&#x2F;受伤掉5血            Hp -&#x3D; 5;        &#125;    &#125;    &#x2F;&#x2F;为玩家拓展一个自杀的方法    static class Tools    &#123;        public static void Suicide(this Player p)        &#123;            p.Hp &#x3D; 0;        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Player p &#x3D; new Player();            p.Name &#x3D; &quot;大逼&quot;;            p.Hp &#x3D; 100;            p.Atk &#x3D; 10;            p.Def &#x3D; 10;            p.Attack();            p.Move();            p.Injured();            if(p.Hp &gt; 0)            &#123;                Console.WriteLine(&quot;&#123;0&#125;现在的状态为血量&#123;1&#125;,攻击力&#123;2&#125;,防御力&#123;3&#125;&quot;, p.Name, p.Hp, p.Atk, p.Def);            &#125;            else if (p.Hp &lt;&#x3D; 0)            &#123;                Console.WriteLine(&quot;&#123;0&#125;已死亡&quot;, p.Name);            &#125;            p.Suicide();            if (p.Hp &gt; 0)            &#123;                Console.WriteLine(&quot;&#123;0&#125;现在的状态为血量&#123;1&#125;,攻击力&#123;2&#125;,防御力&#123;3&#125;&quot;, p.Name, p.Hp, p.Atk, p.Def);            &#125;            else if (p.Hp &lt;&#x3D; 0)            &#123;                Console.WriteLine(&quot;&#123;0&#125;已死亡&quot;, p.Name);            &#125;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>静态类和静态构造函数</title>
    <link href="/2022/05/12/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E9%9D%99%E6%80%81%E7%B1%BB%E5%92%8C%E9%9D%99%E6%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <url>/2022/05/12/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E9%9D%99%E6%80%81%E7%B1%BB%E5%92%8C%E9%9D%99%E6%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>静态类和静态构造函数</p><span id="more"></span><h1 id="静态类和静态构造函数"><a href="#静态类和静态构造函数" class="headerlink" title="静态类和静态构造函数"></a>静态类和静态构造函数</h1><h2 id="静态类"><a href="#静态类" class="headerlink" title="静态类"></a>静态类</h2><p><strong>基本概念：</strong><br>用static修饰的类</p><p><strong>特点：</strong><br>1.只能包含静态成员<br>2.不能被实例化</p><p><strong>作用：</strong><br>1.将常用的静态成员写在静态类中 方便使用<br>2.静态类不能被实例化，更能体现工具性、唯一性<br>    Console就是一个静态类</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">static class TestStatic&#123;    &#x2F;&#x2F;静态成员变量    public static int testIndex &#x3D; 0;    public static void TestFun()    &#123;    &#125;     public static int TestIndex()    &#123;        get;        set;    &#125; </code></pre></div><h2 id="静态构造函数"><a href="#静态构造函数" class="headerlink" title="静态构造函数"></a>静态构造函数</h2><p><strong>基本概念：</strong><br>在构造函数前加上 static 修饰</p><p><strong>特点：</strong><br>1.静态类和普通类都可以有<br>2.不能使用访问修饰符<br>3.不能有参数<br>4.只会自动调用一次</p><p><strong>作用：</strong><br>在静态构造函数中初始化 静态变量</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;静态类中的静态构造函数static class StaticClass&#123;    public static int testInt &#x3D; 100;    public static int testInt2 &#x3D; 100;    static StaticClass()    &#123;        &#x2F;&#x2F;只会在初次使用的时候 调用一次        Console.WriteLine(&quot;静态构造函数&quot;);        testInt &#x3D; 200;        testInt2 &#x3D; 200;    &#125; &#125;&#x2F;&#x2F;普通类中的静态构造函数class Test&#123;    public static int testInt &#x3D; 200;    static Test()    &#123;        Console.WriteLine(&quot;静态构造&quot;);    &#125;    &#x2F;&#x2F;这不是重载 这是两个不同的函数    public Test()    &#123;        Console.WriteLine(&quot;普通构造&quot;);    &#125;&#125;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/12/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E9%9D%99%E6%80%81%E7%B1%BB%E5%92%8C%E9%9D%99%E6%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/exam.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson8_静态类和静态构造函数&#123;    &#x2F;&#x2F;数学计算静态类    static class Calc    &#123;        public static float PI &#x3D;3.145926f;        &#x2F;&#x2F;计算圆的面积        public static float CircleS(int r)        &#123;            return PI * r * r;        &#125;        &#x2F;&#x2F;计算圆的周长        public static float CircleL(int r)        &#123;            return PI * r * 2;        &#125;        &#x2F;&#x2F;计算矩形的面积        public static float RectangleS(int l, int w)        &#123;            return l * w;        &#125;        &#x2F;&#x2F;计算矩形的周长        public static float RectangleL(int l, int w)        &#123;            return 2 * (l + w);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;半径为3的圆面积是&#123;0&#125;&quot;, Calc.CircleS(3));            Console.WriteLine(&quot;半径为3的圆周长是&#123;0&#125;&quot;, Calc.CircleL(3));            Console.WriteLine(&quot;长为3宽为3的矩形面积是&#123;0&#125;&quot;, Calc.RectangleS(3, 3));            Console.WriteLine(&quot;长为3宽为3的矩形周长是&#123;0&#125;&quot;, Calc.RectangleL(3, 3));        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月12日</title>
    <link href="/2022/05/12/diary/2022.5/2022%E5%B9%B45%E6%9C%8812%E6%97%A5/"/>
    <url>/2022/05/12/diary/2022.5/2022%E5%B9%B45%E6%9C%8812%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="47086273676309be83d13ebf8531401cb49a8ccdda44fe7c8408cdc31541cc67">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50d4c0829a8a79ea3b44ecdd1bc8d55452e14aee12c337910927f5586d86733e9c3714b8aa46a90f5ded03e2919eb7614b695a0defcfad29d72d9fcfb60b9a437a5403c1eeec2e3e33f690b3cdb7fe7ae97b097ece43cf2a91a788c9800b918b96c17dd030ffe3e2ee254e2ac8f2f59236a40efc463d7d1d719a71e712b95464d87f3e14cbaee92305d40e4e481607d532adcec9cadd867b270ddef2ed9b5ad73363f75850d84bf94087e64271ad395f78ec0294fcadb5807d41320f2c5a4fc76630450a90fceff0a9351a1edd839bf9c49a772721b3e6b99aa6c4a0bc89feb62302d8cfc53da2668d8273ddc4b64c745112fe1a8e8a6b8f1d4d122b8208c876f98422264e038d11aa0a4704699e55c8ae5cd539cb0d194fbf458de5ec565a98404dd22f79e5625560e96e5da2e55ba40ee78a6d266d650e4a3ba21d1185e923a86bc36f92c6102984f06fc7f47e7dabdb159291fcda490e00e5c7d3e3de468a28a65248959ee48c271e2d95d3f58bae3c4cb98b0c911c8e707dd25c217de9097a64b34a6284a9f65441a293f4916d0ed9b3b4cf2f4056225d69dd940d84056c84aabe61a6ca24c348e4dd1b5d93e781206a6d3f90eb452b423afbd1cd04e4dfcddc793b67a9c86f5e917d82589608211d35814276204742e06b492502b2ae227732d578d7d7978ead2bfdfdab2db230d0ecec5474b7dfc27f8d082b62b0eebae1092b70feb859c5aad66ef15c180e012c3a5a375f4673be58ee2044af07f50fef</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>静态成员</title>
    <link href="/2022/05/11/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/"/>
    <url>/2022/05/11/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/</url>
    
    <content type="html"><![CDATA[<p>静态成员</p><span id="more"></span><h1 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>基本关键字： static<br>用static修饰的成员变量、方法、属性等的成为静态成员</p><p>特点：直接用类名点出使用<br>Console就是一个静态类</p><h2 id="声明静态成员变量-及-使用"><a href="#声明静态成员变量-及-使用" class="headerlink" title="声明静态成员变量 及 使用"></a>声明静态成员变量 及 使用</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Test&#123;    &#x2F;&#x2F;public和static 前后无所谓    public static float PI &#x3D; 3.1415926f;    &#x2F;&#x2F;成员变量    public int testInt &#x3D; 100;    &#x2F;&#x2F;静态成员方法    public static float CalcCricle(float r)    &#123;        return PI * r * r;    &#125;    &#x2F;&#x2F;普通成员方法    public void TestFun()    &#123;        Console.WriteLine(&quot;123&quot;);    &#125;&#125;internal class Program&#123;    static void Main(string[] args)    &#123;        &#x2F;&#x2F;类名.静态成员变量  不需要实例化        Console.WriteLine(Test.PI);        Console.WriteLine(Test.CalcCricle(2));    &#125;&#125;</code></pre></div><h2 id="为什么可以直接点出来使用"><a href="#为什么可以直接点出来使用" class="headerlink" title="为什么可以直接点出来使用"></a>为什么可以直接点出来使用</h2><p><strong>程序中是不能无中生有的</strong><br>需要使用的对象，变量，函数都是要在内存中分配内存空间的<br>之所以要实例化对象，目的就是分配内存空间，在程序中产生一个抽象的对象</p><p><strong>静态成员的特点</strong><br>程序开始运行时，就会分配内存空间，得以直接使用<br>静态成员和程序是同生共死的<br>只要使用了它，知道程序结束时才会被释放<br>所以一个静态成员就会有自己唯一的一个“内存小房间”<br>这让静态成员就有了唯一性<br>在任何地方使用都是用的小房间里的内容，改变了它也是改变小房间里的内容</p><h2 id="静态函数非静态成员-x2F-非静态函数静态成员"><a href="#静态函数非静态成员-x2F-非静态函数静态成员" class="headerlink" title="静态函数非静态成员&#x2F;非静态函数静态成员"></a>静态函数非静态成员&#x2F;非静态函数静态成员</h2><p>成员变量只能将对象实例化出来后，才能点出来使用，不能无中生有<br>不能直接使用非静态函数，否则会报错<br><strong>静态函数中不可以直接使用非静态成员</strong><br><strong>非静态函数中可以直接使用静态成员</strong></p><h2 id="静态成员对于我们的作用"><a href="#静态成员对于我们的作用" class="headerlink" title="静态成员对于我们的作用"></a>静态成员对于我们的作用</h2><p>静态变量：<br>1.常用唯一变量的声明<br>2.方便别人获取的对象声明</p><p>静态方法：<br>常用的唯一的方法声明<br>比如：相同规则的数学计算相关函数</p><h2 id="常量和静态变量"><a href="#常量和静态变量" class="headerlink" title="常量和静态变量"></a>常量和静态变量</h2><p>const 可以理解为特殊的 static<br><strong>相同点：</strong><br>他们都可以通过类名.点出使用<br><strong>不同点：</strong><br>1.const必须初始化，不能修改; static没有这个规则<br>2.const只能修饰变量; static可以修饰很多(成员方法等)<br>3.const一定是写在访问修饰符后面的(3P后面); static没有这个要求</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/11/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><p>const与static<br><strong>相同点：</strong><br>他们都可以通过类名.点出使用<br><strong>不同点：</strong><br>1.const必须初始化，不能修改; static没有这个规则<br>2.const只能修饰变量; static可以修饰很多(成员方法等)<br>3.const一定是写在访问修饰符后面的(3P后面); static没有这个要求</p><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson7_静态成员&#123;    class Sign    &#123;        static public float PI &#x3D; 3.1415926f;     &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Console.WriteLine(Sign.PI);        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月11日</title>
    <link href="/2022/05/11/diary/2022.5/2022%E5%B9%B45%E6%9C%8811%E6%97%A5/"/>
    <url>/2022/05/11/diary/2022.5/2022%E5%B9%B45%E6%9C%8811%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="be939b2d46b025fbe51dda7ebc66eb6271595024478834df5326db5e8a7da3dc">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50fdd0ca3edc57389bd0e88084b7db20234fb2de3fa3c9a49542ad620f534d4c6e8804b5584cdb8a3a926d0211e1b7b90f05911c848b71e690820b0e3332e95fad55a6e09296d83f6fd1172e898d38e42fc5120c6e43033e1dc9c18617ad7dba07711204ac566923a7a8304d26e7a85f0d4ab1f4723f9f438238aa5ddac250ed8355d8d3527506f07dfd520b6167bebf871cf18cdd5cf564666be28c4440538f6f79d479958ef3a03f075fe85795cf78c2c12fcc4efa9a49164816d35a9b6372411d9d299dbcc975918b4d7c4da0b245618bab46a297ced7f824309379cc6a17c9aaa6ef3479e43de57e395a27f79b202c193ed0f2be4867cada9a531d21b90b143b1236b0844635a44489d87b697751a511078032a4b7a8fd536a48b596443d23263e3caa7dd54296e15e800906aaa59cfc8e3f00c155bfa37c4ec958a344d1a9679ef17acc595fbeaa39efda24bb6f3a1dde15ba83d0a37cdcfe54f0fc73c6df01b31a90e0fe630e2e12e91d51c77b28f2910f789c5ec86ccd159ae101df43b862dc109a5349722974f72ad943e4c063bc0915fd0832cef7177d7db854a03be58765284c7dce461b8794b9351c6a095b652363351b8e51bd5c6ee525d89e2495d22e1cf1836d8adce598bd290ab8ed8db3faa0a832330ec53822a8cdeabc004a08f534bebdb18aa4c9fd05091dc25187b765091a6af31af5c55cf0cb9c93bd5681fd881235835189265394eeba7d97dd000f1440b6f12fd081a16140c65edc561244f3fa16c584e4e06a5311ab55eebaf19f8c95ee5d640f2887b9ba44b828f3e4237a8b0526729dc9ba67f983f6699337100b0f7fcdbda2a778b1a3dcc5124d6cfbfbb4df9fc1f89d4e359b63bbf8ec80e0fec225b24507cef06a04aa25d7df615b83c5a78caa61402d182e95f9dee72067b1a81afbbb8cbb7045cd7b02445b069008912a6330aedccae24a60475f9ce24c741d5d09366a6472c21e6c65d882b774b2508ca4f85ba854a7199b591093e5946691cd81fb86b491ef34fc95df39ffb5a513764716585dfd60a7bc577c7ce0579ea76b8bf34b866e164d431d6acb2fdc68eb6825257097c80a492fffb411487e4bba652cc0d340dd72ca4e6b2dace8000a7a4dc784f4ecd633bb3b24ade405ae5b499deae99c18b039fc774cdcc825a4b83d59e4a555f60dfaaa69fd211a5c91ae0b15021bf6426ee07b3ac4eff79054ac0153db9710165013fc0b35cc46a6dba8d5b9fce00406d8212b86b4098f431390d59c7cb0e1c19e7289b001b2d334b128771862514bbfc9c12adc676b4f80abc66d81a163786912f2f1f4e7afc23197f74aef80ed5ee42f50ef28bcbe978d9833ac30a2b8c111dc712634d829e8942dfb81d23bd77661e442cde919e1a298a3c891fd14f474b9cb57d809901de545d228c545b46f7d97f7b9f445bca7ecd6b3f3d39f5bc94e8578caa87644f54d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>索引器</title>
    <link href="/2022/05/11/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E7%B4%A2%E5%BC%95%E5%99%A8/"/>
    <url>/2022/05/11/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E7%B4%A2%E5%BC%95%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>索引器</p><span id="more"></span><h1 id="索引器"><a href="#索引器" class="headerlink" title="索引器"></a>索引器</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>让对象可以像数组一样通过索引访问其中元素<br>使程序看起来更直观，更容易编写</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Person&#123;    private string name;    private int age;    private Person[] friends;    &#x2F;&#x2F;访问修饰符 返回值 this[参数类型 参数名, 参数类型 参数名, ......]    public Person this[int index]    &#123;        get        &#123;            return friends[index];        &#125;        set        &#123;            friends[index] &#x3D; value;        &#125;    &#125;&#125;</code></pre></div><h2 id="索引器的使用"><a href="#索引器的使用" class="headerlink" title="索引器的使用"></a>索引器的使用</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Person p &#x3D; new Person();p[0] &#x3D; new Person();</code></pre></div><h2 id="索引器中可以写逻辑"><a href="#索引器中可以写逻辑" class="headerlink" title="索引器中可以写逻辑"></a>索引器中可以写逻辑</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Person&#123;    private string name;    private int age;    private Person[] friends;    public Person this[int index]    &#123;        get        &#123;            if(friends &#x3D;&#x3D; null ||                friends.Length - 1 &lt; index)            &#123;                return null;            &#125;            return friends[index];        &#125;        set        &#123;            if(friends &#x3D;&#x3D; null)            &#123;                friends &#x3D; new Person[] &#123; value &#125;;            &#125;            else if(index &gt; friends.Length - 1)            &#123;                &#x2F;&#x2F;自己定了一个规则 如果索引越界 就默认把最后一个朋友顶掉                friends[friends.Length - 1] &#x3D; value;            &#125;            friends[index] &#x3D; value;        &#125;    &#125;&#125;</code></pre></div><h2 id="索引器可以重载"><a href="#索引器可以重载" class="headerlink" title="索引器可以重载"></a>索引器可以重载</h2><p>重载的概念是：函数名相同，参数类型、数量、顺序不同</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Person&#123;    private string name;    private int age;    private Person[] friends;    private int[,] array;    &#x2F;&#x2F;重载this    public int this[int i, int j]    &#123;        get        &#123;            return array[i, j];        &#125;        set        &#123;            array[i, j] &#x3D; value;        &#125;    &#125;    public int this[string str]    &#123;        get        &#123;            switch(str)            &#123;                case &quot;name&quot;:                    return this.name;                case &quot;age&quot;:                    return age.ToString();            &#125;            return &quot;&quot;;        &#125;    &#125;    public Person this[int index]    &#123;        get        &#123;            return friends[index];        &#125;        set        &#123;            friends[index] &#x3D; value;        &#125;    &#125;&#125;</code></pre></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>索引器的作用：<br>1.以中括号的形式访问自定义类中的元素<br>2.规则自己定，访问时与数组相同<br>3.比较适用于，在类中有数组变量时使用，可以方便地访问和进行逻辑处理</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/11/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E7%B4%A2%E5%BC%95%E5%99%A8/exam.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson6_索引器&#123;    class Num    &#123;        private int[] number &#x3D; new int[5];        &#x2F;&#x2F;用索引器由外部定义数组        public int this[int index]        &#123;            get            &#123;                return number[index];            &#125;            set            &#123;                number[index] &#x3D; value;            &#125;        &#125;        &#x2F;&#x2F;增        public void Add(Num arr, int num)        &#123;            int[] number1 &#x3D; new int[arr.number.Length + 1];            for (int i &#x3D; 0; i &lt; arr.number.Length; i++)            &#123;                number1[i] &#x3D; arr.number[i];            &#125;            number1[number.Length] &#x3D; num;            arr.number &#x3D; number1;            &#x2F;&#x2F;因为number数组是private类型 只能在类内直接打印            for (int i &#x3D; 0; i &lt; arr.number.Length; i++)            &#123;                Console.WriteLine(arr.number[i]);            &#125;        &#125;        &#x2F;&#x2F;查        public int Search(Num arr, int num)        &#123;            &#x2F;&#x2F;暴力遍历寻找            for (int i &#x3D; 0; i &lt; arr.number.Length; i++)            &#123;                if(arr.number[i] &#x3D;&#x3D; num)                &#123;                    &#x2F;&#x2F;找到输出位置                    return i;                &#125;            &#125;            &#x2F;&#x2F;找不到输出-1            return -1;        &#125;        &#x2F;&#x2F;删        public void Del(Num arr, int num)        &#123;                 if(arr.Search(arr, num) !&#x3D; -1)            &#123;                for (int i &#x3D; arr.Search(arr, num); i &lt; arr.number.Length - 1; i++)                &#123;                    arr.number[i] &#x3D; arr.number[i + 1];                &#125;                arr.number[arr.number.Length - 1] &#x3D; 0;                Console.WriteLine(&quot;删除成功&quot;);             &#125;            else            &#123;                Console.WriteLine(&quot;没有您想要删的数，删除失败&quot;);            &#125;        &#125;        &#x2F;&#x2F;改  num1改成num2        public void Change(Num arr, int num1, int num2)        &#123;            if (arr.Search(arr, num1) !&#x3D; -1)            &#123;                arr.number[arr.Search(arr, num1)] &#x3D; num2;                Console.WriteLine(&quot;修改成功&quot;);            &#125;            else            &#123;                Console.WriteLine(&quot;没有您想要改的数，修改失败&quot;);            &#125;        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            &#x2F;&#x2F;初始化数组            Num arr &#x3D; new Num();            arr[0] &#x3D; 1;            arr[1] &#x3D; 15;            arr[2] &#x3D; 8;            arr[3] &#x3D; 11;            arr[4] &#x3D; 7;            &#x2F;&#x2F;增            arr.Add(arr, 9);            &#x2F;&#x2F;删            arr.Del(arr, 1);            arr.Del(arr, 10);            &#x2F;&#x2F;查            int n &#x3D; int.Parse(Console.ReadLine());            Console.WriteLine(&quot;您想找的数&#123;0&#125;在数组的第&#123;1&#125;位&quot;, n, arr.Search(arr, n) + 1);            &#x2F;&#x2F;改            arr.Change(arr, 9, 66);        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月10日</title>
    <link href="/2022/05/10/diary/2022.5/2022%E5%B9%B45%E6%9C%8810%E6%97%A5/"/>
    <url>/2022/05/10/diary/2022.5/2022%E5%B9%B45%E6%9C%8810%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="2ddfa4cdb3dfb32c5fbb8b9cfd6b6cc0eb8d56c4388893dc14dc7b42bd66d8f9">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50dc870b27b76d3b90c48267d59720f330ba0b7dd5ba881f78758bd2db60f83bb0d35cfaad6b2af34092909565a0195bbaf9ddf7e87d31f7e3c318a88e076cd535bc3fd7aef531751c0f5540593857d91bf4f4f42c93a1a325bb77fdff723b1d82ed1ac68e49f561d1a5093b552d4a42666b95c0a5c9d743ebb28ae48ca585f01534d411ce08eef72296f210475df0ca550c05b75f3c1eb74f226d6af71c454bb96a1aba1e58da61afaf8eeaf2907d94fa1e9555a3792ff62334f2a9eaf61c3f027ffed6813cadc0399eadfea2b935a68335d58afe75057d7614f357a4212eef2dc3774a8c9201fdfb665652c7acd463739060ae2cbe6ad90601a3d58a244f934fbe883f30bbb93ef033c2d58595bdc82c7d8306797e04393478f4eb5c9fd1ceca96044ac94374ae50576701164e85cd1f916154344e38cecb6ac6f9b89f2b76e37a32944ade07db98218ed0d4b88aec24ec0bb24f5854b591864e532171f4507fd5db68ed4e036a915717798e230bc24358f992ef8ba87fc956fbf188a8b78eedc631939617f9a1d4a331c792ef8a623914ce541812bcc59cce1dca10cba76641c18337cbe782ff0c553e2ab7c304d7aff49827b2585c8d20568ab64e66294d9f7701d7d4b269f79f2aae01584a72ff7c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>成员属性</title>
    <link href="/2022/05/10/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7/"/>
    <url>/2022/05/10/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>成员属性</p><span id="more"></span><h1 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>1.用于保护成员变量<br>2.为成员属性的获取和赋值添加逻辑处理<br>3.解决3P的局限性<br>    public - 内外访问<br>    private - 内部访问<br>    protected - 内部和子类访问<br>属性可以让成员变量在外部 <strong>只能获取不能修改</strong> 或 <strong>只能修改不能获取</strong></p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Person&#123;    private string name;    &#x2F;&#x2F;属性的命名一般使用 帕斯卡命名法    &#x2F;&#x2F;访问修饰符 属性类型 属性名    public string Name    &#123;        get        &#123;            &#x2F;&#x2F;可以在返回前添加一下逻辑规则（解密）            &#x2F;&#x2F;get意味着这个属性可以获取的内容 需要return内容            return name;        &#125;        set        &#123;            &#x2F;&#x2F;可以在设置前添加一下逻辑规则（加密）            &#x2F;&#x2F; value 关键字 用于表示外部传入的值            name &#x3D; value;                         &#125;    &#125;&#125;  </code></pre></div><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Person p &#x3D; new Person();p.Name &#x3D; &quot;季宝&quot;;</code></pre></div><h2 id="get和set前可以加访问修饰符"><a href="#get和set前可以加访问修饰符" class="headerlink" title="get和set前可以加访问修饰符"></a>get和set前可以加访问修饰符</h2><p><strong>解决3P局限性</strong><br>1.默认不加 会使用属性声明时的访问权限<br>2.加的访问修饰符要低于属性的访问权限（public的访问权限是最高级的）<br>3.不能让get和set的访问权限都低于属性的权限（逻辑上外部的访问修饰符无效，报错）</p><h2 id="get和set只能有一个"><a href="#get和set只能有一个" class="headerlink" title="get和set只能有一个"></a>get和set只能有一个</h2><p>只有一个时 没有必要在前面加访问修饰符<br>且一般只有get 没有set</p><h2 id="自动属性"><a href="#自动属性" class="headerlink" title="自动属性"></a>自动属性</h2><p>属性语句块中只有get和set<br><strong>作用：</strong><br>外部能得不能改的特征<br>如果类中有一个特征是只希望外部能得不能改的 又没有什么特别处理<br>那么可以直接使用自动属性</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Person&#123;    private Height;    &#x2F;&#x2F;不用专门去声明成员变量 直接通过属性来表示特殊的成员变量    public float Height    &#123;        &#x2F;&#x2F;没有在get和set中写逻辑的需求或者想法        get;        set;    &#125;    &#x2F;&#x2F;等价于    public float Height &#123; get; set; &#125;&#125;  </code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/10/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7/exam.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson5_成员属性&#123;    class Student    &#123;        private string name;        private string sex;        private int age;        private int csharpScore;        private int unityScore;        public string Name &#123; get; set; &#125;        public string Sex         &#123;             get            &#123;                if (sex !&#x3D; &quot;男&quot; &amp;&amp; sex !&#x3D; &quot;女&quot;)                &#123;                    Console.WriteLine(&quot;请输入正确的性别,默认男&quot;);                    return &quot;男&quot;;                &#125;                else                &#123;                    return sex;                &#125;                            &#125;            set            &#123;                sex &#x3D; value;            &#125;        &#125;        public int Age         &#123;             get            &#123;                return age;                &#125;            set            &#123;                if (value &gt;&#x3D; 0 &amp;&amp; value &lt;&#x3D; 150)                &#123;                    age &#x3D; value;                &#125;                else                &#123;                    Console.WriteLine(&quot;请输入0~150之间的年龄,默认20&quot;);                    age &#x3D; 20;                &#125;               &#125;        &#125;        public int CSharpScore        &#123;            get            &#123;                if (csharpScore &gt;&#x3D; 0 &amp;&amp; csharpScore &lt;&#x3D; 150)                &#123;                    return csharpScore;                &#125;                else                &#123;                    Console.WriteLine(&quot;请输入0~100之间的成绩,默认60&quot;);                    return 60;                &#125;            &#125;            set            &#123;                csharpScore &#x3D; value;            &#125;        &#125;        public int UnityScore        &#123;            get            &#123;                if (unityScore &gt;&#x3D; 0 &amp;&amp; unityScore &lt;&#x3D; 150)                &#123;                    return unityScore;                &#125;                else                &#123;                    Console.WriteLine(&quot;请输入0~100之间的成绩,默认60&quot;);                    return 60;                &#125;            &#125;            set            &#123;                unityScore &#x3D; value;            &#125;        &#125;        public void Hello1()        &#123;            Console.WriteLine(&quot;我叫&#123;0&#125;,今年&#123;1&#125;岁了&quot;, Name, Age);        &#125;        public void Hello2()        &#123;            Console.WriteLine(&quot;我是&#123;0&#125;生,我的总分是&#123;1&#125;,平均分是&#123;2&#125;&quot;, Sex, CSharpScore + UnityScore, (CSharpScore + UnityScore)&#x2F;2);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Student s1 &#x3D; new Student();            s1.Name &#x3D; &quot;季宝&quot;;            s1.Sex &#x3D; &quot;男&quot;;            s1.Age &#x3D; 170;            s1.CSharpScore &#x3D; 80;            s1.UnityScore &#x3D; 80;            s1.Hello1();            s1.Hello2();            Student s2 &#x3D; new Student();        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>封装_构造函数和析构函数</title>
    <link href="/2022/05/10/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E5%B0%81%E8%A3%85-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
    <url>/2022/05/10/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E5%B0%81%E8%A3%85-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>封装_构造函数和析构函数</p><span id="more"></span><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>在实例化对象时 会调用的用于初始化的函数<br>（如果不写 默认存在一个无参构造函数）</p><h2 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h2><p>1.没有返回值<br>2.函数名和类名必须相同<br>3.没有特殊需求时，一般都是public的<br>4.构造函数可以被重载<br>5.this代表当前调用该函数的对象自己</p><h2 id="特殊写法"><a href="#特殊写法" class="headerlink" title="特殊写法"></a>特殊写法</h2><p>可以通过this 重用构造函数代码</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">访问修饰符 构造函数名(参数列表):this(参数1,参数2......)</code></pre></div><p>即该构造函数会先执行this所代表的构造函数，再执行自己的逻辑</p><p><strong>注意</strong><br>1.类中是允许自己声明无参构造函数的，结构体是不允许的<br>2.如果不自己实现无参构造函数而实现了有参构造函数，会失去默认的无参构造函数</p><h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p>当<strong>引用类型的堆内存被回收</strong>时，会调用该函数<br>对于需要手动管理内存的语言(比如c++)，需要在析构函数中做一些内存回收处理<br>但是c#中存在垃圾回收机制GC<br>所以几乎不会怎么使用析构函数，除非需要对某一个对象被垃圾回收时，做一些特殊处理</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">~类名()&#123;&#125;</code></pre></div><h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><p>垃圾回收(GC,Garbage Collector)<br>1.垃圾回收的过程是遍历堆(Heap)上动态分配的所有对象<br>2.通过识别他们是否被引用来确定哪些对象是垃圾，哪些对象仍要被引用<br>3.所谓的垃圾就是没有被任何变量，对象引用的内容(垃圾就需要被回收释放)</p><p>垃圾回收有多种算法：<br>1.引用计数(Reference Counting)<br>2.标记清楚(Mark Sweep)<br>3.标记整理(Mark Compact)<br>4.复制集合(Copy Collection)</p><p><strong>注意</strong><br>GC只负责堆(Heap)内存的垃圾回收<br>引用类型都是存在堆(Heap)中的，所以它的分配和释放都通过垃圾回收机制来管理</p><p>栈(Stack)上的内存是有系统自动管理的<br>值类型是在栈(Stack)中分配内存的，他们有自己的生命周期，不用对他们进行管理，会自动分配和释放</p><p><strong>C#中内存回收机制的大概原理</strong><br>内存分为： 0代内存 1代内存 2代内存<br><strong>代的概念</strong>：<br>代是垃圾回收机制使用的一种算法(分代算法)<br>新分配的对象都会被配置在第0代内存中<br>每次分配都可能会进行垃圾回收以释放内存(0代内存满时)</p><p>在一次内存回收过程开始时，垃圾回收器会认为堆中全是垃圾，会进行以下两步：<br>1.标记对象，从根（静态字段、方法参数）开始检查引用对象，标记后为可达对象，未标记为不可达对象，不可达对象就认为是垃圾<br>2.搬迁对象压缩堆（挂起执行托管代码线程），释放未标记的对象，搬迁可达对象，修改引用地址</p><p>大对象总被认为是第2代内存，目的是减少性能损耗，提高性能<br>不会对大对象进行搬迁压缩 85000字节（83kb）以上的对象为大对象</p><p>手动触发垃圾回收的方法<br>一般情况下不会频繁调用<br>都是在Loading过场景时才调用</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">GC.Collect();</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/10/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E5%B0%81%E8%A3%85-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/exam.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson4_封装_构造函数和析构函数&#123;    class Person    &#123;        public string name;        public int age;        public Person()        &#123;            name &#x3D; &quot;大逼&quot;;            age &#x3D; 23;        &#125;        public Person(string name)            &#123; this.name &#x3D; name; &#125;        public Person(int age)            &#123; this.age &#x3D; age; &#125;    &#125;    class Lesson    &#123;        public int ID;        public int num;        public Lesson()        &#123;            ID &#x3D; 1;            num &#x3D; 10;        &#125;        public Lesson(int ID, int num)        &#123;             this.ID &#x3D; ID;             this.num &#x3D; num;        &#125;    &#125;    class Ticket    &#123;        public uint distance;        public float price;        public Ticket(uint distance)        &#123;            this.distance &#x3D; distance;        &#125;        public void GetPrice()        &#123;            if(0 &lt;&#x3D; distance &amp;&amp; distance &lt;&#x3D; 100)            &#123;                price &#x3D; 1.0f * distance;            &#125;            else if(100 &lt; distance &amp;&amp; distance &lt;&#x3D; 200)            &#123;                price &#x3D; 0.95f * (distance - 100) + 100;            &#125;            else if(200 &lt; distance &amp;&amp; distance &lt;&#x3D; 300)            &#123;                price &#x3D; 0.9f * (distance - 200) + 195;            &#125;            else if(distance &gt; 300)            &#123;                price &#x3D; 0.8f * (distance - 300) + 385;            &#125;        &#125;        public void Print()        &#123;            GetPrice();            Console.WriteLine(&quot;&#123;0&#125;公里&#123;1&#125;块钱&quot;, distance, price);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Person p1 &#x3D; new Person();            Person p2 &#x3D; new Person(&quot;季宝&quot;);            Person p3 &#x3D; new Person(22);            Lesson l1 &#x3D; new Lesson();            Lesson l2 &#x3D; new Lesson(2, 46);            try            &#123;                Ticket t1 &#x3D; new Ticket(uint.Parse(Console.ReadLine()));                t1.Print();            &#125;            catch            &#123;                Console.WriteLine(&quot;请输入正数&quot;);            &#125;            &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>成员方法</title>
    <link href="/2022/05/09/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95/"/>
    <url>/2022/05/09/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>成员方法</p><span id="more"></span><h1 id="成员方法的声明"><a href="#成员方法的声明" class="headerlink" title="成员方法的声明"></a>成员方法的声明</h1><p><strong>基本概念</strong>：<br>成员方法（函数） 用来表现对象行为<br>1.声明在语句块中<br>2.是用来描述对象的行为的<br>3.规则和函数声明规则相同<br>4.受到访问修饰符规则影响<br>5.返回值参数不做限制<br>6.方法数量不做限制</p><p><strong>注意</strong>：<br>1.成员方法不要加static关键字<br>2.成员方法必须实例化出对象，再通过对象来使用，相当于该对象执行了某个行为<br>3.成员方法 受到访问修饰符影响</p><h1 id="成员方法的使用"><a href="#成员方法的使用" class="headerlink" title="成员方法的使用"></a>成员方法的使用</h1><p>必须实例化出对象，再通过对象来使用，相当于该对象执行了某个行为</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/09/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95/exam.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson3_成员方法&#123;    #region 练习题1    class Person    &#123;        public string name;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 说话        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;str&quot;&gt;&lt;&#x2F;param&gt;        public void Speak(string str)        &#123;            Console.WriteLine(&quot;&#123;0&#125;说&#123;1&#125;&quot;, name, str);        &#125;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 走路        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;s&quot;&gt;&lt;&#x2F;param&gt;        public void Walk(int s)        &#123;            Console.WriteLine(&quot;&#123;0&#125;走了&#123;1&#125;步&quot;, name, s);        &#125;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 吃饭        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;food&quot;&gt;&lt;&#x2F;param&gt;        public void Eat(Food food)        &#123;            Console.WriteLine(&quot;&#123;0&#125;吃了&#123;1&#125;,吸收了&#123;2&#125;热量&quot;, name, food.name, food.heat);        &#125;    &#125;    #endregion    #region 练习题2    class Student    &#123;        public string name;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 学习        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;subject&quot;&gt;&lt;&#x2F;param&gt;        public void Study(string subject)        &#123;            Console.WriteLine(&quot;&#123;0&#125;在学习&#123;1&#125;&quot;, name, subject);        &#125;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 吃饭        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;food&quot;&gt;&lt;&#x2F;param&gt;        public void Eat(Food food)        &#123;            Console.WriteLine(&quot;&#123;0&#125;吃了&#123;1&#125;,吸收了&#123;2&#125;热量&quot;, name, food.name, food.heat);        &#125;    &#125;    #endregion    #region 练习题3    class Food    &#123;        public E_FoodName name;        public int heat;    &#125;    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 食物种类枚举    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_FoodName    &#123;        Apple &#x3D; 10,        Banana &#x3D; 20,        Mango &#x3D; 30,    &#125;    #endregion        internal class Program    &#123;        static void Main(string[] args)        &#123;            #region 练习题123            Person p &#x3D; new Person();            p.name &#x3D; &quot;大逼&quot;;            Student s &#x3D; new Student();            s.name &#x3D; &quot;季宝&quot;;            Food f &#x3D; new Food();            f.name &#x3D; E_FoodName.Apple;            f.heat &#x3D; (int)f.name;            p.Eat(f);            s.Eat(f);            #endregion        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>成员变量和访问修饰符</title>
    <link href="/2022/05/09/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <url>/2022/05/09/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<p>成员变量  访问修饰符</p><span id="more"></span><h1 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h1><p>基本规则：<br>1.声明在类语句块中 class<br>2.用来描述对象的特征<br>3.可以是任意变量类型<br>4.数量不做限制<br>5.是否赋值根据需求来定<br>6.在类里 可以声明和自己一样的变量类型 但不能对它实例化</p><h1 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h1><p>基本作用： 决定类内部成员的访问权限<br><strong>public</strong>  公共的  自己（内部）和别人（外部）都能访问和使用<br><strong>private</strong>  私有的  自己（内部）才能访问和使用    不写默认为private<br><strong>protected</strong>  保护的  自己（内部）和子类才能访问和使用</p><h1 id="成员变量的初始值"><a href="#成员变量的初始值" class="headerlink" title="成员变量的初始值"></a>成员变量的初始值</h1><p><strong>值类型</strong>：数字类型默认0  bool类型默认false<br><strong>引用类型</strong>：默认为null<br>技巧： Console.WriteLine(default(你想查询初始值的类型名));</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/09/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/exam.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson2_成员变量和访问修饰符&#123;    #region 练习题1    &#x2F;&#x2F; 3P &#x3D; public  private  protected  访问修饰符    #endregion    #region 练习题2    &#x2F;&#x2F;定义人类    class Person    &#123;        &#x2F;&#x2F;特征 成员变量        &#x2F;&#x2F;姓名        public string name;        &#x2F;&#x2F;身高        public int height;        &#x2F;&#x2F;年龄        public int age;         &#x2F;&#x2F;家庭住址        public string location;    &#125;    #endregion    #region 练习题3    &#x2F;&#x2F;定义学生    class Student    &#123;        &#x2F;&#x2F;特征 成员变量        &#x2F;&#x2F;姓名        public string name;        &#x2F;&#x2F;学号        public string ID;        &#x2F;&#x2F;年龄        public int age;         &#x2F;&#x2F;同桌        public Student deskmate;        &#x2F;&#x2F;行为 成员方法            &#125;    #endregion    #region 练习题4    &#x2F;&#x2F;定义班级    class Lesson    &#123;        &#x2F;&#x2F;特征 成员变量        &#x2F;&#x2F;专业名称        public string majorName;        &#x2F;&#x2F;学号        public string ID;        &#x2F;&#x2F;教师容量        public int teacherNum;        &#x2F;&#x2F;学生        public Student[] students;    &#125;    #endregion        internal class Program    &#123;        static void Main(string[] args)        &#123;                     #region 练习题5            Person p &#x3D; new Person();            p.age &#x3D; 10;            Person p2 &#x3D; new Person();            p2.age &#x3D; 20;            Console.WriteLine(p.age);            &#x2F;&#x2F;10            #endregion            #region 练习题6            Person p3 &#x3D; new Person();            p3.age &#x3D; 10;            Person p4 &#x3D; p3;            p4.age &#x3D; 20;            Console.WriteLine(p3.age);            &#x2F;&#x2F;20            #endregion            #region 练习题7            Student s &#x3D; new Student();            s.age &#x3D; 10;            int age &#x3D; s.age;            age &#x3D; 20;            Console.WriteLine(s.age);            &#x2F;&#x2F;10            #endregion            #region 练习题8            Student s1 &#x3D; new Student();            s1.deskmate &#x3D; new Student();            s1.deskmate.age &#x3D; 10;            Student s2 &#x3D; s1.deskmate;            s2.age &#x3D; 20;            Console.WriteLine(s1.deskmate.age);            &#x2F;&#x2F;20            #endregion        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月9日</title>
    <link href="/2022/05/09/diary/2022.5/2022%E5%B9%B45%E6%9C%889%E6%97%A5/"/>
    <url>/2022/05/09/diary/2022.5/2022%E5%B9%B45%E6%9C%889%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="d84eba87eff053a4f05c219966365787260261f4cbb94d56ff5eeb1ec094dde8">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe500d33c330961da8b059aa497902f1d00c4410c00f3db9aa6f2ce9955bc5e104c1a98bc530f4a959a1fa2d4236ca77aae0eb5c5355d7786a3c44af12629597575f747fb04ed906b56e8ad3421784ba17e2c155600383c595fea8bdd189b30477f4b101091a57576294adea8b132d3ae11d1bb2e7f43f487c41678825fe3e100da793400da2af07a6eaa040230bce11743a49ca83f002ce9c69cc4e60b917e2c710fe3b72b5c28dc8cde0ee325f55112d67dd525a484c75817eb7f252fec8cb0fa311f4cdad3d7ec4f88aef74205a2cdcd3534476a7b3177921f983a0661c26a644c5761ba1931b83c6328fdb8cc7918de4da9dcff42de36d825edac9f151f8e7a2b5969d5b34fcfe3e914cca177ee7356e47061ef3c4a45df707867e4e95ce54f4ea9f782f9d0543b5631f22c3652a7caf727bbde4d9cc435c2e836c9ef74b6e6e9fc297fdaeb7fe1d7cf5a961e7cb04a00f34c54a85daa1e9b1573d32ff6c2b9402de755dc71a9357e50ea941b5f5748bb06fef3ee5bfc49db813efa128320352f07240c239607e59b3f619142a101a07a14653e48a88ea02c14322266a11b287216ded8ceddcec4d458448f7ca737ce0186587348816e1b23c8c5a7f7b7db32fc100a3e41e60ecd904d5419b07ae69a51518151ab9ce7aef987328799ca2c0c7</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类和对象</title>
    <link href="/2022/05/08/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <url>/2022/05/08/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>类 对象</p><span id="more"></span><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>基本概念：<br>1.具有相同特征<br>2.具有相同行为<br>3.一类事物的抽象<br>4.类是对象的模板<br>5.可以通过类创建出对象<br>6.类的关键词 class</p><p>一般声明在 <strong>namespace</strong> 语句块中<br>声明语法：<br> <div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">访问修饰符 class 类名&#123;    &#x2F;&#x2F;封装    特征 成员变量    行为 成员方法    保护特征 成员属性    构造函数和析构函数    索引器    运算符重载    静态成员&#125;</code></pre></div></p><h1 id="（类）对象"><a href="#（类）对象" class="headerlink" title="（类）对象"></a>（类）对象</h1><p>基本概念：<br>1.<strong>类的声明</strong>和<strong>类对象（变量）声明</strong>是两个概念<br>2.<strong>类的声明</strong>类似<strong>枚举</strong>和<strong>结构体的声明</strong>（类的声明相当于声明了一个自定义变量类型）<br>3.对象是类创建出来的（相当于声明一个<strong>指定类的变量</strong>）<br>4.类创建对象的过程（一般称为<strong>实例化对象</strong>）<br>5.类对象都是<strong>引用类型</strong>的</p><p>声明语法：</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">类名 变量名;类名 变量名 &#x3D; null; &#x2F;&#x2F;null代表空类名 变量名 &#x3D; new 类名();</code></pre></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1.<strong>类的声明</strong>和<strong>类对象（变量）声明</strong>是两个概念<br>2.<strong>类的声明</strong>是声明对象的模板，用来抽象（形容）显示事物的<br>3.<strong>类对象（变量）声明</strong>是用来表示现实中的对象个体的</p><p>4.<strong>类</strong>是一个自定义的变量类型<br>5.实例化一个<strong>类对象</strong>是在声明变量</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/08/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/%E7%BB%83%E4%B9%A0%E9%A2%98.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">练习题1 懒得做练习题2 A保持不变        GameObject A &#x3D; new GameObject(); &#x2F;&#x2F;新建栈 堆        GameObject B &#x3D; A; &#x2F;&#x2F;新建栈 指向A的堆        B &#x3D; null; &#x2F;&#x2F;B的栈 指向null的堆练习题3 A和B没关系        GameObject A &#x3D; new GameObject(); &#x2F;&#x2F;新建栈 堆        GameObject B &#x3D; A; &#x2F;&#x2F;新建栈 指向A的堆        B &#x3D; new GameObject(); &#x2F;&#x2F;B的栈 指向new的堆</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象编程</title>
    <link href="/2022/05/08/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/05/08/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>面向对象编程 面向过程编程</p><span id="more"></span><h1 id="面向过程编程"><a href="#面向过程编程" class="headerlink" title="面向过程编程"></a>面向过程编程</h1><p>一种<strong>以过程为中心</strong>的编程思想<br>分析出解决问题所需要的步骤<br>然后用函数把步骤一步一步实现<br>使用的时候一个一个一次调用</p><h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>面向对象是一种<strong>对现实世界理解和抽象</strong>的编程方法<br><strong>把相关的数据和方法组织为一个整体来看待</strong><br>从更高的层次来进行程序开发<br>更贴近事物的自然运行模式</p><p>万物皆对象  用程序来抽象（形容）对象  用面向对象的思想来编程</p><img src="/2022/05/08/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E5%AF%B9%E8%B1%A1.png" class=""><p><strong>套路：</strong><br>用中文去形容一类对象<br>把一类对象的共同点提取出来<br>然后用程序语言把它翻译过来<br>带着对象的概念在程序中使用他们</p><h1 id="重要知识点"><a href="#重要知识点" class="headerlink" title="重要知识点"></a>重要知识点</h1><h2 id="面向对象关键知识"><a href="#面向对象关键知识" class="headerlink" title="面向对象关键知识"></a>面向对象关键知识</h2><p>类（class 关键词）</p><h2 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h2><p>重点中的重点：<br><strong>封装</strong> + <strong>继承</strong> + <strong>多态</strong><br><strong>封装</strong>：用程序语言来形容对象<br><strong>继承</strong>：复用封装对象的代码；儿子继承父亲，复用现成代码<br><strong>多态</strong>：同样行为的不同表现，儿子继承父亲的基金但是有不同的行为表现</p><h2 id="面向对象七大原则"><a href="#面向对象七大原则" class="headerlink" title="面向对象七大原则"></a>面向对象七大原则</h2><p>开闭原则<br>依赖倒转原则<br><strong>里式替换原则</strong><br>单一职责原则<br>接口隔离原则<br>合成复用原则<br>迪米特法则</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月8日</title>
    <link href="/2022/05/08/diary/2022.5/2022%E5%B9%B45%E6%9C%888%E6%97%A5/"/>
    <url>/2022/05/08/diary/2022.5/2022%E5%B9%B45%E6%9C%888%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="f59f778e162cd4c5575e8011cc98055fa0bff015c3ee6e202e70659d313c6c3d">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50fdd0ca3edc57389bd0e88084b7db202376ed899917c9c6c734af1f7eca42e06ef4ff0890be6f398558796f868b9f06ee655258737f6db070469b46f13f90d490fab7ed262b0674e752644fe7c26987bc8d8f98b1be0f67c09d7ed761c2f39431f9b5bf55e12b69d0873f8ee72fef88a00ffa617ea3d0cee8ec38a28f098431742f50e9fba2bdd55267e5781d681d47c7621c06254e363fd8f450a5b452e550941cb7bde91bee2ad2dadeef67388f660d4325433b8551d5498c44b50ae1c4ce8573f93da15e1bccd0368270193b6e43ec0bbfb7005c8ccad91008f1ba8dd3c2bc3f817203b2b153ed8b0fb3bb47321b923f8a0b40d5129b483c2eb3b3696f83c13570b18ec4f41c0060981769b4fddf506e84496b93e604bec7f5e9eab245635a58312a1db37ddbe9403b347965029d3609cb00b0963c4f7ea247324ba0a1360931d2cf439647cca7b900d9f7cb66f2fc70100efb41f96eaa24a625c2e6819c6988a6e4223414da010942d393cc9cdef09f2d0040e194370d0dae37a88aeeb44071abbc70cab22737f11086352de96310e23c022150e7804fea3160c52121198389667716f56947b839ddf07ce944b0c04dc9156d1e8f54cc2f56e462f7d484d5437ec4beefea3b5e894006f08d6fd290aed03347811ced529b6d5ab340e33887</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>飞行棋逻辑整理</title>
    <link href="/2022/05/07/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86/"/>
    <url>/2022/05/07/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>逻辑整理</p><span id="more"></span><img src="/2022/05/07/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86-1.jpg" class=""><img src="/2022/05/07/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86-2.jpg" class=""><img src="/2022/05/07/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86-3.jpg" class=""><img src="/2022/05/07/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86-4.jpg" class="">]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月7日</title>
    <link href="/2022/05/07/diary/2022.5/2022%E5%B9%B45%E6%9C%887%E6%97%A5/"/>
    <url>/2022/05/07/diary/2022.5/2022%E5%B9%B45%E6%9C%887%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="5b619cf13cf1e47245c9944edb189af53431bf3141868f33b1bc6c8529b0537d">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50fdd0ca3edc57389bd0e88084b7db2023fbfbe4a886cec053b0d69678e9bd693646e6fc5a95475d4199d73cf5baa89d2975c29f552c86b61ceb5cf6b8d828ed6db54c925b71bbee4d09b841d4bb0f64dcdcd9d240b83082bb804938681252d82c205164b429d4b7cc40521c2a1c9eb276a4827086157c40dd08c639db597f33df1d69e5990cbf1f0daa82a5abedef55f7d8553f67c6e8c5a24555e176ef3f138ca04a19a4c7db4590582dc6990c19f05b5144c85453f8460bc83ff67eaf1680acf0114d9671864f166d3b5c439aa618409638f886f77ee08119b5f0214d27e7db732bb546ec23bf3cb89d59bd45dbd52bc0d339aba3a38f0d42f6dfc00529ddf5a7876c11a1abf0629dbb98324236013694a91bf301af802b2c31917c3a2caf8e0ca3a33c9d6bd17e426e6ffd47dcb9f1ba2c7e447f08e50df23274fe72317fd37f824f76fb200e67a34e8bb75444dd5d793240fff557be54c992bffb19e0c39dba5b1470c114cee0d9856a170838db012709c926e9d7fbae7536b89d6d6239c8ad703e7435ec3a78a0fca41e9b75f5fe53ed49cc0670391375262a47344164b57d860bca9e476c35796b53c645e567fb2fd4ade582bab275248ba8483cce6035d594a8b3ce12d2ab35583ffc7fdec4a4b23ad4b03f77bbcbcfddc4a9a0a28504f5e1ba3dd8350ebee7fb69b537d8d1d5f9c76fcd9b97499bb88b13ed17196c3a3e62f4ff4471d017c87edb919258bc5d8a682c3abdeb500e8dea1bf57bc50a5a3afbfd880e5514001cfe65b8acdb8384761abb4e434ea4755fe3d55ede3c0fe47b8bf0197a7270464e8ba29ace47286981ba52e456c2016304385ec6e39603713d4fc571182313a552578017fbb8aa66e5b707c998a6f28ce3009764e5fb992c956cad0e48b08a49d4e3a71e3c4f4cdc5c00d2eb058bc7dbc42a3e95484617e1a3c04a7675745812016613fbd0494458e2b4deead739896655b0361c89b6e62cb1257e829076547d97646a2df3e42a35b79391779b4661e37221ba1ca42c5964ea8caa54673a10f82dd0d670173c0c0bda388f3901c0b73785df5c06bdd3a630</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>飞行棋实现</title>
    <link href="/2022/05/06/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/05/06/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>飞行棋</p><span id="more"></span><p><strong># 实现结果</strong></p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=553774900&bvid=BV17v4y1K7i2&cid=713732660&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace CSharp基础实践教学&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            #region 1 控制台初始化            int w &#x3D; 50;            int h &#x3D; 30;            ConsoleInit(w, h);            #endregion            #region 2 场景选择相关            &#x2F;&#x2F;申明一个 表示场景标识的 变量             E_SceneType nowSceneType &#x3D; E_SceneType.Begin;            while (true)            &#123;                switch (nowSceneType)                &#123;                    case E_SceneType.Begin:                        &#x2F;&#x2F;开始场景逻辑                        Console.Clear();                        &#x2F;&#x2F;来书写 开始场景相关的逻辑即可                        BeginOrEndScene(w, h, ref nowSceneType);                        break;                    case E_SceneType.Game:                        &#x2F;&#x2F;游戏场景逻辑                        Console.Clear();                        &#x2F;&#x2F;通过函数来处理游戏场景的逻辑内容                        GameScene(w, h, ref nowSceneType);                        break;                    case E_SceneType.End:                        &#x2F;&#x2F;结束场景逻辑                        Console.Clear();                        BeginOrEndScene(w, h, ref nowSceneType);                        break;                    default:                        break;                &#125;            &#125;            #endregion        &#125;        #region 1 控制台初始化        static void ConsoleInit(int w, int h)        &#123;            &#x2F;&#x2F;基础设置            &#x2F;&#x2F;光标的隐藏            Console.CursorVisible &#x3D; false;            &#x2F;&#x2F;舞台的大小            Console.SetWindowSize(w, h);            Console.SetBufferSize(w, h);        &#125;        #endregion        #region 3 开始场景逻辑 + 8 结束场景逻辑        static void BeginOrEndScene(int w, int h, ref E_SceneType nowSceneType)        &#123;            Console.ForegroundColor &#x3D; ConsoleColor.White;            Console.SetCursorPosition(nowSceneType &#x3D;&#x3D; E_SceneType.Begin ? w &#x2F; 2 - 3 : w &#x2F; 2 - 4, 8);            Console.Write(nowSceneType &#x3D;&#x3D; E_SceneType.Begin ? &quot;飞行棋&quot; : &quot;游戏结束&quot;);            &#x2F;&#x2F;当前选项的编号            int nowSelIndex &#x3D; 0;            bool isQuitBegin &#x3D; false;            &#x2F;&#x2F;开始场景逻辑处理循环            while (true)            &#123;                Console.SetCursorPosition(nowSceneType &#x3D;&#x3D; E_SceneType.Begin ? w &#x2F; 2 - 4 : w &#x2F; 2 - 5, 13);                Console.ForegroundColor &#x3D; nowSelIndex &#x3D;&#x3D; 0 ? ConsoleColor.Red : ConsoleColor.White;                Console.Write(nowSceneType &#x3D;&#x3D; E_SceneType.Begin ? &quot;开始游戏&quot; : &quot;回到主菜单&quot;);                Console.SetCursorPosition(w &#x2F; 2 - 4, 15);                Console.ForegroundColor &#x3D; nowSelIndex &#x3D;&#x3D; 1 ? ConsoleColor.Red : ConsoleColor.White;                Console.Write(&quot;退出游戏&quot;);                &#x2F;&#x2F;通过ReadKey可以得到一个输入的枚举类型                switch (Console.ReadKey(true).Key)                &#123;                    case ConsoleKey.W:                        --nowSelIndex;                        if (nowSelIndex &lt; 0)                        &#123;                            nowSelIndex &#x3D; 0;                        &#125;                        break;                    case ConsoleKey.S:                        ++nowSelIndex;                        if (nowSelIndex &gt; 1)                        &#123;                            nowSelIndex &#x3D; 1;                        &#125;                        break;                    case ConsoleKey.J:                        if (nowSelIndex &#x3D;&#x3D; 0)                        &#123;                            &#x2F;&#x2F;进入游戏场景                            &#x2F;&#x2F;1 改变当前场景ID                            nowSceneType &#x3D; nowSceneType &#x3D;&#x3D; E_SceneType.Begin ? E_SceneType.Game : E_SceneType.Begin;                            &#x2F;&#x2F;2 退出当前循环                            isQuitBegin &#x3D; true;                        &#125;                        else                        &#123;                            &#x2F;&#x2F;退出游戏                            Environment.Exit(0);                        &#125;                        break;                &#125;                &#x2F;&#x2F;通过标识决定 是否跳出 开始场景的循环                if (isQuitBegin)                &#123;                    break;                &#125;            &#125;        &#125;        #endregion        #region 游戏场景逻辑        static void GameScene(int w, int h, ref E_SceneType nowSceneType)        &#123;            &#x2F;&#x2F;绘制不变的基本信息            DrawWall(w, h);            &#x2F;&#x2F;绘制地图            &#x2F;&#x2F;初始化一张地图             Map map &#x3D; new Map(14, 3, 80);            map.Draw();            &#x2F;&#x2F;绘制玩家            Player player &#x3D; new Player(0, E_PlayerType.Player);            Player computer &#x3D; new Player(0, E_PlayerType.Computer);            DrawPlayer(player, computer, map);            bool isGameOver &#x3D; false;            &#x2F;&#x2F;游戏场景循环            while (true)            &#123;                &#x2F;&#x2F;之后的游戏逻辑                &#x2F;&#x2F;玩家扔色子逻辑                &#x2F;&#x2F;检测输入                &#x2F;&#x2F;Console.ReadKey(true);                &#x2F;&#x2F;&#x2F;&#x2F;扔色子的逻辑                &#x2F;&#x2F;isGameOver &#x3D; RandomMove(w, h, ref player, ref computer, map);                &#x2F;&#x2F;&#x2F;&#x2F;绘制地图                &#x2F;&#x2F;map.Draw();                &#x2F;&#x2F;&#x2F;&#x2F;绘制玩家                &#x2F;&#x2F;DrawPlayer(player, computer, map);                &#x2F;&#x2F;&#x2F;&#x2F;判断是否要结束游戏                &#x2F;&#x2F;if( isGameOver )                &#x2F;&#x2F;&#123;                &#x2F;&#x2F;    &#x2F;&#x2F;卡住程序 让顽疾按任意键                 &#x2F;&#x2F;    Console.ReadKey(true);                &#x2F;&#x2F;    &#x2F;&#x2F;改变场景ID                &#x2F;&#x2F;    nowSceneType &#x3D; E_SceneType.End;                &#x2F;&#x2F;    &#x2F;&#x2F;直接跳出循环                &#x2F;&#x2F;    break;                &#x2F;&#x2F;&#125;                &#x2F;&#x2F;玩家扔色子                if (PlayerRandoMove(w, h, ref player, ref computer, map, ref nowSceneType))                &#123;                    break;                &#125;                &#x2F;&#x2F;电脑扔色子                if (PlayerRandoMove(w, h, ref computer, ref player, map, ref nowSceneType))                &#123;                    break;                &#125;                &#x2F;&#x2F;电脑扔色子逻辑                &#x2F;&#x2F;检测输入                &#x2F;&#x2F;Console.ReadKey(true);                &#x2F;&#x2F;&#x2F;&#x2F;扔色子的逻辑                &#x2F;&#x2F;isGameOver &#x3D; RandomMove(w, h, ref computer, ref player, map);                &#x2F;&#x2F;&#x2F;&#x2F;绘制地图                &#x2F;&#x2F;map.Draw();                &#x2F;&#x2F;&#x2F;&#x2F;绘制玩家                &#x2F;&#x2F;DrawPlayer(player, computer, map);                &#x2F;&#x2F;&#x2F;&#x2F;判断是否要结束游戏                &#x2F;&#x2F;if (isGameOver)                &#x2F;&#x2F;&#123;                &#x2F;&#x2F;    &#x2F;&#x2F;卡住程序 让顽疾按任意键                 &#x2F;&#x2F;    Console.ReadKey(true);                &#x2F;&#x2F;    &#x2F;&#x2F;改变场景ID                &#x2F;&#x2F;    nowSceneType &#x3D; E_SceneType.End;                &#x2F;&#x2F;    &#x2F;&#x2F;直接跳出循环                &#x2F;&#x2F;    break;                &#x2F;&#x2F;&#125;            &#125;        &#125;        static bool PlayerRandoMove(int w, int h, ref Player p, ref Player otherP, Map map, ref E_SceneType nowSceneType)        &#123;            &#x2F;&#x2F;之后的游戏逻辑            &#x2F;&#x2F;玩家扔色子逻辑            &#x2F;&#x2F;检测输入            Console.ReadKey(true);            &#x2F;&#x2F;扔色子的逻辑            bool isGameOver &#x3D; RandomMove(w, h, ref p, ref otherP, map);            &#x2F;&#x2F;绘制地图            map.Draw();            &#x2F;&#x2F;绘制玩家            DrawPlayer(p, otherP, map);            &#x2F;&#x2F;判断是否要结束游戏            if (isGameOver)            &#123;                &#x2F;&#x2F;卡住程序 让顽疾按任意键                 Console.ReadKey(true);                &#x2F;&#x2F;改变场景ID                nowSceneType &#x3D; E_SceneType.End;                &#x2F;&#x2F;直接跳出循环            &#125;            return isGameOver;        &#125;        #endregion        #region 4 绘制不变内容（红墙 提示等等）        static void DrawWall(int w, int h)        &#123;            Console.ForegroundColor &#x3D; ConsoleColor.Red;            &#x2F;&#x2F;画墙            &#x2F;&#x2F;横着的墙            for (int i &#x3D; 0; i &lt; w; i +&#x3D; 2)            &#123;                &#x2F;&#x2F;最上方的墙                Console.SetCursorPosition(i, 0);                Console.Write(&quot;■&quot;);                &#x2F;&#x2F;最下方的墙                Console.SetCursorPosition(i, h - 1);                Console.Write(&quot;■&quot;);                &#x2F;&#x2F;中间的墙                Console.SetCursorPosition(i, h - 6);                Console.Write(&quot;■&quot;);                Console.SetCursorPosition(i, h - 11);                Console.Write(&quot;■&quot;);            &#125;            &#x2F;&#x2F;竖着的墙            for (int i &#x3D; 0; i &lt; h; i++)            &#123;                &#x2F;&#x2F;最左边                Console.SetCursorPosition(0, i);                Console.Write(&quot;■&quot;);                &#x2F;&#x2F;最右边                Console.SetCursorPosition(w - 2, i);                Console.Write(&quot;■&quot;);            &#125;            &#x2F;&#x2F;文字信息            Console.ForegroundColor &#x3D; ConsoleColor.White;            Console.SetCursorPosition(2, h - 10);            Console.Write(&quot;□:普通格子&quot;);            Console.ForegroundColor &#x3D; ConsoleColor.Blue;            Console.SetCursorPosition(2, h - 9);            Console.Write(&quot;‖:暂停，一回合不懂&quot;);            Console.ForegroundColor &#x3D; ConsoleColor.Red;            Console.SetCursorPosition(26, h - 9);            Console.Write(&quot;●:炸弹，倒退5格&quot;);            Console.ForegroundColor &#x3D; ConsoleColor.Yellow;            Console.SetCursorPosition(2, h - 8);            Console.Write(&quot;¤:时空隧道，随机倒退，暂停，换位置&quot;);            Console.ForegroundColor &#x3D; ConsoleColor.Cyan;            Console.SetCursorPosition(2, h - 7);            Console.Write(&quot;★:玩家&quot;);            Console.ForegroundColor &#x3D; ConsoleColor.Magenta;            Console.SetCursorPosition(12, h - 7);            Console.Write(&quot;▲:电脑&quot;);            Console.ForegroundColor &#x3D; ConsoleColor.DarkGreen;            Console.SetCursorPosition(22, h - 7);            Console.Write(&quot;◎:玩家和电脑重合&quot;);            Console.ForegroundColor &#x3D; ConsoleColor.White;            Console.SetCursorPosition(2, h - 5);            Console.Write(&quot;按任意键开始扔色子&quot;);        &#125;        #endregion        #region 7 绘制玩家        static void DrawPlayer(Player player, Player computer, Map map)        &#123;            &#x2F;&#x2F;重合时            if (player.nowIndex &#x3D;&#x3D; computer.nowIndex)            &#123;                &#x2F;&#x2F;得到重合的位置                Grid grid &#x3D; map.grids[player.nowIndex];                Console.SetCursorPosition(grid.pos.x, grid.pos.y);                Console.ForegroundColor &#x3D; ConsoleColor.DarkGreen;                Console.Write(&quot;◎&quot;);            &#125;            &#x2F;&#x2F;不重合的时候            else            &#123;                player.Draw(map);                computer.Draw(map);            &#125;        &#125;        #endregion        #region 8 扔色子 函数        &#x2F;&#x2F;擦除提示的函数        static void ClearInfo(int h)        &#123;            Console.SetCursorPosition(2, h - 5);            Console.Write(&quot;                                   &quot;);            Console.SetCursorPosition(2, h - 4);            Console.Write(&quot;                                   &quot;);            Console.SetCursorPosition(2, h - 3);            Console.Write(&quot;                                   &quot;);            Console.SetCursorPosition(2, h - 2);            Console.Write(&quot;                                   &quot;);        &#125;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 扔色子函数        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;w&quot;&gt;窗口的宽&lt;&#x2F;param&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;h&quot;&gt;窗口的高&lt;&#x2F;param&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;p&quot;&gt;扔色子的对象&lt;&#x2F;param&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;map&quot;&gt;地图信息&lt;&#x2F;param&gt;        &#x2F;&#x2F;&#x2F; &lt;returns&gt;默认返回false 代表没有结束&lt;&#x2F;returns&gt;        static bool RandomMove(int w, int h, ref Player p, ref Player otherP, Map map)        &#123;            &#x2F;&#x2F;擦除之前显示的提示信息            ClearInfo(h);            &#x2F;&#x2F;根据扔色子的玩家类型 决定信息的颜色            Console.ForegroundColor &#x3D; p.type &#x3D;&#x3D; E_PlayerType.Player ? ConsoleColor.Cyan : ConsoleColor.Magenta;            &#x2F;&#x2F;扔色子之前 判断 玩家是否处于暂停状态            if (p.isPause)            &#123;                Console.SetCursorPosition(2, h - 5);                Console.Write(&quot;处于暂停状态，&#123;0&#125;需要暂停一回合&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;你&quot; : &quot;电脑&quot;);                Console.SetCursorPosition(2, h - 4);                Console.Write(&quot;请按任意键，让&#123;0&#125;开始扔色子&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;电脑&quot; : &quot;你&quot;);                &#x2F;&#x2F;停止暂停                p.isPause &#x3D; false;                return false;            &#125;            &#x2F;&#x2F;扔色子目的 是改变 玩家或者电脑的位置  计算位置的变化            &#x2F;&#x2F;扔色子 随机一个1到6的数 加上去            Random r &#x3D; new Random();            int randomNum &#x3D; r.Next(1, 7);            p.nowIndex +&#x3D; randomNum;            &#x2F;&#x2F;打印扔的点数            Console.SetCursorPosition(2, h - 5);            Console.Write(&quot;&#123;0&#125;扔出的点数为:&#123;1&#125;&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;你&quot; : &quot;电脑&quot;, randomNum);            &#x2F;&#x2F;首先判断是否到终点了            if (p.nowIndex &gt;&#x3D; map.grids.Length - 1)            &#123;                p.nowIndex &#x3D; map.grids.Length - 1;                Console.SetCursorPosition(2, h - 4);                if (p.type &#x3D;&#x3D; E_PlayerType.Player)                &#123;                    Console.Write(&quot;恭喜你，你率先到达了终点&quot;);                &#125;                else                &#123;                    Console.Write(&quot;很遗憾，电脑率到达了终点&quot;);                &#125;                Console.SetCursorPosition(2, h - 3);                Console.Write(&quot;请按任意键结束游戏&quot;);                return true;            &#125;            else            &#123;                &#x2F;&#x2F;没有到终点 就判断 当前对象  到了一个怎么样的格子                Grid grid &#x3D; map.grids[p.nowIndex];                switch (grid.type)                &#123;                    case E_Grid_Type.Normal:                        &#x2F;&#x2F;普通格子不用处理                        Console.SetCursorPosition(2, h - 4);                        Console.Write(&quot;&#123;0&#125;到了一个安全位置&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;你&quot; : &quot;电脑&quot;);                        Console.SetCursorPosition(2, h - 3);                        Console.Write(&quot;请按任意键，让&#123;0&#125;开始扔色子&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;电脑&quot; : &quot;你&quot;);                        break;                    case E_Grid_Type.Boom:                        &#x2F;&#x2F;炸弹退格                        p.nowIndex -&#x3D; 5;                        &#x2F;&#x2F;不能比起点还小                        if (p.nowIndex &lt; 0)                        &#123;                            p.nowIndex &#x3D; 0;                        &#125;                        Console.SetCursorPosition(2, h - 4);                        Console.Write(&quot;&#123;0&#125;踩到了炸弹，退后5格&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;你&quot; : &quot;电脑&quot;);                        Console.SetCursorPosition(2, h - 3);                        Console.Write(&quot;请按任意键，让&#123;0&#125;开始扔色子&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;电脑&quot; : &quot;你&quot;);                        break;                    case E_Grid_Type.Pause:                        &#x2F;&#x2F;暂停一回合                        &#x2F;&#x2F;暂停目前 只有加一个对象的暂停标识  才能知道 下一回合它是不是不能扔色子                        &#x2F;&#x2F;下回合要暂停                        p.isPause &#x3D; true;                        Console.SetCursorPosition(2, h - 4);                        Console.Write(&quot;&#123;0&#125;到达了暂停点，你需要暂停一回合&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;你&quot; : &quot;电脑&quot;);                        Console.SetCursorPosition(2, h - 3);                        Console.Write(&quot;请按任意键，让&#123;0&#125;开始扔色子&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;电脑&quot; : &quot;你&quot;);                        break;                    case E_Grid_Type.Tunnel:                        Console.SetCursorPosition(2, h - 4);                        Console.Write(&quot;&#123;0&#125;踩到了时空隧道&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;你&quot; : &quot;电脑&quot;);                        &#x2F;&#x2F;随机                        randomNum &#x3D; r.Next(1, 91);                        &#x2F;&#x2F;触发 倒退                        if (randomNum &lt;&#x3D; 30)                        &#123;                            p.nowIndex -&#x3D; 5;                            if (p.nowIndex &lt; 0)                            &#123;                                p.nowIndex &#x3D; 0;                            &#125;                            Console.SetCursorPosition(2, h - 3);                            Console.Write(&quot;触发倒退5格&quot;);                        &#125;                        &#x2F;&#x2F;触发 暂停                        else if (randomNum &lt;&#x3D; 60)                        &#123;                            p.isPause &#x3D; true;                            Console.SetCursorPosition(2, h - 3);                            Console.Write(&quot;触发暂停一回合&quot;);                        &#125;                        &#x2F;&#x2F;触发换位置                        else                        &#123;                            int temp &#x3D; p.nowIndex;                            p.nowIndex &#x3D; otherP.nowIndex;                            otherP.nowIndex &#x3D; temp;                            Console.SetCursorPosition(2, h - 3);                            Console.Write(&quot;惊喜，惊喜，双方交换位置&quot;);                        &#125;                        Console.SetCursorPosition(2, h - 2);                        Console.Write(&quot;请按任意键，让&#123;0&#125;开始扔色子&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;电脑&quot; : &quot;你&quot;);                        break;                &#125;            &#125;            &#x2F;&#x2F;默认没有结束            return false;        &#125;        #endregion    &#125;    #region 2 场景选择相关    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 游戏场景枚举类型    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_SceneType    &#123;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 开始场景        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Begin,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 游戏场景        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Game,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 结束场景        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        End,    &#125;    #endregion    #region 5 格子结构体和格子枚举    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 格子类型 枚举    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_Grid_Type    &#123;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 普通格子        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Normal,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 炸弹        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Boom,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 暂停        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Pause,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 时空隧道 随机倒退 暂停 换位置        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Tunnel,    &#125;    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 位置信息结构体 包含xy位置    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    struct Vector2    &#123;        public int x;        public int y;        public Vector2(int x, int y)        &#123;            this.x &#x3D; x;            this.y &#x3D; y;        &#125;    &#125;    struct Grid    &#123;        &#x2F;&#x2F;格子的类型        public E_Grid_Type type;        &#x2F;&#x2F;格子的位置        public Vector2 pos;        &#x2F;&#x2F;初始化构造函数        public Grid(int x, int y, E_Grid_Type type)        &#123;            pos.x &#x3D; x;            pos.y &#x3D; y;            this.type &#x3D; type;        &#125;        public void Draw()        &#123;            &#x2F;&#x2F;提出来的目的 就是少写几行代码 因为他们不管哪种类型 都要设置了位置再画            Console.SetCursorPosition(pos.x, pos.y);            switch (type)            &#123;                &#x2F;&#x2F;普通格子 怎么画                case E_Grid_Type.Normal:                    Console.ForegroundColor &#x3D; ConsoleColor.White;                    Console.Write(&quot;□&quot;);                    break;                &#x2F;&#x2F;炸弹 怎么画                case E_Grid_Type.Boom:                    Console.ForegroundColor &#x3D; ConsoleColor.Red;                    Console.Write(&quot;●&quot;);                    break;                &#x2F;&#x2F;暂停 怎么画                case E_Grid_Type.Pause:                    Console.ForegroundColor &#x3D; ConsoleColor.Blue;                    Console.Write(&quot;‖&quot;);                    break;                &#x2F;&#x2F;时空隧道 怎么画                case E_Grid_Type.Tunnel:                    Console.ForegroundColor &#x3D; ConsoleColor.Yellow;                    Console.Write(&quot;¤&quot;);                    break;            &#125;        &#125;    &#125;    #endregion    #region 6 地图结构体    struct Map    &#123;        public Grid[] grids;        &#x2F;&#x2F;初始化中 初始了 各个格子的类型 和 位置        public Map(int x, int y, int num)        &#123;            grids &#x3D; new Grid[num];            &#x2F;&#x2F;用于位置改变计数的变量            &#x2F;&#x2F;表示X变化的次数            int indexX &#x3D; 0;            &#x2F;&#x2F;表示Y变化的次数            int indexY &#x3D; 0;            &#x2F;&#x2F;x的步长            int stepNum &#x3D; 2;            Random r &#x3D; new Random();            int randomNum;            for (int i &#x3D; 0; i &lt; num; i++)            &#123;                &#x2F;&#x2F;应该初始化 格子类型                randomNum &#x3D; r.Next(0, 101);                &#x2F;&#x2F;设置类型 普通格子                &#x2F;&#x2F;有85%几率 是普通自（首尾两个格子 必为普通格子）                if (randomNum &lt; 85 || i &#x3D;&#x3D; 0 || i &#x3D;&#x3D; num - 1)                &#123;                    grids[i].type &#x3D; E_Grid_Type.Normal;                &#125;                &#x2F;&#x2F;有5%的几率 是炸弹                else if (randomNum &gt;&#x3D; 85 &amp;&amp; randomNum &lt; 90)                &#123;                    grids[i].type &#x3D; E_Grid_Type.Boom;                &#125;                &#x2F;&#x2F;有5%的几率 是暂停                else if (randomNum &gt;&#x3D; 90 &amp;&amp; randomNum &lt; 95)                &#123;                    grids[i].type &#x3D; E_Grid_Type.Pause;                &#125;                &#x2F;&#x2F;有5%的几率 是时空隧道                else                &#123;                    grids[i].type &#x3D; E_Grid_Type.Tunnel;                &#125;                &#x2F;&#x2F;位置应该如何设置                grids[i].pos &#x3D; new Vector2(x, y);                &#x2F;&#x2F;每次循环都应该按一定规则去变化位置吧                &#x2F;&#x2F;加十次                if (indexX &#x3D;&#x3D; 10)                &#123;                    y +&#x3D; 1;                    &#x2F;&#x2F;加一次Y记一次数                    ++indexY;                    if (indexY &#x3D;&#x3D; 2)                    &#123;                        &#x2F;&#x2F;y加了2次过后 把x加的次数记0                        indexX &#x3D; 0;                        indexY &#x3D; 0;                        &#x2F;&#x2F;反向步长                        stepNum &#x3D; -stepNum;                    &#125;                &#125;                else                &#123;                    x +&#x3D; stepNum;                    &#x2F;&#x2F;加一次X记一次数                    ++indexX;                &#125;            &#125;        &#125;        public void Draw()        &#123;            for (int i &#x3D; 0; i &lt; grids.Length; i++)            &#123;                grids[i].Draw();            &#125;        &#125;    &#125;    #endregion    #region 7 玩家枚举和玩家结构体    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 玩家类型枚举    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_PlayerType    &#123;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 玩家        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Player,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 电脑        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Computer,    &#125;    struct Player    &#123;        &#x2F;&#x2F;玩家类型        public E_PlayerType type;        &#x2F;&#x2F;当前所在地图哪一个索引的格子        public int nowIndex;        &#x2F;&#x2F;是否暂停的标识        public bool isPause;        public Player(int index, E_PlayerType type)        &#123;            nowIndex &#x3D; index;            this.type &#x3D; type;            isPause &#x3D; false;        &#125;        public void Draw(Map mapInfo)        &#123;            &#x2F;&#x2F;必须要先得到地图 才能够 得到我在地图上的哪一个格子            &#x2F;&#x2F;从传入的地图中 得到 格子信息            Grid grid &#x3D; mapInfo.grids[nowIndex];            &#x2F;&#x2F;设置位置            Console.SetCursorPosition(grid.pos.x, grid.pos.y);            &#x2F;&#x2F;画 设置颜色 设置图标            switch (type)            &#123;                case E_PlayerType.Player:                    Console.ForegroundColor &#x3D; ConsoleColor.Cyan;                    Console.Write(&quot;★&quot;);                    break;                case E_PlayerType.Computer:                    Console.ForegroundColor &#x3D; ConsoleColor.Magenta;                    Console.Write(&quot;▲&quot;);                    break;            &#125;        &#125;    &#125;    #endregion&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月6日</title>
    <link href="/2022/05/06/diary/2022.5/2022%E5%B9%B45%E6%9C%886%E6%97%A5/"/>
    <url>/2022/05/06/diary/2022.5/2022%E5%B9%B45%E6%9C%886%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="66e42836cfa71681c04573568ab08bc0d5f74b441addf158500edc865fa3a5b6">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe509e5becb1c52418d004df21efc8656ad3164443d15e3426aec259f6651c69cb77793aad835379c9a1816cf1931da50b5899e97c2830c05d575a4743b34a35ff32f5a4fa29c0526e8fc982443375e9f8fd6cf277a101133b1272d3407d8f2a19168677137fd3b36ecb1f84c706fbed376ed6d5de7cdb5d9d656bb6126e326b737fa68e7c0373437510d1f392fed4168dc07d44dd069b31dc0c49f82d59730d8c02be06da9af3c2b3658b6e4bd123c1096bf72d2baee1bafdc331802a4cdde10c99339aa83cee8465cdb4214c73d0592d99c3572a9a58df9e20255525c044ef489eb748c5ab5c10e96e542aff20f36d562d56baa07a626b08bc94621d58c633558e65fabc41c2865abbd20076f1e9e2b7cfdb0f3cbabbfafe0f15a857cfe469025fd48e42886964ad80d51c8ee70fdfa8d1153535ed335a7ccd7aea7ca601bf16182c7e336042c92c7e43c7a64d491462e1b3182db1d033cf267647d687a6813e2f72540eaaccd76675fc21dbc5f2674702b1226313c83993f2a5ead960df1de82247f06e378f31be68a95a48b5504a6f783db90fa9f39c1b5fea7f3fc11be210edfcb3f58faccc325cd8a411d229dfc3cea4584c5f9f7637fc5d2c9e0aa59dac55966df62dbcb57c5a41a75f85d202bf4b0de68bf91bba94a41d986725ed6342d8dbacdf19274fa1e839e276af4191113d5033a2b7fbb07e99188b0289c9fc5619e46bb0bd84ad7095f7a431de37c130261578650cce1c5d29f5d6431d88acf65c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月5日</title>
    <link href="/2022/05/05/diary/2022.5/2022%E5%B9%B45%E6%9C%885%E6%97%A5/"/>
    <url>/2022/05/05/diary/2022.5/2022%E5%B9%B45%E6%9C%885%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="e511f33453d7f039779defafc86db8f6daff2f33133f2aff607c515a0d328970">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50a54d91deb0dd23a86bb3652d32d2d8603260b625ed51d891af3154cdc9e82226531c388ce184435c513a6bdf27303d625affca6eb12412c28000179a1585754fa6ec21d8e8f513522e8041ae60d72b5e464eb336c6cb9fc6271e69b627a3104a757008b0881f597a83821625f0409e9a3ccb67dbff38f2d551d650992fdeb62a40d368772d7320a2fb9bfa83e11bc8e179140c645e130803a6a971388b8d697e657b23739f21b5b3b1179d17b0d04480d65d24f6053a148f3167ea9698cd3b5811ee6e389ba9bf285337c5c643d9ce7f250862304135afb5cc37ee9fa66a39be4ca1c859708e8dc1beb13d004de352b37b1b0e40f61c18bf700a40fa2336fba7516c41ab191c27e86c22676bda861d0e296d91ee18e8c02c1e2417b66392be6c535f732e821a4436c374c5d8db6a170333841f4a9700469aedb6bce63d0f0553e01a782a004bd1157ccf8b033a090473ad734b4dd40916eabf04fe7f7bcaa98d2a7878bd3490632e4f7b9d33106db0db446c72822e848b1e2bf6e370b586743288fd41a4db74420f36101ca7157d1bd72a619372db36cf0d87d775f8a0a3cc7a41e139059cb35c0574c6f4a06fd8cc86830d23a785ecfa36ab81066b288f0efe4b425916390accf22d275216c40a4645e6a58f0790f36cd7a9bac537da2c79eddb817d221a971c55a089d4b3bb08427c298af5a6fa5501daf6eb83463199106dfe1efe1b3215cc3704fef4b1852c65775fb62f05c9be821f1d4e6a8b75123b1e26332e0de47278c5a94a1c3aadcfa12e37fd520d4e85d2125d93b261fde0aa86ca6a51331d9d3f0044b300393bacba389840f4352cdc91df6fffedf7399741c087b18fcb3c475849778d2c49e45a72a477f5a72949c95b155fc6de87de8b13a6b3d6adc150f0757026eb91717a6b800384eb7a1acfe45141cf0c9412ea129963a1e75022cb8f72317ea5185592198377a58464178e933ce316fa183200a7d89c12e1f5551774ca08bf667026c06c6f0e5d2104ddfad6fd51b9cea3c5d9a67e0a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSharp入门实践——简易飞行棋</title>
    <link href="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/CSharp%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%A3%8B/"/>
    <url>/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/CSharp%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%A3%8B/</url>
    
    <content type="html"><![CDATA[<p>控制台实现简易飞行棋</p><span id="more"></span><p><strong># 游戏逻辑流程图</strong><br>游戏逻辑题直接引用唐老狮课程里的流程图</p><p><strong>## 整体逻辑流程图</strong></p><img src="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/CSharp%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%A3%8B/%E6%95%B4%E4%BD%93%E9%80%BB%E8%BE%91%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class=""><p><strong>## 开始场景流程图</strong></p><img src="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/CSharp%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%A3%8B/%E5%BC%80%E5%A7%8B%E5%9C%BA%E6%99%AF%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class=""><p><strong>## 游戏场景流程图</strong></p><img src="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/CSharp%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%A3%8B/%E5%BC%80%E5%A7%8B%E5%9C%BA%E6%99%AF%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class=""><p><strong>## 结束场景流程图</strong></p><img src="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/CSharp%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%A3%8B/%E7%BB%93%E6%9D%9F%E5%9C%BA%E6%99%AF%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class=""><p><strong># 代码实现</strong></p><p>寄 不能实现前一个位置消失 结构体还没搞明白</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace CSharp基础实践教学&#123;    #region 格子结构体（写不来，看答案了）    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 格子类型枚举    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_GridType    &#123;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 普通格子        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Normal,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 炸弹        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Bomb,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 暂停        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Pause,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 时空隧道        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Tunnel,    &#125;    &#x2F;&#x2F;看答案的 可记住    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 位置信息结构体 包含x y位置    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    struct Vector2    &#123;        public int x;        public int y;        public Vector2(int x, int y)        &#123;            this.x &#x3D; x; this.y &#x3D; y;        &#125;    &#125;    &#x2F;&#x2F;格子结构体    struct Grid    &#123;        public E_GridType gridType; &#x2F;&#x2F;格子类型        public Vector2 position; &#x2F;&#x2F;格子位置        &#x2F;&#x2F;构造函数  输入格子位置  格子初始化        public Grid(E_GridType gridType, int x, int y)        &#123;            this.gridType &#x3D; gridType;            position.x &#x3D; x;             position.y &#x3D; y;        &#125;        &#x2F;&#x2F;画格子        public void Draw()        &#123;            &#x2F;&#x2F;控制光标位置  打印选项            Console.SetCursorPosition(position.x, position.y);            switch (gridType)            &#123;                &#x2F;&#x2F;普通格子                case E_GridType.Normal:                    Console.ForegroundColor &#x3D; ConsoleColor.White;                    Console.Write(&#39;□&#39;);                    break;                &#x2F;&#x2F;炸弹                case E_GridType.Bomb:                    Console.ForegroundColor &#x3D; ConsoleColor.Blue;                    Console.Write(&quot;‖&quot;);                    break;                &#x2F;&#x2F;暂停                case E_GridType.Pause:                    Console.ForegroundColor &#x3D; ConsoleColor.Red;                    Console.Write(&quot;●&quot;);                    break;                &#x2F;&#x2F;时空隧道                case E_GridType.Tunnel:                    Console.ForegroundColor &#x3D; ConsoleColor.White;                    Console.Write(&quot;¤&quot;);                    break;            &#125;        &#125;    &#125;    #endregion    #region 地图结构体（写不来，看答案了）    struct Map    &#123;        &#x2F;&#x2F;用一个格子结构体数组 表示地图里的所有格子        public Grid[] grids;        &#x2F;&#x2F;地图初始化构造函数        &#x2F;&#x2F;x, y为棋盘起始点        public Map(int x, int y)        &#123;            grids &#x3D; new Grid[84];            Random r &#x3D; new Random();            int randomNum;            for (int i &#x3D; 0; i &lt; 84; i++)            &#123;                &#x2F;&#x2F;应该初始化 格子类型                randomNum &#x3D; r.Next(0, 100);                &#x2F;&#x2F;设置类型 普通格子                &#x2F;&#x2F;有85%几率 是普通格子 (首尾两个格子 必为普通格子)                if(randomNum &lt; 85 || i &#x3D;&#x3D; 0 || i &#x3D;&#x3D; 95)                &#123;                    grids[i].gridType &#x3D; E_GridType.Normal;                &#125;                &#x2F;&#x2F;有5%几率 是炸弹                if (randomNum &gt;&#x3D; 85 &amp;&amp; randomNum &lt; 90)                &#123;                    grids[i].gridType &#x3D; E_GridType.Bomb;                &#125;                &#x2F;&#x2F;有5%几率 是暂停                if (randomNum &gt;&#x3D; 90 &amp;&amp; randomNum &lt; 95)                &#123;                    grids[i].gridType &#x3D; E_GridType.Pause;                &#125;                &#x2F;&#x2F;有5%几率 是时空隧道                if (randomNum &gt;&#x3D; 95 &amp;&amp; randomNum &lt; 100)                &#123;                    grids[i].gridType &#x3D; E_GridType.Tunnel;                &#125;                &#x2F;&#x2F;设置位置                grids[i].position &#x3D; new Vector2(x, y);                &#x2F;&#x2F;每次循环都应该一定规则去变化位置(每次少4个步长)                if( i &lt;&#x3D; 12 || (i &gt; 56 &amp;&amp; i &lt;&#x3D; 64)  )                &#123;                    y++;                &#125;                else if( (i &gt; 12 &amp;&amp; i &lt;&#x3D; 30) || (i &gt; 64 &amp;&amp; i &lt;&#x3D; 74) )                &#123;                    x +&#x3D; 2;                &#125;                else if( (i &gt; 30 &amp;&amp; i &lt;&#x3D; 42) || (i &gt; 74 &amp;&amp; i &lt;&#x3D; 78) )                &#123;                    y--;                &#125;                else if(( i &gt; 42 &amp;&amp; i &lt;&#x3D; 56) || (i &gt; 78 &amp;&amp; i &lt;&#x3D; 84) )                &#123;                    x -&#x3D; 2;                &#125;            &#125;        &#125;        public void Draw()        &#123;            for (int i &#x3D; 0; i &lt; grids.Length; i++)            &#123;                grids[i].Draw();            &#125;        &#125;    &#125;    #endregion    #region 玩家结构体    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 玩家类型    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_PlayerType    &#123;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 玩家        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        You,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 电脑        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        PC,    &#125;    struct Player    &#123;        public E_PlayerType playerType;        &#x2F;&#x2F;当前位置索引        public int nowIndex;        &#x2F;&#x2F;玩家初始化构造函数        public Player(E_PlayerType playerType, ref int nowIndex)        &#123;            this.playerType &#x3D; playerType;            this.nowIndex &#x3D; nowIndex;        &#125;        &#x2F;&#x2F;画玩家和电脑格子的逻辑 用索引得到所在地图上格子        public void DrawMove( Map mapinfo )        &#123;            &#x2F;&#x2F;从传入的地图得到格子信息            Grid grid &#x3D; mapinfo.grids[nowIndex];            &#x2F;&#x2F;先控制光标位置            Console.SetCursorPosition(grid.position.x, grid.position.y);            &#x2F;&#x2F;判断是画玩家还是电脑            switch(playerType)            &#123;                &#x2F;&#x2F;画玩家                case E_PlayerType.You:                    Console.ForegroundColor &#x3D; ConsoleColor.Cyan;                    Console.WriteLine(&quot;★&quot;);                    break;                case E_PlayerType.PC:                    Console.ForegroundColor &#x3D; ConsoleColor.Magenta;                    Console.WriteLine(&quot;▲&quot;);                    break;            &#125;        &#125;    &#125;    #endregion    internal class Program    &#123;        &#x2F;&#x2F;判断玩家和电脑是否重叠        static void DrawPlayer(Player you, Player PC, Map map)        &#123;            &#x2F;&#x2F;重合的话 Player结构体外部处理            if(you.nowIndex &#x3D;&#x3D; PC.nowIndex)            &#123;                &#x2F;&#x2F;得到重合的位置                Grid grid &#x3D; map.grids[you.nowIndex];                Console.SetCursorPosition(grid.position.x, grid.position.y);                Console.ForegroundColor &#x3D; ConsoleColor.Green;                Console.WriteLine(&quot;◎&quot;);            &#125;            &#x2F;&#x2F;不重合的话 Player结构体内部处理             else            &#123;                you.DrawMove(map);                PC.DrawMove(map);            &#125;        &#125;         static void Main(string[] args)        &#123;            #region 控制台基础设置            &#x2F;&#x2F;控制台大小设置  w表示宽  h表示高            int w &#x3D; 50;            int h &#x3D; 30;            ConsoleInit(w, h);            #endregion            #region 实现多个场景的转换            &#x2F;&#x2F;定义场景ID  初始从开始场景开始            &#x2F;&#x2F;开始场景为0  游戏场景为1  结束场景为2            int nowScene &#x3D; 0; ;            &#x2F;&#x2F;玩家获胜或者电脑获胜的信息            string gameOverInfo;            &#x2F;&#x2F;整体游戏逻辑死循环            while (true)            &#123;                &#x2F;&#x2F;用不同场景ID  进行不同的场景逻辑                &#x2F;&#x2F;用switch实现场景的转换                switch (nowScene)                &#123;                    &#x2F;&#x2F;开始场景                    case 0:                        &#x2F;&#x2F;实现开始场景逻辑                        #region 开始场景逻辑                        &#x2F;&#x2F;清空控制台  以后续添加文字与游戏                        Console.Clear();                        &#x2F;&#x2F;控制光标位置  打印标题                        Console.SetCursorPosition(w &#x2F; 2 - 5, 8);                        Console.Write(&quot;飞行棋小游戏&quot;);                        &#x2F;&#x2F;事先定义想要选择的选项ID 默认初始选择第一个选项(开始游戏)                        &#x2F;&#x2F;开始游戏为0  退出游戏为1                        int nowSelIndex &#x3D; 0;                        &#x2F;&#x2F;开始场景逻辑死循环                        while(true)                        &#123;                            #region 开始场景生成逻辑                                                        &#x2F;&#x2F;控制光标位置  打印选项                            Console.SetCursorPosition(w &#x2F; 2 - 3, 13);                            &#x2F;&#x2F;根据现在选中的选项改变选项的颜色(改变光标前景色)                            &#x2F;&#x2F;选中为红色 未选中为白色                            Console.ForegroundColor &#x3D; nowSelIndex &#x3D;&#x3D; 0 ? ConsoleColor.Red : ConsoleColor.White;                            Console.Write(&quot;开始游戏&quot;);                            &#x2F;&#x2F;逻辑同上                            Console.SetCursorPosition(w &#x2F; 2 - 3, 15);                            Console.ForegroundColor &#x3D; nowSelIndex &#x3D;&#x3D; 1 ? ConsoleColor.Red : ConsoleColor.White;                            Console.Write(&quot;退出游戏&quot;);                            &#x2F;&#x2F;定义玩家输入w为向上选择  输入s为向下选择  输入j为确定选择                            Console.SetCursorPosition(w &#x2F; 2 - 5, 20);                            Console.ForegroundColor &#x3D; ConsoleColor.Yellow;                            Console.Write(&quot;按w向上选择&quot;);                            Console.SetCursorPosition(w &#x2F; 2 - 5, 22);                            Console.ForegroundColor &#x3D; ConsoleColor.Yellow;                            Console.Write(&quot;按s向下选择&quot;);                            Console.SetCursorPosition(w &#x2F; 2 - 3, 24);                            Console.ForegroundColor &#x3D; ConsoleColor.Yellow;                            Console.Write(&quot;按j确定&quot;);                            #endregion                            #region 开始场景跳转逻辑                            &#x2F;&#x2F;因为break只能跳出最近的switch(即下文跳转场景的)  而为结束开始场景逻辑                              &#x2F;&#x2F;需要定义一个标识判断是否跳出开始场景逻辑死循环                            bool isQuitWhile &#x3D; false;                            &#x2F;&#x2F;获取玩家输入  且不显示玩家的输入                            char input &#x3D; Console.ReadKey(true).KeyChar;                            &#x2F;&#x2F;根据玩家输入  转换选中选项  与  确定选择                            switch(input)                            &#123;                                &#x2F;&#x2F;按w的逻辑  大小写Ww均可                                case &#39;W&#39;:                                case &#39;w&#39;:                                    &#x2F;&#x2F;实际上就是让选项ID变为0                                    --nowSelIndex;                                    &#x2F;&#x2F;且若已经是0 不能再减                                    if(nowSelIndex &lt; 0)                                    &#123;                                        nowSelIndex &#x3D; 0;                                    &#125;                                    break;                                &#x2F;&#x2F;按s的逻辑  大小写Ss均可                                case &#39;S&#39;:                                case &#39;s&#39;:                                    &#x2F;&#x2F;实际上就是让选项ID变为0                                    ++nowSelIndex;                                    &#x2F;&#x2F;且若已经是1 不能再加                                    if (nowSelIndex &gt; 1)                                    &#123;                                        nowSelIndex &#x3D; 1;                                    &#125;                                    break;                                &#x2F;&#x2F;按j的逻辑  大小写Jj均可                                case &#39;J&#39;:                                case &#39;j&#39;:                                                                       &#x2F;&#x2F;判断是进入哪个场景                                    &#x2F;&#x2F;进入游戏场景                                    if( nowSelIndex &#x3D;&#x3D; 0)                                    &#123;                                        &#x2F;&#x2F;将场景ID变为1                                        nowScene &#x3D; 1;                                        &#x2F;&#x2F;确定选择后就要进入其他场景  故必须跳出开始场景的死循环                                        &#x2F;&#x2F;即要使判断跳出标识置为true                                        isQuitWhile &#x3D; true;                                    &#125;                                    &#x2F;&#x2F;退出游戏                                    else if(nowSelIndex &#x3D;&#x3D; 1)                                    &#123;                                        &#x2F;&#x2F;关闭控制台(也不需要跳出循环了)                                        Environment.Exit(0);                                    &#125;                                    break;                            &#125;                            &#x2F;&#x2F;若isQuitWhile为true  则跳出开始场景循环                            if (isQuitWhile)                            &#123;                                break;                            &#125;                                #endregion                        &#125;                        #endregion                        break;                    &#x2F;&#x2F;游戏场景                    case 1:                        &#x2F;&#x2F;实现游戏场景逻辑                        #region 游戏场景逻辑                        #region 参数设置                        Console.Clear();                        &#x2F;&#x2F;退出while的标识                        bool isQuitGameWhile &#x3D; false;                        &#x2F;&#x2F;定义骰子的随机数                        Random d &#x3D; new Random();                        int dice;                        &#x2F;&#x2F;设置一个计数位选择是玩家动还是电脑动                        int count &#x3D; 0;                        &#x2F;&#x2F;设置玩家和电脑所在的格数 初始化为0                        int numYou &#x3D; 0;                        int numPC &#x3D; 0;                        &#x2F;&#x2F;设置玩家变量 电脑变量                        Player you &#x3D; new Player(E_PlayerType.You, ref numYou);                        Player PC &#x3D; new Player(E_PlayerType.PC, ref numPC);                        #endregion                        #region 红色墙壁                        DrawWall(w, h);                        #endregion                        #region 绘制棋盘                        Map map &#x3D; new Map(6, 3);                        map.Draw();                        #endregion                        #region 静态信息栏(每种格子类型的含义)                        Console.SetCursorPosition(2, h - 10);                        Console.ForegroundColor &#x3D; ConsoleColor.White;                        Console.WriteLine(&quot;□:普通格子&quot;);                        Console.SetCursorPosition(2, h - 9);                        Console.ForegroundColor &#x3D; ConsoleColor.Blue;                        Console.WriteLine(&quot;‖:暂停,一回合不动&quot;);                        Console.SetCursorPosition(26, h - 9);                        Console.ForegroundColor &#x3D; ConsoleColor.Red;                        Console.WriteLine(&quot;●:炸弹,倒退5格&quot;);                        Console.SetCursorPosition(2, h - 8);                        Console.ForegroundColor &#x3D; ConsoleColor.White;                        Console.WriteLine(&quot;¤:时空隧道,随机倒退,暂停,换位置&quot;);                        Console.SetCursorPosition(2, h - 7);                        Console.ForegroundColor &#x3D; ConsoleColor.Cyan;                        Console.WriteLine(&quot;★:玩家&quot;);                        Console.SetCursorPosition(12, h - 7);                        Console.ForegroundColor &#x3D; ConsoleColor.Magenta;                        Console.WriteLine(&quot;▲:电脑&quot;);                        Console.SetCursorPosition(22, h - 7);                        Console.ForegroundColor &#x3D; ConsoleColor.Green;                        Console.WriteLine(&quot;◎:玩家与电脑重合&quot;);                        #endregion                        #region 动态信息栏(你走几步 电脑走几步)                        Console.SetCursorPosition(2, h - 5);                        Console.ForegroundColor &#x3D; ConsoleColor.White;                        Console.WriteLine(&quot;按任意键开始扔骰子&quot;);                        #endregion                        &#x2F;&#x2F;先打印起始位置                        DrawPlayer(you, PC, map);                        &#x2F;&#x2F;玩家 电脑 是否暂停                        bool youPause &#x3D; false;                        bool PCPause &#x3D; false;                        &#x2F;&#x2F;游戏场景死循环 专门用来检测 玩家输入相关循环                        while (true)                        &#123;                                                            &#x2F;&#x2F;每次输入                            Console.ReadKey(true);                            dice &#x3D; d.Next(1, 7);                            if(youPause)                            &#123;                                &#x2F;&#x2F;玩家暂停一回合 让电脑走                                youPause &#x3D; false;                                count &#x3D; 1;                            &#125;                            if (PCPause)                            &#123;                                &#x2F;&#x2F;电脑暂停一回合 让玩家走                                PCPause &#x3D; false;                                count &#x3D; 0;                            &#125;                            switch (count)                            &#123;                                &#x2F;&#x2F;玩家移动                                case 0:                                    you.nowIndex +&#x3D; dice;                                    &#x2F;&#x2F;玩家的格子先超出地图数                                     if(you.nowIndex &gt; 83)                                    &#123;                                        gameOverInfo &#x3D; &quot;玩家获胜&quot;;                                        isQuitGameWhile &#x3D; true;                                        nowScene &#x3D; 2;                                        break;                                    &#125;                                    Grid grid1 &#x3D; map.grids[you.nowIndex];                                    switch (grid1.gridType)                                    &#123;                                        case E_GridType.Normal:                                            &#x2F;&#x2F;普通格子  切换到电脑移动                                            count++;                                            break;                                        case E_GridType.Bomb:                                            &#x2F;&#x2F;炸弹倒退5格                                            you.nowIndex -&#x3D; 5;                                            &#x2F;&#x2F;不能退出起点                                            if(you.nowIndex &lt; 0)                                            &#123;                                                you.nowIndex &#x3D; 0;                                            &#125;                                            break;                                        case E_GridType.Pause:                                            &#x2F;&#x2F;暂停一回合                                            youPause &#x3D; true;                                            break;                                        case E_GridType.Tunnel:                                            &#x2F;&#x2F;随机 倒退 暂停 和电脑交换位置                                            dice &#x3D; d.Next(1, 91);                                            if(dice &lt; 30) &#x2F;&#x2F;倒退                                            &#123;                                                you.nowIndex -&#x3D; 5;                                            &#125;                                            else if(dice &gt;&#x3D; 30 &amp;&amp; dice &lt;60) &#x2F;&#x2F;暂停                                            &#123;                                                youPause &#x3D; true;                                            &#125;                                            else &#x2F;&#x2F;和电脑交换位置                                            &#123;                                                int t &#x3D; you.nowIndex;                                                you.nowIndex &#x3D; PC.nowIndex;                                                PC.nowIndex &#x3D; t;                                            &#125;                                            break;                                    &#125;                                    DrawPlayer(you, PC, map);                                    &#x2F;&#x2F;切换到电脑移动                                                                    break;                                &#x2F;&#x2F;电脑移动                                case 1:                                    PC.nowIndex +&#x3D; dice;                                    if (PC.nowIndex &gt; 83)                                    &#123;                                        gameOverInfo &#x3D; &quot;电脑获胜&quot;;                                        isQuitGameWhile &#x3D; true;                                        nowScene &#x3D; 2;                                        break;                                    &#125;                                    DrawPlayer(you, PC, map);                                    Grid grid2 &#x3D; map.grids[PC.nowIndex];                                    switch (grid2.gridType)                                    &#123;                                        case E_GridType.Normal:                                            &#x2F;&#x2F;普通格子  切换到玩家移动                                            count--;                                            break;                                        case E_GridType.Bomb:                                            &#x2F;&#x2F;炸弹倒退5格                                            PC.nowIndex -&#x3D; 5;                                            &#x2F;&#x2F;不能退出起点                                            if (PC.nowIndex &lt; 0)                                            &#123;                                                PC.nowIndex &#x3D; 0;                                            &#125;                                            break;                                        case E_GridType.Pause:                                            &#x2F;&#x2F;暂停一回合                                            PCPause &#x3D; true;                                            break;                                        case E_GridType.Tunnel:                                            &#x2F;&#x2F;随机 倒退 暂停 和电脑交换位置                                            dice &#x3D; d.Next(1, 91);                                            if (dice &lt; 30) &#x2F;&#x2F;倒退                                            &#123;                                                PC.nowIndex -&#x3D; 5;                                            &#125;                                            else if (dice &gt;&#x3D; 30 &amp;&amp; dice &lt; 60) &#x2F;&#x2F;暂停                                            &#123;                                                PCPause &#x3D; true;                                            &#125;                                            else &#x2F;&#x2F;和电脑交换位置                                            &#123;                                                int t &#x3D; you.nowIndex;                                                you.nowIndex &#x3D; PC.nowIndex;                                                PC.nowIndex &#x3D; t;                                            &#125;                                            break;                                    &#125;                                    break;                            &#125;                                                        if (isQuitGameWhile)                            &#123;                                break;                            &#125;                        &#125;                        #endregion                            break;                    &#x2F;&#x2F;结束场景                    case 2:                        &#x2F;&#x2F;实现结束场景逻辑                        #region 结束场景逻辑                        &#x2F;&#x2F;清空控制台  以后续添加文字与游戏                        Console.Clear();                        &#x2F;&#x2F;控制光标位置  打印标题                        Console.SetCursorPosition(w &#x2F; 2 - 3, 8);                        Console.Write(&quot;Gameover&quot;);                        &#x2F;&#x2F;可变内容的显示 根据失败或成功 显示内容不同                        Console.ForegroundColor &#x3D; ConsoleColor.Green;                        Console.SetCursorPosition(w &#x2F; 2 - 4, 6);                                                &#x2F;&#x2F;事先定义想要选择的选项ID  默认初始选择第一个选项(重新开始)                        &#x2F;&#x2F;(重新开始为0  退出游戏为1)                        int nowSelEndIndex &#x3D; 0;                        &#x2F;&#x2F;开始场景逻辑死循环                        while (true)                        &#123;                            #region 结束场景生成逻辑                            &#x2F;&#x2F;控制光标位置  打印选项                            Console.SetCursorPosition(w &#x2F; 2 - 3, 13);                            &#x2F;&#x2F;根据现在选中的选项改变选项的颜色(改变光标前景色)                            &#x2F;&#x2F;选中为红色 未选中为白色                            Console.ForegroundColor &#x3D; nowSelEndIndex &#x3D;&#x3D; 0 ? ConsoleColor.Red : ConsoleColor.White;                            Console.Write(&quot;重新开始&quot;);                            &#x2F;&#x2F;逻辑同上                            Console.SetCursorPosition(w &#x2F; 2 - 3, 15);                            Console.ForegroundColor &#x3D; nowSelEndIndex &#x3D;&#x3D; 1 ? ConsoleColor.Red : ConsoleColor.White;                            Console.Write(&quot;退出游戏&quot;);                            &#x2F;&#x2F;定义玩家输入w为向上选择  输入s为向下选择  输入j为确定选择                            Console.SetCursorPosition(w &#x2F; 2 - 5, 20);                            Console.ForegroundColor &#x3D; ConsoleColor.Yellow;                            Console.Write(&quot;按w向上选择&quot;);                            Console.SetCursorPosition(w &#x2F; 2 - 5, 22);                            Console.ForegroundColor &#x3D; ConsoleColor.Yellow;                            Console.Write(&quot;按s向下选择&quot;);                            Console.SetCursorPosition(w &#x2F; 2 - 3, 24);                            Console.ForegroundColor &#x3D; ConsoleColor.Yellow;                            Console.Write(&quot;按j确定&quot;);                            #endregion                            #region 结束场景跳转逻辑                            &#x2F;&#x2F;因为break只能跳出最近的switch(即下文跳转场景的)  而为结束开始场景逻辑                              &#x2F;&#x2F;需要定义一个标识判断是否跳出开始场景逻辑死循环                            bool isQuitEndWhile &#x3D; false;                            &#x2F;&#x2F;获取玩家输入  且不显示玩家的输入                            char input &#x3D; Console.ReadKey(true).KeyChar;                            &#x2F;&#x2F;根据玩家输入  转换选中选项  与  确定选择                            switch (input)                            &#123;                                &#x2F;&#x2F;按w的逻辑  大小写Ww均可                                case &#39;W&#39;:                                case &#39;w&#39;:                                    &#x2F;&#x2F;实际上就是让选项ID变为0                                    --nowSelEndIndex;                                    &#x2F;&#x2F;且若已经是0 不能再减                                    if (nowSelEndIndex &lt; 0)                                    &#123;                                        nowSelEndIndex &#x3D; 0;                                    &#125;                                    break;                                &#x2F;&#x2F;按s的逻辑  大小写Ss均可                                case &#39;S&#39;:                                case &#39;s&#39;:                                    &#x2F;&#x2F;实际上就是让选项ID变为0                                    ++nowSelEndIndex;                                    &#x2F;&#x2F;且若已经是1 不能再加                                    if (nowSelEndIndex &gt; 1)                                    &#123;                                        nowSelEndIndex &#x3D; 1;                                    &#125;                                    break;                                &#x2F;&#x2F;按j的逻辑  大小写Jj均可                                case &#39;J&#39;:                                case &#39;j&#39;:                                    &#x2F;&#x2F;判断是进入哪个场景                                    &#x2F;&#x2F;进入游戏场景                                    if (nowSelEndIndex &#x3D;&#x3D; 0)                                    &#123;                                        &#x2F;&#x2F;将场景ID变为1                                        nowScene &#x3D; 1;                                        &#x2F;&#x2F;确定选择后就要进入其他场景  故必须跳出开始场景的死循环                                        &#x2F;&#x2F;即要使判断跳出标识置为true                                        isQuitEndWhile &#x3D; true;                                    &#125;                                    &#x2F;&#x2F;退出游戏                                    else if (nowSelEndIndex &#x3D;&#x3D; 1)                                    &#123;                                        &#x2F;&#x2F;关闭控制台(也不需要跳出循环了)                                        Environment.Exit(0);                                    &#125;                                    break;                            &#125;                            &#x2F;&#x2F;若isQuitEndWhile为true  则跳出结束场景循环                            if (isQuitEndWhile)                            &#123;                                break;                            &#125;                            #endregion                        &#125;                        #endregion                        break;                &#125;            &#125;            #endregion        &#125;        #region 控制台基础设置        static void ConsoleInit(int w, int h)        &#123;            &#x2F;&#x2F;隐藏光标            Console.CursorVisible &#x3D; false;            &#x2F;&#x2F;设置舞台（控制台）大小            Console.SetWindowSize(w, h);            &#x2F;&#x2F;设置缓冲区大小            Console.SetBufferSize(w, h);        &#125;        #endregion        #region 红色墙壁        static void DrawWall(int w, int h)        &#123;            &#x2F;&#x2F;设置颜色为红色            Console.ForegroundColor &#x3D; ConsoleColor.Red;            &#x2F;&#x2F;画墙            &#x2F;&#x2F;上方墙 下方墙 中间墙1 中间墙2            for (int i &#x3D; 0; i &lt;&#x3D; w - 2; i +&#x3D; 2)            &#123;                Console.SetCursorPosition(i, 0); &#x2F;&#x2F;上方墙                Console.Write(&#39;■&#39;);                Console.SetCursorPosition(i, h - 1); &#x2F;&#x2F;下方墙                Console.Write(&#39;■&#39;);                Console.SetCursorPosition(i, h - 11); &#x2F;&#x2F;中间墙1                Console.Write(&#39;■&#39;);                Console.SetCursorPosition(i, h - 6); &#x2F;&#x2F;中间墙2                Console.Write(&#39;■&#39;);            &#125;            &#x2F;&#x2F;左边墙 右边墙            for (int i &#x3D; 0; i &lt;&#x3D; h - 1; i++)            &#123;                Console.SetCursorPosition(0, i); &#x2F;&#x2F;左边墙                Console.Write(&#39;■&#39;);                Console.SetCursorPosition(w - 2, i); &#x2F;&#x2F;右边墙                Console.Write(&#39;■&#39;);            &#125;        &#125;        #endregion    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSharp入门总结</title>
    <link href="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/CSharp%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/"/>
    <url>/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/CSharp%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>入门总结</p><span id="more"></span><img src="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/CSharp%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/summary.png" class="">]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSharp基础总结</title>
    <link href="/2022/05/04/CSharp/CSharp%E5%9F%BA%E7%A1%80/CSharp%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"/>
    <url>/2022/05/04/CSharp/CSharp%E5%9F%BA%E7%A1%80/CSharp%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>基础总结</p><span id="more"></span><img src="/2022/05/04/CSharp/CSharp%E5%9F%BA%E7%A1%80/CSharp%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/summary.png" class="">]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>选择排序</title>
    <link href="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>2022.5.4</p><span id="more"></span><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>重点知识点：<br><strong>选择排序</strong><br>1.基本概念： 新建中间商 遍历依次比较找出极值 放入目标位置<br>2.套路写法：两层循环（外层轮数 内层寻找 初始索引 记录极值）<br>3.优化： 已经完成比较的不参与比较  加一个bool标识判断是否已经有序</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><img src="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/exam.png" class=""><p>以下是答案：</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson14_选择排序练习题&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;选择排序练习题&quot;);            #region 练习题1               &#x2F;&#x2F;生成随机数组            Random r &#x3D; new Random();            int[] arr &#x3D; new int[20];            for (int i &#x3D; 0; i &lt; arr.Length; i++)            &#123;                arr[i] &#x3D; r.Next(0, 101);            &#125;            &#x2F;&#x2F;选择排序升序排序            Console.WriteLine(&quot;选择排序升序排序结果:&quot;);            for (int m &#x3D; 0; m &lt; arr.Length; m++)            &#123;                int index &#x3D; 0;                int temp;                for (int n &#x3D; 0; n &lt; arr.Length - m; n++)                &#123;                    if (arr[index] &lt; arr[n])                    &#123;                        index &#x3D; n;                    &#125;                &#125;                if(index !&#x3D; arr.Length - m -1 )                &#123;                    temp &#x3D; arr[index];                    arr[index] &#x3D; arr[arr.Length - m - 1];                    arr[arr.Length - m - 1] &#x3D; temp;                &#125;            &#125;            for (int i &#x3D; 0; i &lt; arr.Length; i++)            &#123;                Console.Write(arr[i] + &quot; &quot;);            &#125;            &#x2F;&#x2F;中间间隔            Console.WriteLine();            Console.WriteLine(&quot;*************&quot;);            &#x2F;&#x2F;冒泡排序降序排序            Console.WriteLine(&quot;选择排序降序排序结果:&quot;);            for (int m &#x3D; 0; m &lt; arr.Length; m++)            &#123;                int index &#x3D; 0;                int temp;                for (int n &#x3D; 0; n &lt; arr.Length - m; n++)                &#123;                    if (arr[index] &gt; arr[n])                    &#123;                        index &#x3D; n;                    &#125;                &#125;                if (index !&#x3D; arr.Length - m - 1)                &#123;                    temp &#x3D; arr[index];                    arr[index] &#x3D; arr[arr.Length - m - 1];                    arr[arr.Length - m - 1] &#x3D; temp;                &#125;            &#125;            for (int i &#x3D; 0; i &lt; arr.Length; i++)            &#123;                Console.Write(arr[i] + &quot; &quot;);            &#125;            #endregion        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>冒泡排序</title>
    <link href="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>2022.5.4</p><span id="more"></span><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>重点知识点：<br><strong>冒泡排序</strong><br>1.基本概念： “无序”数组中两两相邻的数不断比较与交换直到“有序”<br>2.套路写法：两层循环（外层轮数 内层比较 满足则交换）<br>3.优化： 已经完成比较的不参与比较  加一个bool标识判断是否已经有序</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><img src="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/exam.png" class=""><p>以下是答案：</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson13_冒泡排序练习题&#123;    internal class Program    &#123;        #region 练习题2        &#x2F;&#x2F;冒泡排序函数        static void PaiXu( int[] arr, bool upDown)        &#123;            &#x2F;&#x2F;小优化 在循环外声明变量 可以提高一些性能            bool isSort;            int temp;            for (int m &#x3D; 0; m &lt; arr.Length; m++)            &#123;                isSort &#x3D; false;                for (int n &#x3D; 0; n &lt; arr.Length - 1 - m; n++)                &#123;                    if(upDown)                    &#123;                        if (arr[n] &gt; arr[n + 1])                        &#123;                            isSort &#x3D; true;                            temp &#x3D; arr[n];                            arr[n] &#x3D; arr[n + 1];                            arr[n + 1] &#x3D; temp;                        &#125;                    &#125;                    else                    &#123;                        if (arr[n] &lt; arr[n + 1])                        &#123;                            isSort &#x3D; true;                            temp &#x3D; arr[n];                            arr[n] &#x3D; arr[n + 1];                            arr[n + 1] &#x3D; temp;                        &#125;                    &#125;                &#125;                if (!isSort)                &#123;                    break;                &#125;            &#125;            if (upDown)            &#123;                Console.WriteLine(&quot;冒泡排序升序排序结果:&quot;);            &#125;            else            &#123;                Console.WriteLine(&quot;冒泡排序降序排序结果:&quot;);            &#125;            for (int i &#x3D; 0; i &lt; arr.Length; i++)            &#123;                            Console.Write(arr[i] + &quot; &quot;);            &#125;        &#125;        #endregion        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;冒泡排序练习题&quot;);            #region 练习题1            &#x2F;&#x2F;判断是否已经有序 标识符            bool isSort &#x3D; false;            &#x2F;&#x2F;生成随机数组            Random r &#x3D; new Random();            int[] arr1 &#x3D; new int[20];            for (int i &#x3D; 0; i &lt; arr1.Length; i++)            &#123;                arr1[i] &#x3D; r.Next(0, 101);            &#125;            &#x2F;&#x2F;冒泡排序升序排序            Console.WriteLine(&quot;冒泡排序升序排序结果:&quot;);            for(int m &#x3D; 0; m &lt; arr1.Length; m++)            &#123;                isSort &#x3D; false;                for(int n &#x3D; 0; n &lt; arr1.Length - 1 - m; n++)                &#123;                    if(arr1[n] &gt; arr1[n + 1])                    &#123;                        isSort &#x3D; true;                        int temp &#x3D; arr1[n];                        arr1[n] &#x3D; arr1[n + 1];                        arr1[n + 1] &#x3D; temp;                    &#125;                &#125;                if( !isSort )                &#123;                    break;                &#125;            &#125;            for(int i &#x3D; 0; i &lt; arr1.Length; i++)            &#123;                Console.Write(arr1[i] + &quot; &quot;);            &#125;            &#x2F;&#x2F;中间间隔            Console.WriteLine();            Console.WriteLine(&quot;*************&quot;);            &#x2F;&#x2F;冒泡排序降序排序            Console.WriteLine(&quot;冒泡排序降序排序结果:&quot;);            for (int m &#x3D; 0; m &lt; arr1.Length; m++)            &#123;                isSort &#x3D; false;                for (int n &#x3D; 0; n &lt; arr1.Length - 1 - m; n++)                &#123;                    if (arr1[n] &lt; arr1[n + 1])                    &#123;                        isSort &#x3D; true;                        int temp &#x3D; arr1[n];                        arr1[n] &#x3D; arr1[n + 1];                        arr1[n + 1] &#x3D; temp;                    &#125;                &#125;                if (!isSort)                &#123;                    break;                &#125;            &#125;            for (int i &#x3D; 0; i &lt; arr1.Length; i++)            &#123;                Console.Write(arr1[i] + &quot; &quot;);            &#125;            #endregion            &#x2F;&#x2F;中间间隔            Console.WriteLine();            Console.WriteLine(&quot;*************&quot;);            #region 练习题2            &#x2F;&#x2F;生成数组            int[] arr2 &#x3D; new int[20];            for (int i &#x3D; 0; i &lt; arr2.Length; i++)            &#123;                arr2[i] &#x3D; r.Next(0, 101);            &#125;            &#x2F;&#x2F;true代表升序排序 false代表降序排序            PaiXu( arr2, true);            &#x2F;&#x2F;中间间隔            Console.WriteLine();            Console.WriteLine(&quot;*************&quot;);            PaiXu( arr2, false);            #endregion        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月4日</title>
    <link href="/2022/05/04/diary/2022.5/2022%E5%B9%B45%E6%9C%884%E6%97%A5/"/>
    <url>/2022/05/04/diary/2022.5/2022%E5%B9%B45%E6%9C%884%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="ca17d6d80839b79c53b590df5936d99722a2d8593f839772f3c9ff00bcc3861c">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe5022d3d41ced9faff4c414d720080b2e532c1575e70f40aaaa88040ab450a6d1b0981729a275468a2721b3c204a6438005e1b5dd0eda5f210f00659b2455b19b448bfeb7c8941de5e1738392fcd8a90658b21cee475b6f6f7850c67a821be6789a381b5c6361d290687a364526d955099a05abcd6ca8f1caef52449ea73fe9ecc01d01c4dac98b49289d9b265518c538098ab70dfc8a28cb57379f527e9bd0a41b7ed937d545fc2ec58cbcb8e1836d320435d2f561d0b922aeefd20c5a25dd8bd482b3affd7788f1026b0d164a7a1200be4ab783d22b509cc73df2d4a874d0927a13e57e9ec51d570395fa33de0e935b103a40adc0cfe9ff993878099917f32a5a19d88c26393c99c0a4890ce9ff8564a79291510b8245fc819b0234d92ced7002d06feb702682424bbe6ab3322e9c0dbd3577666fb907d3216a13cc3cbd10869f2c9845eac2453c3363f1347ed6930624116787e8057962cc5e876f1a8aa89cd91c6b0f18a816b0ad8802c2c893771c661759aa20f59fadb7f1040662ad22398e09d575ce8ed41d9aeab6db4151b2948e28c5229464590834ddad0a940e32364b2e3c8d14458afbdfc789483484c8f258adb5c3faa2f4d91357f7d6c79ca83bb3ac087144bec966eb987b987ef814a4311ab886fb10d891ec7a453742f3faf3cdbe9545b4e543ed1022974eb5a499fc1d5d4acf78fa639948aa942b79af2d9fb253092f62af74adf84cedc58e522c50d20e8ecfb3e11c34f5edaa8d51de69d203dbe77a37e2178d21bae9e228c01061321d43002bda5dcf3e0a6714af76808dad9a16423791a676c4e6fb251bd2609d5b1adea9a7feb76a4a3fb6abb284b7de4aa2d12819871ef1469d3c4fa40fd7117c4bdd71bcc12738ac3ac2ed6fbb81a546a73511aeb0fda205c809615aec05f7d10edd4a61249d735f01843ea532b2aff4fed3afb9befaf5273192217c3f4dc2b0688271f585c76f41dd161360351247a0120360a70861bc6567d68c936eb575392ac8ccd8d9d37301b545f139307c88d27958347d808655a4bcbd9e524012d1ecf357c9953130f6834dfda6fb569a3b0db2074370860cb42f99fe730320a5549908fb11d3e1ada8913328b09f8910e1b0f9be670d6f16ae41c08ddb2baa5ea8be39be72bef47f792fd312f6a591964a4fcf60ae91793f4da790894159b69ee8eda7d54e722f14ecab819cf37c204f11f609b2201122ff5e24782387000c3e22ae5c1bc01de55aa50a7345e37ab938f3f51990237004b7a81f2e5d7a75ac3b877d9619025b31d1ae3b07c8dd55b60c815f3a320b13854e8c7a3646e7b12a5dc8f6b29c451c03265998681ebce942f031eb2d72354bba0fc68a4f7482ae1d51833f71101d4175e13dfa242bbc4864f067ed446c8526a2449682d90e9ec80760a2ecdcc3018651157b6897825d906c9ddd2d926d9d75121c9ebaf9b4cc8911651a854785d2c17c1f607214a02f0532e9a27700168d4df41faa35855366c4e62864c05f153b16b0496363f215fac5c7c4238c9bbd1cb87567af61ff4f9b4bbc54decb3c5a7cd68ac1ab0c4791acf83d7c521134889163bf5fb9d549103823c9ad35cb00240f06330d3e4ddd534831ca1a61f5efdf96e5b192d1849f61a225db50ba046c62150b561f719fdb8a4b9e53dfae29a476b50442398bdf55d5f2b992b11adf99b1e2a972ff8d3032d37ea4a1b7857396b42e5f4f97327daa6683fa4a0e6967a7a2377b7dda7d678d53b85e993c07d2a475af2152156804da9e6234dd1ff032fa4d4fed908990a59ac9e3e457a5715f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月3日</title>
    <link href="/2022/05/04/diary/2022.5/2022%E5%B9%B45%E6%9C%883%E6%97%A5/"/>
    <url>/2022/05/04/diary/2022.5/2022%E5%B9%B45%E6%9C%883%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="eca6d1fe149299d16fdebff137629187afd2b07ff353739ed1229d83d3640d27">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe5009c12dd1b715f42596ff4c88e24a0cfe8922606d46efa74ddbd9f5d3b426f56687102603786378470a4ecaae8b2313d0c003aaefde25d0f4bfa6cf8adcc4fbaa0a568aa7648f307311400a354664366507492f645fe02049bb0be8437ca7c835fca64706458d6fdd363a529564b60a3b26384e67ab2e038ad4b5d30b6a9c4925856a93271e13ba94afa16c26633b31e9ee540bb1ddb9f30dbc9f02df3101ce70b7d2d6b666fd3296fee8a9d4e1cd30d4e2808d3d23569489143fe1ce520c639063e2260f47b9a0435d49c601b499354313d5749d8dedd8f136d00fe0e3e3c2e078e7d7b8e484c261a9f9daefd65ce671fa990edd217fb86de23e9982edc3d0881d85390fd9fecf94c8b90918bb57a8ba3336b474952f80f1a08fc8634c8bcc0cb6d38bb2402a896db95b4f7356a1e11ada26cd4796de4a3c305847a1a2cab31f9794c08599ff6db9b0c4e89cb8aada39df07c2787d825ab709670194aa34c42a28e6d2b353bc49a39d7206a416b5f9a1db7705a31fd3378793c16f46334dff3101d76794745deaf80cea915eab7185931cce95ed77726e596ed18cd8418533fff97e9920cd9c00a880649087d082db0273ff52138bb8bcd3c7e58f3aac7f95ce6315df7225142d7485580499691c74ab94a1bd67ab7090999d80461c634d04653ce41bf84b6d17cd9af5fb85f31a7f132c467cb8f634b56c0ef59186ec1f561eaa4256804a827ca8f556e7afea92a81664dabaebfb2922af74339be92e7467846da05585de7ea69713758bb31bfb9be3</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构体</title>
    <link href="/2022/05/03/CSharp/CSharp%E5%85%A5%E9%97%A8/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <url>/2022/05/03/CSharp/CSharp%E5%85%A5%E9%97%A8/%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<p>2022.5.3</p><span id="more"></span><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>重点知识点：<br><strong>结构体</strong><br>1.概念： 结构体 struct 是变量和函数的集合 用来表示特定的数据集合<br>2.访问修饰符：用来修饰变量和方法  public-&gt;外部可以调用   private-&gt;只能内部调用   不写默认private<br>3.构造函数：没有返回值 函数名和结构体名相同 可以重载 主要是帮助我们快速初始化结构体对象</p><p>注意：<br>1.在结构体中声明的变量不能初始化  只能在外部或者函数中赋值（初始化）<br>2.在结构体中声明的函数 不用加static</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><img src="/2022/05/03/CSharp/CSharp%E5%85%A5%E9%97%A8/%E7%BB%93%E6%9E%84%E4%BD%93/exam.png" class=""><p>以下是答案：</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson12_结构体练习题&#123;    #region 练习题1    struct Student    &#123;               public string name;        public bool sex;        public int age;        public int lesson;        public string major;        public Student(string name, bool sex, int age, int lesson, string major)        &#123;            this.name &#x3D; name;                       this.sex &#x3D; sex;            this.age &#x3D; age;            this.lesson &#x3D; lesson;            this.major &#x3D; major;        &#125;        public void Information()        &#123;            Console.WriteLine(&quot;学员姓名&#123;0&#125;,性别&#123;1&#125;,年龄&#123;2&#125;,班级&#123;3&#125;,专业&#123;4&#125;&quot;, name, age, age, lesson, major);        &#125;    &#125;    #endregion    #region 练习题2    &#x2F;&#x2F;他们都是访问修饰符 用来修饰变量和方法    &#x2F;&#x2F;private 只能内部调用    &#x2F;&#x2F;public  外部可以调用    #endregion    #region 练习题3    struct Rectangular    &#123;        public int x;        public int y;        public Rectangular(int x, int y)        &#123;            this.x &#x3D; x;            this.y &#x3D; y;        &#125;        public void Information()        &#123;            Console.WriteLine(&quot;矩形的长为&#123;0&#125;,宽为&#123;1&#125;,面积为&#123;2&#125;,周长为&#123;3&#125;&quot;, x, y, x * y, 2 *(x + y));        &#125;    &#125;    #endregion    #region 练习题4    struct PlayerInfo    &#123;        public string name;        public E_Occupation occupation;                public PlayerInfo(string name, E_Occupation occupation)        &#123;            this.name &#x3D; name;            this.occupation &#x3D; occupation;                &#125;        public void AttackInformation()        &#123;            string o &#x3D; &quot;&quot;;            string s &#x3D; &quot;&quot;;            switch (occupation)            &#123;                case E_Occupation.Warrior:                    o &#x3D; &quot;战士&quot;;                    s &#x3D; &quot;冲锋&quot;;                    break;                case E_Occupation.Hunter:                    o &#x3D; &quot;猎人&quot;;                    s &#x3D; &quot;假死&quot;;                    break;                case E_Occupation.Witch:                    o &#x3D; &quot;法师&quot;;                    s &#x3D; &quot;奥术冲击&quot;;                    break;            &#125;            Console.WriteLine(&quot;&#123;0&#125;&#123;1&#125;施放了&#123;2&#125;&quot;, o, name, s);        &#125;    &#125;    enum E_Occupation    &#123;        Warrior,        Hunter,        Witch,    &#125;    #endregion    #region 练习题5    struct Monster    &#123;        public string name;        public int atk;        public Monster(string name)        &#123;            this.name &#x3D; name;            Random r &#x3D; new Random();            atk &#x3D; r.Next( 10, 30 );        &#125;        public void Atk()        &#123;            Console.WriteLine(&quot;&#123;0&#125;的攻击力是&#123;1&#125;&quot;, name, atk);        &#125;    &#125;    #endregion    #region 练习题7    struct UltraMan    &#123;        public string name;        public int atk;        public int def;        public int hp;        public UltraMan(string name, int atk, int def, int hp)        &#123;            this.name &#x3D; name;            this.atk &#x3D; atk;            this.def &#x3D; def;            this.hp &#x3D; hp;                   &#125;        &#x2F;&#x2F;结构体是值类型 想要在函数内部改变值类型信息 外部受影响 一定要用ref或out        public void Attack(ref Boss monster)        &#123;            &#x2F;&#x2F;奥特曼打怪兽的逻辑            monster.hp -&#x3D; atk - monster.def;            Console.WriteLine(&quot;&#123;0&#125;攻击了&#123;1&#125;，造成了&#123;2&#125;点伤害，&#123;1&#125;剩余血量&#123;3&#125;&quot;, name, monster.name, atk - monster.def, monster.hp);        &#125;    &#125;    struct Boss    &#123;        public string name;        public int atk;        public int def;        public int hp;        public Boss(string name, int atk, int def, int hp)        &#123;            this.name &#x3D; name;            this.atk &#x3D; atk;            this.def &#x3D; def;            this.hp &#x3D; hp;        &#125;        public void Attack(ref UltraMan Tiga)        &#123;            &#x2F;&#x2F;怪兽打奥特曼的逻辑            Tiga.hp -&#x3D; atk - Tiga.def;            Console.WriteLine(&quot;&#123;0&#125;攻击了&#123;1&#125;，造成了&#123;2&#125;点伤害，&#123;1&#125;剩余血量&#123;3&#125;&quot;, name, Tiga.name, atk - Tiga.def, Tiga.hp);        &#125;    &#125;    #endregion    internal class Program    &#123;                        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;结构体练习题&quot;);            #region 练习题1            Student s1 &#x3D; new Student(&quot;季宝&quot;, true, 23, 2, &quot;微电子&quot;);            Student s2 &#x3D; new Student(&quot;大逼&quot;, true, 23, 2, &quot;网安&quot;);            s1.Information();            s2.Information();            #endregion            #region 练习题3            Rectangular r1 &#x3D; new Rectangular (5, 4);            r1.Information();            #endregion            #region 练习题4            Console.Write(&quot;请输入玩家名字：&quot;);            string name &#x3D; Console.ReadLine();            Console.Write(&quot;请选择你的职业：（0战士，1猎人，2法师）&quot;);            try             &#123;                E_Occupation o &#x3D; (E_Occupation)int.Parse(Console.ReadLine());                PlayerInfo p1 &#x3D; new PlayerInfo(name ,o);                p1.AttackInformation();            &#125;            catch            &#123;                Console.WriteLine(&quot;请输入数字&quot;);            &#125;            #endregion            #region 练习题6            &#x2F;&#x2F;声明Monster数组            Monster[] monsters &#x3D; new Monster[10];            for (int i &#x3D; 0; i &lt; monsters.Length; i++)            &#123;                monsters[i] &#x3D; new Monster(&quot;怪兽&quot; + i);                monsters[i].Atk();            &#125;            #endregion            #region 练习题7            UltraMan Tiga &#x3D; new UltraMan(&quot;迪迦&quot;, 10, 5, 100);            Boss boss &#x3D; new Boss(&quot;哥斯拉&quot;, 8, 4, 100);            while(true)            &#123;                Tiga.Attack(ref boss);                if( boss.hp &lt;&#x3D; 0)                &#123;                    Console.WriteLine(&quot;迪迦胜利&quot;);                    break;                &#125;                boss.Attack(ref Tiga);                if (Tiga.hp &lt;&#x3D; 0)                &#123;                    Console.WriteLine(&quot;哥斯拉胜利&quot;);                    break;                &#125;                Console.WriteLine(&quot;按任意键继续&quot;);                Console.ReadKey(true);            &#125;            #endregion        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>递归函数</title>
    <link href="/2022/05/03/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/"/>
    <url>/2022/05/03/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>2022.5.3</p><span id="more"></span><h1 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h1><p>重点知识点：<br><strong>递归函数</strong><br>概念： 让函数自己调用自己<br>注意：<br>一个正确的递归函数<br>1.必须有结束调用的条件<br>2.用于条件判断的 这个条件必须改变 能够打到停止的目的</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><img src="/2022/05/03/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/exam.png" class=""><div class="code-wrapper"><pre><code class="csharp">using System;namespace Lesson11_递归函数练习题&#123;    internal class Program    &#123;        #region 练习题1        static void ZeroTen(int a)        &#123;            if(a &gt; 10)            &#123;                return;            &#125;            Console.WriteLine(a);            ZeroTen(++a);        &#125;        #endregion        #region 练习题2        static int Factorial(int a)        &#123;            if(a == 1)            &#123;                return 1;            &#125;            return a * Factorial(--a);//--a应写在后面, 或用a - 1            //若是 Factorial(--a) * a ,后面的a是已经减掉的a,得不到正确结果        &#125;        #endregion        #region 练习题3        static long SumFactorial(int a)        &#123;            if(a == 1)            &#123;                return 1;            &#125;            return Factorial(a) + SumFactorial(--a);        &#125;        #endregion        #region 练习题4        //自己写的        static double ZhuganLength1(int a)        &#123;            if(a == 0)            &#123;                return 100;            &#125;            return 0.5 * ZhuganLength1(--a);        &#125;        //答案        //一是长度 二是天数        static void ZhuganLength2(double length, int day = 0)        &#123;            length /= 2;            ++day;            //第十天砍了后的长度            if (day == 10)            &#123;                Console.WriteLine(&quot;第十天砍后竹竿长&#123;0&#125;米&quot;, length);                return;            &#125;                        ZhuganLength2(length, day);        &#125;        #endregion        #region 练习题5        //看答案的 想不出来短路怎么写        static bool PrintNum(int a)        &#123;            Console.WriteLine(a);                       return a == 200 || PrintNum(a + 1);             //逻辑短路，若逻辑或前面的为真，不执行逻辑或后面的        &#125;                #endregion        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;递归函数练习题&quot;);            //ZeroTen(0);            Console.WriteLine(Factorial(5));            Console.WriteLine(SumFactorial(10));            Console.WriteLine(ZhuganLength1(10));            ZhuganLength2(100, 0);            PrintNum(1);        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏设想(更新中)</title>
    <link href="/2022/05/03/project_game/%E6%B8%B8%E6%88%8F%E8%AE%BE%E6%83%B3-%E6%9B%B4%E6%96%B0%E4%B8%AD/"/>
    <url>/2022/05/03/project_game/%E6%B8%B8%E6%88%8F%E8%AE%BE%E6%83%B3-%E6%9B%B4%E6%96%B0%E4%B8%AD/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="085b8f3c7f5217256b375c6ae6075e8a8adae91a0ade8f8a94c33da807588fd2">1432a7b75e994fca526a11f4c4c29edb5d95ddd08071f06d8e2b1881f40addc49717d4ad2129bf03f288d888dddd593047eece5bda476a758cc60ea414b92c2fde57109810737be6114d7bc1b6b7562288492faa485ce10d9f6299e57b851357b155e4efdd34cbdd97c62497dc707a8984ec16459a2b29863b8efb819d6be55fee9506e4cffd6a89bbbd6344b2f51a0b1deb0385f3209dfde7e16b2730acd43ef49c7653d1401cc12f99952648c7e9fac2e3d036f71ac2a224d882c9eb52b53e8ce41ad4adcb845a1ece03152a88f6b9b4a60f385b7cd2bb197f64876a288ef21ea0f1cd6c1413b5bb87c41430ede2ee3757bf646cb9be07686a61467b31f274ec251a3402c81ab754e4f64b4371f59d3e48b066a9d4374932d26748038e8972751dbd5ccf58182e5c1ffdd89532c2b4d16f4e9e2f1d2ca1aff8bf2b9f1a02ec8cb9b08156183203b1e6d5d9e33805bdfdcf86d2d455b22f3cf0c5256eeeba4ecd62b87719f83f61c86654cd68f2d2cca26593c99c9d37ac15226c4abb48fd006cebb943c3977b2e1e46f10646380aed592825f2f183df4476ec6f707913e8fe88cf823b72bf2aec4dc26fc020a783d26174557db927ca6c764208fa1f0de861d954ea17ba42cba643a0d82b2a34bbe7d1add7f69f822495de81deabf3f37c59366a1ad681568c2d6c73d0fbbe10b4f00148cd62c7e8c8ca89963dfdd89ea0201c6163f7a9d843737c71d4c25a133621e9b429eac7b530ca1162fa2a9c8f83a78239efbf362a28152fd1812b3bd1306bc1ce235d6944e5c6352f6a6d6d14cda004f50ae8f27c35d7eb6ebe68e6246b1766d92f34bbd91f1aafd140c0bdc584aa53d91b49fc7bde567c308953bb3021801af6fcec8d469dd0f7c38b11f9383c63f733c54f7ec71d8221103ac971dd97a1510cb199dad83bda9253e38f3f945571</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数重载</title>
    <link href="/2022/05/03/CSharp/CSharp%E5%85%A5%E9%97%A8/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/"/>
    <url>/2022/05/03/CSharp/CSharp%E5%85%A5%E9%97%A8/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<p>2022.5.2</p><span id="more"></span><h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><p>重点知识点：<br><strong>函数重载</strong><br>概念： 同一个语句块中，函数名相同，参数数量、类型、顺序不同的函数 就称为函数重载<br>注意： 和返回值无关<br>作用： 一般用来处理不同参数的同一类型的逻辑处理</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><img src="/2022/05/03/CSharp/CSharp%E5%85%A5%E9%97%A8/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/exam.jpg" class=""><p>以下是答案：</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson10_函数重载练习题&#123;    internal class Program    &#123;        #region 练习题1        static int CompareNum(int a, int b)        &#123;            return a &gt; b ? a : b;        &#125;        static float CompareNum(float a, float b)        &#123;            return a &gt; b ? a : b;        &#125;        static double CompareNum(double a, double b)        &#123;            return a &gt; b ? a : b;        &#125;        #endregion        #region 练习题2        static int CompareArray(int[] arr)        &#123;            int max &#x3D; arr[0];            for (int i &#x3D; 1; i &lt; arr.Length; i++)            &#123;                if (arr[i] &gt; max)                    max &#x3D; arr[i];            &#125;            return max;        &#125;        static float CompareArray(float[] arr)        &#123;            float max &#x3D; arr[0];            for (int i &#x3D; 1; i &lt; arr.Length; i++)            &#123;               if (arr[i] &gt; max)                   max &#x3D; arr[i];            &#125;            return max;        &#125;        static double CompareArray(double[] arr)        &#123;            double max &#x3D; arr[0];            for (int i &#x3D; 1; i &lt; arr.Length; i++)            &#123;                f (arr[i] &gt; max)                   max &#x3D; arr[i];            &#125;            return max;        &#125;        #endregion        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;函数重载练习题&quot;);            #region 练习题1            Console.WriteLine(CompareNum(5, 7));            Console.WriteLine(CompareNum(10.9f, 4.5f));            Console.WriteLine(CompareNum(20.975, 100.45));            #endregion            #region 练习题2            int[] arrInt &#x3D; &#123; 1, 4, 5, 8, 6 &#125;;            Console.WriteLine(CompareArray(arrInt));            float[] arrFloat &#x3D; &#123; 2.1f, 4.5f, 5.9f, 8.1f, 5.8f &#125;;            Console.WriteLine(CompareArray(arrFloat));            double[] arrDouble &#x3D; &#123; 1.2, 4.5, 5.8, 8.4, 6.6, 8.5 &#125;;            Console.WriteLine(CompareArray(arrDouble));            #endregion        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月2日</title>
    <link href="/2022/05/02/diary/2022.5/2022%E5%B9%B45%E6%9C%882%E6%97%A5/"/>
    <url>/2022/05/02/diary/2022.5/2022%E5%B9%B45%E6%9C%882%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="491f82e74d100b7c0ea7a128893e0938270b929bd3c36f691cdf1082d62df28d">a03af1012de36d86e65bfb0d51f6ff10488d28acf4ffb3e9d40e31ff66292b18d63fe0d726a396877e15d0f45ea8c4d0fca64270b3af481bbf674539be9d74ef68c82a089e06187f209c1d9148866c6889149615508e1920a0ba4dfede99cd4f1c78d484984659bc16451c78231727151c61eb8e511e88202c667f6492a364b4675af00dab110af61f89478fb7bf1e08ab42759f2346284503e36031ddd429d25b0534f43dda5bdafe4e506c1c70035c6cadad563a3c2357e939054059579347b9934247a362a556c365ea249a8dc505ce1d6d8ca02cfccd72b2a108d0eb68d21f51ea413ffdda474e96f5fc9814f7bcc309066ecda23a2402bfb054e09fd25585ec506d740893f0a92fefe328df54c6c5e30ccee78c493458af915a8bd62d591845f1826a4e9bb303d3f4ffa2a0a630ea2eeca8a0aa24bf1fac84529eca1eca00b428e66ee56674f67df6893fb3b6638bf6072f6e9a9070d033dbce154ec5f4f8cf9a7a4f71745f97e5632413ce634d8752541d453cc1f8efc43cb6e55f4f5387885b68fb16745bbfeab5b3f794bfcf28fa185ee8184906a049f0af8ad88ad4f440aa03d10017a143f7f5d6205e3de25d9d59cfa3851b9f2e81f5696c8a2a346b46a76c157a9c2ec305a56e0d7731f4171170433961c676df299d8c595faf5781699895fd001cb183f0542a53f04e059eb4aa707eb1ebec51596a61e4214457d3198eed0cd1c0fe925ad8fc6bcd34e0e0461ee7011d206c6498b0d22654c77579c9cad6d84edd07b81589b80dead8c40e53fffe3640728be6c57f1adecc1adae8789b3531cecd41f4e7f4fdba0c51531d5582c3f825cc4baf81d38a72ab443582fd97b24a4ac9d6c1678f5112c39bfa42e025e83c92e477964c88db0c102230ac7f4629e91dcb511bb7ade9fd16c786601f7194bf912cbed763641345d003c7f4b338765e3cdddfa403c98b5c030f06481f4598c8aa5a297abeb1492047cf5ad3c8496b451b942ff3336266c3b224372060d667f3d6346ba3004f5b9a598335fbc69ab72aa78c648cbf86d34d7d87a21e3675b42c696d20f83b50d8dc483eaa7a111f3b1534d4e39bc38e09196cc7d43fa342fa1233c4f07e63b8a1b464e3d7e0129d364e1556e6087b43e6dced704a2f793fe41e9f717c15c74c85b78c76b947e4ce7bb47e343b6ac8217d74f905bbdf1fee49a8beb58026eb33f2767416d12bc9838b2d1f102cbd24687614dd3a6e17f1367e92340e9641400d3882c9cd747a9447b4ccf8ebb10700132e285d8abc7b51413191a46b696898772325468360fef28752ae0335b0cff4d8aa52466cfc1ce30fd9ee0f7636af2696c47d23e8c8cdeddd2c9d3909f2e3f8d8538a1c26a9fb47e56892a3d0d4e1c9ceb9112a9dca53101795505354efe7a809cb4af82ea138c98c207b9900c5c9ed067cc8f724ee174489e410bb86821f0862bae558c20657a113c556316f8222ff65e9859371f0cf0c759ecf953da0cda9f4b302962e44</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>变长参数和参数默认值</title>
    <link href="/2022/05/02/CSharp/CSharp%E5%85%A5%E9%97%A8/%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC/"/>
    <url>/2022/05/02/CSharp/CSharp%E5%85%A5%E9%97%A8/%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>2022.5.2</p><span id="more"></span><h1 id="变长参数和参数默认值"><a href="#变长参数和参数默认值" class="headerlink" title="变长参数和参数默认值"></a>变长参数和参数默认值</h1><p>重点知识点：<br><strong>1 变长参数关键字 params</strong><br>作用： 可以传入n个同类型参数 n可以是0<br>注意：<br>    1.params 后面必须是数组 意味着只能是同一类型的可变参数<br>    2.变长参数只能有一个<br>    3.必须在所有参数后面写变长参数</p><p><strong>2 参数默认值（可选参数）</strong><br>作用：可以给参数默认值 使用时可以不传参 不传用默认的 传了用传的<br>注意：<br>    1.可选参数可以有多个<br>    2.正常参数必须写在可选参数前面，可选参数只能写在所有参数的后面</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><img src="/2022/05/02/CSharp/CSharp%E5%85%A5%E9%97%A8/%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC/exam.jpg" class=""><p>以下是答案：</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson9_变长参数和参数默认值练习题&#123;    internal class Program    &#123;        #region 练习题1        static void SumAndAvg(params int[] arr)        &#123;            int sum &#x3D; 0;            for (int i &#x3D; 0; i &lt; arr.Length; i++)            &#123;                sum +&#x3D; arr[i];            &#125;            double avg &#x3D; sum &#x2F; (double)arr.Length;            Console.WriteLine(&quot;它们的和为&#123;0&#125;,平均数为&#123;1&#125;&quot;, sum, avg);        &#125;        #endregion        #region 练习题2        static void OddEven(params int[] arr)        &#123;            int odd &#x3D; 0, even &#x3D; 0;            for (int i &#x3D; 0; i &lt; arr.Length; i++)            &#123;                if(arr[i] % 2 &#x3D;&#x3D; 0)                &#123;                    even +&#x3D; arr[i];                &#125;                else                &#123;                    odd +&#x3D; arr[i];                &#125;            &#125;            Console.WriteLine(&quot;奇数和为&#123;0&#125;,偶数和为&#123;1&#125;&quot;, odd, even);        &#125;        #endregion        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;变长参数和参数默认值练习题&quot;);            #region 练习题1            SumAndAvg(5, 9, 11, 52);            #endregion            #region 练习题2            OddEven(10, 11, 12);            #endregion        &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ref和out</title>
    <link href="/2022/05/02/CSharp/CSharp%E5%85%A5%E9%97%A8/ref%E5%92%8Cout/"/>
    <url>/2022/05/02/CSharp/CSharp%E5%85%A5%E9%97%A8/ref%E5%92%8Cout/</url>
    
    <content type="html"><![CDATA[<p>2022.5.1</p><span id="more"></span><p>#ref和out</p><p>重点知识点：<br>1.ref和out的作用: 解决值类型和引用类型 在函数内部 改值 或者 重新声明 能够影响外部传入的变量 让其也被修改<br>2.使用上: 就是在声明参数的时候 前面加上ref和out的 关键字即可 使用时同上<br>3.区别：<br> 1.ref传入的变量必须初始化  out不用<br> 2.out传入的变量必须在内部赋值  ref不用</p><p>#练习题</p><img src="/2022/05/02/CSharp/CSharp%E5%85%A5%E9%97%A8/ref%E5%92%8Cout/exam.jpg" class=""><p>以下是答案：</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">static bool Login(int user, int key, ref string info)    &#123;        if(user == 0)        &#123;            //用户名正确的逻辑            if(key == 0)            &#123;                //用户名正确且密码正确的逻辑                info = &quot;登录成功&quot;;            &#125;            else            &#123;                //密码错误的逻辑                info = &quot;密码错误&quot;;                return false;            &#125;        &#125;        else        &#123;            //用户名错误的逻辑            info = &quot;用户名错误&quot;;            return false;        &#125;               return true;    &#125;static void Main(string[] args)    &#123;        Console.WriteLine(&quot;请输入用户名和密码&quot;);            int user = int.Parse(Console.ReadLine());            int key = int.Parse(Console.ReadLine());            string info = &quot;&quot;; //ref需要初始化            while (!Login(user, key, ref info)) //若登录失败继续尝试            &#123;                Console.WriteLine(info); //登录失败直接进入循环 打印登陆失败                Console.WriteLine(&quot;请输入用户名和密码&quot;);                user = int.Parse(Console.ReadLine()); //不需要再声明                key = int.Parse(Console.ReadLine());            &#125;            Console.WriteLine(info);    &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月1日</title>
    <link href="/2022/05/01/diary/2022.5/2022%E5%B9%B45%E6%9C%881%E6%97%A5/"/>
    <url>/2022/05/01/diary/2022.5/2022%E5%B9%B45%E6%9C%881%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="8231443e481bad21d3be8c11f026cef33b9d2ec10d2c75db8a6a3fc9353e6db7">a03af1012de36d86e65bfb0d51f6ff1082829027e374e7685fe9ab85e3524a611ae1849435e4e7a720cff75f6e0c69420b45613e2699125232dbe72ca80048bebea598f361ba86018511cca15b95988dc0cfaef36e0d9831c314d5a5c0c42027b37202a638339207f929734f64e08597cbddc5ea522252e2e02962224d8f2610c567a9905f51b07d0b9ecc25ce9b92d845f910467ef77166d775f3ecd0d5e21bf953b08187237aa313add55b1c228dd7d053f127c9a6a47c0c5a7938ac994063ac4002df1fa06e05aafb90d8bc2640f6cd006d7ed7c8863170e64e1bd6245c77b0fa8e735e224b950e1f54e78b0133b701d1403fb2cfdf2d386b43e9fbaa1451076e4191f3d354e3fffc715fac93c09b38122dd8cb11d8342dc0c89192430adca4b08219e517801151b2a0f8c9d9db1c25359477c00a5f8a9d1f4dde7f15395f067821cdc6c518b824eb6db732a6f9509e2879bd5d893c34ef5dd9fb4feedd57143b5d8aaf6a95442b8ceaff1b20ed7a0103ef67d68f97923d95e97146672a06d3dbddf62d8d0308409f487798bfb2890628acb6da93b261a2be6b203fc5941ccf4602858ff06456f1cd8549bb19df0507e01adc30cf1edc3cf2ec7b1df2a01b64cbd75040011043907e573076bddaa0b8a1fd0278e802bee90f5473a88a8c185022aba3ed8be34c76a5f6841409c505a1b3068b32090cb5b1185e0bf33fc4b5a25b6b0dd4bbf90f8dbe9dcd98b38b25733197162851b604f16a5d7772dc986f3421c043d218bb4333b43d9982b085bbab19f29923bf644069879a756156a5ec5b6d9ac660e35e9544558afb91261123bcc30f7e00c6a468fe4f57c4a11fc966a618fc6f22037b00a3579d3f3ed4935bf7fa8ea29659083c3065e01531f9ca0aa7c185eb275f06844f98e1d86241cec7c6516f3c1490ef92db64b4894aa8b258b0ba055d641c53dbc0ac122fcf5d310d795b7943c3d1894ebd7906d91214d99dddb8546ee1ffc8f85958f09c8cde59fe895fc0b50b36ec620446c4ddc9685f8caccdebeca493bfe948808fb00921585db583e011fd37c3d175b970b75715e00d4b7e12ec96c492a95b96e523bb5e176bb0f49b3ff8ca86fdb500a752bda74eee760803b291021a3b9f0126cd7bb23dd1e72f470659f85b746c63aacba02862c6854f0b1ed71aad37a7828628896f1d5102453015e7769e691b07182728455dafcbc3e954aac72ef8a611d29a2392426ab51e80c901b6d0f46356365fa9660c731b71e7105a4a38d26fbffc6e804be1de7dafd2888b15a688c5d0b44b925821bb280a6ad0b3e82e48cec923663f4c22edb27946f90144f4df62e0c193bfa4186c0436989434570289d5a8a70a5823b41e640d330234ebaee4eceb1523b43b168b8a107765dd1b102c41cd200d3899fa241b87e8473e40b0d49ac9044249d8f74419b7507518041f3d7aad9e2152b0f8f425906095dd601697acd1a70bf3f5f2f64a0d38118e03282f3ae2a9ab8c9cc695c9f64a8cc722703e6e6805e21245b11f8f26228b91e66bd1b6f8d3ded0181491370dad82bdd46863138d11c8c6e4c70811bbb0afa15a450570fba043e2aa477441cf006111f916f0f80445a7ce1780af01a2b8688c4f70a758f6e7579d5d3cf9ddcc6a1dc3a83744c3ceb40f10fb072cb04940867ea5d2e7d7373bc2201d1c30a976745440597f87dd867d870c146ef3d4277dea046a21e2c758895343dde22f37061758a16095030c3f2664f9abb1f771ac28e2f55925974c7771f54557e447ebb7bee6449d22e52053925b248b05ba706590eedf6e24c1ea9f3685b83fd21e20dc9a8fdd87bb65266ddf72d99eaca5f7786afca9b98817f3c1a32ff87f776475024dd53cdbabc996921be1a50d5478a6f92cbd1f05885dce23af78eb58979c608fc64d3adf796861c673610fd9bf47793893da8bfcc7d0c9217244cb8768e699c45fb85d0658640db520170b1a420b72d890b4d056ef168bba17bd957af12f5239e8ae0687848c2e630234b4b46f680c1bce2cbd9711dabba8425ab03056c3a5f9592d7745499784fd25ade98ca511819ce01db178db801b75528f8dddb4aaf68cfbd76889f8720f774514aff1ef12734bf07f573b716d746e1ac572d62c788de740b599cfd6705a91db8c2d0974f2fafa47072dc231e1634008624e648489d915542f3bf2343b56b8b41482638b9cff93a60fd1d221550bfe947e4fafc8f7666803db2210081228e94e2e143133f3b851c8a2f5524e0c612da970f01576fd2f2c704bb10d79e52c7b75d8ca01c7a7f1aae45e43de5b208a64c4006038a8cb</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
