<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2022年5月21日</title>
    <link href="/2022/05/21/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%8821%E6%97%A5/"/>
    <url>/2022/05/21/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%8821%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="25294449ad5488957ea695c17d0a15bdcae6240f381af4f590fa2131155ecccd">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50016237ab31399f3751c3548491ff8ed0c7517623ada711016ab0ae6da5280084fac8481a0de647ac2a1aac4d29092ab5c8a931972e1bbbd81a8f6e12576ef2be5c58eb692ba2fa896bc13446fb79173797e6addac0ceb52997a9145cf705168b3ebf7ad7b966557db6d276313b29f4882f2c466d2fdf819aa8578ab8226e1828be6ef6735bbf5310168b73763c451a5a0430473271182256454830cba5d299eb6c421d4ecc76d64b584a9f34d0f35eee8f22f2f1d1bd73eb38e39a46f3b892b1d9a27d08cb3090f42085ef2b815d7093e52b696c5c16bb4e23dee4dab55fc9b1335d6929ceaed121f8804226572b01caf71f87b46f2eb7469bba734972a300e9806c77d4bc8b28433568e4e81dd7aaf0540c0afdcf2042671d330db204845a599ba583186539e10380ba6db2ec9726a97bdb7797db4e62a68816cafa759f42520f2a12af1e13acded044b19e1359e17595071343cec63c29c94a263661d6722ec793955c049ac4ff430325d916d452d257830d702c26a9fc80b8b66ee1aee4a4feab3de1e4f0ae939d2552a471e7def37e7f64203384a08e3fb80b13a254876021666a071578565068c29491c6e03b0d38a513ee119226ee71604c9ad087a32fb2f5af1bb3b48fa6d4fb87d37edabdd522f51a327c26b383dc249344728c7e9ee92ee95e081b679b93aa5146d9abfb07a8c5f0ad5b7c3219bb605f2c5b5644a785077efacf1e8cf727e206ae3dec8c893846781fd8150304f7af96fb2b03d8e9b42b8e558279ff8c484e5c72d05c1919dc2e94a01e96e6bcdf70c79b176ac1a6b32e20ac2c7da6ad89b0961939cdef6b3dcfb6b575549908a970c7906711fe7c431ec0fb4770ad7d3767f7131446693310274e6f89da7d380b621bb848b5bf2f17cc38f944393dde3ee81f6095953688f59dff53b6c156bd0ea5e36d1ad292804a37434614357e382b47444190e6f791092aed5d0f393f94e87c12548256f6d22f98ed5e16c9839cefcba4cc249e08e98feb0844f8df4c8f40eda5688f141c008f9596eb9d835186c4e8d1af2c7474a70b1fed2e649b460812bb960ccb91738920d67a87dd045e22d8d48163f551d1b18b3e33ca837ca2c2e060a9568071088b938977d094c1bf77c64f90aa7f81a7276183f6886bcdbd702fae7e0e5ca926ade21ca03632cdfa3ac46718c6e8b5c0cfc3a1c05839e686c9c292ba399e458b1028ae6232dde4450c0b91a3a8a29f1e9112458500767a98eb065b2b96fad368f8783b9c196fb6a6ba1d96329cc04ae9fd6fb56a78ff11f226e25260fc959211df02e75820963478fee3fb842d1dd8c64e9d5ee858543419b4ee2d9e6412274b4cb530dbc02454baf4faf8e6b6e4378f7217f2f4dfda463178e168a2f752373313e8aaeec9fea07e3e57a28105a0e14060e6e62f11208a90fd5e0f8d896f950fe1a1c932a81b9f3f1ab2dee07ce0d3a6f9b197a0210db27ba3487a83624240fbc623a6610c1353049cf98f657a21afe78fe1edca0b850643e7349aa71524394cc55684a6069c691b1ef1083d4103b3e6ced984ef3fbb3305037349862d24f9f86336d29d16ffb4aad2f4667f4710b61365e6effc99e014044995fa4d31f0cd5c5ca24201db45bd1d8a764e6adc59693bc865deded1877fb0e0d814af586beac151bde53d72f13e5a2741b4d3bf6df948c23dd26d5eab68d324bc834ca3c59d32b93d71c53453756fa6ef166ca1d3218d4876a12d62ca433695ac0cd83cd4ac7073df4685143450d4a21b4c47b3881a0b9a74d125f6a540950aa98bcd32c753f7570a6adf728b9e4412aa7dcb8df59a6a764e61b0df145b1b469eb2ed612c4a546c249f3a14dec68d456d28fc8a085cd2133529d9d5107406fbb93badf656a357ac7e1913ea88850b50f66d68f07c6048bb6f42b0c2591ebbcb2ee5887e21ee48b73ff4597781ab4200ebbd84d6b18aa9c1eff6f889b4fcc5c6563d5d9f2eeae46aec89e95a7c9ed1067716d2f4d88875ee55a2f691cb7128d94f141b7a3ddcff50362dd7c22bad4f10dde9a925d0ae6b4fcf0a71ef5ddad81d9be2c1ba6a62bef673d8664ac7c85717775f50f7ae8f5a7e58ca6e824ce0ae55e56a3ee039c303d07c8b6caa5cd71b30b6a61fbcef6b123f6130bc73fe41e16f7d5e2e7310791af690047446a72e72648c11baabdb1868aa54801379f5c0869c2076a870d6234df742c4ac4fc6fa011bdcf93076828d0cdc1187d36d7105b55df6fdb4c07d73bed0ead660ab76c454108190cc3c91259937df90f4834d26b9ef60c1d6849981c1f3e498f7b9ca606b01254f9c47a335f95050266652ff19475c0c346b4a2c03c21d605efdca2c784f7f89d502555d52312cbe2b8178716ef970ba35c49bf5d87d7592958a0457964ad4a3cff1638b5d53b923b6be81531e13c37b9df5165e2c04a1</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">要密码，快滚.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月20日</title>
    <link href="/2022/05/19/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%8820%E6%97%A5/"/>
    <url>/2022/05/19/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%8820%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="8fac42808f01149c878ef2f2d7020868436faa65251f25dd5bb26ca1d1e26bba">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50477ff5b269e8ceb0cdcb67073e2e8fa77eb849c556241cfdc6a563d0301ed1d839b944fae7507f15d160de0be980dd1aba9380a4a321b232853b5e08ca31a843573f053791cd1802b784a9e046f70f255a43bca196e25c5f09a0970e507017aee56824e0c2bb418dcb3b5c3e7142b0f32af66cc08ff563c957652db3928e55d98acec026a987db89a5e6e9ea1c98db0f86e0b8b53e55eee67ec2ee0efdb101b2a6d66f6b58c4490983dc7efba61056a9caa977a39fd79c919506d628ad4134882428c79e23591122352382cca2cb9976ac48290e98e71fcbccaeacc401b00f3c3e48b31d522b62549550a3f0548d7a25</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">要密码，快滚.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口</title>
    <link href="/2022/05/19/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%A4%9A%E6%80%81/%E6%8E%A5%E5%8F%A3/"/>
    <url>/2022/05/19/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%A4%9A%E6%80%81/%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<p>接口</p><span id="more"></span><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>接口是行为的抽象规范，也是一种自定义类型<br>用于存储不同类的对象之间相同的方法<br>关键字：interface</p><p>声明规范：<br>1.不包含成员变量<br>2.只包含方法、属性、索引器、事件<br>3.成员不能被实现<br>4.成员可以不用写访问修饰符（默认public），不能是private<br>5.接口不能继承类，但是可以继承另一个接口</p><p>使用规范：<br>1.类可以继承多个接口<br>2.类继承接口后，必须实现接口中所有成员</p><h2 id="接口的声明及使用"><a href="#接口的声明及使用" class="headerlink" title="接口的声明及使用"></a>接口的声明及使用</h2><p>一句话记忆：接口是抽象行为的“基类”<br>接口命名规范：帕斯卡命名法前加I</p><p>接口用来继承：<br>1.类可以继承一个类,n个接口<br>2.继承了接口后,必须实现其中的内容,并且必须是public的<br>3.实现的接口函数,可以加virtual再写在子类里重写<br>4.接口也遵循里式替换原则</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;interface 接口名interface IFly&#123;    &#x2F;&#x2F;方法    void Fly();    &#x2F;&#x2F;属性    string Name    &#123;        get; &#x2F;&#x2F;不能有语句块,即默认自动属性        set;    &#125;    &#x2F;&#x2F;索引器    int this[int index]    &#123;        get;        set;    &#125;    &#x2F;&#x2F;事件    event Action doSomething;&#125; class Animal&#123;&#125;&#x2F;&#x2F;1.类可以继承一个类,n个接口class Person : Animal, Ifly&#123;    &#x2F;&#x2F;2.继承了接口后,必须实现其中的内容,并且必须是public的    &#x2F;&#x2F;3.实现的接口函数,可以加virtual再写在子类里重写    public virtual void Fly()    &#123;    &#125;    public string Name    &#123;        get;        set;    &#125;    public int this[int index]    &#123;        get;        set;    &#125;    public event Action doSomething;&#125;internal class Program&#123;    static void Main(string[] args)    &#123;        &#x2F;&#x2F;4.接口也遵循里式替换原则        IFly f &#x3D; new Person();        &#x2F;&#x2F;注意 IFly f &#x3D; new IFly();是错误的,接口是不能实例化的    &#125;&#125;</code></pre></div><h2 id="接口可以继承接口"><a href="#接口可以继承接口" class="headerlink" title="接口可以继承接口"></a>接口可以继承接口</h2><p>接口继承接口时,不需要实现<br>带类继承接口后,类自己要去实现所有内容</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">interface IWalk&#123;    void Walk();&#125;interface IMove : IWalk&#123;&#125;class Test: IMove&#123;    public void Walk();&#125;</code></pre></div><h2 id="显示实现接口"><a href="#显示实现接口" class="headerlink" title="显示实现接口"></a>显示实现接口</h2><p>当一个类继承两个接口,但是接口中存在着同名方法时<br>注意：显示实现接口时,不能写访问修饰符</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">interface IAtk&#123;    void Atk();&#125;interface ISuperAtk&#123;    void Atk();&#125;class Player : IAtk, ISuperAtk&#123;    &#x2F;&#x2F;显示实现接口,就是用接口名.行为名来实现    void IAtk.Atk()    &#123;            &#125;    void ISuperAtk.Atk()    &#123;    &#125;&#125;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/19/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%A4%9A%E6%80%81/%E6%8E%A5%E5%8F%A3/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson19_接口&#123;    interface IRegister    &#123;        void Register();    &#125;    class Person : IRegister    &#123;        public void Register()        &#123;            Console.WriteLine(&quot;个人请到派出所登记&quot;);        &#125;    &#125;    class Car : IRegister    &#123;        public void Register()        &#123;            Console.WriteLine(&quot;车辆请到车管所登记&quot;);        &#125;    &#125;    class House : IRegister    &#123;        public void Register()        &#123;            Console.WriteLine(&quot;房子请到房管局登记&quot;);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            &#x2F;&#x2F;可用数组实例化            IRegister p &#x3D; new Person();            p.Register();            IRegister c &#x3D; new Car();            c.Register();            IRegister h &#x3D; new House();            h.Register();        &#125;    &#125;&#125;</code></pre></div><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson19_接口&#123;    &#x2F;&#x2F;定义三个接口 1.飞 2.游泳    &#x2F;&#x2F;定义一个鸟类(因为鸟类都能走，走就不用接口)    &#x2F;&#x2F;飞    interface IFly    &#123;        void Fly();    &#125;    &#x2F;&#x2F;游泳    interface ISwim    &#123;        void Swim();    &#125;    &#x2F;&#x2F;鸟类，鸟类都能走，用抽象类及抽象方法    abstract class Bird    &#123;        public abstract void Walk();    &#125;    &#x2F;&#x2F;麻雀，能飞，不能游泳    class Sparrow : Bird, IFly    &#123;        public void Fly()        &#123;            Console.WriteLine(&quot;麻雀能飞&quot;);        &#125;        public override void Walk()        &#123;            Console.WriteLine(&quot;麻雀能走&quot;);        &#125;    &#125;    &#x2F;&#x2F;鸵鸟，不能飞，不能游泳    class Ostrich : Bird    &#123;        public override void Walk()        &#123;            Console.WriteLine(&quot;鸵鸟能走&quot;);        &#125;    &#125;    &#x2F;&#x2F;企鹅，不能飞，能游泳    class Penguin : Bird, ISwim    &#123;        public void Swim()        &#123;            Console.WriteLine(&quot;企鹅能游泳&quot;);        &#125;        public override void Walk()        &#123;            Console.WriteLine(&quot;企鹅能走&quot;);        &#125;    &#125;    &#x2F;&#x2F;鹦鹉，能飞，不能游泳    class Parrot : Bird, IFly    &#123;        public void Fly()        &#123;            Console.WriteLine(&quot;鹦鹉能飞&quot;);        &#125;        public override void Walk()        &#123;            Console.WriteLine(&quot;鹦鹉能走&quot;);        &#125;    &#125;    &#x2F;&#x2F;天鹅，能飞，能游泳    class Swan : Bird, IFly, ISwim    &#123;        public void Fly()        &#123;            Console.WriteLine(&quot;天鹅能飞&quot;);        &#125;        public void Swim()        &#123;            Console.WriteLine(&quot;天鹅能游泳&quot;);        &#125;        public override void Walk()        &#123;            Console.WriteLine(&quot;天鹅能走&quot;);        &#125;    &#125;    &#x2F;&#x2F;直升机    class Helicopter : IFly    &#123;        public void Fly()        &#123;            Console.WriteLine(&quot;直升机能飞&quot;);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            &#x2F;&#x2F;请自行实例化            Swan swan &#x3D; new Swan();            swan.Swim();            swan.Walk();            swan.Fly();        &#125;    &#125;&#125;</code></pre></div><h2 id="题3"><a href="#题3" class="headerlink" title="题3"></a>题3</h2><p><strong>本题关键：</strong><br>    public IUSB usb; </p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson19_接口&#123;    &#x2F;&#x2F;定义接口 USB接口    interface IUSB    &#123;        void ReadData();    &#125;    &#x2F;&#x2F;存储设备类,插在USB接口上可以读取设备名    class StorageDevice : IUSB    &#123;        public string name;        public StorageDevice(string name)        &#123;            this.name &#x3D; name;        &#125;        public void ReadData()        &#123;            Console.WriteLine(&quot;&#123;0&#125;正在传输数据&quot;, name);        &#125;    &#125;    &#x2F;&#x2F;MP3属于播放设备    class Mp3 : IUSB    &#123;        public void ReadData()        &#123;            Console.WriteLine(&quot;MP3正在传输数据&quot;);        &#125;    &#125;    &#x2F;&#x2F;用于实例化的电脑类,它有一个USB接口    class Computer    &#123;        &#x2F;&#x2F;声明一个接口成员，用于接口对接        public IUSB usb;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Computer computer &#x3D; new Computer();            StorageDevice mhd &#x3D; new StorageDevice(&quot;移动硬盘&quot;);            StorageDevice usbd &#x3D; new StorageDevice(&quot;U盘&quot;);            Mp3 mp3 &#x3D; new Mp3();            &#x2F;&#x2F;USB接移动硬盘            computer.usb &#x3D; mhd;            computer.usb.ReadData();            &#x2F;&#x2F;USB接U盘            computer.usb &#x3D; usbd;            computer.usb.ReadData();            &#x2F;&#x2F;USB接MP3            computer.usb &#x3D; mp3;            computer.usb.ReadData();        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>抽象类和抽象函数</title>
    <link href="/2022/05/19/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%A4%9A%E6%80%81/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%87%BD%E6%95%B0/"/>
    <url>/2022/05/19/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%A4%9A%E6%80%81/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>抽象类和抽象函数</p><span id="more"></span><h1 id="抽象类和抽象函数"><a href="#抽象类和抽象函数" class="headerlink" title="抽象类和抽象函数"></a>抽象类和抽象函数</h1><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>概念：<br>被抽象关键字abstract修饰的类<br>不希望被实例化的对象,相对比较抽象的类可以使用抽象类（水果等）</p><p>特点：<br>1.不能被实例化的类，但遵循里式替换原则（用父类容器装子类）<br>2.可以包含抽象方法<br>3.继承抽象类必须重写其抽象方法</p><h2 id="抽象函数"><a href="#抽象函数" class="headerlink" title="抽象函数"></a>抽象函数</h2><p>又称 纯虚方法<br>用abstract关键字修饰的方法</p><p>特点：<br>1.只能在抽象类中声明<br>2.没有方法体<br>3.不能是私有的<br>4.继承后必须实现 用override重写</p><p><strong>虚方法</strong>和<strong>抽象方法</strong>的异同：<br>相同点：<br>可以无限被子类重写<br>不同点：<br>1.<strong>抽象方法</strong>需要调用,必须用public或protected修饰,不能有函数体,只能在子类里override重写；<strong>虚方法</strong>一定有函数体,且里面可写可不写逻辑<br>2.<strong>抽象方法</strong>继承后必须实现；<strong>虚方法</strong>是子类里选择性实现的</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">abstract class Fruits&#123;    public string name;    &#x2F;&#x2F;因为抽象函数需要调用,必须用public或protected修饰    &#x2F;&#x2F;不能有函数体,只能在子类里override重写    abstract public void Bad();        public virtual void Test()    &#123;        &#x2F;&#x2F;虚方法一定有函数体,且里面可写可不写逻辑    &#125;&#125;class Apple : Fruits&#123;    &#x2F;&#x2F;虚方法是子类里选择性实现的    &#x2F;&#x2F;抽象方法继承后必须实现    public override void Bad()    &#123;        Console.WriteLine(&quot;苹果坏了&quot;);    &#125;&#125;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/19/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%A4%9A%E6%80%81/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%87%BD%E6%95%B0/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson18_抽象类和抽象函数&#123;    abstract class Animals    &#123;        abstract public void Speak();        &#125;    class People : Animals    &#123;        public override void Speak()        &#123;            Console.WriteLine(&quot;人叫&quot;);        &#125;    &#125;    class Dog : Animals    &#123;        public override void Speak()        &#123;            Console.WriteLine(&quot;狗叫&quot;);        &#125;    &#125;    class Cat : Animals    &#123;        public override void Speak()        &#123;            Console.WriteLine(&quot;猫叫&quot;);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Animals p &#x3D; new People();            p.Speak();            Animals d &#x3D; new Dog();            d.Speak();            Animals c &#x3D; new Cat();            c.Speak();        &#125;    &#125;&#125;</code></pre></div><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson18_抽象类和抽象函数&#123;    &#x2F;&#x2F;图形    abstract class Figure    &#123;        &#x2F;&#x2F;求面积        public abstract void Area();        &#x2F;&#x2F;求周长        public abstract void Perimeter();    &#125;    &#x2F;&#x2F;矩形    class Rectangular : Figure    &#123;        public int l;        public int w;        public Rectangular(int l, int w)        &#123;            this.l &#x3D; l;            this.w &#x3D; w;        &#125;        public override void Area()        &#123;            int s &#x3D; l * w;            Console.WriteLine(&quot;该矩形面积为&#123;0&#125;&quot;, s);        &#125;        public override void Perimeter()        &#123;            int c &#x3D; 2 * (l + w);            Console.WriteLine(&quot;该矩形周长为&#123;0&#125;&quot;, c);        &#125;    &#125;    &#x2F;&#x2F;矩形    class Square : Figure    &#123;        public int a;        public Square(int a)        &#123;            this.a &#x3D; a;        &#125;        public override void Area()        &#123;            int s &#x3D; a * a;            Console.WriteLine(&quot;该矩形面积为&#123;0&#125;&quot;, s);        &#125;        public override void Perimeter()        &#123;            int c &#x3D; 4 * a;            Console.WriteLine(&quot;该矩形周长为&#123;0&#125;&quot;, c);        &#125;    &#125;    &#x2F;&#x2F;圆形    class Circular : Figure    &#123;        public int r;        const float PI &#x3D; 3.1415926f;        public Circular(int r)        &#123;            this.r &#x3D; r;        &#125;        public override void Area()        &#123;            float s &#x3D; PI * r * r;            Console.WriteLine(&quot;该矩形面积为&#123;0&#125;&quot;, s);        &#125;        public override void Perimeter()        &#123;            float c &#x3D; 2 * r * PI;            Console.WriteLine(&quot;该矩形周长为&#123;0&#125;&quot;, c);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Figure r &#x3D; new Rectangular(2, 4);            r.Area();            r.Perimeter();            Figure s &#x3D; new Square(3);            s.Area();            s.Perimeter();            Figure c &#x3D; new Circular(5);            c.Area();            c.Perimeter();        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月19日</title>
    <link href="/2022/05/19/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%8819%E6%97%A5/"/>
    <url>/2022/05/19/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%8819%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="48556d71d8baf9e68f43b7588c0eaf2aa69ecb7fe05f9935211d77410ad8902c">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe507ad714b7d694638672ec89b6453f8a870b5aca629534dc9939024c47076fc51e739c6387f33ebf795ff8acfead750237dcc49917e7acc0ab1df7fa7d157ab40c60b4bd8d422cbc1a057c36715f8088e56f9a264298ce83d6a007eeb71f75eb25a79dab4cbe562ae542922a7cf369024d8217443f1445c3bf334157b3307265385f3c8e05c937977d5736dca1a94106d6366f4c9c7a60df78b9792646bc04efd2825fe45d9a0406c8f8dad3a49806d31918518ee754b8c1bb0963f861c62de92c1a82d5315ee20303e27032803a397fb7503caad7342a564396a134a24bba157a3bc47aa1db6cde81d43f49c1dbf2168409bba3be47e5de6d5dae9ef14fd96865b6c9ef2a47a9644abf121805c9e297fb093c75f68142b456ff6b8b6b11e157230f1d44f077ae942b1c5cb22c20a0cc5e51e6b83e775114368182356a827862f6263957cbf7725c29debaca3c57a27f52f48985792213cbadfb50f404c552f3830127c7aa7e86841c3e84f4f092bda3b8abca508fab6469573dede8c5c38f3dd1398f0e7c3a86ed3802abc8a26550161f7c114dda137c0a7205d1fa677e7d6e2a6f2237c09507e8afa5ad7c3eef4feb768ae2b5d5fc973fec0300c1246fc5d959c5306c32bb025c6edd7b9f5dfdd82b61c61b9820a8d57b50b7da20a132c7eb7bbcdf9998baa361b79abc7238f7b8de27</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">要密码，快滚.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VOB</title>
    <link href="/2022/05/18/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%A4%9A%E6%80%81/vob/"/>
    <url>/2022/05/18/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%A4%9A%E6%80%81/vob/</url>
    
    <content type="html"><![CDATA[<p>VOB</p><span id="more"></span><h1 id="VOB"><a href="#VOB" class="headerlink" title="VOB"></a>VOB</h1><h2 id="多态的概念"><a href="#多态的概念" class="headerlink" title="多态的概念"></a>多态的概念</h2><p>多态： 字面意思“多种状态”<br>让继&#x3D;继承同一父类的子类们，在执行相同方法时有不同表现（状态）</p><p>主要目的：<br>同一父类的对象 执行相同行为（方法）有不同的表现</p><p>解决的问题：<br>让同一个对象有唯一行为的特征</p><h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2><p>使同一种方法在不同对象下有不同表现</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Father&#123;    public void SpeakName()    &#123;        Console.WriteLine(&quot;Father的方法&quot;);    &#125;&#125;class Son : Father&#123;    public new void SpeakName()    &#123;        Console.WriteLine(&quot;Son的方法&quot;);    &#125;&#125;internal class Program&#123;    static void Main(string[] args)    &#123;        Father f &#x3D; new Son();        f.SpeakName(); &#x2F;&#x2F;打印Father的方法        (f as Son).SpeakName(); &#x2F;&#x2F;打印Son的方法    &#125;&#125;</code></pre></div><h2 id="多态的实现"><a href="#多态的实现" class="headerlink" title="多态的实现"></a>多态的实现</h2><p>函数重载 就是一种编译时的多态</p><p>运行时的多态：<br>(VOB, 抽象函数, 接口)<br>V:  virtual 虚函数<br>O:  override 重写<br>B:  base 父类</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class GameObject&#123;    public string name;    public GameObject(string name)    &#123;        this.name &#x3D; name;    &#125;    &#x2F;&#x2F;虚函数 可以被子类重写    public virtual void Atk()    &#123;        Console.WriteLine(&quot;游戏对象进行攻击&quot;);    &#125;&#125;class Player : GameObject&#123;    public Player(string name): base (name)    &#123;    &#125;    public override void Atk()    &#123;        &#x2F;&#x2F;base代表父类,可以通过base来保留父类的行为        base.Atk();        Console.WriteLine(&quot;玩家对象进行攻击&quot;);    &#125;&#125;internal class Program&#123;    static void Main(string[] args)    &#123;        GameObject p &#x3D; new Player(&quot;大逼&quot;);        p.Atk(); &#x2F;&#x2F;先打印父类行为&quot;游戏对象进行攻击&quot;,再打印子类行为&quot;玩家对象进行攻击&quot;    &#125;&#125;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/18/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%A4%9A%E6%80%81/vob/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson17_VOB&#123;    &#x2F;&#x2F;鸭子    class Duck    &#123;        public virtual void Quack()        &#123;            Console.WriteLine(&quot;真的鸭子嘎嘎叫&quot;);        &#125;    &#125;        &#x2F;&#x2F;木头鸭子    class WoodDuck : Duck    &#123;        public override void Quack()        &#123;            Console.WriteLine(&quot;木头鸭子吱吱叫&quot;);        &#125;    &#125;    &#x2F;&#x2F;木头鸭子    class RubberDuck : Duck    &#123;        public override void Quack()        &#123;            Console.WriteLine(&quot;橡皮鸭子唧唧叫&quot;);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Duck d &#x3D; new Duck();            d.Quack();            Duck wd &#x3D; new WoodDuck();            wd.Quack();            Duck rd &#x3D; new RubberDuck();            rd.Quack();        &#125;    &#125;&#125;</code></pre></div><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson17_VOB&#123;    &#x2F;&#x2F;员工    class Worker    &#123;        public virtual void ClockIn()        &#123;            Console.WriteLine(&quot;员工9点打卡&quot;);        &#125;    &#125;        &#x2F;&#x2F;经理    class Manager : Worker    &#123;        public override void ClockIn()        &#123;            Console.WriteLine(&quot;经理10点打卡&quot;);        &#125;    &#125;    &#x2F;&#x2F;程序员    class Programmer : Worker    &#123;        public override void ClockIn()        &#123;            Console.WriteLine(&quot;程序员不打卡&quot;);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Worker w &#x3D; new Worker();            w.ClockIn();            Worker m &#x3D; new Manager();            m.ClockIn();            Worker p &#x3D; new Programmer();            p.ClockIn();        &#125;    &#125;&#125;</code></pre></div><h2 id="题3"><a href="#题3" class="headerlink" title="题3"></a>题3</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson17_VOB&#123;    &#x2F;&#x2F;图形    class Figure    &#123;        &#x2F;&#x2F;求面积        public virtual void Area()        &#123;                    &#125;        &#x2F;&#x2F;求周长        public virtual void Perimeter()        &#123;                    &#125;    &#125;        &#x2F;&#x2F;矩形    class Rectangular : Figure    &#123;        public int l;        public int w;        public Rectangular(int l, int w)        &#123;            this.l &#x3D; l;            this.w &#x3D; w;        &#125;        public override void Area()        &#123;            int s &#x3D; l * w;            Console.WriteLine(&quot;该矩形面积为&#123;0&#125;&quot;, s);        &#125;        public override void Perimeter()        &#123;            int c &#x3D; 2 * ( l + w );            Console.WriteLine(&quot;该矩形周长为&#123;0&#125;&quot;, c);        &#125;    &#125;    &#x2F;&#x2F;矩形    class Square : Figure    &#123;        public int a;        public Square(int a)        &#123;            this.a &#x3D; a;        &#125;        public override void Area()        &#123;            int s &#x3D; a * a;            Console.WriteLine(&quot;该矩形面积为&#123;0&#125;&quot;, s);        &#125;        public override void Perimeter()        &#123;            int c &#x3D; 4 * a;            Console.WriteLine(&quot;该矩形周长为&#123;0&#125;&quot;, c);        &#125;    &#125;    &#x2F;&#x2F;圆形    class Circular : Figure    &#123;        public int r;        const float PI &#x3D; 3.1415926f;        public Circular(int r)        &#123;            this.r &#x3D; r;        &#125;        public override void Area()        &#123;            float s &#x3D; PI * r * r;            Console.WriteLine(&quot;该矩形面积为&#123;0&#125;&quot;, s);        &#125;        public override void Perimeter()        &#123;            float c &#x3D; 2 * r * PI;            Console.WriteLine(&quot;该矩形周长为&#123;0&#125;&quot;, c);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Figure r &#x3D; new Rectangular(2, 4);            r.Area();            r.Perimeter();            Figure s &#x3D; new Square(3);            s.Area();            s.Perimeter();             Figure c &#x3D; new Circular(5);            c.Area();            c.Perimeter();        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月18日</title>
    <link href="/2022/05/18/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%8818%E6%97%A5/"/>
    <url>/2022/05/18/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%8818%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="a1e0b094e8144ae808b5fe252e93194749f564d6cb90a8ab16d5e443fa35d2ed">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50fdd0ca3edc57389bd0e88084b7db20234a98291e286b22bc2d9be6b79caf6bf12130a2f5b91531b1c2ee2bef6a4ff1d8c15e8e38553d8e073e69dc788ad2d52a364479e47d567e379b2b5f22a15dd3f53ed0be8d7b7ac692e45812a8642a5013db4da0a2531fb7bef6e2a9fa0e5e808ed727a568dad693f59ed95f6ffe6a7e24ff2ff6967f54ab0f69c8ca23b9c98cd27e876da11d20abca0ca2c245ef90e43ffd9ec833befc129cff54213bf9b7cfa3977a914f7d9c895a44811d12494185a208b05934c2fbe11794024a855b1b8292dffc89e2a5223cda59d9991ef84a05ccb27919e2f95988af7f72a28fc191be507b43da1f47428a47453e846a14cd1e274f02e6ca983f88f4f142e3f2c9343f8075ff1934c861f87ea7a678a7981bc3c19514cae9fa3af4887d16a7da8a568d4fad930f4542bbdf796c578ba19a225b1572572d7dab49843e81a4b6da463d56ed423f11995ab1abf487a51498cff56ad2e6f9ff0b0e53eb19dbf206b70a912c27d680af9d0c42942630d7bf9d507a864f56fd77d1c8d95c0d7ac0629d30dd043d8d6d97a1949c6438f14d3bd667abca6308f4aebc2ccf7a60ac066aad0d1b8e61c929f1b90e970bd20ab752a60425808eb43f6e8e7aef4cb262d4f692ff6a18130ce4cc70e193fd803a9bda42e65a615af7749a391ffd7463696f01b30bb24fa4d9e17ff89549deb07cce53e04e2327172d96fb48ee090e7f34a68a2913bbe2e2a45e95d83d217c7a020ac19ae25559a80f7bcba224f98cce420a63cf3f3292efa71df421d973aba683f860011ee439bee17318f3d49c44da527a6081446bd5e7ece325cf6dd36007629d6e5b095276e3c060ed84fd29830a39aa86a4fd681b3a0491e85bf9f48d0946d71f31ec446342e5792898853d2db62eae8ca66ee2d66176d9352f14780f1801d3bcd9550aae1cc988a96f89805bf6406739bea117900d35834cfc0e8e30de1edf7ff16353ea599f5bf118128db41e7fa6e5947794915fb94a564ce80f9332061b5d8d3eb44caaa8d7d9648e0d1feff08e6711c7fc625661e19f1b42bc19638b8c5a0e28ba2b9523010163f111a7321002c5f5bef758114ffbb1b459e49dfbbb3198c0514b830fbea234508b2a242682d2739da6138e7afe3d13b7f79d97b78e65821f024a6820f8fa65e9e4e9f2984c59a3877023b2ef7d56bc0b3b018ea5bffdbe47b41a4c3cc5165b8067e63fcc8ab842353c385c42eb6c4d86d5bc52f55303f4b1ae4b5f7b8384e2f36ab3b6804427a8abadc8a054754579e3ab6449264f1bdd54125de4f1</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">要密码，快滚.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月17日</title>
    <link href="/2022/05/17/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%8817%E6%97%A5/"/>
    <url>/2022/05/17/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%8817%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="18704ebd8b16e1e9d2ad672a38c56040c3530adf64cbb4ba074124c2c9298010">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50fdd0ca3edc57389bd0e88084b7db2023f42eee7650a2032f2b23d7fd0fc253e4226e332027f8095b3a83a4b6176d19d0e1c37b7629e1188d5ac39265ba057e9e1cf18cfe6a7cd96bc3f0901e5db825e9e3f9dbae55f8c66f0ba77b55c50cd309ebcff3e2b6613838ec0a63d0d269441e6bee4ac22ccbb92c2f0cba5b4d195235fc0d1b9f47d5ec7245165cdd15ea9b4a8e6a6472bc511d383f802ed4a5eaf65df3b2528fb45c1e45df243eeb9a98e204775e74bd28b5ff42eeba70b1553e5c75f79e45e2dc818d428521c8ba05d608c96c63632d35f3813c9e8c0867f10f6ba4e2ddb54996ee938beac164f268acc5fd0b444f866bb27bd1c7fffcf4c41eb9407ac14b8c3bd9924dd726607fe2ece45b0aaed379d5aac22bb0e62c6874c4807341a7fb6b3ed22521331f28fafb35c1683e91f33e21d08a7a9fd5d68ab5953690f2294c0cd7152964996a673d7c7b88367ede816d7a6cbdb44b48c4fda4ad489955eb35c717be379f8ca429b15cfaf20c1c1f2f847a82e5519fb9fc4b888024a7a3b87ce5b60f43196a55ff1273e05e4ac26ec482932bc0d61d0c3872efad7b493030cda9a722ad0cd5a956e0883bbb626d9eebb84abbe197885dbd61725dcfa5d47fb2220147677d3b9254f2b8b3af50bb20e941d583ff887a901f1e7b95202a4fed455b6637d1fc89c6b7da80cce79f7131102cf2dd99e95dfaf625d973f63196dee5026d286da82794f1166a43ae014901c4e13422c935fd4d0d9caa72e161ac49c38493761807c49d2aeddfa01036af2d7d1a1c196ba83a311f7443eeb964</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">要密码，快滚.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>密封类</title>
    <link href="/2022/05/17/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E5%AF%86%E5%B0%81%E7%B1%BB/"/>
    <url>/2022/05/17/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E5%AF%86%E5%B0%81%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>密封类</p><span id="more"></span><h1 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>密封类：使用sealed密封关键字修饰的类<br>作用：让类无法再被继承</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">sealed class 类名</code></pre></div><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>不允许最底层子类被继承，保证程序的规范性、结构性、安全性</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/17/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E5%AF%86%E5%B0%81%E7%B1%BB/exam.png" class=""><p>没设置自定义乘客数量、途径站点数</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson16_密封类&#123;    sealed class Carrier    &#123;        &#x2F;&#x2F;两站间隔1km        int s &#x3D; 1000;        &#x2F;&#x2F;载具速度        int speed;        &#x2F;&#x2F;最大速度100m&#x2F;min        int speedMax &#x3D; 100;        &#x2F;&#x2F;最大可乘10人,包含司机        int maxNumber &#x3D; 10;                &#x2F;&#x2F;上车人数        public int onNum &#x3D; 0;        &#x2F;&#x2F;下车人数        public int offNum &#x3D; 0;        &#x2F;&#x2F;乘客数组        public bool[] passengers &#x3D; new bool[10];        &#x2F;&#x2F;上下车人数的随机数,载具速度的随机数        Random r &#x3D; new Random();        &#x2F;&#x2F;逻辑上先上车再下车        &#x2F;&#x2F;上车 + 下车        public void GetOnOff(ref int nowNum)        &#123;             &#x2F;&#x2F;上车人数不能超过总人数            onNum &#x3D; r.Next(10 - nowNum);            Console.Write(&quot;上车&#123;0&#125;人  &quot;, onNum);            for (int i &#x3D; nowNum; i &lt; nowNum + onNum; i++)            &#123;                passengers[i] &#x3D; true;            &#125;            &#x2F;&#x2F;下车人数不能超过原已上车人数            offNum &#x3D; r.Next(nowNum);             Console.Write(&quot;下车&#123;0&#125;人  &quot;, offNum);            for (int i &#x3D; nowNum + onNum - 1; i &gt;&#x3D; nowNum + onNum - offNum; i--)            &#123;                passengers[i] &#x3D; false;            &#125;            &#x2F;&#x2F;更新已上车人数            nowNum &#x3D; nowNum + onNum - offNum;        &#125;        &#x2F;&#x2F;行驶 打印多久到下一站 按任意键到下一站        public void Drive()        &#123;            &#x2F;&#x2F;载具速度            speed &#x3D; r.Next(50, speedMax + 1);            Console.WriteLine(&quot;耗时&#123;0&#125;分钟,到达下一站&quot;, s&#x2F;speed);                &#125;        &#x2F;&#x2F;车祸        public void Accident()        &#123;            Console.WriteLine(&quot;很不幸,发生了车祸&quot;);            Environment.Exit(0);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            &#x2F;&#x2F;定义一个随机数,判断是否车祸            Random r &#x3D; new Random();            &#x2F;&#x2F;默认一开始没人上车,即乘客全为false            Carrier c &#x3D; new Carrier();            &#x2F;&#x2F;已上车人数 初始为0            int nowNum &#x3D; 0;            &#x2F;&#x2F;计数到站数,设一共10站            int set &#x3D; 0;            for (int i &#x3D; 0; i &lt; c.passengers.Length; i++)            &#123;                c.passengers[i] &#x3D; false;            &#125;            Console.WriteLine(&quot;现在从始发站开始出发,车上无乘客&quot;);            while(true)            &#123;                Console.WriteLine(&quot;请按任意键前往下一站&quot;);                Console.WriteLine(&quot;&quot;);                Console.ReadKey(true);                                &#x2F;&#x2F;95%的概率正常行驶,5%的概率出车祸                if ( r.Next(101) &lt;&#x3D; 95 )                &#123;                    c.Drive();                    c.GetOnOff(ref nowNum);                    Console.WriteLine(&quot;现在车上有&#123;0&#125;人&quot;, nowNum);                    set++;                &#125;                else                &#123;                    c.Accident();                &#125;                if( set &#x3D;&#x3D; 10 )                &#123;                    Console.WriteLine(&quot;\n已到达终点站&quot;);                    Environment.Exit(0);                &#125;            &#125;         &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>万物之父和装箱拆箱</title>
    <link href="/2022/05/17/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E4%B8%87%E7%89%A9%E4%B9%8B%E7%88%B6%E5%92%8C%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1/"/>
    <url>/2022/05/17/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E4%B8%87%E7%89%A9%E4%B9%8B%E7%88%B6%E5%92%8C%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1/</url>
    
    <content type="html"><![CDATA[<p>万物之父和装箱拆箱</p><span id="more"></span><h1 id="万物之父和装箱拆箱"><a href="#万物之父和装箱拆箱" class="headerlink" title="万物之父和装箱拆箱"></a>万物之父和装箱拆箱</h1><h2 id="万物之父"><a href="#万物之父" class="headerlink" title="万物之父"></a>万物之父</h2><p>关键字： object<br>概念： object是所有类型的基类，它是一个类（引用类型）<br>作用：<br>1.可以利用里式替换原则，用object容器装所有对象<br>2.可以用来表示不确定类型，作为函数参数类型</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Father&#123;&#125;class Son : Father&#123;    public void Speak()    &#123;    &#125;&#125;internal class Program&#123;    static void Main(string[] args)    &#123;        Father f &#x3D; new Son();        if( f is Son )        &#123;            ( f as Son ).Speak();        &#125;        &#x2F;&#x2F;引用类型        object o &#x3D; new Son();        if( o is Son )        &#123;            (o as Son ).Speak();        &#125;        &#x2F;&#x2F;值类型        object o2 &#x3D; 1;        &#x2F;&#x2F;用强转进行数值使用        int i &#x3D; (int)o2;        &#x2F;&#x2F;特殊的string类型        object o3 &#x3D; &quot;123123&quot;;        string s &#x3D; o3 as string; &#x2F;&#x2F;o3.ToString();        &#x2F;&#x2F;数组类型        object o4 &#x3D; new int[10];        int[] arr &#x3D; o4 as int[]; &#x2F;&#x2F;(int[])o4;    &#125;&#125;</code></pre></div><h2 id="拆箱装箱"><a href="#拆箱装箱" class="headerlink" title="拆箱装箱"></a>拆箱装箱</h2><p>发生条件：<br>装箱： object中存入值类型<br>拆箱： object转为值类型</p><p>装箱：<br>把值类型用引用类型存储<br>栈内存会迁移到堆内存中</p><p>拆箱：<br>把引用类型存储的值类型取出来<br>堆内存会迁移到栈内存中</p><p>好处：不确定类型时可以方便参数的存储和传递<br>坏处：存在内存迁移，增加性能消耗</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">internal class Program&#123;    static void Main(string[] args)    &#123;        &#x2F;&#x2F;装箱        object v &#x3D; 3;        &#x2F;&#x2F;拆箱        int intValue &#x3D; (int)v;        &#x2F;&#x2F;传入object类数组        TestFun(1, 1.5f , 2, &quot;123&quot;, new int[10]);    &#125;    static void TestFun( params object[] array )    &#123;    &#125;&#125;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/17/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E4%B8%87%E7%89%A9%E4%B9%8B%E7%88%B6%E5%92%8C%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><p>装箱： object中存入值类型；把值类型用引用类型存储；栈内存会迁移到堆内存中<br>拆箱： object转为值类型；把引用类型存储的值类型取出来；堆内存会迁移到栈内存中</p><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">internal class Program&#123;    &#x2F;&#x2F;装箱    object v &#x3D; 3;    &#x2F;&#x2F;拆箱    int intValue &#x3D; (int)v;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>继承中的构造函数</title>
    <link href="/2022/05/16/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <url>/2022/05/16/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>继承中的构造函数</p><span id="more"></span><h1 id="继承中的构造函数"><a href="#继承中的构造函数" class="headerlink" title="继承中的构造函数"></a>继承中的构造函数</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>特点：</strong><br>当声明一个子类对象时<br>先执行父类的构造函数<br>再执行子类的构造函数</p><p><strong>注意：</strong><br>1.父类的无参构造 很重要<br>2.子类可以通过base关键字 代表父类 调用父类构造</p><h2 id="继承中构造函数的执行顺序"><a href="#继承中构造函数的执行顺序" class="headerlink" title="继承中构造函数的执行顺序"></a>继承中构造函数的执行顺序</h2><p>1.父类的父类的构造函数<br>2.父类的构造函数<br>3.子类的构造函数<br>即<strong>从高到低依次调用</strong></p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class GameObject&#123;    public GameObject()    &#123;        Console.WriteLine(&quot;GameObject的构造函数&quot;);    &#125;&#125;class Player : GameObject&#123;    public Player()    &#123;        Console.WriteLine(&quot;Player的构造函数&quot;);    &#125;&#125;class MainPlayer : Player&#123;    public MainPlayer()    &#123;        Console.WriteLine(&quot;MainPlayer的构造函数&quot;);    &#125;&#125;internal class Program&#123;    static void Main(string[] args)    &#123;        MainPlayer mp &#x3D; new MainPlayer();    &#125;&#125;</code></pre></div><h2 id="父类的无参构造函数很重要"><a href="#父类的无参构造函数很重要" class="headerlink" title="父类的无参构造函数很重要"></a>父类的无参构造函数很重要</h2><p>重点：<br>无参构造函数会被有参构造函数顶替</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Father&#123;    public Father(int i)    &#123;        Console.WriteLine(&quot;Father构造函数&quot;);    &#125;&#125;class Son : Father&#123;    &#x2F;&#x2F;默认调用父类的无参构造函数，但父类中无参构造函数被顶替，所以报错&#125;internal class Program&#123;    static void Main(string[] args)    &#123;        Son s &#x3D; new Son();    &#125;&#125;</code></pre></div><h2 id="通过base调用制定父类构造"><a href="#通过base调用制定父类构造" class="headerlink" title="通过base调用制定父类构造"></a>通过base调用制定父类构造</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Father&#123;    public Father(int i)    &#123;        Console.WriteLine(&quot;Father构造函数&quot;);    &#125;&#125;class Son : Father&#123;    public Son(int i) : base(i)    &#123;        Console.WriteLine(&quot;Son一个参数的构造函数&quot;);    &#125;    public Son(int i, string str) : this (i)    &#x2F;&#x2F;this其实是先调用base(i),是一种间接的方式;如果用base会直接执行父类构造函数    &#123;        Console.WriteLine(&quot;Son两个参数的构造函数&quot;);    &#125;&#125;internal class Program&#123;    static void Main(string[] args)    &#123;        Son s1 &#x3D; new Son(1, &quot;123&quot;);    &#125;&#125;</code></pre></div><p>注意：<br>this和base的区别<br>this:自己的另一个对应构造函数<br>base:父类的对应构造函数</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/16/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/exam.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson14_继承中的构造函数&#123;    enum E_TypeOfWork    &#123;        Programmer,        Planner,        Artist,    &#125;    enum E_WorkContent    &#123;        program,        plan,        paint,    &#125;    class Worker    &#123;        public E_TypeOfWork typeOfWork;        public E_WorkContent workContent;        public Worker(E_TypeOfWork typeOfWork, E_WorkContent workContent)        &#123;            Console.WriteLine(&quot;我是打工人&quot;);        &#125;    &#125;        class Programmer : Worker    &#123;        public Programmer(E_TypeOfWork typeOfWork, E_WorkContent workContent) : base(typeOfWork, workContent)        &#123;            Console.WriteLine(&quot;&#123;0&#125; is &#123;1&#125;ing&quot;, typeOfWork, workContent);        &#125;    &#125;    class Planner : Worker    &#123;        public Planner(E_TypeOfWork typeOfWork, E_WorkContent workContent) : base(typeOfWork, workContent)        &#123;            Console.WriteLine(&quot;&#123;0&#125; is &#123;1&#125;ing&quot;, typeOfWork, workContent);        &#125;    &#125;    class Artist : Worker    &#123;        public Artist(E_TypeOfWork typeOfWork, E_WorkContent workContent) : base(typeOfWork, workContent)        &#123;            Console.WriteLine(&quot;&#123;0&#125; is &#123;1&#125;ing&quot;, typeOfWork, workContent);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Programmer programmer &#x3D; new Programmer(E_TypeOfWork.Programmer, E_WorkContent.program);             Planner planner &#x3D; new Planner(E_TypeOfWork.Planner, E_WorkContent.plan);            Artist artist &#x3D; new Artist(E_TypeOfWork.Artist, E_WorkContent.paint);        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>里式替换原则</title>
    <link href="/2022/05/16/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E9%87%8C%E5%BC%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/"/>
    <url>/2022/05/16/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E9%87%8C%E5%BC%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<p>里式替换原则</p><span id="more"></span><h1 id="里式替换原则"><a href="#里式替换原则" class="headerlink" title="里式替换原则"></a>里式替换原则</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>任何父类出现的地方，子类都可以替代</p><p><strong>重点</strong><br>语法表现： 父类容器装子类对象，因为子类对象包含了父类的所有内容</p><p><strong>作用</strong><br>方便进行对象存储和管理</p><h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class GameObject&#123;&#125;class Player : GameObject&#123;    public void PlayerAtk()    &#123;        Console.WriteLine(&quot;玩家攻击&quot;);    &#125;&#125;class Monster : GameObject&#123;    public void MonsterAtk()    &#123;        Console.WriteLine(&quot;怪物攻击&quot;);    &#125;&#125;class Boss : GameObject&#123;    public void BossAtk()    &#123;        Console.WriteLine(&quot;Boss攻击&quot;);    &#125;&#125;internal class Program&#123;    static void Main(string[] args)    &#123;        &#x2F;&#x2F;里式替换原则 用父类容器 装载子类对象        GameObject player &#x3D; new Player();        GameObject monster &#x3D; new Monster();        GameObject boss &#x3D; new Boss();        GameObject[] objects &#x3D; new GameObject[] &#123; new Player(), new Monster(), new Boss() &#125;;                &#x2F;&#x2F;此时player对象中不存在Playeratk的方法，因为player是在父类容器GameObject中，而GameObject中没有Playeratk的方法        &#x2F;&#x2F;即父类容器装载子类对象不能直接使用子类中的方法    &#125;&#125;</code></pre></div><h2 id="is和as"><a href="#is和as" class="headerlink" title="is和as"></a>is和as</h2><p><strong>基本概念</strong><br>is : 判断一个对象是否是指定类对象<br>返回值： bool 是为true 不是为false</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">if(player is Player)&#123;&#125;else if (player is Monster)&#123;&#125;</code></pre></div><p>as : 将一个对象转换为指定类对象<br>返回值： 指定类型对象<br>成功返回指定类型对象，失败返回null</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Player p &#x3D; player as Player; &#x2F;&#x2F;成功 p 是PlayerPlayer p &#x3D; monster as Player; &#x2F;&#x2F;失败 p &#x3D; null</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">if(player is Player)&#123;    &#x2F;&#x2F;Player p &#x3D; player as Player;    &#x2F;&#x2F;p.Playatk();    (player as Player).PlayerAtk();    &#x2F;&#x2F;上面两种等价&#125;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/16/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E9%87%8C%E5%BC%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><p>is是判断该对象是不是这个类，返回的是bool值<br>as是将该对象转换为指定类型，成功则转换成功，失败则将该对象变为null</p><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson13_里式替换原则&#123;    class Monster    &#123;    &#125;    class Boss : Monster    &#123;        public void Skill()        &#123;            Console.WriteLine(&quot;Boss释放技能&quot;);        &#125;    &#125;    class Goblin : Monster    &#123;        public void Atk()        &#123;            Console.WriteLine(&quot;哥布林攻击&quot;);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Monster[] monsters &#x3D; new Monster[10];            Random rand &#x3D; new Random();            for (int i &#x3D; 0; i &lt; monsters.Length; i++)            &#123;                if(rand.Next(1,101) &lt;&#x3D; 50)                &#123;                    monsters[i] &#x3D; new Boss();                &#125;                else                &#123;                    monsters[i] &#x3D; new Goblin();                &#125;            &#125;            for (int i &#x3D; 0; i &lt; monsters.Length; i++)            &#123;                if(monsters[i] is Boss)                &#123;                    (monsters[i] as Boss).Skill();                &#125;                else if(monsters[i] is Goblin)                &#123;                    (monsters[i] as Goblin).Atk();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div><h2 id="题3"><a href="#题3" class="headerlink" title="题3"></a>题3</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson13_里式替换原则&#123;    &#x2F;&#x2F;玩家类    class Player    &#123;        public void SwitchWeapon(int k)        &#123;            Player[] weapons &#x3D; new Player[4] &#123; new SMG(), new Shotgun(), new Pistol(), new Dagger() &#125;;            if (weapons[k] is SMG)            &#123;                (weapons[k] as SMG).Print();            &#125;            else if (weapons[k] is Shotgun)            &#123;                (weapons[k] as Shotgun).Print();            &#125;            else if (weapons[k] is Pistol)            &#123;                (weapons[k] as Pistol).Print();            &#125;            else if (weapons[k] is Dagger)            &#123;                (weapons[k] as Dagger).Print();            &#125;        &#125;    &#125;    &#x2F;&#x2F;冲锋枪类    class SMG : Player    &#123;        public void Print()        &#123;            Console.WriteLine(&quot;你现在手持冲锋枪&quot;);        &#125;    &#125;    &#x2F;&#x2F;霰弹枪类    class Shotgun : Player    &#123;        public void Print()        &#123;            Console.WriteLine(&quot;你现在手持霰弹枪&quot;);        &#125;    &#125;    &#x2F;&#x2F;手枪类    class Pistol : Player    &#123;        public void Print()        &#123;            Console.WriteLine(&quot;你现在手持手枪&quot;);        &#125;    &#125;    &#x2F;&#x2F;匕首类    class Dagger : Player    &#123;        public void Print()        &#123;            Console.WriteLine(&quot;你现在手持匕首&quot;);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Player p &#x3D; new Player();            &#x2F;&#x2F;默认匕首            p.SwitchWeapon(3);            Console.WriteLine(&quot;按1(冲锋枪),2(霰弹枪),3(手枪),4(匕首)进行切枪&quot; + &quot; &quot; + &quot;按q退出程序&quot;);            while (true)            &#123;                char cmd &#x3D; Console.ReadKey(true).KeyChar;                try                 &#123;                    if(cmd !&#x3D; &#39;q&#39;)                    &#123;                        p.SwitchWeapon(Convert.ToInt32(cmd - &#39;0&#39;) - 1);                    &#125;                    else                    &#123;                        Environment.Exit(0);                    &#125;                &#125;                catch                &#123;                    Console.WriteLine(&quot;请输入正确指令&quot;);                &#125;                           &#125;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月16日</title>
    <link href="/2022/05/16/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%8816%E6%97%A5/"/>
    <url>/2022/05/16/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%8816%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="8ff5085b02db703695eb0573d5e2395718f232387ff5a7bcffab20389c364185">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe505b803b8feaab671cea5ab5e4652ea6c36a02f1947ad70fc2430bd172aca29c6de61259f12fbbd1a4855621ddc3d9d79291f362396f3716bf88727952e141b19141594a62e1e2a1cfce1049c766c052e9189ec318c83d4889671d1206c52a37e925512f04d7e6cf54ff03f5a54a66e4d0f1771bd9a0aa9e6e12bde83af7c4521de6822c6a3c85521d8406e4ee55cc09630a7a3b945f25dbcd29f27aeaa1955a761710f18fbc6df5b1461fe1d5e9ff92b8445f70ec9d16c48ae8eab299ea194cb155a5dbb022d2862dbaabc2f3e4554310341b80c0e38ad644bef9f30ce6c9862b12efd2953531245df513c5ea1e5c94483495f72abfdb32eeec3a1bec1e7f82612dadd133fe3bc11200d8944b1abf9ad0ffba36bc6025ad69f3988ab774dbe96e8d090740736b887dc8998511d9063c9605290758a36a4f6160c28f2e6cc61b2e213a6d6b9ec204ab8d0c2ec0799e9c2677eadc39875b2e663f17c41b31bc971117b9a800d3087acdd0d368d71e4393cb</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">要密码，快滚.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月15日</title>
    <link href="/2022/05/15/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%8815%E6%97%A5/"/>
    <url>/2022/05/15/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%8815%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="829ded19b386609cf9ac49cbf1c44b2b04da821bfccef03a6e2c685585e6e71c">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe5016a4faf8194f2f8aa9b1a6144f7333a3892e1f4a31a2d18309e56f20249bd16769e464f7d6eb4a6e4fab04466bd357c63e94ff3c847c3aecee23dd98d9231033f5cf1745aa32f0f11f3731764b767d424ac8e92d145e3b510d2ad55a0294a4cd5d617e36d2284f04ec73f005e7f9611edd4dc41b9fe47cf734c8432125ca2590cee134ac84e982742ceb768e2d0b46d6f68f55bf42afa3adc8113d1c7dcf90cd726885350ddbaa3dd0f3f4e47bc8e6ce71ebbcddee631d3a847d5b94fdf47b7eae9909ede14e84c594d26966b216134c28a72f32366189176140edf5f011107352fcef378e49c52c2f8634d4ceb69ea17eacd5c048fafe1a5ed420aadffa07682696725fa3297c629086715f33d0dfeda09df377c955a225eb8f1bf0be1aa8e377fb0d26fd960c67b6e405a1bde81c51c54cc246071d139ad9f772292fc0260a3d7ab2d9a0c1e545bca15aa7e8537ff71b7ca315bcc1a07aae28f38d577044add5bc085f924bc8b84659dd5fd7cad2ca1588d2a3fc18e5c6659d8dfc4fbb657d6af886ec46f678329afb02a95781c497363c9e0f5b0aa42abbaaf228ef4667d9d5b4fdb4483291c18d999d01718a6f50a85e66bb5e9572ec80da526bee47f920f74ffc4d34d5e0aea04f883ca9b87c231a6c158ea694c2fd9402477c370dee9067d57b934831465f9c4a06e041c7a4e74e04cda4ff80dbe1b730d430c0bad17fc92e2ecc1ef39d60707c523253a050ed1e8609e6cd446778ef9177c15d21cbabc53cef4802f4f22081c8725229a160c3844026dc7262dae8cd0d424306c117c63e98e7542e46002c688f6209043df006d8f2520374946c69590dfe8bd09179572178ee2922783b1e3fabfe43c9aa4750ce54b82ddf39a6233e8c3848b7157825ac303cb81c187e655f37ad05c0f29591027b97f499838cfaf900f752fb4fcadb1942c980476a6d7347c7fe5006e51db3b3c4e601b2f81c939a1958611635f29c2e79d3ba4925a61a69644bed421abef71a39c70e57f3b16f47a5fb85254caa8a602004c6e01d70c63abaf69146a6243882c0cc089b60d764e83d96ac561778711086d1dd7c3f3a3b88d2ec61fb15c2cfc94c68eda9882facb8564ac3949c1145e133e4eb3d4feed6cd809a1f7e7a690d2cfddc19fea4323a107f12975738b2f4ad9d66700b06ca3028706b150318e5802e0175f7022224b9fde1f682fe18ac0f8bc03fee8ef646ca3dbe86367bc1473a17cfdd92d2f66206bc85cdcda7379e45385cbeedfb11987dabc13fb4cd1946f926d03256f0ba26a8f7ed320a2e293a1a222bedf2dde4df4e9afb694fcd4130075c0e9057bc9e7d9f456bc917eec3c8418643f198517ee42fb5b2766c483884d2c21316c4101bba7eb18f0f664c6b52b743217cbb2841c8217e85edb64fff4dbc2675438c138a709a27e5b4d3e214f342e80c3fe12612c775eb35af60812ab78bc5937232116cc0213ce918ab795751af0a40cdd88edb39485100cce6a4af3ee73206065e209eb62cb2f33cbbf34cd061ff68ce136ad467c6863ca6528cc5cd66b11d960a91242d9e1c772699bf2910f3ab77782fe39826e701df2001f30d529b0cf44b4eaaa0011ea88c2eeb85410a60e0d10f215871042cb1b9aed53bb50ad265e2a27139c3e35b1d48e164089d501238a78ff71e86baa180d50ebc88d1d28e09c9153e91a8e837819def61873f41dcaecc3908eac609be37d31975c35ed7b18271e8222c1b8591697310a0db730ad7a7f0227009d827653828c4f36e2b3eb3d658fcbb178e97abc960152228787fd6fb6fe84cb172ea669d1d53efe52f2cce4630cb39c0fda09dc0042ce238133b2eac4eae6107edfbe0b2528013fc7356b63a22cec41e3f466cb2c9e6b8844dafd3aa79234f0f2009463f3471c4d8c5dde2602db028b62998e338afa1f18c28f84ac7789f9a8ebd60dd90045a0cdb45df6984dcda44e2e5f5e923dbabed5cde3e986f77c2968414236383715ef0b20386b1a14c47ba289a3b71647c5cfdbe816ae0c1bf75da080719b6fae2fcfa7b8fcffece1c3771dbfc2d4ac16490c5fec57e07c6488058a8e6636fb1205fd450c4fc195218774497759f86ecb9d177613550359f29ca09e16241559385d710397ab7f7edfa3c65fc974c4be19951dda2a361a58faaf18eb0157dd6f4b3d5913916e8e848f665a816ac6cd4f43a38e6872e1dc5b8d3972daa05107b4a2efd6a4dd9eeb1413b6783a6d81d6587267ab625a04ad4317d3a54c06ab31a632699e27ad109be508037ef5b34dffc376122954d493e5aad2653d11b56f7929050ba6a954c641be9f82c8c0fbed2c1211a7025f1edb5737aabbab7175419f5d52befe987c4d0fb43b04849f4e727446d891953cdd7f4b444a19e516db931198efbe5629f652fe953e1585a4a7311acdecac62e330e280b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">要密码，快滚.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月14日</title>
    <link href="/2022/05/14/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%8814%E6%97%A5/"/>
    <url>/2022/05/14/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%8814%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="0d2d3e74c0b88ce0e89374106356adaec4166149c0b200bfcae26f6136b84842">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50eab5a83f549bec176812e5d10b67ba0dcb7ab007c94ce139a456f545dfed2122acee6f64839288f02efb7a0ade81be20e4fcb98a37a126e8c08d3745c9a2c29c5ba00cf3b5d1957d413586b65b4c4ce75dbf344e86c5e5ea5c6ab445d806a2c8516e4b35b8cf1cafbd1ad726fe8c3ef0cd0b399e88e11bf157ec758812cbfe7c43a1221624af8d9cf5aef115f882d51e9d5156e17b1ef31b936994250fa210514b10fd98ddd056e583b10505eada21a85658b5a84db87e7b04735f8dfa27de28576898d03ea61ce2a2e0347248a524f15b85f0228ca1d6e442359173862bb1b2a7521af6b0051d12c0e9903863e9bfcd536f6ab37f0bd9e7f2f5f76578ccc02b780c72109f9b4bd4b2727eb5b4de1270428b49f32edd5387fd3a770463524b7ae3f8f923a0ef0819f1e76f60e6d1a71dbf8814667f68956269c37c16de288a96b64333959bb2db4d4cdb8a64c80082b61c7d457e8cd3385dcca90f4da4064b53879151466b3e9a6dd6835129a0fecd22</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">要密码，快滚.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>继承的基本规则</title>
    <link href="/2022/05/14/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99/"/>
    <url>/2022/05/14/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99/</url>
    
    <content type="html"><![CDATA[<p>继承的基本规则</p><span id="more"></span><h1 id="继承的基本规则"><a href="#继承的基本规则" class="headerlink" title="继承的基本规则"></a>继承的基本规则</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>一个类A继承一个类B<br>类A将会继承类B的所有成员<br>类A将拥有类B的所有特征和行为</p><p><strong>被继承的类：</strong><br><em>父类</em> &#x2F; 基类 &#x2F; 超类 </p><p><strong>继承的类：</strong><br><em>子类</em> &#x2F; 派生类</p><p>子类可以有自己的特征和行为</p><p><strong>特点：</strong><br>1.单根性：子类只能有一个父类<br>2.传递性：子类可以简介继承父类的父类</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class 类名 : 被继承的类名&#123;&#125;</code></pre></div><img src="/2022/05/14/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99/%E6%A0%91%E7%8A%B6%E5%9B%BE.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;老师类class Teacher&#123;    &#x2F;&#x2F;姓名    public string name;    &#x2F;&#x2F;职工号    public int number;    &#x2F;&#x2F;介绍名字    public void SpeakName()    &#123;        Console.WriteLine(name);    &#125;&#125;&#x2F;&#x2F;教学老师类 作为 老师类的 子类class TeachingTeacher : Teacher&#123;    &#x2F;&#x2F;科目    public string subject;    &#x2F;&#x2F;介绍科目    public void SpeakSubject()    &#123;        Console.WriteLine(subject + &quot;老师&quot;);    &#125;&#125;&#x2F;&#x2F;语文老师类 class ChineseTeacher : TeachingTeacher&#123;&#125;internal class Program&#123;    static void Main(string[] args)    &#123;        TeachingTeacher tt &#x3D; new TeachingTeacher();        tt.name &#x3D; &quot;季宝&quot;;        tt.number &#x3D; 1;        tt.SpeakName();        tt.subject &#x3D; &quot;Unity&quot;;        tt.SpeakSubject();    &#125;&#125;</code></pre></div><h2 id="访问修饰符的影响"><a href="#访问修饰符的影响" class="headerlink" title="访问修饰符的影响"></a>访问修饰符的影响</h2><p>public - 公共 内外部访问<br>private - 私有 内部访问（子类不能访问）<br>protected - 保护 内部和子类访问<br>internal - 内部的 只有在同一个程序集的文件中，内部类型或者是成员才可以访问</p><h2 id="子类和父类的同名成员"><a href="#子类和父类的同名成员" class="headerlink" title="子类和父类的同名成员"></a>子类和父类的同名成员</h2><p><strong>概念：</strong><br>C#中允许子类存在和父类同名的成员<br>但 极不建议使用</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public new string name;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/14/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99/exam.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson12_继承的基本规则&#123;    &#x2F;&#x2F;人类类    class Person    &#123;        public string name;        public int age;        public void Speak()        &#123;            Console.WriteLine(&quot;我是&quot; + name);        &#125;    &#125;    &#x2F;&#x2F;战士类    class Warrior : Person    &#123;        public void Attack()        &#123;            Console.WriteLine(&quot;wslnm&quot;);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Warrior warrior &#x3D; new Warrior();            warrior.name &#x3D; &quot;大逼&quot;;            warrior.Speak();             warrior.Attack();        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内部类和分部类</title>
    <link href="/2022/05/13/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%88%86%E9%83%A8%E7%B1%BB/"/>
    <url>/2022/05/13/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%88%86%E9%83%A8%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>内部类和分部类</p><span id="more"></span><h1 id="内部类和分部类"><a href="#内部类和分部类" class="headerlink" title="内部类和分部类"></a>内部类和分部类</h1><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p><strong>基本概念：</strong><br>在一个类中再声明一个类</p><p><strong>特点：</strong><br>使用时要用包裹者点出自己</p><p><strong>作用：</strong><br>亲密关系的表现</p><p><strong>注意：</strong><br>访问修饰符作用很大</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Person &#123;     public int age;     public string name;     public Body body;     public class Body     &#123;         Arm leftArm;         Arm rightArm;         &#x2F;&#x2F;class在内部类里默认private         class Arm         &#123;         &#125;     &#125;      &#125; internal class Program &#123;     static void Main(string[] args)     &#123;         Person p &#x3D; new Person();         Person.Body body &#x3D; new Person.Body();         &#x2F;&#x2F;Person.Body.Arm arm &#x3D; new Person.Body.Arm(); 会报错     &#125; &#125;</code></pre></div><h2 id="分部类"><a href="#分部类" class="headerlink" title="分部类"></a>分部类</h2><p><strong>基本概念：</strong><br>把一个类分成几部分声明</p><p><strong>关键字</strong> <em>partial</em></p><p><strong>作用：</strong><br>1.分布描述一个类<br>2.增加程序的拓展性</p><p><strong>注意：</strong><br>1.分部类可以写在多个脚本文件中<br>2.分部类的访问修饰符要一致<br>3.分部类中不能有重复成员</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">partial class Student&#123;    public bool sex;    public string name;&#125;&#x2F;&#x2F;一个类 分开写partial class Student&#123;    public int number;    public void Speak(string str)    &#123;    &#125;&#125;internal class Program&#123;    static void Main(string[] args)    &#123;        Student student &#x3D; new Student();        student.Speak(string.Empty);    &#125;&#125;</code></pre></div><h2 id="分部方法"><a href="#分部方法" class="headerlink" title="分部方法"></a>分部方法</h2><p><strong>基本概念：</strong><br>将方法的声明和实现分离</p><p><strong>特点：</strong><br>1.不能加访问修饰符  默认private<br>2.只能在分部类中声明<br>3.返回值只能是void<br>4.可以有参数  不能用out关键字</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;声明和实现分到两个分部类里面    partial class Student    &#123;        public bool sex;        public string name;        &#x2F;&#x2F;声明        partial void Speak();    &#125;    &#x2F;&#x2F;一个类 分开写    partial class Student    &#123;        public int number;        &#x2F;&#x2F;实现        partial void Speak()        &#123;            &#x2F;&#x2F;实现逻辑        &#125;    &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运算符重载</title>
    <link href="/2022/05/13/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    <url>/2022/05/13/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<p>运算符重载</p><span id="more"></span><h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>让自定义类和结构体，能够使用运算符<br>关键词 <em>operator</em></p><p><strong>特点：</strong><br>1.一定是一个公共的静态方法<br>2.返回值写在operator前面<br>3.逻辑处理自定义</p><p><strong>作用：</strong><br>让自定义类和结构体对象可以进行运算</p><p><strong>注意：</strong><br>1.条件运算符需要成对实现<br>2.一个符号可以多个重载<br>3.不能使用ref和out</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Point&#123;    public int x;    public int y;    &#x2F;&#x2F;重载+号    public static Point operator +(Point p1, Point p2)    &#x2F;&#x2F;public static 返回类型 operator 运算符(参数列表)    &#123;        Point p &#x3D; new Point();        p.x &#x3D; p1.x + p2.x;        p.y &#x3D; p1.y + p2.y;        return p;    &#125;    &#x2F;&#x2F;+号多个重载    public static Point operator +(Point p1, int value)    &#x2F;&#x2F;public static 返回类型 operator 运算符(参数列表)    &#123;        Point p &#x3D; new Point();        p.x &#x3D; p1.x + value;        p.y &#x3D; p1.y + value;        return p;    &#125;&#125;internal class Program&#123;    static void Main(string[] args)    &#123;        Point p1 &#x3D; new Point();        p1.x &#x3D; 1;        p1.y &#x3D; 1;        Point p2 &#x3D; new Point();        p2.x &#x3D; 2;        p2.y &#x3D; 2;        Point p3 &#x3D; p1 + p2;        Console.WriteLine(&quot;(&#123;0&#125;,&#123;1&#125;)&quot;, p3.x, p3.y);        Point p4 &#x3D; p3 + 2; &#x2F;&#x2F;顺序不能错 一定是先Point类,再int类        Console.WriteLine(&quot;(&#123;0&#125;,&#123;1&#125;)&quot;, p4.x, p4.y);    &#125;&#125;</code></pre></div><h2 id="可重载和不可重载的运算符"><a href="#可重载和不可重载的运算符" class="headerlink" title="可重载和不可重载的运算符"></a>可重载和不可重载的运算符</h2><h3 id="可重载运算符"><a href="#可重载运算符" class="headerlink" title="可重载运算符"></a>可重载运算符</h3><p><strong>算术运算符</strong></p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">+ - * &#x2F; %  ++ --注意: 符号需要两个参数还是一个参数</code></pre></div><p><strong>逻辑运算符</strong></p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;!(逻辑非) &#x2F;&#x2F;注意： &amp;&amp;(逻辑与)和||(逻辑或)不允许重载</code></pre></div><p><strong>位运算符</strong></p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">| &amp; ^ ~ &lt;&lt; &gt;&gt;&#x2F;&#x2F;注意: 符号需要两个参数还是一个参数</code></pre></div><p><strong>条件运算符</strong></p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;&gt; &lt; &#x3D;&gt; &lt;&#x3D; &#x3D;&#x3D; !&#x3D;&#x2F;&#x2F;注意：&#x2F;&#x2F;1.返回值一般是bool值，也可以是其他的&#x2F;&#x2F;2.相关符号必须配对实现(实现了&gt;，就要同时实现&lt;)</code></pre></div><h3 id="不可重载运算符"><a href="#不可重载运算符" class="headerlink" title="不可重载运算符"></a>不可重载运算符</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;逻辑与  &amp;&amp; &#x2F;&#x2F;逻辑或  || &#x2F;&#x2F;索引符  [] &#x2F;&#x2F;强转运算符  () &#x2F;&#x2F;    特殊运算符：&#x2F;&#x2F;    点  .   &#x2F;&#x2F;    三目运算符  ? :   &#x2F;&#x2F;    赋值符号  &#x3D;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/13/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson10_运算符重载&#123;    class Vector2    &#123;        public int x;        public int y;        &#x2F;&#x2F;重载&#x3D;&#x3D;号        public static bool operator &#x3D;&#x3D;(Vector2 v1, Vector2 v2)        &#123;            return v1.x &#x3D;&#x3D; v2.x &amp;&amp; v1.y &#x3D;&#x3D; v2.y;        &#125;        public static bool operator !&#x3D;(Vector2 v1, Vector2 v2)        &#123;            return !(v1.x &#x3D;&#x3D; v2.x &amp;&amp; v1.y &#x3D;&#x3D; v2.y);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Vector2 v1 &#x3D; new Vector2();            v1.x &#x3D; 1;            v1.y &#x3D; 1;            Vector2 v2 &#x3D; new Vector2();            v2.x &#x3D; 1;            v2.y &#x3D; 1;            Console.WriteLine(v1 &#x3D;&#x3D; v2);             &#125;    &#125;&#125;</code></pre></div><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson10_运算符重载&#123;    class Vector3    &#123;        public int x;        public int y;        public int z;        &#x2F;&#x2F;重载&#x3D;&#x3D;号        public static Vector3 operator +(Vector3 v1, Vector3 v2)        &#123;            Vector3 v &#x3D; new Vector3();            v.x &#x3D; v1.x + v2.x;            v.y &#x3D; v1.y + v2.y;            v.z &#x3D; v1.z + v2.z;            return v;        &#125;        public static Vector3 operator -(Vector3 v1, Vector3 v2)        &#123;            Vector3 v &#x3D; new Vector3();            v.x &#x3D; v1.x - v2.x;            v.y &#x3D; v1.y - v2.y;            v.z &#x3D; v1.z - v2.z;            return v;        &#125;        public static Vector3 operator *(Vector3 v1, int num)        &#123;            Vector3 v &#x3D; new Vector3();            v.x &#x3D; v1.x * num;            v.y &#x3D; v1.y * num;            v.z &#x3D; v1.z * num;            return v;        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Vector3 v1 &#x3D; new Vector3();            v1.x &#x3D; 1;            v1.y &#x3D; 1;            v1.z &#x3D; 1;            Vector3 v2 &#x3D; new Vector3();            v2.x &#x3D; 2;            v2.y &#x3D; 3;            v2.z &#x3D; 4;            int num &#x3D; 8;            Vector3 v3 &#x3D; v1 + v2;            Vector3 v4 &#x3D; v2 - v1;            Vector3 v5 &#x3D; v2 * num;            Console.WriteLine(&quot;(&#123;0&#125;,&#123;1&#125;,&#123;2&#125;)&quot;, v3.x, v3.y, v3.z);            Console.WriteLine(&quot;(&#123;0&#125;,&#123;1&#125;,&#123;2&#125;)&quot;, v4.x, v4.y, v4.z);            Console.WriteLine(&quot;(&#123;0&#125;,&#123;1&#125;,&#123;2&#125;)&quot;, v5.x, v5.y, v5.z);        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月13日</title>
    <link href="/2022/05/13/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%8813%E6%97%A5/"/>
    <url>/2022/05/13/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%8813%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="fbbcf625d92544d5df3d44ac542131102feb9fbd15ca0852893ab5901da2fb32">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe506e3bbc3039a6aa643d94bba3c0a5944c3000ff7fa000df3927de73467607197ccec9c66374b92e0f81e072804d501535ac8a7eee38888c5007151c617ed82a1c690e4dc1ef4fb47045f82e89006f717a7fb19e7fefab38085a7c62a562c58058bf9d677ec961e8e15822a354247ec0e624c42d79405ffe28ce71a51aacae688bb936e022fecfb2ecfc36563a50b5f41e97ba7f934c2ca7f5542947fb8d4a938ae8944e924ee5988f12041e8d0a3d134c4a4682d64469a108efbd6aa9dcff6427a92707e97e5beffd53d975af6795abf99626a3245a0775a6b35f8ed7fb4bfa3f30463a3dba02cc1ee1c56eefbc194d89d375241ac45a8092772f7db8b0384232e7162edb46f6c33c653599b2a8128c2e5d223148acbe13645425ee432503346889e5e855cfd087ec0bc1b7b454da62c9a90b1fc994336a1cbc735840d8c98ee5c179c40db6109dbb0c123c5888ddfbe715d767a27721a0bbb9ee40f78c73cff0ee758852160fce56837f4a32e03a7ae9e7b3398acb7478f0a4bf9d7a7c7f1ae3cab150d6706b3859ddac575996a5721ffd7b3930bde3c123bba298a1c6fa98fface1bd4ed49ec04c0241982205786343795dd0482c0d4c80b5691109ca44c4b07d3185f743ec26540bb02060a8126e26f279136fa6f1c74ed4bc41e95b9e434537275a52003e00fd238ef9cb11ea6d459f4c21295d76ab8eebd82be04c1a8d2ef5c46043ff2055d7a45099e20ba75faaf138b11b17b64d0a4b28ba720dca9f1ba7ce739caa825bb45f67b2640ba0abb60d53b70937bdc4bf79f7d76e32dc7fbc0dd50acb69f5af9b7b94b60d5177c23cb9efa1340dc928b561ed3148271b6d878faf99333dbaa728d3faca0d734dc24fd63928bca1d918a25f3f1ff289ba1b2d4a3009ebb7d9d6b6bb8b11792514e5961223a2f8a7c6aa0de8a4073023b171622416a26a79947fa1dd6a4d9c885223d70a243a9e8417c84b7db48fcbf5dfdadc</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">要密码，快滚.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拓展方法</title>
    <link href="/2022/05/12/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95/"/>
    <url>/2022/05/12/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>拓展方法</p><span id="more"></span><h1 id="拓展方法"><a href="#拓展方法" class="headerlink" title="拓展方法"></a>拓展方法</h1><p><strong>基本概念：</strong><br>为现有<strong>非静态</strong>的变量类型 添加新方法</p><p><strong>作用：</strong><br>1.提升程序拓展性<br>2.不需要在对象中重新写方法<br>3.不需要继承来添加方法<br>4.为别人封装的类型写额外的方法</p><p><strong>特点：</strong><br>1.一定是写在静态类中<br>2.一定是一个静态函数<br>3.第一个参数为拓展目标<br>4.第一个参数用this修饰</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;声明static class Tools&#123;    &#x2F;&#x2F;访问修饰符 static 返回值 函数名(this 拓展类名 参数名, 参数类型 参数名, 参数类型 参数名, ......)    public static void SpeakValue(this int value)    &#x2F;&#x2F;为int拓展了一个成员方法    &#x2F;&#x2F;成员方法 是需要实例化对象后 才能使用的    &#x2F;&#x2F;value 代表使用该方法的 实例化对象    &#123;        &#x2F;&#x2F;拓展的方法的逻辑        Console.WriteLine(&quot;为int拓展的方法&quot; + value);    &#125;    public static void SpeakStringInfo(this string str, string str2, string str3)    &#x2F;&#x2F;为string拓展了一个成员方法    &#x2F;&#x2F;str 代表使用该方法的 实例化对象    &#x2F;&#x2F;str2, str3 代表传进去的参数    &#123;        Console.WriteLine(&quot;为string拓展的方法&quot;);        Console.WriteLine(&quot;调用方法的对象&quot; + str);        Console.WriteLine(&quot;传的参数&quot; + str2 + str3);    &#125;&#125;&#x2F;&#x2F;使用internal class Program&#123;    static void Main(string[] args)    &#123;        &#x2F;&#x2F;i就是int这一拓展类 实例化的对象        int i &#x3D; 10;        i.SpeakValue();        &#x2F;&#x2F;str就是string这一拓展类 实例化的对象        string str &#x3D; &quot;000&quot;;        str.SpeakStringInfo(&quot;111&quot;, &quot;222&quot;);    &#125;&#125;</code></pre></div><h2 id="为自定义的类型拓展方法"><a href="#为自定义的类型拓展方法" class="headerlink" title="为自定义的类型拓展方法"></a>为自定义的类型拓展方法</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;声明static class Tools&#123;    public static void Fun3(this Test t)    &#x2F;&#x2F;为Test类的t拓展了一个成员方法    &#123;        Console.WriteLine(&quot;为test拓展的方法&quot;);    &#125;&#125;class Test&#123;    public int i &#x3D; 10;    public void Fun1()    &#123;        Console.WriteLine(&quot;123&quot;);    &#125;    public void Fun2()    &#123;        Console.WriteLine(&quot;456&quot;);    &#125;&#125;&#x2F;&#x2F;使用internal class Program&#123;    static void Main(string[] args)    &#123;        Test t &#x3D; new Test();        t.Fun3();    &#125;&#125;</code></pre></div><p><strong>注意：</strong><br>拓展方法名若和原有方法名相同，会默认使用原有方法名</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/12/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson9_拓展方法&#123;    &#x2F;&#x2F;为整形拓展一个求平方的方法    static class Tools    &#123;        &#x2F;&#x2F;平方返回值int        public static int Square(this int value)        &#123;            return value * value;        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Console.Write(&quot;请输入一个整数：&quot;);            int i &#x3D; int.Parse(Console.ReadLine());            Console.WriteLine(&quot;它的平方是&#123;0&#125;&quot;, i.Square());        &#125;    &#125;&#125;</code></pre></div><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson9_拓展方法&#123;    &#x2F;&#x2F;声明一个玩家类    &#x2F;&#x2F;因为没写敌人，逻辑写的简单点    class Player    &#123;        public string Name &#123; get; set; &#125;        public int Hp &#123; get; set; &#125;        public int Atk &#123; get; set; &#125;        public int Def &#123; get; set; &#125;        &#x2F;&#x2F;攻击方法        public void Attack()        &#123;            &#x2F;&#x2F;攻击能提升气势，增加攻击力            Atk +&#x3D; 1;        &#125;        &#x2F;&#x2F;移动方法        public void Move()        &#123;            &#x2F;&#x2F;移动就会找到宝箱打开，要么获得武器，要么获得防具            Random r &#x3D; new Random();            &#x2F;&#x2F;一半概率为武器            if(r.Next(1, 101) &lt;&#x3D; 50)            &#123;                Atk +&#x3D; 50;            &#125;            &#x2F;&#x2F;一半概率为防具            else            &#123;                Def +&#x3D; 50;            &#125;        &#125;        &#x2F;&#x2F;受伤方法        public void Injured()        &#123;            &#x2F;&#x2F;受伤掉5血            Hp -&#x3D; 5;        &#125;    &#125;    &#x2F;&#x2F;为玩家拓展一个自杀的方法    static class Tools    &#123;        public static void Suicide(this Player p)        &#123;            p.Hp &#x3D; 0;        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Player p &#x3D; new Player();            p.Name &#x3D; &quot;大逼&quot;;            p.Hp &#x3D; 100;            p.Atk &#x3D; 10;            p.Def &#x3D; 10;            p.Attack();            p.Move();            p.Injured();            if(p.Hp &gt; 0)            &#123;                Console.WriteLine(&quot;&#123;0&#125;现在的状态为血量&#123;1&#125;,攻击力&#123;2&#125;,防御力&#123;3&#125;&quot;, p.Name, p.Hp, p.Atk, p.Def);            &#125;            else if (p.Hp &lt;&#x3D; 0)            &#123;                Console.WriteLine(&quot;&#123;0&#125;已死亡&quot;, p.Name);            &#125;            p.Suicide();            if (p.Hp &gt; 0)            &#123;                Console.WriteLine(&quot;&#123;0&#125;现在的状态为血量&#123;1&#125;,攻击力&#123;2&#125;,防御力&#123;3&#125;&quot;, p.Name, p.Hp, p.Atk, p.Def);            &#125;            else if (p.Hp &lt;&#x3D; 0)            &#123;                Console.WriteLine(&quot;&#123;0&#125;已死亡&quot;, p.Name);            &#125;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>静态类和静态构造函数</title>
    <link href="/2022/05/12/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E9%9D%99%E6%80%81%E7%B1%BB%E5%92%8C%E9%9D%99%E6%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <url>/2022/05/12/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E9%9D%99%E6%80%81%E7%B1%BB%E5%92%8C%E9%9D%99%E6%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>静态类和静态构造函数</p><span id="more"></span><h1 id="静态类和静态构造函数"><a href="#静态类和静态构造函数" class="headerlink" title="静态类和静态构造函数"></a>静态类和静态构造函数</h1><h2 id="静态类"><a href="#静态类" class="headerlink" title="静态类"></a>静态类</h2><p><strong>基本概念：</strong><br>用static修饰的类</p><p><strong>特点：</strong><br>1.只能包含静态成员<br>2.不能被实例化</p><p><strong>作用：</strong><br>1.将常用的静态成员写在静态类中 方便使用<br>2.静态类不能被实例化，更能体现工具性、唯一性<br>    Console就是一个静态类</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">static class TestStatic&#123;    &#x2F;&#x2F;静态成员变量    public static int testIndex &#x3D; 0;    public static void TestFun()    &#123;    &#125;     public static int TestIndex()    &#123;        get;        set;    &#125; </code></pre></div><h2 id="静态构造函数"><a href="#静态构造函数" class="headerlink" title="静态构造函数"></a>静态构造函数</h2><p><strong>基本概念：</strong><br>在构造函数前加上 static 修饰</p><p><strong>特点：</strong><br>1.静态类和普通类都可以有<br>2.不能使用访问修饰符<br>3.不能有参数<br>4.只会自动调用一次</p><p><strong>作用：</strong><br>在静态构造函数中初始化 静态变量</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;静态类中的静态构造函数static class StaticClass&#123;    public static int testInt &#x3D; 100;    public static int testInt2 &#x3D; 100;    static StaticClass()    &#123;        &#x2F;&#x2F;只会在初次使用的时候 调用一次        Console.WriteLine(&quot;静态构造函数&quot;);        testInt &#x3D; 200;        testInt2 &#x3D; 200;    &#125; &#125;&#x2F;&#x2F;普通类中的静态构造函数class Test&#123;    public static int testInt &#x3D; 200;    static Test()    &#123;        Console.WriteLine(&quot;静态构造&quot;);    &#125;    &#x2F;&#x2F;这不是重载 这是两个不同的函数    public Test()    &#123;        Console.WriteLine(&quot;普通构造&quot;);    &#125;&#125;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/12/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E9%9D%99%E6%80%81%E7%B1%BB%E5%92%8C%E9%9D%99%E6%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/exam.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson8_静态类和静态构造函数&#123;    &#x2F;&#x2F;数学计算静态类    static class Calc    &#123;        public static float PI &#x3D;3.145926f;        &#x2F;&#x2F;计算圆的面积        public static float CircleS(int r)        &#123;            return PI * r * r;        &#125;        &#x2F;&#x2F;计算圆的周长        public static float CircleL(int r)        &#123;            return PI * r * 2;        &#125;        &#x2F;&#x2F;计算矩形的面积        public static float RectangleS(int l, int w)        &#123;            return l * w;        &#125;        &#x2F;&#x2F;计算矩形的周长        public static float RectangleL(int l, int w)        &#123;            return 2 * (l + w);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;半径为3的圆面积是&#123;0&#125;&quot;, Calc.CircleS(3));            Console.WriteLine(&quot;半径为3的圆周长是&#123;0&#125;&quot;, Calc.CircleL(3));            Console.WriteLine(&quot;长为3宽为3的矩形面积是&#123;0&#125;&quot;, Calc.RectangleS(3, 3));            Console.WriteLine(&quot;长为3宽为3的矩形周长是&#123;0&#125;&quot;, Calc.RectangleL(3, 3));        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月12日</title>
    <link href="/2022/05/12/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%8812%E6%97%A5/"/>
    <url>/2022/05/12/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%8812%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="e6f05afd7dde67ae8ed6788ed11c379aed728678974f1de1e1e29bf95a9f1b88">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50d4c0829a8a79ea3b44ecdd1bc8d55452e14aee12c337910927f5586d86733e9c3714b8aa46a90f5ded03e2919eb7614b695a0defcfad29d72d9fcfb60b9a437a5403c1eeec2e3e33f690b3cdb7fe7ae97b097ece43cf2a91a788c9800b918b96c17dd030ffe3e2ee254e2ac8f2f59236a40efc463d7d1d719a71e712b95464d87f3e14cbaee92305d40e4e481607d532adcec9cadd867b270ddef2ed9b5ad73363f75850d84bf94087e64271ad395f78ec0294fcadb5807d41320f2c5a4fc76630450a90fceff0a9351a1edd839bf9c49a772721b3e6b99aa6c4a0bc89feb62302d8cfc53da2668d8273ddc4b64c745112fe1a8e8a6b8f1d4d122b8208c876f98422264e038d11aa0a4704699e55c8ae5cd539cb0d194fbf458de5ec565a98404dd22f79e5625560e96e5da2e55ba40ee78a6d266d650e4a3ba21d1185e923a86bc36f92c6102984f06fc7f47e7dabdb159291fcda490e00e5c7d3e3de468a28a65248959ee48c271e2d95d3f58bae3c4cb98b0c911c8e707dd25c217de9097a64b34a6284a9f65441a293f4916d0ed957ec1c1371e8b492c4caf6aa5f987b07c205471fe9cddb6967cdfdff2b8f7fb10481c3f2fc93178b4debdab78e0149a4cce6bd521b8fba6f0a122ba9a25790fbbaada244562738f5b6606507ce1a22930a533b04b2bdaf00c9b9660664cd506d55c135aeff8b7fe3d5a957511a6fbcbe8eb957660906aba3129e4d4a92e753d0a35b0bdca1c18e9c8198d0d9536f71714610ffb50ff89f05aed68d769cc070e03d59fe2dc2ac0241f2468278584b0366</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">要密码，快滚.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>静态成员</title>
    <link href="/2022/05/11/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/"/>
    <url>/2022/05/11/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/</url>
    
    <content type="html"><![CDATA[<p>静态成员</p><span id="more"></span><h1 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>基本关键字： static<br>用static修饰的成员变量、方法、属性等的成为静态成员</p><p>特点：直接用类名点出使用<br>Console就是一个静态类</p><h2 id="声明静态成员变量-及-使用"><a href="#声明静态成员变量-及-使用" class="headerlink" title="声明静态成员变量 及 使用"></a>声明静态成员变量 及 使用</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Test&#123;    &#x2F;&#x2F;public和static 前后无所谓    public static float PI &#x3D; 3.1415926f;    &#x2F;&#x2F;成员变量    public int testInt &#x3D; 100;    &#x2F;&#x2F;静态成员方法    public static float CalcCricle(float r)    &#123;        return PI * r * r;    &#125;    &#x2F;&#x2F;普通成员方法    public void TestFun()    &#123;        Console.WriteLine(&quot;123&quot;);    &#125;&#125;internal class Program&#123;    static void Main(string[] args)    &#123;        &#x2F;&#x2F;类名.静态成员变量  不需要实例化        Console.WriteLine(Test.PI);        Console.WriteLine(Test.CalcCricle(2));    &#125;&#125;</code></pre></div><h2 id="为什么可以直接点出来使用"><a href="#为什么可以直接点出来使用" class="headerlink" title="为什么可以直接点出来使用"></a>为什么可以直接点出来使用</h2><p><strong>程序中是不能无中生有的</strong><br>需要使用的对象，变量，函数都是要在内存中分配内存空间的<br>之所以要实例化对象，目的就是分配内存空间，在程序中产生一个抽象的对象</p><p><strong>静态成员的特点</strong><br>程序开始运行时，就会分配内存空间，得以直接使用<br>静态成员和程序是同生共死的<br>只要使用了它，知道程序结束时才会被释放<br>所以一个静态成员就会有自己唯一的一个“内存小房间”<br>这让静态成员就有了唯一性<br>在任何地方使用都是用的小房间里的内容，改变了它也是改变小房间里的内容</p><h2 id="静态函数非静态成员-x2F-非静态函数静态成员"><a href="#静态函数非静态成员-x2F-非静态函数静态成员" class="headerlink" title="静态函数非静态成员&#x2F;非静态函数静态成员"></a>静态函数非静态成员&#x2F;非静态函数静态成员</h2><p>成员变量只能将对象实例化出来后，才能点出来使用，不能无中生有<br>不能直接使用非静态函数，否则会报错<br><strong>静态函数中不可以直接使用非静态成员</strong><br><strong>非静态函数中可以直接使用静态成员</strong></p><h2 id="静态成员对于我们的作用"><a href="#静态成员对于我们的作用" class="headerlink" title="静态成员对于我们的作用"></a>静态成员对于我们的作用</h2><p>静态变量：<br>1.常用唯一变量的声明<br>2.方便别人获取的对象声明</p><p>静态方法：<br>常用的唯一的方法声明<br>比如：相同规则的数学计算相关函数</p><h2 id="常量和静态变量"><a href="#常量和静态变量" class="headerlink" title="常量和静态变量"></a>常量和静态变量</h2><p>const 可以理解为特殊的 static<br><strong>相同点：</strong><br>他们都可以通过类名.点出使用<br><strong>不同点：</strong><br>1.const必须初始化，不能修改; static没有这个规则<br>2.const只能修饰变量; static可以修饰很多(成员方法等)<br>3.const一定是写在访问修饰符后面的(3P后面); static没有这个要求</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/11/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><p>const与static<br><strong>相同点：</strong><br>他们都可以通过类名.点出使用<br><strong>不同点：</strong><br>1.const必须初始化，不能修改; static没有这个规则<br>2.const只能修饰变量; static可以修饰很多(成员方法等)<br>3.const一定是写在访问修饰符后面的(3P后面); static没有这个要求</p><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson7_静态成员&#123;    class Sign    &#123;        static public float PI &#x3D; 3.1415926f;     &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Console.WriteLine(Sign.PI);        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月11日</title>
    <link href="/2022/05/11/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%8811%E6%97%A5/"/>
    <url>/2022/05/11/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%8811%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="be939b2d46b025fbe51dda7ebc66eb6271595024478834df5326db5e8a7da3dc">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50fdd0ca3edc57389bd0e88084b7db20234fb2de3fa3c9a49542ad620f534d4c6e8804b5584cdb8a3a926d0211e1b7b90f05911c848b71e690820b0e3332e95fad55a6e09296d83f6fd1172e898d38e42fc5120c6e43033e1dc9c18617ad7dba07711204ac566923a7a8304d26e7a85f0d4ab1f4723f9f438238aa5ddac250ed8355d8d3527506f07dfd520b6167bebf871cf18cdd5cf564666be28c4440538f6f79d479958ef3a03f075fe85795cf78c2c12fcc4efa9a49164816d35a9b6372411d9d299dbcc975918b4d7c4da0b245618bab46a297ced7f824309379cc6a17c9aaa6ef3479e43de57e395a27f79b202c193ed0f2be4867cada9a531d21b90b143b1236b0844635a44489d87b697751a511078032a4b7a8fd536a48b596443d23263e3caa7dd54296e15e800906aaa59cfc8e3f00c155bfa37c4ec958a344d1a9679ef17acc595fbeaa39efda24bb6f3a1dde15ba83d0a37cdcfe54f0fc73c6df01b31a90e0fe630e2e12e91d51c77b28f2910f789c5ec86ccd159ae101df43b862dc109a5349722974f72ad943e4c063bc0915fd0832cef7177d7db854a03be58765284c7dce461b8794b9351c6a095b652363351b8e51bd5c6ee525d89e2495d22e1cf1836d8adce598bd290ab8ed8db3faa0a832330ec53822a8cdeabc004a08f534bebdb18aa4c9fd05091dc25187b765091a6af31af5c55cf0cb9c93bd5681fd881235835189265394eeba7d97dd000f1440b6f12fd081a16140c65edc561244f3fa16c584e4e06a5311ab55eebaf19f8c95ee5d640f2887b9ba44b828f3e4237a8b0526729dc9ba67f983f6699337100b0f7fcdbda2a778b1a3dcc5124d6cfbfbb4df9fc1f89d4e359b63bbf8ec80e0fec225b24507cef06a04aa25d7df615b83c5a78caa61402d182e95f9dee72067b1a81afbbb8cbb7045cd7b02445b069008912a6330aedccae24a60475f9ce24c741d5d09366a6472c21e6c65d882b774b2508ca4f85ba854a7199b591093e5946691cd81fb86b491ef34fc95df39ffb5a513764716585dfd60a7bc577c7ce0579ea76b8bf34b866e164d431d6acb2fdc68eb6825257097c80a492fffb411487e4bba652cc0d340dd72ca4e6b2dace8000a7a4dc784f4ecd633bb3b24ade405ae5b499deae99c18b039fc774cdcc825a4b83d59e4a555f60dfaaa69fd211a5c91ae0b15021bf6426ee07b3ac4eff79054ac0153db9710165013fc0b35cc46a6dba8d5b9fce00406d8212b86b4098f431390d59c7cb0e1c19e7289b001b2d334b128771862514bbfc9c12adc676b4f80abc66d81a163786912f2f1f4e7afc23197f74aef80ed5ee42f50ef28bcbe978d9833ac30a2b8c111dc712634d829e8942dfb81d23bd77661e442cde919e1a298a3c891fd14f474b9cb57d809901de545d228c545b46f7d97f7b9f445bca7ecd6b3f3d39f5bc94e8578caa87644f54d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">要密码，快滚.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>索引器</title>
    <link href="/2022/05/11/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E7%B4%A2%E5%BC%95%E5%99%A8/"/>
    <url>/2022/05/11/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E7%B4%A2%E5%BC%95%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>索引器</p><span id="more"></span><h1 id="索引器"><a href="#索引器" class="headerlink" title="索引器"></a>索引器</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>让对象可以像数组一样通过索引访问其中元素<br>使程序看起来更直观，更容易编写</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Person&#123;    private string name;    private int age;    private Person[] friends;    &#x2F;&#x2F;访问修饰符 返回值 this[参数类型 参数名, 参数类型 参数名, ......]    public Person this[int index]    &#123;        get        &#123;            return friends[index];        &#125;        set        &#123;            friends[index] &#x3D; value;        &#125;    &#125;&#125;</code></pre></div><h2 id="索引器的使用"><a href="#索引器的使用" class="headerlink" title="索引器的使用"></a>索引器的使用</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Person p &#x3D; new Person();p[0] &#x3D; new Person();</code></pre></div><h2 id="索引器中可以写逻辑"><a href="#索引器中可以写逻辑" class="headerlink" title="索引器中可以写逻辑"></a>索引器中可以写逻辑</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Person&#123;    private string name;    private int age;    private Person[] friends;    public Person this[int index]    &#123;        get        &#123;            if(friends &#x3D;&#x3D; null ||                friends.Length - 1 &lt; index)            &#123;                return null;            &#125;            return friends[index];        &#125;        set        &#123;            if(friends &#x3D;&#x3D; null)            &#123;                friends &#x3D; new Person[] &#123; value &#125;;            &#125;            else if(index &gt; friends.Length - 1)            &#123;                &#x2F;&#x2F;自己定了一个规则 如果索引越界 就默认把最后一个朋友顶掉                friends[friends.Length - 1] &#x3D; value;            &#125;            friends[index] &#x3D; value;        &#125;    &#125;&#125;</code></pre></div><h2 id="索引器可以重载"><a href="#索引器可以重载" class="headerlink" title="索引器可以重载"></a>索引器可以重载</h2><p>重载的概念是：函数名相同，参数类型、数量、顺序不同</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Person&#123;    private string name;    private int age;    private Person[] friends;    private int[,] array;    &#x2F;&#x2F;重载this    public int this[int i, int j]    &#123;        get        &#123;            return array[i, j];        &#125;        set        &#123;            array[i, j] &#x3D; value;        &#125;    &#125;    public int this[string str]    &#123;        get        &#123;            switch(str)            &#123;                case &quot;name&quot;:                    return this.name;                case &quot;age&quot;:                    return age.ToString();            &#125;            return &quot;&quot;;        &#125;    &#125;    public Person this[int index]    &#123;        get        &#123;            return friends[index];        &#125;        set        &#123;            friends[index] &#x3D; value;        &#125;    &#125;&#125;</code></pre></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>索引器的作用：<br>1.以中括号的形式访问自定义类中的元素<br>2.规则自己定，访问时与数组相同<br>3.比较适用于，在类中有数组变量时使用，可以方便地访问和进行逻辑处理</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/11/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E7%B4%A2%E5%BC%95%E5%99%A8/exam.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson6_索引器&#123;    class Num    &#123;        private int[] number &#x3D; new int[5];        &#x2F;&#x2F;用索引器由外部定义数组        public int this[int index]        &#123;            get            &#123;                return number[index];            &#125;            set            &#123;                number[index] &#x3D; value;            &#125;        &#125;        &#x2F;&#x2F;增        public void Add(Num arr, int num)        &#123;            int[] number1 &#x3D; new int[arr.number.Length + 1];            for (int i &#x3D; 0; i &lt; arr.number.Length; i++)            &#123;                number1[i] &#x3D; arr.number[i];            &#125;            number1[number.Length] &#x3D; num;            arr.number &#x3D; number1;            &#x2F;&#x2F;因为number数组是private类型 只能在类内直接打印            for (int i &#x3D; 0; i &lt; arr.number.Length; i++)            &#123;                Console.WriteLine(arr.number[i]);            &#125;        &#125;        &#x2F;&#x2F;查        public int Search(Num arr, int num)        &#123;            &#x2F;&#x2F;暴力遍历寻找            for (int i &#x3D; 0; i &lt; arr.number.Length; i++)            &#123;                if(arr.number[i] &#x3D;&#x3D; num)                &#123;                    &#x2F;&#x2F;找到输出位置                    return i;                &#125;            &#125;            &#x2F;&#x2F;找不到输出-1            return -1;        &#125;        &#x2F;&#x2F;删        public void Del(Num arr, int num)        &#123;                 if(arr.Search(arr, num) !&#x3D; -1)            &#123;                for (int i &#x3D; arr.Search(arr, num); i &lt; arr.number.Length - 1; i++)                &#123;                    arr.number[i] &#x3D; arr.number[i + 1];                &#125;                arr.number[arr.number.Length - 1] &#x3D; 0;                Console.WriteLine(&quot;删除成功&quot;);             &#125;            else            &#123;                Console.WriteLine(&quot;没有您想要删的数，删除失败&quot;);            &#125;        &#125;        &#x2F;&#x2F;改  num1改成num2        public void Change(Num arr, int num1, int num2)        &#123;            if (arr.Search(arr, num1) !&#x3D; -1)            &#123;                arr.number[arr.Search(arr, num1)] &#x3D; num2;                Console.WriteLine(&quot;修改成功&quot;);            &#125;            else            &#123;                Console.WriteLine(&quot;没有您想要改的数，修改失败&quot;);            &#125;        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            &#x2F;&#x2F;初始化数组            Num arr &#x3D; new Num();            arr[0] &#x3D; 1;            arr[1] &#x3D; 15;            arr[2] &#x3D; 8;            arr[3] &#x3D; 11;            arr[4] &#x3D; 7;            &#x2F;&#x2F;增            arr.Add(arr, 9);            &#x2F;&#x2F;删            arr.Del(arr, 1);            arr.Del(arr, 10);            &#x2F;&#x2F;查            int n &#x3D; int.Parse(Console.ReadLine());            Console.WriteLine(&quot;您想找的数&#123;0&#125;在数组的第&#123;1&#125;位&quot;, n, arr.Search(arr, n) + 1);            &#x2F;&#x2F;改            arr.Change(arr, 9, 66);        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月10日</title>
    <link href="/2022/05/10/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%8810%E6%97%A5/"/>
    <url>/2022/05/10/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%8810%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="2ddfa4cdb3dfb32c5fbb8b9cfd6b6cc0eb8d56c4388893dc14dc7b42bd66d8f9">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50dc870b27b76d3b90c48267d59720f330ba0b7dd5ba881f78758bd2db60f83bb0d35cfaad6b2af34092909565a0195bbaf9ddf7e87d31f7e3c318a88e076cd535bc3fd7aef531751c0f5540593857d91bf4f4f42c93a1a325bb77fdff723b1d82ed1ac68e49f561d1a5093b552d4a42666b95c0a5c9d743ebb28ae48ca585f01534d411ce08eef72296f210475df0ca550c05b75f3c1eb74f226d6af71c454bb96a1aba1e58da61afaf8eeaf2907d94fa1e9555a3792ff62334f2a9eaf61c3f027ffed6813cadc0399eadfea2b935a68335d58afe75057d7614f357a4212eef2dc3774a8c9201fdfb665652c7acd463739060ae2cbe6ad90601a3d58a244f934fbe883f30bbb93ef033c2d58595bdc82c7d8306797e04393478f4eb5c9fd1ceca96044ac94374ae50576701164e85cd1f916154344e38cecb6ac6f9b89f2b76e37a32944ade07db98218ed0d4b88aec24ec0bb24f5854b591864e532171f4507fd5db68ed4e036a915717798e230bc24358f992ef8ba87fc956fbf188a8b78eedc631939617f9a1d4a331c792ef8a623914ce541812bcc59cce1dca10cba76641c18337cbe782ff0c553e2ab7c304d7aff49827b2585c8d20568ab64e66294d9f7701d7d4b269f79f2aae01584a72ff7c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">要密码，快滚.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>成员属性</title>
    <link href="/2022/05/10/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7/"/>
    <url>/2022/05/10/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>成员属性</p><span id="more"></span><h1 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>1.用于保护成员变量<br>2.为成员属性的获取和赋值添加逻辑处理<br>3.解决3P的局限性<br>    public - 内外访问<br>    private - 内部访问<br>    protected - 内部和子类访问<br>属性可以让成员变量在外部 <strong>只能获取不能修改</strong> 或 <strong>只能修改不能获取</strong></p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Person&#123;    private string name;    &#x2F;&#x2F;属性的命名一般使用 帕斯卡命名法    &#x2F;&#x2F;访问修饰符 属性类型 属性名    public string Name    &#123;        get        &#123;            &#x2F;&#x2F;可以在返回前添加一下逻辑规则（解密）            &#x2F;&#x2F;get意味着这个属性可以获取的内容 需要return内容            return name;        &#125;        set        &#123;            &#x2F;&#x2F;可以在设置前添加一下逻辑规则（加密）            &#x2F;&#x2F; value 关键字 用于表示外部传入的值            name &#x3D; value;                         &#125;    &#125;&#125;  </code></pre></div><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Person p &#x3D; new Person();p.Name &#x3D; &quot;季宝&quot;;</code></pre></div><h2 id="get和set前可以加访问修饰符"><a href="#get和set前可以加访问修饰符" class="headerlink" title="get和set前可以加访问修饰符"></a>get和set前可以加访问修饰符</h2><p><strong>解决3P局限性</strong><br>1.默认不加 会使用属性声明时的访问权限<br>2.加的访问修饰符要低于属性的访问权限（public的访问权限是最高级的）<br>3.不能让get和set的访问权限都低于属性的权限（逻辑上外部的访问修饰符无效，报错）</p><h2 id="get和set只能有一个"><a href="#get和set只能有一个" class="headerlink" title="get和set只能有一个"></a>get和set只能有一个</h2><p>只有一个时 没有必要在前面加访问修饰符<br>且一般只有get 没有set</p><h2 id="自动属性"><a href="#自动属性" class="headerlink" title="自动属性"></a>自动属性</h2><p>属性语句块中只有get和set<br><strong>作用：</strong><br>外部能得不能改的特征<br>如果类中有一个特征是只希望外部能得不能改的 又没有什么特别处理<br>那么可以直接使用自动属性</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Person&#123;    private Height;    &#x2F;&#x2F;不用专门去声明成员变量 直接通过属性来表示特殊的成员变量    public float Height    &#123;        &#x2F;&#x2F;没有在get和set中写逻辑的需求或者想法        get;        set;    &#125;    &#x2F;&#x2F;等价于    public float Height &#123; get; set; &#125;&#125;  </code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/10/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7/exam.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson5_成员属性&#123;    class Student    &#123;        private string name;        private string sex;        private int age;        private int csharpScore;        private int unityScore;        public string Name &#123; get; set; &#125;        public string Sex         &#123;             get            &#123;                if (sex !&#x3D; &quot;男&quot; &amp;&amp; sex !&#x3D; &quot;女&quot;)                &#123;                    Console.WriteLine(&quot;请输入正确的性别,默认男&quot;);                    return &quot;男&quot;;                &#125;                else                &#123;                    return sex;                &#125;                            &#125;            set            &#123;                sex &#x3D; value;            &#125;        &#125;        public int Age         &#123;             get            &#123;                return age;                &#125;            set            &#123;                if (value &gt;&#x3D; 0 &amp;&amp; value &lt;&#x3D; 150)                &#123;                    age &#x3D; value;                &#125;                else                &#123;                    Console.WriteLine(&quot;请输入0~150之间的年龄,默认20&quot;);                    age &#x3D; 20;                &#125;               &#125;        &#125;        public int CSharpScore        &#123;            get            &#123;                if (csharpScore &gt;&#x3D; 0 &amp;&amp; csharpScore &lt;&#x3D; 150)                &#123;                    return csharpScore;                &#125;                else                &#123;                    Console.WriteLine(&quot;请输入0~100之间的成绩,默认60&quot;);                    return 60;                &#125;            &#125;            set            &#123;                csharpScore &#x3D; value;            &#125;        &#125;        public int UnityScore        &#123;            get            &#123;                if (unityScore &gt;&#x3D; 0 &amp;&amp; unityScore &lt;&#x3D; 150)                &#123;                    return unityScore;                &#125;                else                &#123;                    Console.WriteLine(&quot;请输入0~100之间的成绩,默认60&quot;);                    return 60;                &#125;            &#125;            set            &#123;                unityScore &#x3D; value;            &#125;        &#125;        public void Hello1()        &#123;            Console.WriteLine(&quot;我叫&#123;0&#125;,今年&#123;1&#125;岁了&quot;, Name, Age);        &#125;        public void Hello2()        &#123;            Console.WriteLine(&quot;我是&#123;0&#125;生,我的总分是&#123;1&#125;,平均分是&#123;2&#125;&quot;, Sex, CSharpScore + UnityScore, (CSharpScore + UnityScore)&#x2F;2);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Student s1 &#x3D; new Student();            s1.Name &#x3D; &quot;季宝&quot;;            s1.Sex &#x3D; &quot;男&quot;;            s1.Age &#x3D; 170;            s1.CSharpScore &#x3D; 80;            s1.UnityScore &#x3D; 80;            s1.Hello1();            s1.Hello2();            Student s2 &#x3D; new Student();        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>封装_构造函数和析构函数</title>
    <link href="/2022/05/10/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E5%B0%81%E8%A3%85-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
    <url>/2022/05/10/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E5%B0%81%E8%A3%85-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>封装_构造函数和析构函数</p><span id="more"></span><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>在实例化对象时 会调用的用于初始化的函数<br>（如果不写 默认存在一个无参构造函数）</p><h2 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h2><p>1.没有返回值<br>2.函数名和类名必须相同<br>3.没有特殊需求时，一般都是public的<br>4.构造函数可以被重载<br>5.this代表当前调用该函数的对象自己</p><h2 id="特殊写法"><a href="#特殊写法" class="headerlink" title="特殊写法"></a>特殊写法</h2><p>可以通过this 重用构造函数代码</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">访问修饰符 构造函数名(参数列表):this(参数1,参数2......)</code></pre></div><p>即该构造函数会先执行this所代表的构造函数，再执行自己的逻辑</p><p><strong>注意</strong><br>1.类中是允许自己声明无参构造函数的，结构体是不允许的<br>2.如果不自己实现无参构造函数而实现了有参构造函数，会失去默认的无参构造函数</p><h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p>当<strong>引用类型的堆内存被回收</strong>时，会调用该函数<br>对于需要手动管理内存的语言(比如c++)，需要在析构函数中做一些内存回收处理<br>但是c#中存在垃圾回收机制GC<br>所以几乎不会怎么使用析构函数，除非需要对某一个对象被垃圾回收时，做一些特殊处理</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">~类名()&#123;&#125;</code></pre></div><h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><p>垃圾回收(GC,Garbage Collector)<br>1.垃圾回收的过程是遍历堆(Heap)上动态分配的所有对象<br>2.通过识别他们是否被引用来确定哪些对象是垃圾，哪些对象仍要被引用<br>3.所谓的垃圾就是没有被任何变量，对象引用的内容(垃圾就需要被回收释放)</p><p>垃圾回收有多种算法：<br>1.引用计数(Reference Counting)<br>2.标记清楚(Mark Sweep)<br>3.标记整理(Mark Compact)<br>4.复制集合(Copy Collection)</p><p><strong>注意</strong><br>GC只负责堆(Heap)内存的垃圾回收<br>引用类型都是存在堆(Heap)中的，所以它的分配和释放都通过垃圾回收机制来管理</p><p>栈(Stack)上的内存是有系统自动管理的<br>值类型是在栈(Stack)中分配内存的，他们有自己的生命周期，不用对他们进行管理，会自动分配和释放</p><p><strong>C#中内存回收机制的大概原理</strong><br>内存分为： 0代内存 1代内存 2代内存<br><strong>代的概念</strong>：<br>代是垃圾回收机制使用的一种算法(分代算法)<br>新分配的对象都会被配置在第0代内存中<br>每次分配都可能会进行垃圾回收以释放内存(0代内存满时)</p><p>在一次内存回收过程开始时，垃圾回收器会认为堆中全是垃圾，会进行以下两步：<br>1.标记对象，从根（静态字段、方法参数）开始检查引用对象，标记后为可达对象，未标记为不可达对象，不可达对象就认为是垃圾<br>2.搬迁对象压缩堆（挂起执行托管代码线程），释放未标记的对象，搬迁可达对象，修改引用地址</p><p>大对象总被认为是第2代内存，目的是减少性能损耗，提高性能<br>不会对大对象进行搬迁压缩 85000字节（83kb）以上的对象为大对象</p><p>手动触发垃圾回收的方法<br>一般情况下不会频繁调用<br>都是在Loading过场景时才调用</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">GC.Collect();</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/10/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E5%B0%81%E8%A3%85-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/exam.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson4_封装_构造函数和析构函数&#123;    class Person    &#123;        public string name;        public int age;        public Person()        &#123;            name &#x3D; &quot;大逼&quot;;            age &#x3D; 23;        &#125;        public Person(string name)            &#123; this.name &#x3D; name; &#125;        public Person(int age)            &#123; this.age &#x3D; age; &#125;    &#125;    class Lesson    &#123;        public int ID;        public int num;        public Lesson()        &#123;            ID &#x3D; 1;            num &#x3D; 10;        &#125;        public Lesson(int ID, int num)        &#123;             this.ID &#x3D; ID;             this.num &#x3D; num;        &#125;    &#125;    class Ticket    &#123;        public uint distance;        public float price;        public Ticket(uint distance)        &#123;            this.distance &#x3D; distance;        &#125;        public void GetPrice()        &#123;            if(0 &lt;&#x3D; distance &amp;&amp; distance &lt;&#x3D; 100)            &#123;                price &#x3D; 1.0f * distance;            &#125;            else if(100 &lt; distance &amp;&amp; distance &lt;&#x3D; 200)            &#123;                price &#x3D; 0.95f * (distance - 100) + 100;            &#125;            else if(200 &lt; distance &amp;&amp; distance &lt;&#x3D; 300)            &#123;                price &#x3D; 0.9f * (distance - 200) + 195;            &#125;            else if(distance &gt; 300)            &#123;                price &#x3D; 0.8f * (distance - 300) + 385;            &#125;        &#125;        public void Print()        &#123;            GetPrice();            Console.WriteLine(&quot;&#123;0&#125;公里&#123;1&#125;块钱&quot;, distance, price);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Person p1 &#x3D; new Person();            Person p2 &#x3D; new Person(&quot;季宝&quot;);            Person p3 &#x3D; new Person(22);            Lesson l1 &#x3D; new Lesson();            Lesson l2 &#x3D; new Lesson(2, 46);            try            &#123;                Ticket t1 &#x3D; new Ticket(uint.Parse(Console.ReadLine()));                t1.Print();            &#125;            catch            &#123;                Console.WriteLine(&quot;请输入正数&quot;);            &#125;            &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>成员方法</title>
    <link href="/2022/05/09/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95/"/>
    <url>/2022/05/09/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>成员方法</p><span id="more"></span><h1 id="成员方法的声明"><a href="#成员方法的声明" class="headerlink" title="成员方法的声明"></a>成员方法的声明</h1><p><strong>基本概念</strong>：<br>成员方法（函数） 用来表现对象行为<br>1.声明在语句块中<br>2.是用来描述对象的行为的<br>3.规则和函数声明规则相同<br>4.受到访问修饰符规则影响<br>5.返回值参数不做限制<br>6.方法数量不做限制</p><p><strong>注意</strong>：<br>1.成员方法不要加static关键字<br>2.成员方法必须实例化出对象，再通过对象来使用，相当于该对象执行了某个行为<br>3.成员方法 受到访问修饰符影响</p><h1 id="成员方法的使用"><a href="#成员方法的使用" class="headerlink" title="成员方法的使用"></a>成员方法的使用</h1><p>必须实例化出对象，再通过对象来使用，相当于该对象执行了某个行为</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/09/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95/exam.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson3_成员方法&#123;    #region 练习题1    class Person    &#123;        public string name;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 说话        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;str&quot;&gt;&lt;&#x2F;param&gt;        public void Speak(string str)        &#123;            Console.WriteLine(&quot;&#123;0&#125;说&#123;1&#125;&quot;, name, str);        &#125;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 走路        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;s&quot;&gt;&lt;&#x2F;param&gt;        public void Walk(int s)        &#123;            Console.WriteLine(&quot;&#123;0&#125;走了&#123;1&#125;步&quot;, name, s);        &#125;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 吃饭        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;food&quot;&gt;&lt;&#x2F;param&gt;        public void Eat(Food food)        &#123;            Console.WriteLine(&quot;&#123;0&#125;吃了&#123;1&#125;,吸收了&#123;2&#125;热量&quot;, name, food.name, food.heat);        &#125;    &#125;    #endregion    #region 练习题2    class Student    &#123;        public string name;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 学习        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;subject&quot;&gt;&lt;&#x2F;param&gt;        public void Study(string subject)        &#123;            Console.WriteLine(&quot;&#123;0&#125;在学习&#123;1&#125;&quot;, name, subject);        &#125;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 吃饭        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;food&quot;&gt;&lt;&#x2F;param&gt;        public void Eat(Food food)        &#123;            Console.WriteLine(&quot;&#123;0&#125;吃了&#123;1&#125;,吸收了&#123;2&#125;热量&quot;, name, food.name, food.heat);        &#125;    &#125;    #endregion    #region 练习题3    class Food    &#123;        public E_FoodName name;        public int heat;    &#125;    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 食物种类枚举    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_FoodName    &#123;        Apple &#x3D; 10,        Banana &#x3D; 20,        Mango &#x3D; 30,    &#125;    #endregion        internal class Program    &#123;        static void Main(string[] args)        &#123;            #region 练习题123            Person p &#x3D; new Person();            p.name &#x3D; &quot;大逼&quot;;            Student s &#x3D; new Student();            s.name &#x3D; &quot;季宝&quot;;            Food f &#x3D; new Food();            f.name &#x3D; E_FoodName.Apple;            f.heat &#x3D; (int)f.name;            p.Eat(f);            s.Eat(f);            #endregion        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>成员变量和访问修饰符</title>
    <link href="/2022/05/09/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <url>/2022/05/09/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<p>成员变量  访问修饰符</p><span id="more"></span><h1 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h1><p>基本规则：<br>1.声明在类语句块中 class<br>2.用来描述对象的特征<br>3.可以是任意变量类型<br>4.数量不做限制<br>5.是否赋值根据需求来定<br>6.在类里 可以声明和自己一样的变量类型 但不能对它实例化</p><h1 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h1><p>基本作用： 决定类内部成员的访问权限<br><strong>public</strong>  公共的  自己（内部）和别人（外部）都能访问和使用<br><strong>private</strong>  私有的  自己（内部）才能访问和使用    不写默认为private<br><strong>protected</strong>  保护的  自己（内部）和子类才能访问和使用</p><h1 id="成员变量的初始值"><a href="#成员变量的初始值" class="headerlink" title="成员变量的初始值"></a>成员变量的初始值</h1><p><strong>值类型</strong>：数字类型默认0  bool类型默认false<br><strong>引用类型</strong>：默认为null<br>技巧： Console.WriteLine(default(你想查询初始值的类型名));</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/09/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/exam.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson2_成员变量和访问修饰符&#123;    #region 练习题1    &#x2F;&#x2F; 3P &#x3D; public  private  protected  访问修饰符    #endregion    #region 练习题2    &#x2F;&#x2F;定义人类    class Person    &#123;        &#x2F;&#x2F;特征 成员变量        &#x2F;&#x2F;姓名        public string name;        &#x2F;&#x2F;身高        public int height;        &#x2F;&#x2F;年龄        public int age;         &#x2F;&#x2F;家庭住址        public string location;    &#125;    #endregion    #region 练习题3    &#x2F;&#x2F;定义学生    class Student    &#123;        &#x2F;&#x2F;特征 成员变量        &#x2F;&#x2F;姓名        public string name;        &#x2F;&#x2F;学号        public string ID;        &#x2F;&#x2F;年龄        public int age;         &#x2F;&#x2F;同桌        public Student deskmate;        &#x2F;&#x2F;行为 成员方法            &#125;    #endregion    #region 练习题4    &#x2F;&#x2F;定义班级    class Lesson    &#123;        &#x2F;&#x2F;特征 成员变量        &#x2F;&#x2F;专业名称        public string majorName;        &#x2F;&#x2F;学号        public string ID;        &#x2F;&#x2F;教师容量        public int teacherNum;        &#x2F;&#x2F;学生        public Student[] students;    &#125;    #endregion        internal class Program    &#123;        static void Main(string[] args)        &#123;                     #region 练习题5            Person p &#x3D; new Person();            p.age &#x3D; 10;            Person p2 &#x3D; new Person();            p2.age &#x3D; 20;            Console.WriteLine(p.age);            &#x2F;&#x2F;10            #endregion            #region 练习题6            Person p3 &#x3D; new Person();            p3.age &#x3D; 10;            Person p4 &#x3D; p3;            p4.age &#x3D; 20;            Console.WriteLine(p3.age);            &#x2F;&#x2F;20            #endregion            #region 练习题7            Student s &#x3D; new Student();            s.age &#x3D; 10;            int age &#x3D; s.age;            age &#x3D; 20;            Console.WriteLine(s.age);            &#x2F;&#x2F;10            #endregion            #region 练习题8            Student s1 &#x3D; new Student();            s1.deskmate &#x3D; new Student();            s1.deskmate.age &#x3D; 10;            Student s2 &#x3D; s1.deskmate;            s2.age &#x3D; 20;            Console.WriteLine(s1.deskmate.age);            &#x2F;&#x2F;20            #endregion        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月9日</title>
    <link href="/2022/05/09/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%889%E6%97%A5/"/>
    <url>/2022/05/09/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%889%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="d84eba87eff053a4f05c219966365787260261f4cbb94d56ff5eeb1ec094dde8">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe500d33c330961da8b059aa497902f1d00c4410c00f3db9aa6f2ce9955bc5e104c1a98bc530f4a959a1fa2d4236ca77aae0eb5c5355d7786a3c44af12629597575f747fb04ed906b56e8ad3421784ba17e2c155600383c595fea8bdd189b30477f4b101091a57576294adea8b132d3ae11d1bb2e7f43f487c41678825fe3e100da793400da2af07a6eaa040230bce11743a49ca83f002ce9c69cc4e60b917e2c710fe3b72b5c28dc8cde0ee325f55112d67dd525a484c75817eb7f252fec8cb0fa311f4cdad3d7ec4f88aef74205a2cdcd3534476a7b3177921f983a0661c26a644c5761ba1931b83c6328fdb8cc7918de4da9dcff42de36d825edac9f151f8e7a2b5969d5b34fcfe3e914cca177ee7356e47061ef3c4a45df707867e4e95ce54f4ea9f782f9d0543b5631f22c3652a7caf727bbde4d9cc435c2e836c9ef74b6e6e9fc297fdaeb7fe1d7cf5a961e7cb04a00f34c54a85daa1e9b1573d32ff6c2b9402de755dc71a9357e50ea941b5f5748bb06fef3ee5bfc49db813efa128320352f07240c239607e59b3f619142a101a07a14653e48a88ea02c14322266a11b287216ded8ceddcec4d458448f7ca737ce0186587348816e1b23c8c5a7f7b7db32fc100a3e41e60ecd904d5419b07ae69a51518151ab9ce7aef987328799ca2c0c7</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">要密码，快滚.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类和对象</title>
    <link href="/2022/05/08/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <url>/2022/05/08/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>类 对象</p><span id="more"></span><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>基本概念：<br>1.具有相同特征<br>2.具有相同行为<br>3.一类事物的抽象<br>4.类是对象的模板<br>5.可以通过类创建出对象<br>6.类的关键词 class</p><p>一般声明在 <strong>namespace</strong> 语句块中<br>声明语法：<br> <div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">访问修饰符 class 类名&#123;    &#x2F;&#x2F;封装    特征 成员变量    行为 成员方法    保护特征 成员属性    构造函数和析构函数    索引器    运算符重载    静态成员&#125;</code></pre></div></p><h1 id="（类）对象"><a href="#（类）对象" class="headerlink" title="（类）对象"></a>（类）对象</h1><p>基本概念：<br>1.<strong>类的声明</strong>和<strong>类对象（变量）声明</strong>是两个概念<br>2.<strong>类的声明</strong>类似<strong>枚举</strong>和<strong>结构体的声明</strong>（类的声明相当于声明了一个自定义变量类型）<br>3.对象是类创建出来的（相当于声明一个<strong>指定类的变量</strong>）<br>4.类创建对象的过程（一般称为<strong>实例化对象</strong>）<br>5.类对象都是<strong>引用类型</strong>的</p><p>声明语法：</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">类名 变量名;类名 变量名 &#x3D; null; &#x2F;&#x2F;null代表空类名 变量名 &#x3D; new 类名();</code></pre></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1.<strong>类的声明</strong>和<strong>类对象（变量）声明</strong>是两个概念<br>2.<strong>类的声明</strong>是声明对象的模板，用来抽象（形容）显示事物的<br>3.<strong>类对象（变量）声明</strong>是用来表示现实中的对象个体的</p><p>4.<strong>类</strong>是一个自定义的变量类型<br>5.实例化一个<strong>类对象</strong>是在声明变量</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/08/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/%E7%BB%83%E4%B9%A0%E9%A2%98.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">练习题1 懒得做练习题2 A保持不变        GameObject A &#x3D; new GameObject(); &#x2F;&#x2F;新建栈 堆        GameObject B &#x3D; A; &#x2F;&#x2F;新建栈 指向A的堆        B &#x3D; null; &#x2F;&#x2F;B的栈 指向null的堆练习题3 A和B没关系        GameObject A &#x3D; new GameObject(); &#x2F;&#x2F;新建栈 堆        GameObject B &#x3D; A; &#x2F;&#x2F;新建栈 指向A的堆        B &#x3D; new GameObject(); &#x2F;&#x2F;B的栈 指向new的堆</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象编程</title>
    <link href="/2022/05/08/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/05/08/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>面向对象编程 面向过程编程</p><span id="more"></span><h1 id="面向过程编程"><a href="#面向过程编程" class="headerlink" title="面向过程编程"></a>面向过程编程</h1><p>一种<strong>以过程为中心</strong>的编程思想<br>分析出解决问题所需要的步骤<br>然后用函数把步骤一步一步实现<br>使用的时候一个一个一次调用</p><h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>面向对象是一种<strong>对现实世界理解和抽象</strong>的编程方法<br><strong>把相关的数据和方法组织为一个整体来看待</strong><br>从更高的层次来进行程序开发<br>更贴近事物的自然运行模式</p><p>万物皆对象  用程序来抽象（形容）对象  用面向对象的思想来编程</p><img src="/2022/05/08/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E5%AF%B9%E8%B1%A1.png" class=""><p><strong>套路：</strong><br>用中文去形容一类对象<br>把一类对象的共同点提取出来<br>然后用程序语言把它翻译过来<br>带着对象的概念在程序中使用他们</p><h1 id="重要知识点"><a href="#重要知识点" class="headerlink" title="重要知识点"></a>重要知识点</h1><h2 id="面向对象关键知识"><a href="#面向对象关键知识" class="headerlink" title="面向对象关键知识"></a>面向对象关键知识</h2><p>类（class 关键词）</p><h2 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h2><p>重点中的重点：<br><strong>封装</strong> + <strong>继承</strong> + <strong>多态</strong><br><strong>封装</strong>：用程序语言来形容对象<br><strong>继承</strong>：复用封装对象的代码；儿子继承父亲，复用现成代码<br><strong>多态</strong>：同样行为的不同表现，儿子继承父亲的基金但是有不同的行为表现</p><h2 id="面向对象七大原则"><a href="#面向对象七大原则" class="headerlink" title="面向对象七大原则"></a>面向对象七大原则</h2><p>开闭原则<br>依赖倒转原则<br><strong>里式替换原则</strong><br>单一职责原则<br>接口隔离原则<br>合成复用原则<br>迪米特法则</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月8日</title>
    <link href="/2022/05/08/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%888%E6%97%A5/"/>
    <url>/2022/05/08/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%888%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="f59f778e162cd4c5575e8011cc98055fa0bff015c3ee6e202e70659d313c6c3d">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50fdd0ca3edc57389bd0e88084b7db202376ed899917c9c6c734af1f7eca42e06ef4ff0890be6f398558796f868b9f06ee655258737f6db070469b46f13f90d490fab7ed262b0674e752644fe7c26987bc8d8f98b1be0f67c09d7ed761c2f39431f9b5bf55e12b69d0873f8ee72fef88a00ffa617ea3d0cee8ec38a28f098431742f50e9fba2bdd55267e5781d681d47c7621c06254e363fd8f450a5b452e550941cb7bde91bee2ad2dadeef67388f660d4325433b8551d5498c44b50ae1c4ce8573f93da15e1bccd0368270193b6e43ec0bbfb7005c8ccad91008f1ba8dd3c2bc3f817203b2b153ed8b0fb3bb47321b923f8a0b40d5129b483c2eb3b3696f83c13570b18ec4f41c0060981769b4fddf506e84496b93e604bec7f5e9eab245635a58312a1db37ddbe9403b347965029d3609cb00b0963c4f7ea247324ba0a1360931d2cf439647cca7b900d9f7cb66f2fc70100efb41f96eaa24a625c2e6819c6988a6e4223414da010942d393cc9cdef09f2d0040e194370d0dae37a88aeeb44071abbc70cab22737f11086352de96310e23c022150e7804fea3160c52121198389667716f56947b839ddf07ce944b0c04dc9156d1e8f54cc2f56e462f7d484d5437ec4beefea3b5e894006f08d6fd290aed03347811ced529b6d5ab340e33887</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">要密码，快滚.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>飞行棋逻辑整理</title>
    <link href="/2022/05/07/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86/"/>
    <url>/2022/05/07/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>逻辑整理</p><span id="more"></span><img src="/2022/05/07/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86-1.jpg" class=""><img src="/2022/05/07/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86-2.jpg" class=""><img src="/2022/05/07/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86-3.jpg" class=""><img src="/2022/05/07/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86-4.jpg" class="">]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月7日</title>
    <link href="/2022/05/07/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%887%E6%97%A5/"/>
    <url>/2022/05/07/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%887%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="5b619cf13cf1e47245c9944edb189af53431bf3141868f33b1bc6c8529b0537d">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50fdd0ca3edc57389bd0e88084b7db2023fbfbe4a886cec053b0d69678e9bd693646e6fc5a95475d4199d73cf5baa89d2975c29f552c86b61ceb5cf6b8d828ed6db54c925b71bbee4d09b841d4bb0f64dcdcd9d240b83082bb804938681252d82c205164b429d4b7cc40521c2a1c9eb276a4827086157c40dd08c639db597f33df1d69e5990cbf1f0daa82a5abedef55f7d8553f67c6e8c5a24555e176ef3f138ca04a19a4c7db4590582dc6990c19f05b5144c85453f8460bc83ff67eaf1680acf0114d9671864f166d3b5c439aa618409638f886f77ee08119b5f0214d27e7db732bb546ec23bf3cb89d59bd45dbd52bc0d339aba3a38f0d42f6dfc00529ddf5a7876c11a1abf0629dbb98324236013694a91bf301af802b2c31917c3a2caf8e0ca3a33c9d6bd17e426e6ffd47dcb9f1ba2c7e447f08e50df23274fe72317fd37f824f76fb200e67a34e8bb75444dd5d793240fff557be54c992bffb19e0c39dba5b1470c114cee0d9856a170838db012709c926e9d7fbae7536b89d6d6239c8ad703e7435ec3a78a0fca41e9b75f5fe53ed49cc0670391375262a47344164b57d860bca9e476c35796b53c645e567fb2fd4ade582bab275248ba8483cce6035d594a8b3ce12d2ab35583ffc7fdec4a4b23ad4b03f77bbcbcfddc4a9a0a28504f5e1ba3dd8350ebee7fb69b537d8d1d5f9c76fcd9b97499bb88b13ed17196c3a3e62f4ff4471d017c87edb919258bc5d8a682c3abdeb500e8dea1bf57bc50a5a3afbfd880e5514001cfe65b8acdb8384761abb4e434ea4755fe3d55ede3c0fe47b8bf0197a7270464e8ba29ace47286981ba52e456c2016304385ec6e39603713d4fc571182313a552578017fbb8aa66e5b707c998a6f28ce3009764e5fb992c956cad0e48b08a49d4e3a71e3c4f4cdc5c00d2eb058bc7dbc42a3e95484617e1a3c04a7675745812016613fbd0494458e2b4deead739896655b0361c89b6e62cb1257e829076547d97646a2df3e42a35b79391779b4661e37221ba1ca42c5964ea8caa54673a10f82dd0d670173c0c0bda388f3901c0b73785df5c06bdd3a630</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">要密码，快滚.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>飞行棋实现</title>
    <link href="/2022/05/06/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/05/06/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>飞行棋</p><span id="more"></span><p><strong># 实现结果</strong></p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=553774900&bvid=BV17v4y1K7i2&cid=713732660&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace CSharp基础实践教学&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            #region 1 控制台初始化            int w &#x3D; 50;            int h &#x3D; 30;            ConsoleInit(w, h);            #endregion            #region 2 场景选择相关            &#x2F;&#x2F;申明一个 表示场景标识的 变量             E_SceneType nowSceneType &#x3D; E_SceneType.Begin;            while (true)            &#123;                switch (nowSceneType)                &#123;                    case E_SceneType.Begin:                        &#x2F;&#x2F;开始场景逻辑                        Console.Clear();                        &#x2F;&#x2F;来书写 开始场景相关的逻辑即可                        BeginOrEndScene(w, h, ref nowSceneType);                        break;                    case E_SceneType.Game:                        &#x2F;&#x2F;游戏场景逻辑                        Console.Clear();                        &#x2F;&#x2F;通过函数来处理游戏场景的逻辑内容                        GameScene(w, h, ref nowSceneType);                        break;                    case E_SceneType.End:                        &#x2F;&#x2F;结束场景逻辑                        Console.Clear();                        BeginOrEndScene(w, h, ref nowSceneType);                        break;                    default:                        break;                &#125;            &#125;            #endregion        &#125;        #region 1 控制台初始化        static void ConsoleInit(int w, int h)        &#123;            &#x2F;&#x2F;基础设置            &#x2F;&#x2F;光标的隐藏            Console.CursorVisible &#x3D; false;            &#x2F;&#x2F;舞台的大小            Console.SetWindowSize(w, h);            Console.SetBufferSize(w, h);        &#125;        #endregion        #region 3 开始场景逻辑 + 8 结束场景逻辑        static void BeginOrEndScene(int w, int h, ref E_SceneType nowSceneType)        &#123;            Console.ForegroundColor &#x3D; ConsoleColor.White;            Console.SetCursorPosition(nowSceneType &#x3D;&#x3D; E_SceneType.Begin ? w &#x2F; 2 - 3 : w &#x2F; 2 - 4, 8);            Console.Write(nowSceneType &#x3D;&#x3D; E_SceneType.Begin ? &quot;飞行棋&quot; : &quot;游戏结束&quot;);            &#x2F;&#x2F;当前选项的编号            int nowSelIndex &#x3D; 0;            bool isQuitBegin &#x3D; false;            &#x2F;&#x2F;开始场景逻辑处理循环            while (true)            &#123;                Console.SetCursorPosition(nowSceneType &#x3D;&#x3D; E_SceneType.Begin ? w &#x2F; 2 - 4 : w &#x2F; 2 - 5, 13);                Console.ForegroundColor &#x3D; nowSelIndex &#x3D;&#x3D; 0 ? ConsoleColor.Red : ConsoleColor.White;                Console.Write(nowSceneType &#x3D;&#x3D; E_SceneType.Begin ? &quot;开始游戏&quot; : &quot;回到主菜单&quot;);                Console.SetCursorPosition(w &#x2F; 2 - 4, 15);                Console.ForegroundColor &#x3D; nowSelIndex &#x3D;&#x3D; 1 ? ConsoleColor.Red : ConsoleColor.White;                Console.Write(&quot;退出游戏&quot;);                &#x2F;&#x2F;通过ReadKey可以得到一个输入的枚举类型                switch (Console.ReadKey(true).Key)                &#123;                    case ConsoleKey.W:                        --nowSelIndex;                        if (nowSelIndex &lt; 0)                        &#123;                            nowSelIndex &#x3D; 0;                        &#125;                        break;                    case ConsoleKey.S:                        ++nowSelIndex;                        if (nowSelIndex &gt; 1)                        &#123;                            nowSelIndex &#x3D; 1;                        &#125;                        break;                    case ConsoleKey.J:                        if (nowSelIndex &#x3D;&#x3D; 0)                        &#123;                            &#x2F;&#x2F;进入游戏场景                            &#x2F;&#x2F;1 改变当前场景ID                            nowSceneType &#x3D; nowSceneType &#x3D;&#x3D; E_SceneType.Begin ? E_SceneType.Game : E_SceneType.Begin;                            &#x2F;&#x2F;2 退出当前循环                            isQuitBegin &#x3D; true;                        &#125;                        else                        &#123;                            &#x2F;&#x2F;退出游戏                            Environment.Exit(0);                        &#125;                        break;                &#125;                &#x2F;&#x2F;通过标识决定 是否跳出 开始场景的循环                if (isQuitBegin)                &#123;                    break;                &#125;            &#125;        &#125;        #endregion        #region 游戏场景逻辑        static void GameScene(int w, int h, ref E_SceneType nowSceneType)        &#123;            &#x2F;&#x2F;绘制不变的基本信息            DrawWall(w, h);            &#x2F;&#x2F;绘制地图            &#x2F;&#x2F;初始化一张地图             Map map &#x3D; new Map(14, 3, 80);            map.Draw();            &#x2F;&#x2F;绘制玩家            Player player &#x3D; new Player(0, E_PlayerType.Player);            Player computer &#x3D; new Player(0, E_PlayerType.Computer);            DrawPlayer(player, computer, map);            bool isGameOver &#x3D; false;            &#x2F;&#x2F;游戏场景循环            while (true)            &#123;                &#x2F;&#x2F;之后的游戏逻辑                &#x2F;&#x2F;玩家扔色子逻辑                &#x2F;&#x2F;检测输入                &#x2F;&#x2F;Console.ReadKey(true);                &#x2F;&#x2F;&#x2F;&#x2F;扔色子的逻辑                &#x2F;&#x2F;isGameOver &#x3D; RandomMove(w, h, ref player, ref computer, map);                &#x2F;&#x2F;&#x2F;&#x2F;绘制地图                &#x2F;&#x2F;map.Draw();                &#x2F;&#x2F;&#x2F;&#x2F;绘制玩家                &#x2F;&#x2F;DrawPlayer(player, computer, map);                &#x2F;&#x2F;&#x2F;&#x2F;判断是否要结束游戏                &#x2F;&#x2F;if( isGameOver )                &#x2F;&#x2F;&#123;                &#x2F;&#x2F;    &#x2F;&#x2F;卡住程序 让顽疾按任意键                 &#x2F;&#x2F;    Console.ReadKey(true);                &#x2F;&#x2F;    &#x2F;&#x2F;改变场景ID                &#x2F;&#x2F;    nowSceneType &#x3D; E_SceneType.End;                &#x2F;&#x2F;    &#x2F;&#x2F;直接跳出循环                &#x2F;&#x2F;    break;                &#x2F;&#x2F;&#125;                &#x2F;&#x2F;玩家扔色子                if (PlayerRandoMove(w, h, ref player, ref computer, map, ref nowSceneType))                &#123;                    break;                &#125;                &#x2F;&#x2F;电脑扔色子                if (PlayerRandoMove(w, h, ref computer, ref player, map, ref nowSceneType))                &#123;                    break;                &#125;                &#x2F;&#x2F;电脑扔色子逻辑                &#x2F;&#x2F;检测输入                &#x2F;&#x2F;Console.ReadKey(true);                &#x2F;&#x2F;&#x2F;&#x2F;扔色子的逻辑                &#x2F;&#x2F;isGameOver &#x3D; RandomMove(w, h, ref computer, ref player, map);                &#x2F;&#x2F;&#x2F;&#x2F;绘制地图                &#x2F;&#x2F;map.Draw();                &#x2F;&#x2F;&#x2F;&#x2F;绘制玩家                &#x2F;&#x2F;DrawPlayer(player, computer, map);                &#x2F;&#x2F;&#x2F;&#x2F;判断是否要结束游戏                &#x2F;&#x2F;if (isGameOver)                &#x2F;&#x2F;&#123;                &#x2F;&#x2F;    &#x2F;&#x2F;卡住程序 让顽疾按任意键                 &#x2F;&#x2F;    Console.ReadKey(true);                &#x2F;&#x2F;    &#x2F;&#x2F;改变场景ID                &#x2F;&#x2F;    nowSceneType &#x3D; E_SceneType.End;                &#x2F;&#x2F;    &#x2F;&#x2F;直接跳出循环                &#x2F;&#x2F;    break;                &#x2F;&#x2F;&#125;            &#125;        &#125;        static bool PlayerRandoMove(int w, int h, ref Player p, ref Player otherP, Map map, ref E_SceneType nowSceneType)        &#123;            &#x2F;&#x2F;之后的游戏逻辑            &#x2F;&#x2F;玩家扔色子逻辑            &#x2F;&#x2F;检测输入            Console.ReadKey(true);            &#x2F;&#x2F;扔色子的逻辑            bool isGameOver &#x3D; RandomMove(w, h, ref p, ref otherP, map);            &#x2F;&#x2F;绘制地图            map.Draw();            &#x2F;&#x2F;绘制玩家            DrawPlayer(p, otherP, map);            &#x2F;&#x2F;判断是否要结束游戏            if (isGameOver)            &#123;                &#x2F;&#x2F;卡住程序 让顽疾按任意键                 Console.ReadKey(true);                &#x2F;&#x2F;改变场景ID                nowSceneType &#x3D; E_SceneType.End;                &#x2F;&#x2F;直接跳出循环            &#125;            return isGameOver;        &#125;        #endregion        #region 4 绘制不变内容（红墙 提示等等）        static void DrawWall(int w, int h)        &#123;            Console.ForegroundColor &#x3D; ConsoleColor.Red;            &#x2F;&#x2F;画墙            &#x2F;&#x2F;横着的墙            for (int i &#x3D; 0; i &lt; w; i +&#x3D; 2)            &#123;                &#x2F;&#x2F;最上方的墙                Console.SetCursorPosition(i, 0);                Console.Write(&quot;■&quot;);                &#x2F;&#x2F;最下方的墙                Console.SetCursorPosition(i, h - 1);                Console.Write(&quot;■&quot;);                &#x2F;&#x2F;中间的墙                Console.SetCursorPosition(i, h - 6);                Console.Write(&quot;■&quot;);                Console.SetCursorPosition(i, h - 11);                Console.Write(&quot;■&quot;);            &#125;            &#x2F;&#x2F;竖着的墙            for (int i &#x3D; 0; i &lt; h; i++)            &#123;                &#x2F;&#x2F;最左边                Console.SetCursorPosition(0, i);                Console.Write(&quot;■&quot;);                &#x2F;&#x2F;最右边                Console.SetCursorPosition(w - 2, i);                Console.Write(&quot;■&quot;);            &#125;            &#x2F;&#x2F;文字信息            Console.ForegroundColor &#x3D; ConsoleColor.White;            Console.SetCursorPosition(2, h - 10);            Console.Write(&quot;□:普通格子&quot;);            Console.ForegroundColor &#x3D; ConsoleColor.Blue;            Console.SetCursorPosition(2, h - 9);            Console.Write(&quot;‖:暂停，一回合不懂&quot;);            Console.ForegroundColor &#x3D; ConsoleColor.Red;            Console.SetCursorPosition(26, h - 9);            Console.Write(&quot;●:炸弹，倒退5格&quot;);            Console.ForegroundColor &#x3D; ConsoleColor.Yellow;            Console.SetCursorPosition(2, h - 8);            Console.Write(&quot;¤:时空隧道，随机倒退，暂停，换位置&quot;);            Console.ForegroundColor &#x3D; ConsoleColor.Cyan;            Console.SetCursorPosition(2, h - 7);            Console.Write(&quot;★:玩家&quot;);            Console.ForegroundColor &#x3D; ConsoleColor.Magenta;            Console.SetCursorPosition(12, h - 7);            Console.Write(&quot;▲:电脑&quot;);            Console.ForegroundColor &#x3D; ConsoleColor.DarkGreen;            Console.SetCursorPosition(22, h - 7);            Console.Write(&quot;◎:玩家和电脑重合&quot;);            Console.ForegroundColor &#x3D; ConsoleColor.White;            Console.SetCursorPosition(2, h - 5);            Console.Write(&quot;按任意键开始扔色子&quot;);        &#125;        #endregion        #region 7 绘制玩家        static void DrawPlayer(Player player, Player computer, Map map)        &#123;            &#x2F;&#x2F;重合时            if (player.nowIndex &#x3D;&#x3D; computer.nowIndex)            &#123;                &#x2F;&#x2F;得到重合的位置                Grid grid &#x3D; map.grids[player.nowIndex];                Console.SetCursorPosition(grid.pos.x, grid.pos.y);                Console.ForegroundColor &#x3D; ConsoleColor.DarkGreen;                Console.Write(&quot;◎&quot;);            &#125;            &#x2F;&#x2F;不重合的时候            else            &#123;                player.Draw(map);                computer.Draw(map);            &#125;        &#125;        #endregion        #region 8 扔色子 函数        &#x2F;&#x2F;擦除提示的函数        static void ClearInfo(int h)        &#123;            Console.SetCursorPosition(2, h - 5);            Console.Write(&quot;                                   &quot;);            Console.SetCursorPosition(2, h - 4);            Console.Write(&quot;                                   &quot;);            Console.SetCursorPosition(2, h - 3);            Console.Write(&quot;                                   &quot;);            Console.SetCursorPosition(2, h - 2);            Console.Write(&quot;                                   &quot;);        &#125;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 扔色子函数        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;w&quot;&gt;窗口的宽&lt;&#x2F;param&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;h&quot;&gt;窗口的高&lt;&#x2F;param&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;p&quot;&gt;扔色子的对象&lt;&#x2F;param&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;map&quot;&gt;地图信息&lt;&#x2F;param&gt;        &#x2F;&#x2F;&#x2F; &lt;returns&gt;默认返回false 代表没有结束&lt;&#x2F;returns&gt;        static bool RandomMove(int w, int h, ref Player p, ref Player otherP, Map map)        &#123;            &#x2F;&#x2F;擦除之前显示的提示信息            ClearInfo(h);            &#x2F;&#x2F;根据扔色子的玩家类型 决定信息的颜色            Console.ForegroundColor &#x3D; p.type &#x3D;&#x3D; E_PlayerType.Player ? ConsoleColor.Cyan : ConsoleColor.Magenta;            &#x2F;&#x2F;扔色子之前 判断 玩家是否处于暂停状态            if (p.isPause)            &#123;                Console.SetCursorPosition(2, h - 5);                Console.Write(&quot;处于暂停状态，&#123;0&#125;需要暂停一回合&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;你&quot; : &quot;电脑&quot;);                Console.SetCursorPosition(2, h - 4);                Console.Write(&quot;请按任意键，让&#123;0&#125;开始扔色子&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;电脑&quot; : &quot;你&quot;);                &#x2F;&#x2F;停止暂停                p.isPause &#x3D; false;                return false;            &#125;            &#x2F;&#x2F;扔色子目的 是改变 玩家或者电脑的位置  计算位置的变化            &#x2F;&#x2F;扔色子 随机一个1到6的数 加上去            Random r &#x3D; new Random();            int randomNum &#x3D; r.Next(1, 7);            p.nowIndex +&#x3D; randomNum;            &#x2F;&#x2F;打印扔的点数            Console.SetCursorPosition(2, h - 5);            Console.Write(&quot;&#123;0&#125;扔出的点数为:&#123;1&#125;&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;你&quot; : &quot;电脑&quot;, randomNum);            &#x2F;&#x2F;首先判断是否到终点了            if (p.nowIndex &gt;&#x3D; map.grids.Length - 1)            &#123;                p.nowIndex &#x3D; map.grids.Length - 1;                Console.SetCursorPosition(2, h - 4);                if (p.type &#x3D;&#x3D; E_PlayerType.Player)                &#123;                    Console.Write(&quot;恭喜你，你率先到达了终点&quot;);                &#125;                else                &#123;                    Console.Write(&quot;很遗憾，电脑率到达了终点&quot;);                &#125;                Console.SetCursorPosition(2, h - 3);                Console.Write(&quot;请按任意键结束游戏&quot;);                return true;            &#125;            else            &#123;                &#x2F;&#x2F;没有到终点 就判断 当前对象  到了一个怎么样的格子                Grid grid &#x3D; map.grids[p.nowIndex];                switch (grid.type)                &#123;                    case E_Grid_Type.Normal:                        &#x2F;&#x2F;普通格子不用处理                        Console.SetCursorPosition(2, h - 4);                        Console.Write(&quot;&#123;0&#125;到了一个安全位置&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;你&quot; : &quot;电脑&quot;);                        Console.SetCursorPosition(2, h - 3);                        Console.Write(&quot;请按任意键，让&#123;0&#125;开始扔色子&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;电脑&quot; : &quot;你&quot;);                        break;                    case E_Grid_Type.Boom:                        &#x2F;&#x2F;炸弹退格                        p.nowIndex -&#x3D; 5;                        &#x2F;&#x2F;不能比起点还小                        if (p.nowIndex &lt; 0)                        &#123;                            p.nowIndex &#x3D; 0;                        &#125;                        Console.SetCursorPosition(2, h - 4);                        Console.Write(&quot;&#123;0&#125;踩到了炸弹，退后5格&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;你&quot; : &quot;电脑&quot;);                        Console.SetCursorPosition(2, h - 3);                        Console.Write(&quot;请按任意键，让&#123;0&#125;开始扔色子&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;电脑&quot; : &quot;你&quot;);                        break;                    case E_Grid_Type.Pause:                        &#x2F;&#x2F;暂停一回合                        &#x2F;&#x2F;暂停目前 只有加一个对象的暂停标识  才能知道 下一回合它是不是不能扔色子                        &#x2F;&#x2F;下回合要暂停                        p.isPause &#x3D; true;                        Console.SetCursorPosition(2, h - 4);                        Console.Write(&quot;&#123;0&#125;到达了暂停点，你需要暂停一回合&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;你&quot; : &quot;电脑&quot;);                        Console.SetCursorPosition(2, h - 3);                        Console.Write(&quot;请按任意键，让&#123;0&#125;开始扔色子&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;电脑&quot; : &quot;你&quot;);                        break;                    case E_Grid_Type.Tunnel:                        Console.SetCursorPosition(2, h - 4);                        Console.Write(&quot;&#123;0&#125;踩到了时空隧道&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;你&quot; : &quot;电脑&quot;);                        &#x2F;&#x2F;随机                        randomNum &#x3D; r.Next(1, 91);                        &#x2F;&#x2F;触发 倒退                        if (randomNum &lt;&#x3D; 30)                        &#123;                            p.nowIndex -&#x3D; 5;                            if (p.nowIndex &lt; 0)                            &#123;                                p.nowIndex &#x3D; 0;                            &#125;                            Console.SetCursorPosition(2, h - 3);                            Console.Write(&quot;触发倒退5格&quot;);                        &#125;                        &#x2F;&#x2F;触发 暂停                        else if (randomNum &lt;&#x3D; 60)                        &#123;                            p.isPause &#x3D; true;                            Console.SetCursorPosition(2, h - 3);                            Console.Write(&quot;触发暂停一回合&quot;);                        &#125;                        &#x2F;&#x2F;触发换位置                        else                        &#123;                            int temp &#x3D; p.nowIndex;                            p.nowIndex &#x3D; otherP.nowIndex;                            otherP.nowIndex &#x3D; temp;                            Console.SetCursorPosition(2, h - 3);                            Console.Write(&quot;惊喜，惊喜，双方交换位置&quot;);                        &#125;                        Console.SetCursorPosition(2, h - 2);                        Console.Write(&quot;请按任意键，让&#123;0&#125;开始扔色子&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;电脑&quot; : &quot;你&quot;);                        break;                &#125;            &#125;            &#x2F;&#x2F;默认没有结束            return false;        &#125;        #endregion    &#125;    #region 2 场景选择相关    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 游戏场景枚举类型    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_SceneType    &#123;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 开始场景        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Begin,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 游戏场景        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Game,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 结束场景        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        End,    &#125;    #endregion    #region 5 格子结构体和格子枚举    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 格子类型 枚举    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_Grid_Type    &#123;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 普通格子        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Normal,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 炸弹        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Boom,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 暂停        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Pause,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 时空隧道 随机倒退 暂停 换位置        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Tunnel,    &#125;    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 位置信息结构体 包含xy位置    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    struct Vector2    &#123;        public int x;        public int y;        public Vector2(int x, int y)        &#123;            this.x &#x3D; x;            this.y &#x3D; y;        &#125;    &#125;    struct Grid    &#123;        &#x2F;&#x2F;格子的类型        public E_Grid_Type type;        &#x2F;&#x2F;格子的位置        public Vector2 pos;        &#x2F;&#x2F;初始化构造函数        public Grid(int x, int y, E_Grid_Type type)        &#123;            pos.x &#x3D; x;            pos.y &#x3D; y;            this.type &#x3D; type;        &#125;        public void Draw()        &#123;            &#x2F;&#x2F;提出来的目的 就是少写几行代码 因为他们不管哪种类型 都要设置了位置再画            Console.SetCursorPosition(pos.x, pos.y);            switch (type)            &#123;                &#x2F;&#x2F;普通格子 怎么画                case E_Grid_Type.Normal:                    Console.ForegroundColor &#x3D; ConsoleColor.White;                    Console.Write(&quot;□&quot;);                    break;                &#x2F;&#x2F;炸弹 怎么画                case E_Grid_Type.Boom:                    Console.ForegroundColor &#x3D; ConsoleColor.Red;                    Console.Write(&quot;●&quot;);                    break;                &#x2F;&#x2F;暂停 怎么画                case E_Grid_Type.Pause:                    Console.ForegroundColor &#x3D; ConsoleColor.Blue;                    Console.Write(&quot;‖&quot;);                    break;                &#x2F;&#x2F;时空隧道 怎么画                case E_Grid_Type.Tunnel:                    Console.ForegroundColor &#x3D; ConsoleColor.Yellow;                    Console.Write(&quot;¤&quot;);                    break;            &#125;        &#125;    &#125;    #endregion    #region 6 地图结构体    struct Map    &#123;        public Grid[] grids;        &#x2F;&#x2F;初始化中 初始了 各个格子的类型 和 位置        public Map(int x, int y, int num)        &#123;            grids &#x3D; new Grid[num];            &#x2F;&#x2F;用于位置改变计数的变量            &#x2F;&#x2F;表示X变化的次数            int indexX &#x3D; 0;            &#x2F;&#x2F;表示Y变化的次数            int indexY &#x3D; 0;            &#x2F;&#x2F;x的步长            int stepNum &#x3D; 2;            Random r &#x3D; new Random();            int randomNum;            for (int i &#x3D; 0; i &lt; num; i++)            &#123;                &#x2F;&#x2F;应该初始化 格子类型                randomNum &#x3D; r.Next(0, 101);                &#x2F;&#x2F;设置类型 普通格子                &#x2F;&#x2F;有85%几率 是普通自（首尾两个格子 必为普通格子）                if (randomNum &lt; 85 || i &#x3D;&#x3D; 0 || i &#x3D;&#x3D; num - 1)                &#123;                    grids[i].type &#x3D; E_Grid_Type.Normal;                &#125;                &#x2F;&#x2F;有5%的几率 是炸弹                else if (randomNum &gt;&#x3D; 85 &amp;&amp; randomNum &lt; 90)                &#123;                    grids[i].type &#x3D; E_Grid_Type.Boom;                &#125;                &#x2F;&#x2F;有5%的几率 是暂停                else if (randomNum &gt;&#x3D; 90 &amp;&amp; randomNum &lt; 95)                &#123;                    grids[i].type &#x3D; E_Grid_Type.Pause;                &#125;                &#x2F;&#x2F;有5%的几率 是时空隧道                else                &#123;                    grids[i].type &#x3D; E_Grid_Type.Tunnel;                &#125;                &#x2F;&#x2F;位置应该如何设置                grids[i].pos &#x3D; new Vector2(x, y);                &#x2F;&#x2F;每次循环都应该按一定规则去变化位置吧                &#x2F;&#x2F;加十次                if (indexX &#x3D;&#x3D; 10)                &#123;                    y +&#x3D; 1;                    &#x2F;&#x2F;加一次Y记一次数                    ++indexY;                    if (indexY &#x3D;&#x3D; 2)                    &#123;                        &#x2F;&#x2F;y加了2次过后 把x加的次数记0                        indexX &#x3D; 0;                        indexY &#x3D; 0;                        &#x2F;&#x2F;反向步长                        stepNum &#x3D; -stepNum;                    &#125;                &#125;                else                &#123;                    x +&#x3D; stepNum;                    &#x2F;&#x2F;加一次X记一次数                    ++indexX;                &#125;            &#125;        &#125;        public void Draw()        &#123;            for (int i &#x3D; 0; i &lt; grids.Length; i++)            &#123;                grids[i].Draw();            &#125;        &#125;    &#125;    #endregion    #region 7 玩家枚举和玩家结构体    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 玩家类型枚举    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_PlayerType    &#123;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 玩家        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Player,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 电脑        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Computer,    &#125;    struct Player    &#123;        &#x2F;&#x2F;玩家类型        public E_PlayerType type;        &#x2F;&#x2F;当前所在地图哪一个索引的格子        public int nowIndex;        &#x2F;&#x2F;是否暂停的标识        public bool isPause;        public Player(int index, E_PlayerType type)        &#123;            nowIndex &#x3D; index;            this.type &#x3D; type;            isPause &#x3D; false;        &#125;        public void Draw(Map mapInfo)        &#123;            &#x2F;&#x2F;必须要先得到地图 才能够 得到我在地图上的哪一个格子            &#x2F;&#x2F;从传入的地图中 得到 格子信息            Grid grid &#x3D; mapInfo.grids[nowIndex];            &#x2F;&#x2F;设置位置            Console.SetCursorPosition(grid.pos.x, grid.pos.y);            &#x2F;&#x2F;画 设置颜色 设置图标            switch (type)            &#123;                case E_PlayerType.Player:                    Console.ForegroundColor &#x3D; ConsoleColor.Cyan;                    Console.Write(&quot;★&quot;);                    break;                case E_PlayerType.Computer:                    Console.ForegroundColor &#x3D; ConsoleColor.Magenta;                    Console.Write(&quot;▲&quot;);                    break;            &#125;        &#125;    &#125;    #endregion&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月6日</title>
    <link href="/2022/05/06/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%886%E6%97%A5/"/>
    <url>/2022/05/06/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%886%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="66e42836cfa71681c04573568ab08bc0d5f74b441addf158500edc865fa3a5b6">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe509e5becb1c52418d004df21efc8656ad3164443d15e3426aec259f6651c69cb77793aad835379c9a1816cf1931da50b5899e97c2830c05d575a4743b34a35ff32f5a4fa29c0526e8fc982443375e9f8fd6cf277a101133b1272d3407d8f2a19168677137fd3b36ecb1f84c706fbed376ed6d5de7cdb5d9d656bb6126e326b737fa68e7c0373437510d1f392fed4168dc07d44dd069b31dc0c49f82d59730d8c02be06da9af3c2b3658b6e4bd123c1096bf72d2baee1bafdc331802a4cdde10c99339aa83cee8465cdb4214c73d0592d99c3572a9a58df9e20255525c044ef489eb748c5ab5c10e96e542aff20f36d562d56baa07a626b08bc94621d58c633558e65fabc41c2865abbd20076f1e9e2b7cfdb0f3cbabbfafe0f15a857cfe469025fd48e42886964ad80d51c8ee70fdfa8d1153535ed335a7ccd7aea7ca601bf16182c7e336042c92c7e43c7a64d491462e1b3182db1d033cf267647d687a6813e2f72540eaaccd76675fc21dbc5f2674702b1226313c83993f2a5ead960df1de82247f06e378f31be68a95a48b5504a6f783db90fa9f39c1b5fea7f3fc11be210edfcb3f58faccc325cd8a411d229dfc3cea4584c5f9f7637fc5d2c9e0aa59dac55966df62dbcb57c5a41a75f85d202bf4b0de68bf91bba94a41d986725ed6342d8dbacdf19274fa1e839e276af4191113d5033a2b7fbb07e99188b0289c9fc5619e46bb0bd84ad7095f7a431de37c130261578650cce1c5d29f5d6431d88acf65c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">要密码，快滚.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月5日</title>
    <link href="/2022/05/05/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%885%E6%97%A5/"/>
    <url>/2022/05/05/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%885%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="e511f33453d7f039779defafc86db8f6daff2f33133f2aff607c515a0d328970">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50a54d91deb0dd23a86bb3652d32d2d8603260b625ed51d891af3154cdc9e82226531c388ce184435c513a6bdf27303d625affca6eb12412c28000179a1585754fa6ec21d8e8f513522e8041ae60d72b5e464eb336c6cb9fc6271e69b627a3104a757008b0881f597a83821625f0409e9a3ccb67dbff38f2d551d650992fdeb62a40d368772d7320a2fb9bfa83e11bc8e179140c645e130803a6a971388b8d697e657b23739f21b5b3b1179d17b0d04480d65d24f6053a148f3167ea9698cd3b5811ee6e389ba9bf285337c5c643d9ce7f250862304135afb5cc37ee9fa66a39be4ca1c859708e8dc1beb13d004de352b37b1b0e40f61c18bf700a40fa2336fba7516c41ab191c27e86c22676bda861d0e296d91ee18e8c02c1e2417b66392be6c535f732e821a4436c374c5d8db6a170333841f4a9700469aedb6bce63d0f0553e01a782a004bd1157ccf8b033a090473ad734b4dd40916eabf04fe7f7bcaa98d2a7878bd3490632e4f7b9d33106db0db446c72822e848b1e2bf6e370b586743288fd41a4db74420f36101ca7157d1bd72a619372db36cf0d87d775f8a0a3cc7a41e139059cb35c0574c6f4a06fd8cc86830d23a785ecfa36ab81066b288f0efe4b425916390accf22d275216c40a4645e6a58f0790f36cd7a9bac537da2c79eddb817d221a971c55a089d4b3bb08427c298af5a6fa5501daf6eb83463199106dfe1efe1b3215cc3704fef4b1852c65775fb62f05c9be821f1d4e6a8b75123b1e26332e0de47278c5a94a1c3aadcfa12e37fd520d4e85d2125d93b261fde0aa86ca6a51331d9d3f0044b300393bacba389840f4352cdc91df6fffedf7399741c087b18fcb3c475849778d2c49e45a72a477f5a72949c95b155fc6de87de8b13a6b3d6adc150f0757026eb91717a6b800384eb7a1acfe45141cf0c9412ea129963a1e75022cb8f72317ea5185592198377a58464178e933ce316fa183200a7d89c12e1f5551774ca08bf667026c06c6f0e5d2104ddfad6fd51b9cea3c5d9a67e0a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">要密码，快滚.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSharp入门实践——简易飞行棋</title>
    <link href="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/CSharp%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%A3%8B/"/>
    <url>/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/CSharp%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%A3%8B/</url>
    
    <content type="html"><![CDATA[<p>控制台实现简易飞行棋</p><span id="more"></span><p><strong># 游戏逻辑流程图</strong><br>游戏逻辑题直接引用唐老狮课程里的流程图</p><p><strong>## 整体逻辑流程图</strong></p><img src="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/CSharp%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%A3%8B/%E6%95%B4%E4%BD%93%E9%80%BB%E8%BE%91%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class=""><p><strong>## 开始场景流程图</strong></p><img src="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/CSharp%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%A3%8B/%E5%BC%80%E5%A7%8B%E5%9C%BA%E6%99%AF%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class=""><p><strong>## 游戏场景流程图</strong></p><img src="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/CSharp%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%A3%8B/%E5%BC%80%E5%A7%8B%E5%9C%BA%E6%99%AF%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class=""><p><strong>## 结束场景流程图</strong></p><img src="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/CSharp%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%A3%8B/%E7%BB%93%E6%9D%9F%E5%9C%BA%E6%99%AF%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class=""><p><strong># 代码实现</strong></p><p>寄 不能实现前一个位置消失 结构体还没搞明白</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace CSharp基础实践教学&#123;    #region 格子结构体（写不来，看答案了）    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 格子类型枚举    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_GridType    &#123;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 普通格子        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Normal,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 炸弹        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Bomb,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 暂停        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Pause,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 时空隧道        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Tunnel,    &#125;    &#x2F;&#x2F;看答案的 可记住    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 位置信息结构体 包含x y位置    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    struct Vector2    &#123;        public int x;        public int y;        public Vector2(int x, int y)        &#123;            this.x &#x3D; x; this.y &#x3D; y;        &#125;    &#125;    &#x2F;&#x2F;格子结构体    struct Grid    &#123;        public E_GridType gridType; &#x2F;&#x2F;格子类型        public Vector2 position; &#x2F;&#x2F;格子位置        &#x2F;&#x2F;构造函数  输入格子位置  格子初始化        public Grid(E_GridType gridType, int x, int y)        &#123;            this.gridType &#x3D; gridType;            position.x &#x3D; x;             position.y &#x3D; y;        &#125;        &#x2F;&#x2F;画格子        public void Draw()        &#123;            &#x2F;&#x2F;控制光标位置  打印选项            Console.SetCursorPosition(position.x, position.y);            switch (gridType)            &#123;                &#x2F;&#x2F;普通格子                case E_GridType.Normal:                    Console.ForegroundColor &#x3D; ConsoleColor.White;                    Console.Write(&#39;□&#39;);                    break;                &#x2F;&#x2F;炸弹                case E_GridType.Bomb:                    Console.ForegroundColor &#x3D; ConsoleColor.Blue;                    Console.Write(&quot;‖&quot;);                    break;                &#x2F;&#x2F;暂停                case E_GridType.Pause:                    Console.ForegroundColor &#x3D; ConsoleColor.Red;                    Console.Write(&quot;●&quot;);                    break;                &#x2F;&#x2F;时空隧道                case E_GridType.Tunnel:                    Console.ForegroundColor &#x3D; ConsoleColor.White;                    Console.Write(&quot;¤&quot;);                    break;            &#125;        &#125;    &#125;    #endregion    #region 地图结构体（写不来，看答案了）    struct Map    &#123;        &#x2F;&#x2F;用一个格子结构体数组 表示地图里的所有格子        public Grid[] grids;        &#x2F;&#x2F;地图初始化构造函数        &#x2F;&#x2F;x, y为棋盘起始点        public Map(int x, int y)        &#123;            grids &#x3D; new Grid[84];            Random r &#x3D; new Random();            int randomNum;            for (int i &#x3D; 0; i &lt; 84; i++)            &#123;                &#x2F;&#x2F;应该初始化 格子类型                randomNum &#x3D; r.Next(0, 100);                &#x2F;&#x2F;设置类型 普通格子                &#x2F;&#x2F;有85%几率 是普通格子 (首尾两个格子 必为普通格子)                if(randomNum &lt; 85 || i &#x3D;&#x3D; 0 || i &#x3D;&#x3D; 95)                &#123;                    grids[i].gridType &#x3D; E_GridType.Normal;                &#125;                &#x2F;&#x2F;有5%几率 是炸弹                if (randomNum &gt;&#x3D; 85 &amp;&amp; randomNum &lt; 90)                &#123;                    grids[i].gridType &#x3D; E_GridType.Bomb;                &#125;                &#x2F;&#x2F;有5%几率 是暂停                if (randomNum &gt;&#x3D; 90 &amp;&amp; randomNum &lt; 95)                &#123;                    grids[i].gridType &#x3D; E_GridType.Pause;                &#125;                &#x2F;&#x2F;有5%几率 是时空隧道                if (randomNum &gt;&#x3D; 95 &amp;&amp; randomNum &lt; 100)                &#123;                    grids[i].gridType &#x3D; E_GridType.Tunnel;                &#125;                &#x2F;&#x2F;设置位置                grids[i].position &#x3D; new Vector2(x, y);                &#x2F;&#x2F;每次循环都应该一定规则去变化位置(每次少4个步长)                if( i &lt;&#x3D; 12 || (i &gt; 56 &amp;&amp; i &lt;&#x3D; 64)  )                &#123;                    y++;                &#125;                else if( (i &gt; 12 &amp;&amp; i &lt;&#x3D; 30) || (i &gt; 64 &amp;&amp; i &lt;&#x3D; 74) )                &#123;                    x +&#x3D; 2;                &#125;                else if( (i &gt; 30 &amp;&amp; i &lt;&#x3D; 42) || (i &gt; 74 &amp;&amp; i &lt;&#x3D; 78) )                &#123;                    y--;                &#125;                else if(( i &gt; 42 &amp;&amp; i &lt;&#x3D; 56) || (i &gt; 78 &amp;&amp; i &lt;&#x3D; 84) )                &#123;                    x -&#x3D; 2;                &#125;            &#125;        &#125;        public void Draw()        &#123;            for (int i &#x3D; 0; i &lt; grids.Length; i++)            &#123;                grids[i].Draw();            &#125;        &#125;    &#125;    #endregion    #region 玩家结构体    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 玩家类型    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_PlayerType    &#123;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 玩家        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        You,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 电脑        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        PC,    &#125;    struct Player    &#123;        public E_PlayerType playerType;        &#x2F;&#x2F;当前位置索引        public int nowIndex;        &#x2F;&#x2F;玩家初始化构造函数        public Player(E_PlayerType playerType, ref int nowIndex)        &#123;            this.playerType &#x3D; playerType;            this.nowIndex &#x3D; nowIndex;        &#125;        &#x2F;&#x2F;画玩家和电脑格子的逻辑 用索引得到所在地图上格子        public void DrawMove( Map mapinfo )        &#123;            &#x2F;&#x2F;从传入的地图得到格子信息            Grid grid &#x3D; mapinfo.grids[nowIndex];            &#x2F;&#x2F;先控制光标位置            Console.SetCursorPosition(grid.position.x, grid.position.y);            &#x2F;&#x2F;判断是画玩家还是电脑            switch(playerType)            &#123;                &#x2F;&#x2F;画玩家                case E_PlayerType.You:                    Console.ForegroundColor &#x3D; ConsoleColor.Cyan;                    Console.WriteLine(&quot;★&quot;);                    break;                case E_PlayerType.PC:                    Console.ForegroundColor &#x3D; ConsoleColor.Magenta;                    Console.WriteLine(&quot;▲&quot;);                    break;            &#125;        &#125;    &#125;    #endregion    internal class Program    &#123;        &#x2F;&#x2F;判断玩家和电脑是否重叠        static void DrawPlayer(Player you, Player PC, Map map)        &#123;            &#x2F;&#x2F;重合的话 Player结构体外部处理            if(you.nowIndex &#x3D;&#x3D; PC.nowIndex)            &#123;                &#x2F;&#x2F;得到重合的位置                Grid grid &#x3D; map.grids[you.nowIndex];                Console.SetCursorPosition(grid.position.x, grid.position.y);                Console.ForegroundColor &#x3D; ConsoleColor.Green;                Console.WriteLine(&quot;◎&quot;);            &#125;            &#x2F;&#x2F;不重合的话 Player结构体内部处理             else            &#123;                you.DrawMove(map);                PC.DrawMove(map);            &#125;        &#125;         static void Main(string[] args)        &#123;            #region 控制台基础设置            &#x2F;&#x2F;控制台大小设置  w表示宽  h表示高            int w &#x3D; 50;            int h &#x3D; 30;            ConsoleInit(w, h);            #endregion            #region 实现多个场景的转换            &#x2F;&#x2F;定义场景ID  初始从开始场景开始            &#x2F;&#x2F;开始场景为0  游戏场景为1  结束场景为2            int nowScene &#x3D; 0; ;            &#x2F;&#x2F;玩家获胜或者电脑获胜的信息            string gameOverInfo;            &#x2F;&#x2F;整体游戏逻辑死循环            while (true)            &#123;                &#x2F;&#x2F;用不同场景ID  进行不同的场景逻辑                &#x2F;&#x2F;用switch实现场景的转换                switch (nowScene)                &#123;                    &#x2F;&#x2F;开始场景                    case 0:                        &#x2F;&#x2F;实现开始场景逻辑                        #region 开始场景逻辑                        &#x2F;&#x2F;清空控制台  以后续添加文字与游戏                        Console.Clear();                        &#x2F;&#x2F;控制光标位置  打印标题                        Console.SetCursorPosition(w &#x2F; 2 - 5, 8);                        Console.Write(&quot;飞行棋小游戏&quot;);                        &#x2F;&#x2F;事先定义想要选择的选项ID 默认初始选择第一个选项(开始游戏)                        &#x2F;&#x2F;开始游戏为0  退出游戏为1                        int nowSelIndex &#x3D; 0;                        &#x2F;&#x2F;开始场景逻辑死循环                        while(true)                        &#123;                            #region 开始场景生成逻辑                                                        &#x2F;&#x2F;控制光标位置  打印选项                            Console.SetCursorPosition(w &#x2F; 2 - 3, 13);                            &#x2F;&#x2F;根据现在选中的选项改变选项的颜色(改变光标前景色)                            &#x2F;&#x2F;选中为红色 未选中为白色                            Console.ForegroundColor &#x3D; nowSelIndex &#x3D;&#x3D; 0 ? ConsoleColor.Red : ConsoleColor.White;                            Console.Write(&quot;开始游戏&quot;);                            &#x2F;&#x2F;逻辑同上                            Console.SetCursorPosition(w &#x2F; 2 - 3, 15);                            Console.ForegroundColor &#x3D; nowSelIndex &#x3D;&#x3D; 1 ? ConsoleColor.Red : ConsoleColor.White;                            Console.Write(&quot;退出游戏&quot;);                            &#x2F;&#x2F;定义玩家输入w为向上选择  输入s为向下选择  输入j为确定选择                            Console.SetCursorPosition(w &#x2F; 2 - 5, 20);                            Console.ForegroundColor &#x3D; ConsoleColor.Yellow;                            Console.Write(&quot;按w向上选择&quot;);                            Console.SetCursorPosition(w &#x2F; 2 - 5, 22);                            Console.ForegroundColor &#x3D; ConsoleColor.Yellow;                            Console.Write(&quot;按s向下选择&quot;);                            Console.SetCursorPosition(w &#x2F; 2 - 3, 24);                            Console.ForegroundColor &#x3D; ConsoleColor.Yellow;                            Console.Write(&quot;按j确定&quot;);                            #endregion                            #region 开始场景跳转逻辑                            &#x2F;&#x2F;因为break只能跳出最近的switch(即下文跳转场景的)  而为结束开始场景逻辑                              &#x2F;&#x2F;需要定义一个标识判断是否跳出开始场景逻辑死循环                            bool isQuitWhile &#x3D; false;                            &#x2F;&#x2F;获取玩家输入  且不显示玩家的输入                            char input &#x3D; Console.ReadKey(true).KeyChar;                            &#x2F;&#x2F;根据玩家输入  转换选中选项  与  确定选择                            switch(input)                            &#123;                                &#x2F;&#x2F;按w的逻辑  大小写Ww均可                                case &#39;W&#39;:                                case &#39;w&#39;:                                    &#x2F;&#x2F;实际上就是让选项ID变为0                                    --nowSelIndex;                                    &#x2F;&#x2F;且若已经是0 不能再减                                    if(nowSelIndex &lt; 0)                                    &#123;                                        nowSelIndex &#x3D; 0;                                    &#125;                                    break;                                &#x2F;&#x2F;按s的逻辑  大小写Ss均可                                case &#39;S&#39;:                                case &#39;s&#39;:                                    &#x2F;&#x2F;实际上就是让选项ID变为0                                    ++nowSelIndex;                                    &#x2F;&#x2F;且若已经是1 不能再加                                    if (nowSelIndex &gt; 1)                                    &#123;                                        nowSelIndex &#x3D; 1;                                    &#125;                                    break;                                &#x2F;&#x2F;按j的逻辑  大小写Jj均可                                case &#39;J&#39;:                                case &#39;j&#39;:                                                                       &#x2F;&#x2F;判断是进入哪个场景                                    &#x2F;&#x2F;进入游戏场景                                    if( nowSelIndex &#x3D;&#x3D; 0)                                    &#123;                                        &#x2F;&#x2F;将场景ID变为1                                        nowScene &#x3D; 1;                                        &#x2F;&#x2F;确定选择后就要进入其他场景  故必须跳出开始场景的死循环                                        &#x2F;&#x2F;即要使判断跳出标识置为true                                        isQuitWhile &#x3D; true;                                    &#125;                                    &#x2F;&#x2F;退出游戏                                    else if(nowSelIndex &#x3D;&#x3D; 1)                                    &#123;                                        &#x2F;&#x2F;关闭控制台(也不需要跳出循环了)                                        Environment.Exit(0);                                    &#125;                                    break;                            &#125;                            &#x2F;&#x2F;若isQuitWhile为true  则跳出开始场景循环                            if (isQuitWhile)                            &#123;                                break;                            &#125;                                #endregion                        &#125;                        #endregion                        break;                    &#x2F;&#x2F;游戏场景                    case 1:                        &#x2F;&#x2F;实现游戏场景逻辑                        #region 游戏场景逻辑                        #region 参数设置                        Console.Clear();                        &#x2F;&#x2F;退出while的标识                        bool isQuitGameWhile &#x3D; false;                        &#x2F;&#x2F;定义骰子的随机数                        Random d &#x3D; new Random();                        int dice;                        &#x2F;&#x2F;设置一个计数位选择是玩家动还是电脑动                        int count &#x3D; 0;                        &#x2F;&#x2F;设置玩家和电脑所在的格数 初始化为0                        int numYou &#x3D; 0;                        int numPC &#x3D; 0;                        &#x2F;&#x2F;设置玩家变量 电脑变量                        Player you &#x3D; new Player(E_PlayerType.You, ref numYou);                        Player PC &#x3D; new Player(E_PlayerType.PC, ref numPC);                        #endregion                        #region 红色墙壁                        DrawWall(w, h);                        #endregion                        #region 绘制棋盘                        Map map &#x3D; new Map(6, 3);                        map.Draw();                        #endregion                        #region 静态信息栏(每种格子类型的含义)                        Console.SetCursorPosition(2, h - 10);                        Console.ForegroundColor &#x3D; ConsoleColor.White;                        Console.WriteLine(&quot;□:普通格子&quot;);                        Console.SetCursorPosition(2, h - 9);                        Console.ForegroundColor &#x3D; ConsoleColor.Blue;                        Console.WriteLine(&quot;‖:暂停,一回合不动&quot;);                        Console.SetCursorPosition(26, h - 9);                        Console.ForegroundColor &#x3D; ConsoleColor.Red;                        Console.WriteLine(&quot;●:炸弹,倒退5格&quot;);                        Console.SetCursorPosition(2, h - 8);                        Console.ForegroundColor &#x3D; ConsoleColor.White;                        Console.WriteLine(&quot;¤:时空隧道,随机倒退,暂停,换位置&quot;);                        Console.SetCursorPosition(2, h - 7);                        Console.ForegroundColor &#x3D; ConsoleColor.Cyan;                        Console.WriteLine(&quot;★:玩家&quot;);                        Console.SetCursorPosition(12, h - 7);                        Console.ForegroundColor &#x3D; ConsoleColor.Magenta;                        Console.WriteLine(&quot;▲:电脑&quot;);                        Console.SetCursorPosition(22, h - 7);                        Console.ForegroundColor &#x3D; ConsoleColor.Green;                        Console.WriteLine(&quot;◎:玩家与电脑重合&quot;);                        #endregion                        #region 动态信息栏(你走几步 电脑走几步)                        Console.SetCursorPosition(2, h - 5);                        Console.ForegroundColor &#x3D; ConsoleColor.White;                        Console.WriteLine(&quot;按任意键开始扔骰子&quot;);                        #endregion                        &#x2F;&#x2F;先打印起始位置                        DrawPlayer(you, PC, map);                        &#x2F;&#x2F;玩家 电脑 是否暂停                        bool youPause &#x3D; false;                        bool PCPause &#x3D; false;                        &#x2F;&#x2F;游戏场景死循环 专门用来检测 玩家输入相关循环                        while (true)                        &#123;                                                            &#x2F;&#x2F;每次输入                            Console.ReadKey(true);                            dice &#x3D; d.Next(1, 7);                            if(youPause)                            &#123;                                &#x2F;&#x2F;玩家暂停一回合 让电脑走                                youPause &#x3D; false;                                count &#x3D; 1;                            &#125;                            if (PCPause)                            &#123;                                &#x2F;&#x2F;电脑暂停一回合 让玩家走                                PCPause &#x3D; false;                                count &#x3D; 0;                            &#125;                            switch (count)                            &#123;                                &#x2F;&#x2F;玩家移动                                case 0:                                    you.nowIndex +&#x3D; dice;                                    &#x2F;&#x2F;玩家的格子先超出地图数                                     if(you.nowIndex &gt; 83)                                    &#123;                                        gameOverInfo &#x3D; &quot;玩家获胜&quot;;                                        isQuitGameWhile &#x3D; true;                                        nowScene &#x3D; 2;                                        break;                                    &#125;                                    Grid grid1 &#x3D; map.grids[you.nowIndex];                                    switch (grid1.gridType)                                    &#123;                                        case E_GridType.Normal:                                            &#x2F;&#x2F;普通格子  切换到电脑移动                                            count++;                                            break;                                        case E_GridType.Bomb:                                            &#x2F;&#x2F;炸弹倒退5格                                            you.nowIndex -&#x3D; 5;                                            &#x2F;&#x2F;不能退出起点                                            if(you.nowIndex &lt; 0)                                            &#123;                                                you.nowIndex &#x3D; 0;                                            &#125;                                            break;                                        case E_GridType.Pause:                                            &#x2F;&#x2F;暂停一回合                                            youPause &#x3D; true;                                            break;                                        case E_GridType.Tunnel:                                            &#x2F;&#x2F;随机 倒退 暂停 和电脑交换位置                                            dice &#x3D; d.Next(1, 91);                                            if(dice &lt; 30) &#x2F;&#x2F;倒退                                            &#123;                                                you.nowIndex -&#x3D; 5;                                            &#125;                                            else if(dice &gt;&#x3D; 30 &amp;&amp; dice &lt;60) &#x2F;&#x2F;暂停                                            &#123;                                                youPause &#x3D; true;                                            &#125;                                            else &#x2F;&#x2F;和电脑交换位置                                            &#123;                                                int t &#x3D; you.nowIndex;                                                you.nowIndex &#x3D; PC.nowIndex;                                                PC.nowIndex &#x3D; t;                                            &#125;                                            break;                                    &#125;                                    DrawPlayer(you, PC, map);                                    &#x2F;&#x2F;切换到电脑移动                                                                    break;                                &#x2F;&#x2F;电脑移动                                case 1:                                    PC.nowIndex +&#x3D; dice;                                    if (PC.nowIndex &gt; 83)                                    &#123;                                        gameOverInfo &#x3D; &quot;电脑获胜&quot;;                                        isQuitGameWhile &#x3D; true;                                        nowScene &#x3D; 2;                                        break;                                    &#125;                                    DrawPlayer(you, PC, map);                                    Grid grid2 &#x3D; map.grids[PC.nowIndex];                                    switch (grid2.gridType)                                    &#123;                                        case E_GridType.Normal:                                            &#x2F;&#x2F;普通格子  切换到玩家移动                                            count--;                                            break;                                        case E_GridType.Bomb:                                            &#x2F;&#x2F;炸弹倒退5格                                            PC.nowIndex -&#x3D; 5;                                            &#x2F;&#x2F;不能退出起点                                            if (PC.nowIndex &lt; 0)                                            &#123;                                                PC.nowIndex &#x3D; 0;                                            &#125;                                            break;                                        case E_GridType.Pause:                                            &#x2F;&#x2F;暂停一回合                                            PCPause &#x3D; true;                                            break;                                        case E_GridType.Tunnel:                                            &#x2F;&#x2F;随机 倒退 暂停 和电脑交换位置                                            dice &#x3D; d.Next(1, 91);                                            if (dice &lt; 30) &#x2F;&#x2F;倒退                                            &#123;                                                PC.nowIndex -&#x3D; 5;                                            &#125;                                            else if (dice &gt;&#x3D; 30 &amp;&amp; dice &lt; 60) &#x2F;&#x2F;暂停                                            &#123;                                                PCPause &#x3D; true;                                            &#125;                                            else &#x2F;&#x2F;和电脑交换位置                                            &#123;                                                int t &#x3D; you.nowIndex;                                                you.nowIndex &#x3D; PC.nowIndex;                                                PC.nowIndex &#x3D; t;                                            &#125;                                            break;                                    &#125;                                    break;                            &#125;                                                        if (isQuitGameWhile)                            &#123;                                break;                            &#125;                        &#125;                        #endregion                            break;                    &#x2F;&#x2F;结束场景                    case 2:                        &#x2F;&#x2F;实现结束场景逻辑                        #region 结束场景逻辑                        &#x2F;&#x2F;清空控制台  以后续添加文字与游戏                        Console.Clear();                        &#x2F;&#x2F;控制光标位置  打印标题                        Console.SetCursorPosition(w &#x2F; 2 - 3, 8);                        Console.Write(&quot;Gameover&quot;);                        &#x2F;&#x2F;可变内容的显示 根据失败或成功 显示内容不同                        Console.ForegroundColor &#x3D; ConsoleColor.Green;                        Console.SetCursorPosition(w &#x2F; 2 - 4, 6);                                                &#x2F;&#x2F;事先定义想要选择的选项ID  默认初始选择第一个选项(重新开始)                        &#x2F;&#x2F;(重新开始为0  退出游戏为1)                        int nowSelEndIndex &#x3D; 0;                        &#x2F;&#x2F;开始场景逻辑死循环                        while (true)                        &#123;                            #region 结束场景生成逻辑                            &#x2F;&#x2F;控制光标位置  打印选项                            Console.SetCursorPosition(w &#x2F; 2 - 3, 13);                            &#x2F;&#x2F;根据现在选中的选项改变选项的颜色(改变光标前景色)                            &#x2F;&#x2F;选中为红色 未选中为白色                            Console.ForegroundColor &#x3D; nowSelEndIndex &#x3D;&#x3D; 0 ? ConsoleColor.Red : ConsoleColor.White;                            Console.Write(&quot;重新开始&quot;);                            &#x2F;&#x2F;逻辑同上                            Console.SetCursorPosition(w &#x2F; 2 - 3, 15);                            Console.ForegroundColor &#x3D; nowSelEndIndex &#x3D;&#x3D; 1 ? ConsoleColor.Red : ConsoleColor.White;                            Console.Write(&quot;退出游戏&quot;);                            &#x2F;&#x2F;定义玩家输入w为向上选择  输入s为向下选择  输入j为确定选择                            Console.SetCursorPosition(w &#x2F; 2 - 5, 20);                            Console.ForegroundColor &#x3D; ConsoleColor.Yellow;                            Console.Write(&quot;按w向上选择&quot;);                            Console.SetCursorPosition(w &#x2F; 2 - 5, 22);                            Console.ForegroundColor &#x3D; ConsoleColor.Yellow;                            Console.Write(&quot;按s向下选择&quot;);                            Console.SetCursorPosition(w &#x2F; 2 - 3, 24);                            Console.ForegroundColor &#x3D; ConsoleColor.Yellow;                            Console.Write(&quot;按j确定&quot;);                            #endregion                            #region 结束场景跳转逻辑                            &#x2F;&#x2F;因为break只能跳出最近的switch(即下文跳转场景的)  而为结束开始场景逻辑                              &#x2F;&#x2F;需要定义一个标识判断是否跳出开始场景逻辑死循环                            bool isQuitEndWhile &#x3D; false;                            &#x2F;&#x2F;获取玩家输入  且不显示玩家的输入                            char input &#x3D; Console.ReadKey(true).KeyChar;                            &#x2F;&#x2F;根据玩家输入  转换选中选项  与  确定选择                            switch (input)                            &#123;                                &#x2F;&#x2F;按w的逻辑  大小写Ww均可                                case &#39;W&#39;:                                case &#39;w&#39;:                                    &#x2F;&#x2F;实际上就是让选项ID变为0                                    --nowSelEndIndex;                                    &#x2F;&#x2F;且若已经是0 不能再减                                    if (nowSelEndIndex &lt; 0)                                    &#123;                                        nowSelEndIndex &#x3D; 0;                                    &#125;                                    break;                                &#x2F;&#x2F;按s的逻辑  大小写Ss均可                                case &#39;S&#39;:                                case &#39;s&#39;:                                    &#x2F;&#x2F;实际上就是让选项ID变为0                                    ++nowSelEndIndex;                                    &#x2F;&#x2F;且若已经是1 不能再加                                    if (nowSelEndIndex &gt; 1)                                    &#123;                                        nowSelEndIndex &#x3D; 1;                                    &#125;                                    break;                                &#x2F;&#x2F;按j的逻辑  大小写Jj均可                                case &#39;J&#39;:                                case &#39;j&#39;:                                    &#x2F;&#x2F;判断是进入哪个场景                                    &#x2F;&#x2F;进入游戏场景                                    if (nowSelEndIndex &#x3D;&#x3D; 0)                                    &#123;                                        &#x2F;&#x2F;将场景ID变为1                                        nowScene &#x3D; 1;                                        &#x2F;&#x2F;确定选择后就要进入其他场景  故必须跳出开始场景的死循环                                        &#x2F;&#x2F;即要使判断跳出标识置为true                                        isQuitEndWhile &#x3D; true;                                    &#125;                                    &#x2F;&#x2F;退出游戏                                    else if (nowSelEndIndex &#x3D;&#x3D; 1)                                    &#123;                                        &#x2F;&#x2F;关闭控制台(也不需要跳出循环了)                                        Environment.Exit(0);                                    &#125;                                    break;                            &#125;                            &#x2F;&#x2F;若isQuitEndWhile为true  则跳出结束场景循环                            if (isQuitEndWhile)                            &#123;                                break;                            &#125;                            #endregion                        &#125;                        #endregion                        break;                &#125;            &#125;            #endregion        &#125;        #region 控制台基础设置        static void ConsoleInit(int w, int h)        &#123;            &#x2F;&#x2F;隐藏光标            Console.CursorVisible &#x3D; false;            &#x2F;&#x2F;设置舞台（控制台）大小            Console.SetWindowSize(w, h);            &#x2F;&#x2F;设置缓冲区大小            Console.SetBufferSize(w, h);        &#125;        #endregion        #region 红色墙壁        static void DrawWall(int w, int h)        &#123;            &#x2F;&#x2F;设置颜色为红色            Console.ForegroundColor &#x3D; ConsoleColor.Red;            &#x2F;&#x2F;画墙            &#x2F;&#x2F;上方墙 下方墙 中间墙1 中间墙2            for (int i &#x3D; 0; i &lt;&#x3D; w - 2; i +&#x3D; 2)            &#123;                Console.SetCursorPosition(i, 0); &#x2F;&#x2F;上方墙                Console.Write(&#39;■&#39;);                Console.SetCursorPosition(i, h - 1); &#x2F;&#x2F;下方墙                Console.Write(&#39;■&#39;);                Console.SetCursorPosition(i, h - 11); &#x2F;&#x2F;中间墙1                Console.Write(&#39;■&#39;);                Console.SetCursorPosition(i, h - 6); &#x2F;&#x2F;中间墙2                Console.Write(&#39;■&#39;);            &#125;            &#x2F;&#x2F;左边墙 右边墙            for (int i &#x3D; 0; i &lt;&#x3D; h - 1; i++)            &#123;                Console.SetCursorPosition(0, i); &#x2F;&#x2F;左边墙                Console.Write(&#39;■&#39;);                Console.SetCursorPosition(w - 2, i); &#x2F;&#x2F;右边墙                Console.Write(&#39;■&#39;);            &#125;        &#125;        #endregion    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSharp入门总结</title>
    <link href="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/CSharp%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/"/>
    <url>/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/CSharp%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>入门总结</p><span id="more"></span><img src="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/CSharp%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/summary.png" class="">]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSharp基础总结</title>
    <link href="/2022/05/04/CSharp/CSharp%E5%9F%BA%E7%A1%80/CSharp%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"/>
    <url>/2022/05/04/CSharp/CSharp%E5%9F%BA%E7%A1%80/CSharp%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>基础总结</p><span id="more"></span><img src="/2022/05/04/CSharp/CSharp%E5%9F%BA%E7%A1%80/CSharp%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/summary.png" class="">]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>选择排序</title>
    <link href="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>2022.5.4</p><span id="more"></span><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>重点知识点：<br><strong>选择排序</strong><br>1.基本概念： 新建中间商 遍历依次比较找出极值 放入目标位置<br>2.套路写法：两层循环（外层轮数 内层寻找 初始索引 记录极值）<br>3.优化： 已经完成比较的不参与比较  加一个bool标识判断是否已经有序</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><img src="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/exam.png" class=""><p>以下是答案：</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson14_选择排序练习题&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;选择排序练习题&quot;);            #region 练习题1               &#x2F;&#x2F;生成随机数组            Random r &#x3D; new Random();            int[] arr &#x3D; new int[20];            for (int i &#x3D; 0; i &lt; arr.Length; i++)            &#123;                arr[i] &#x3D; r.Next(0, 101);            &#125;            &#x2F;&#x2F;选择排序升序排序            Console.WriteLine(&quot;选择排序升序排序结果:&quot;);            for (int m &#x3D; 0; m &lt; arr.Length; m++)            &#123;                int index &#x3D; 0;                int temp;                for (int n &#x3D; 0; n &lt; arr.Length - m; n++)                &#123;                    if (arr[index] &lt; arr[n])                    &#123;                        index &#x3D; n;                    &#125;                &#125;                if(index !&#x3D; arr.Length - m -1 )                &#123;                    temp &#x3D; arr[index];                    arr[index] &#x3D; arr[arr.Length - m - 1];                    arr[arr.Length - m - 1] &#x3D; temp;                &#125;            &#125;            for (int i &#x3D; 0; i &lt; arr.Length; i++)            &#123;                Console.Write(arr[i] + &quot; &quot;);            &#125;            &#x2F;&#x2F;中间间隔            Console.WriteLine();            Console.WriteLine(&quot;*************&quot;);            &#x2F;&#x2F;冒泡排序降序排序            Console.WriteLine(&quot;选择排序降序排序结果:&quot;);            for (int m &#x3D; 0; m &lt; arr.Length; m++)            &#123;                int index &#x3D; 0;                int temp;                for (int n &#x3D; 0; n &lt; arr.Length - m; n++)                &#123;                    if (arr[index] &gt; arr[n])                    &#123;                        index &#x3D; n;                    &#125;                &#125;                if (index !&#x3D; arr.Length - m - 1)                &#123;                    temp &#x3D; arr[index];                    arr[index] &#x3D; arr[arr.Length - m - 1];                    arr[arr.Length - m - 1] &#x3D; temp;                &#125;            &#125;            for (int i &#x3D; 0; i &lt; arr.Length; i++)            &#123;                Console.Write(arr[i] + &quot; &quot;);            &#125;            #endregion        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>冒泡排序</title>
    <link href="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>2022.5.4</p><span id="more"></span><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>重点知识点：<br><strong>冒泡排序</strong><br>1.基本概念： “无序”数组中两两相邻的数不断比较与交换直到“有序”<br>2.套路写法：两层循环（外层轮数 内层比较 满足则交换）<br>3.优化： 已经完成比较的不参与比较  加一个bool标识判断是否已经有序</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><img src="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/exam.png" class=""><p>以下是答案：</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson13_冒泡排序练习题&#123;    internal class Program    &#123;        #region 练习题2        &#x2F;&#x2F;冒泡排序函数        static void PaiXu( int[] arr, bool upDown)        &#123;            &#x2F;&#x2F;小优化 在循环外声明变量 可以提高一些性能            bool isSort;            int temp;            for (int m &#x3D; 0; m &lt; arr.Length; m++)            &#123;                isSort &#x3D; false;                for (int n &#x3D; 0; n &lt; arr.Length - 1 - m; n++)                &#123;                    if(upDown)                    &#123;                        if (arr[n] &gt; arr[n + 1])                        &#123;                            isSort &#x3D; true;                            temp &#x3D; arr[n];                            arr[n] &#x3D; arr[n + 1];                            arr[n + 1] &#x3D; temp;                        &#125;                    &#125;                    else                    &#123;                        if (arr[n] &lt; arr[n + 1])                        &#123;                            isSort &#x3D; true;                            temp &#x3D; arr[n];                            arr[n] &#x3D; arr[n + 1];                            arr[n + 1] &#x3D; temp;                        &#125;                    &#125;                &#125;                if (!isSort)                &#123;                    break;                &#125;            &#125;            if (upDown)            &#123;                Console.WriteLine(&quot;冒泡排序升序排序结果:&quot;);            &#125;            else            &#123;                Console.WriteLine(&quot;冒泡排序降序排序结果:&quot;);            &#125;            for (int i &#x3D; 0; i &lt; arr.Length; i++)            &#123;                            Console.Write(arr[i] + &quot; &quot;);            &#125;        &#125;        #endregion        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;冒泡排序练习题&quot;);            #region 练习题1            &#x2F;&#x2F;判断是否已经有序 标识符            bool isSort &#x3D; false;            &#x2F;&#x2F;生成随机数组            Random r &#x3D; new Random();            int[] arr1 &#x3D; new int[20];            for (int i &#x3D; 0; i &lt; arr1.Length; i++)            &#123;                arr1[i] &#x3D; r.Next(0, 101);            &#125;            &#x2F;&#x2F;冒泡排序升序排序            Console.WriteLine(&quot;冒泡排序升序排序结果:&quot;);            for(int m &#x3D; 0; m &lt; arr1.Length; m++)            &#123;                isSort &#x3D; false;                for(int n &#x3D; 0; n &lt; arr1.Length - 1 - m; n++)                &#123;                    if(arr1[n] &gt; arr1[n + 1])                    &#123;                        isSort &#x3D; true;                        int temp &#x3D; arr1[n];                        arr1[n] &#x3D; arr1[n + 1];                        arr1[n + 1] &#x3D; temp;                    &#125;                &#125;                if( !isSort )                &#123;                    break;                &#125;            &#125;            for(int i &#x3D; 0; i &lt; arr1.Length; i++)            &#123;                Console.Write(arr1[i] + &quot; &quot;);            &#125;            &#x2F;&#x2F;中间间隔            Console.WriteLine();            Console.WriteLine(&quot;*************&quot;);            &#x2F;&#x2F;冒泡排序降序排序            Console.WriteLine(&quot;冒泡排序降序排序结果:&quot;);            for (int m &#x3D; 0; m &lt; arr1.Length; m++)            &#123;                isSort &#x3D; false;                for (int n &#x3D; 0; n &lt; arr1.Length - 1 - m; n++)                &#123;                    if (arr1[n] &lt; arr1[n + 1])                    &#123;                        isSort &#x3D; true;                        int temp &#x3D; arr1[n];                        arr1[n] &#x3D; arr1[n + 1];                        arr1[n + 1] &#x3D; temp;                    &#125;                &#125;                if (!isSort)                &#123;                    break;                &#125;            &#125;            for (int i &#x3D; 0; i &lt; arr1.Length; i++)            &#123;                Console.Write(arr1[i] + &quot; &quot;);            &#125;            #endregion            &#x2F;&#x2F;中间间隔            Console.WriteLine();            Console.WriteLine(&quot;*************&quot;);            #region 练习题2            &#x2F;&#x2F;生成数组            int[] arr2 &#x3D; new int[20];            for (int i &#x3D; 0; i &lt; arr2.Length; i++)            &#123;                arr2[i] &#x3D; r.Next(0, 101);            &#125;            &#x2F;&#x2F;true代表升序排序 false代表降序排序            PaiXu( arr2, true);            &#x2F;&#x2F;中间间隔            Console.WriteLine();            Console.WriteLine(&quot;*************&quot;);            PaiXu( arr2, false);            #endregion        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月4日</title>
    <link href="/2022/05/04/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%884%E6%97%A5/"/>
    <url>/2022/05/04/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%884%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="ca17d6d80839b79c53b590df5936d99722a2d8593f839772f3c9ff00bcc3861c">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe5022d3d41ced9faff4c414d720080b2e532c1575e70f40aaaa88040ab450a6d1b0981729a275468a2721b3c204a6438005e1b5dd0eda5f210f00659b2455b19b448bfeb7c8941de5e1738392fcd8a90658b21cee475b6f6f7850c67a821be6789a381b5c6361d290687a364526d955099a05abcd6ca8f1caef52449ea73fe9ecc01d01c4dac98b49289d9b265518c538098ab70dfc8a28cb57379f527e9bd0a41b7ed937d545fc2ec58cbcb8e1836d320435d2f561d0b922aeefd20c5a25dd8bd482b3affd7788f1026b0d164a7a1200be4ab783d22b509cc73df2d4a874d0927a13e57e9ec51d570395fa33de0e935b103a40adc0cfe9ff993878099917f32a5a19d88c26393c99c0a4890ce9ff8564a79291510b8245fc819b0234d92ced7002d06feb702682424bbe6ab3322e9c0dbd3577666fb907d3216a13cc3cbd10869f2c9845eac2453c3363f1347ed6930624116787e8057962cc5e876f1a8aa89cd91c6b0f18a816b0ad8802c2c893771c661759aa20f59fadb7f1040662ad22398e09d575ce8ed41d9aeab6db4151b2948e28c5229464590834ddad0a940e32364b2e3c8d14458afbdfc789483484c8f258adb5c3faa2f4d91357f7d6c79ca83bb3ac087144bec966eb987b987ef814a4311ab886fb10d891ec7a453742f3faf3cdbe9545b4e543ed1022974eb5a499fc1d5d4acf78fa639948aa942b79af2d9fb253092f62af74adf84cedc58e522c50d20e8ecfb3e11c34f5edaa8d51de69d203dbe77a37e2178d21bae9e228c01061321d43002bda5dcf3e0a6714af76808dad9a16423791a676c4e6fb251bd2609d5b1adea9a7feb76a4a3fb6abb284b7de4aa2d12819871ef1469d3c4fa40fd7117c4bdd71bcc12738ac3ac2ed6fbb81a546a73511aeb0fda205c809615aec05f7d10edd4a61249d735f01843ea532b2aff4fed3afb9befaf5273192217c3f4dc2b0688271f585c76f41dd161360351247a0120360a70861bc6567d68c936eb575392ac8ccd8d9d37301b545f139307c88d27958347d808655a4bcbd9e524012d1ecf357c9953130f6834dfda6fb569a3b0db2074370860cb42f99fe730320a5549908fb11d3e1ada8913328b09f8910e1b0f9be670d6f16ae41c08ddb2baa5ea8be39be72bef47f792fd312f6a591964a4fcf60ae91793f4da790894159b69ee8eda7d54e722f14ecab819cf37c204f11f609b2201122ff5e24782387000c3e22ae5c1bc01de55aa50a7345e37ab938f3f51990237004b7a81f2e5d7a75ac3b877d9619025b31d1ae3b07c8dd55b60c815f3a320b13854e8c7a3646e7b12a5dc8f6b29c451c03265998681ebce942f031eb2d72354bba0fc68a4f7482ae1d51833f71101d4175e13dfa242bbc4864f067ed446c8526a2449682d90e9ec80760a2ecdcc3018651157b6897825d906c9ddd2d926d9d75121c9ebaf9b4cc8911651a854785d2c17c1f607214a02f0532e9a27700168d4df41faa35855366c4e62864c05f153b16b0496363f215fac5c7c4238c9bbd1cb87567af61ff4f9b4bbc54decb3c5a7cd68ac1ab0c4791acf83d7c521134889163bf5fb9d549103823c9ad35cb00240f06330d3e4ddd534831ca1a61f5efdf96e5b192d1849f61a225db50ba046c62150b561f719fdb8a4b9e53dfae29a476b50442398bdf55d5f2b992b11adf99b1e2a972ff8d3032d37ea4a1b7857396b42e5f4f97327daa6683fa4a0e6967a7a2377b7dda7d678d53b85e993c07d2a475af2152156804da9e6234dd1ff032fa4d4fed908990a59ac9e3e457a5715f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">要密码，快滚.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月3日</title>
    <link href="/2022/05/04/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%883%E6%97%A5/"/>
    <url>/2022/05/04/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%883%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="eca6d1fe149299d16fdebff137629187afd2b07ff353739ed1229d83d3640d27">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe5009c12dd1b715f42596ff4c88e24a0cfe8922606d46efa74ddbd9f5d3b426f56687102603786378470a4ecaae8b2313d0c003aaefde25d0f4bfa6cf8adcc4fbaa0a568aa7648f307311400a354664366507492f645fe02049bb0be8437ca7c835fca64706458d6fdd363a529564b60a3b26384e67ab2e038ad4b5d30b6a9c4925856a93271e13ba94afa16c26633b31e9ee540bb1ddb9f30dbc9f02df3101ce70b7d2d6b666fd3296fee8a9d4e1cd30d4e2808d3d23569489143fe1ce520c639063e2260f47b9a0435d49c601b499354313d5749d8dedd8f136d00fe0e3e3c2e078e7d7b8e484c261a9f9daefd65ce671fa990edd217fb86de23e9982edc3d0881d85390fd9fecf94c8b90918bb57a8ba3336b474952f80f1a08fc8634c8bcc0cb6d38bb2402a896db95b4f7356a1e11ada26cd4796de4a3c305847a1a2cab31f9794c08599ff6db9b0c4e89cb8aada39df07c2787d825ab709670194aa34c42a28e6d2b353bc49a39d7206a416b5f9a1db7705a31fd3378793c16f46334dff3101d76794745deaf80cea915eab7185931cce95ed77726e596ed18cd8418533fff97e9920cd9c00a880649087d082db0273ff52138bb8bcd3c7e58f3aac7f95ce6315df7225142d7485580499691c74ab94a1bd67ab7090999d80461c634d04653ce41bf84b6d17cd9af5fb85f31a7f132c467cb8f634b56c0ef59186ec1f561eaa4256804a827ca8f556e7afea92a81664dabaebfb2922af74339be92e7467846da05585de7ea69713758bb31bfb9be3</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">要密码，快滚.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构体</title>
    <link href="/2022/05/03/CSharp/CSharp%E5%85%A5%E9%97%A8/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <url>/2022/05/03/CSharp/CSharp%E5%85%A5%E9%97%A8/%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<p>2022.5.3</p><span id="more"></span><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>重点知识点：<br><strong>结构体</strong><br>1.概念： 结构体 struct 是变量和函数的集合 用来表示特定的数据集合<br>2.访问修饰符：用来修饰变量和方法  public-&gt;外部可以调用   private-&gt;只能内部调用   不写默认private<br>3.构造函数：没有返回值 函数名和结构体名相同 可以重载 主要是帮助我们快速初始化结构体对象</p><p>注意：<br>1.在结构体中声明的变量不能初始化  只能在外部或者函数中赋值（初始化）<br>2.在结构体中声明的函数 不用加static</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><img src="/2022/05/03/CSharp/CSharp%E5%85%A5%E9%97%A8/%E7%BB%93%E6%9E%84%E4%BD%93/exam.png" class=""><p>以下是答案：</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson12_结构体练习题&#123;    #region 练习题1    struct Student    &#123;               public string name;        public bool sex;        public int age;        public int lesson;        public string major;        public Student(string name, bool sex, int age, int lesson, string major)        &#123;            this.name &#x3D; name;                       this.sex &#x3D; sex;            this.age &#x3D; age;            this.lesson &#x3D; lesson;            this.major &#x3D; major;        &#125;        public void Information()        &#123;            Console.WriteLine(&quot;学员姓名&#123;0&#125;,性别&#123;1&#125;,年龄&#123;2&#125;,班级&#123;3&#125;,专业&#123;4&#125;&quot;, name, age, age, lesson, major);        &#125;    &#125;    #endregion    #region 练习题2    &#x2F;&#x2F;他们都是访问修饰符 用来修饰变量和方法    &#x2F;&#x2F;private 只能内部调用    &#x2F;&#x2F;public  外部可以调用    #endregion    #region 练习题3    struct Rectangular    &#123;        public int x;        public int y;        public Rectangular(int x, int y)        &#123;            this.x &#x3D; x;            this.y &#x3D; y;        &#125;        public void Information()        &#123;            Console.WriteLine(&quot;矩形的长为&#123;0&#125;,宽为&#123;1&#125;,面积为&#123;2&#125;,周长为&#123;3&#125;&quot;, x, y, x * y, 2 *(x + y));        &#125;    &#125;    #endregion    #region 练习题4    struct PlayerInfo    &#123;        public string name;        public E_Occupation occupation;                public PlayerInfo(string name, E_Occupation occupation)        &#123;            this.name &#x3D; name;            this.occupation &#x3D; occupation;                &#125;        public void AttackInformation()        &#123;            string o &#x3D; &quot;&quot;;            string s &#x3D; &quot;&quot;;            switch (occupation)            &#123;                case E_Occupation.Warrior:                    o &#x3D; &quot;战士&quot;;                    s &#x3D; &quot;冲锋&quot;;                    break;                case E_Occupation.Hunter:                    o &#x3D; &quot;猎人&quot;;                    s &#x3D; &quot;假死&quot;;                    break;                case E_Occupation.Witch:                    o &#x3D; &quot;法师&quot;;                    s &#x3D; &quot;奥术冲击&quot;;                    break;            &#125;            Console.WriteLine(&quot;&#123;0&#125;&#123;1&#125;施放了&#123;2&#125;&quot;, o, name, s);        &#125;    &#125;    enum E_Occupation    &#123;        Warrior,        Hunter,        Witch,    &#125;    #endregion    #region 练习题5    struct Monster    &#123;        public string name;        public int atk;        public Monster(string name)        &#123;            this.name &#x3D; name;            Random r &#x3D; new Random();            atk &#x3D; r.Next( 10, 30 );        &#125;        public void Atk()        &#123;            Console.WriteLine(&quot;&#123;0&#125;的攻击力是&#123;1&#125;&quot;, name, atk);        &#125;    &#125;    #endregion    #region 练习题7    struct UltraMan    &#123;        public string name;        public int atk;        public int def;        public int hp;        public UltraMan(string name, int atk, int def, int hp)        &#123;            this.name &#x3D; name;            this.atk &#x3D; atk;            this.def &#x3D; def;            this.hp &#x3D; hp;                   &#125;        &#x2F;&#x2F;结构体是值类型 想要在函数内部改变值类型信息 外部受影响 一定要用ref或out        public void Attack(ref Boss monster)        &#123;            &#x2F;&#x2F;奥特曼打怪兽的逻辑            monster.hp -&#x3D; atk - monster.def;            Console.WriteLine(&quot;&#123;0&#125;攻击了&#123;1&#125;，造成了&#123;2&#125;点伤害，&#123;1&#125;剩余血量&#123;3&#125;&quot;, name, monster.name, atk - monster.def, monster.hp);        &#125;    &#125;    struct Boss    &#123;        public string name;        public int atk;        public int def;        public int hp;        public Boss(string name, int atk, int def, int hp)        &#123;            this.name &#x3D; name;            this.atk &#x3D; atk;            this.def &#x3D; def;            this.hp &#x3D; hp;        &#125;        public void Attack(ref UltraMan Tiga)        &#123;            &#x2F;&#x2F;怪兽打奥特曼的逻辑            Tiga.hp -&#x3D; atk - Tiga.def;            Console.WriteLine(&quot;&#123;0&#125;攻击了&#123;1&#125;，造成了&#123;2&#125;点伤害，&#123;1&#125;剩余血量&#123;3&#125;&quot;, name, Tiga.name, atk - Tiga.def, Tiga.hp);        &#125;    &#125;    #endregion    internal class Program    &#123;                        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;结构体练习题&quot;);            #region 练习题1            Student s1 &#x3D; new Student(&quot;季宝&quot;, true, 23, 2, &quot;微电子&quot;);            Student s2 &#x3D; new Student(&quot;大逼&quot;, true, 23, 2, &quot;网安&quot;);            s1.Information();            s2.Information();            #endregion            #region 练习题3            Rectangular r1 &#x3D; new Rectangular (5, 4);            r1.Information();            #endregion            #region 练习题4            Console.Write(&quot;请输入玩家名字：&quot;);            string name &#x3D; Console.ReadLine();            Console.Write(&quot;请选择你的职业：（0战士，1猎人，2法师）&quot;);            try             &#123;                E_Occupation o &#x3D; (E_Occupation)int.Parse(Console.ReadLine());                PlayerInfo p1 &#x3D; new PlayerInfo(name ,o);                p1.AttackInformation();            &#125;            catch            &#123;                Console.WriteLine(&quot;请输入数字&quot;);            &#125;            #endregion            #region 练习题6            &#x2F;&#x2F;声明Monster数组            Monster[] monsters &#x3D; new Monster[10];            for (int i &#x3D; 0; i &lt; monsters.Length; i++)            &#123;                monsters[i] &#x3D; new Monster(&quot;怪兽&quot; + i);                monsters[i].Atk();            &#125;            #endregion            #region 练习题7            UltraMan Tiga &#x3D; new UltraMan(&quot;迪迦&quot;, 10, 5, 100);            Boss boss &#x3D; new Boss(&quot;哥斯拉&quot;, 8, 4, 100);            while(true)            &#123;                Tiga.Attack(ref boss);                if( boss.hp &lt;&#x3D; 0)                &#123;                    Console.WriteLine(&quot;迪迦胜利&quot;);                    break;                &#125;                boss.Attack(ref Tiga);                if (Tiga.hp &lt;&#x3D; 0)                &#123;                    Console.WriteLine(&quot;哥斯拉胜利&quot;);                    break;                &#125;                Console.WriteLine(&quot;按任意键继续&quot;);                Console.ReadKey(true);            &#125;            #endregion        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>递归函数</title>
    <link href="/2022/05/03/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/"/>
    <url>/2022/05/03/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>2022.5.3</p><span id="more"></span><h1 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h1><p>重点知识点：<br><strong>递归函数</strong><br>概念： 让函数自己调用自己<br>注意：<br>一个正确的递归函数<br>1.必须有结束调用的条件<br>2.用于条件判断的 这个条件必须改变 能够打到停止的目的</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><img src="/2022/05/03/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/exam.png" class=""><div class="code-wrapper"><pre><code class="csharp">using System;namespace Lesson11_递归函数练习题&#123;    internal class Program    &#123;        #region 练习题1        static void ZeroTen(int a)        &#123;            if(a &gt; 10)            &#123;                return;            &#125;            Console.WriteLine(a);            ZeroTen(++a);        &#125;        #endregion        #region 练习题2        static int Factorial(int a)        &#123;            if(a == 1)            &#123;                return 1;            &#125;            return a * Factorial(--a);//--a应写在后面, 或用a - 1            //若是 Factorial(--a) * a ,后面的a是已经减掉的a,得不到正确结果        &#125;        #endregion        #region 练习题3        static long SumFactorial(int a)        &#123;            if(a == 1)            &#123;                return 1;            &#125;            return Factorial(a) + SumFactorial(--a);        &#125;        #endregion        #region 练习题4        //自己写的        static double ZhuganLength1(int a)        &#123;            if(a == 0)            &#123;                return 100;            &#125;            return 0.5 * ZhuganLength1(--a);        &#125;        //答案        //一是长度 二是天数        static void ZhuganLength2(double length, int day = 0)        &#123;            length /= 2;            ++day;            //第十天砍了后的长度            if (day == 10)            &#123;                Console.WriteLine(&quot;第十天砍后竹竿长&#123;0&#125;米&quot;, length);                return;            &#125;                        ZhuganLength2(length, day);        &#125;        #endregion        #region 练习题5        //看答案的 想不出来短路怎么写        static bool PrintNum(int a)        &#123;            Console.WriteLine(a);                       return a == 200 || PrintNum(a + 1);             //逻辑短路，若逻辑或前面的为真，不执行逻辑或后面的        &#125;                #endregion        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;递归函数练习题&quot;);            //ZeroTen(0);            Console.WriteLine(Factorial(5));            Console.WriteLine(SumFactorial(10));            Console.WriteLine(ZhuganLength1(10));            ZhuganLength2(100, 0);            PrintNum(1);        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏设想(更新中)</title>
    <link href="/2022/05/03/%E9%A1%B9%E7%9B%AE/%E6%B8%B8%E6%88%8F%E8%AE%BE%E6%83%B3-%E6%9B%B4%E6%96%B0%E4%B8%AD/"/>
    <url>/2022/05/03/%E9%A1%B9%E7%9B%AE/%E6%B8%B8%E6%88%8F%E8%AE%BE%E6%83%B3-%E6%9B%B4%E6%96%B0%E4%B8%AD/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="085b8f3c7f5217256b375c6ae6075e8a8adae91a0ade8f8a94c33da807588fd2">1432a7b75e994fca526a11f4c4c29edb5d95ddd08071f06d8e2b1881f40addc49717d4ad2129bf03f288d888dddd593047eece5bda476a758cc60ea414b92c2fde57109810737be6114d7bc1b6b7562288492faa485ce10d9f6299e57b851357b155e4efdd34cbdd97c62497dc707a8984ec16459a2b29863b8efb819d6be55fee9506e4cffd6a89bbbd6344b2f51a0b1deb0385f3209dfde7e16b2730acd43ef49c7653d1401cc12f99952648c7e9fac2e3d036f71ac2a224d882c9eb52b53e8ce41ad4adcb845a1ece03152a88f6b9b4a60f385b7cd2bb197f64876a288ef21ea0f1cd6c1413b5bb87c41430ede2ee3757bf646cb9be07686a61467b31f274ec251a3402c81ab754e4f64b4371f59d3e48b066a9d4374932d26748038e8972751dbd5ccf58182e5c1ffdd89532c2b4d16f4e9e2f1d2ca1aff8bf2b9f1a02ec8cb9b08156183203b1e6d5d9e33805bdfdcf86d2d455b22f3cf0c5256eeeba4ecd62b87719f83f61c86654cd68f2d2cca26593c99c9d37ac15226c4abb48fd006cebb943c3977b2e1e46f10646380aed592825f2f183df4476ec6f707913e8fe88cf823b72bf2aec4dc26fc020a783d26174557db927ca6c764208fa1f0de861d954ea17ba42cba643a0d82b2a34bbe7d1add7f69f822495de81deabf3f37c59366a1ad681568c2d6c73d0fbbe10b4f00148cd62c7e8c8ca89963dfdd89ea0201c6163f7a9d843737c71d4c25a133621e9b429eac7b530ca1162fa2a9c8f83a78239efbf362a28152fd1812b3bd1306bc1ce235d6944e5c6352f6a6d6d14cda004f50ae8f27c35d7eb6ebe68e6246b1766d92f34bbd91f1aafd140c0bdc584aa53d91b49fc7bde567c308953bb3021801af6fcec8d469dd0f7c38b11f9383c63f733c54f7ec71d8221103ac971dd97a1510cb199dad83bda9253e38f3f945571</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">要密码，快滚.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数重载</title>
    <link href="/2022/05/03/CSharp/CSharp%E5%85%A5%E9%97%A8/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/"/>
    <url>/2022/05/03/CSharp/CSharp%E5%85%A5%E9%97%A8/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<p>2022.5.2</p><span id="more"></span><h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><p>重点知识点：<br><strong>函数重载</strong><br>概念： 同一个语句块中，函数名相同，参数数量、类型、顺序不同的函数 就称为函数重载<br>注意： 和返回值无关<br>作用： 一般用来处理不同参数的同一类型的逻辑处理</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><img src="/2022/05/03/CSharp/CSharp%E5%85%A5%E9%97%A8/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/exam.jpg" class=""><p>以下是答案：</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson10_函数重载练习题&#123;    internal class Program    &#123;        #region 练习题1        static int CompareNum(int a, int b)        &#123;            return a &gt; b ? a : b;        &#125;        static float CompareNum(float a, float b)        &#123;            return a &gt; b ? a : b;        &#125;        static double CompareNum(double a, double b)        &#123;            return a &gt; b ? a : b;        &#125;        #endregion        #region 练习题2        static int CompareArray(int[] arr)        &#123;            int max &#x3D; arr[0];            for (int i &#x3D; 1; i &lt; arr.Length; i++)            &#123;                if (arr[i] &gt; max)                    max &#x3D; arr[i];            &#125;            return max;        &#125;        static float CompareArray(float[] arr)        &#123;            float max &#x3D; arr[0];            for (int i &#x3D; 1; i &lt; arr.Length; i++)            &#123;               if (arr[i] &gt; max)                   max &#x3D; arr[i];            &#125;            return max;        &#125;        static double CompareArray(double[] arr)        &#123;            double max &#x3D; arr[0];            for (int i &#x3D; 1; i &lt; arr.Length; i++)            &#123;                f (arr[i] &gt; max)                   max &#x3D; arr[i];            &#125;            return max;        &#125;        #endregion        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;函数重载练习题&quot;);            #region 练习题1            Console.WriteLine(CompareNum(5, 7));            Console.WriteLine(CompareNum(10.9f, 4.5f));            Console.WriteLine(CompareNum(20.975, 100.45));            #endregion            #region 练习题2            int[] arrInt &#x3D; &#123; 1, 4, 5, 8, 6 &#125;;            Console.WriteLine(CompareArray(arrInt));            float[] arrFloat &#x3D; &#123; 2.1f, 4.5f, 5.9f, 8.1f, 5.8f &#125;;            Console.WriteLine(CompareArray(arrFloat));            double[] arrDouble &#x3D; &#123; 1.2, 4.5, 5.8, 8.4, 6.6, 8.5 &#125;;            Console.WriteLine(CompareArray(arrDouble));            #endregion        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月2日</title>
    <link href="/2022/05/02/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%882%E6%97%A5/"/>
    <url>/2022/05/02/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%882%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="491f82e74d100b7c0ea7a128893e0938270b929bd3c36f691cdf1082d62df28d">a03af1012de36d86e65bfb0d51f6ff10488d28acf4ffb3e9d40e31ff66292b18d63fe0d726a396877e15d0f45ea8c4d0fca64270b3af481bbf674539be9d74ef68c82a089e06187f209c1d9148866c6889149615508e1920a0ba4dfede99cd4f1c78d484984659bc16451c78231727151c61eb8e511e88202c667f6492a364b4675af00dab110af61f89478fb7bf1e08ab42759f2346284503e36031ddd429d25b0534f43dda5bdafe4e506c1c70035c6cadad563a3c2357e939054059579347b9934247a362a556c365ea249a8dc505ce1d6d8ca02cfccd72b2a108d0eb68d21f51ea413ffdda474e96f5fc9814f7bcc309066ecda23a2402bfb054e09fd25585ec506d740893f0a92fefe328df54c6c5e30ccee78c493458af915a8bd62d591845f1826a4e9bb303d3f4ffa2a0a630ea2eeca8a0aa24bf1fac84529eca1eca00b428e66ee56674f67df6893fb3b6638bf6072f6e9a9070d033dbce154ec5f4f8cf9a7a4f71745f97e5632413ce634d8752541d453cc1f8efc43cb6e55f4f5387885b68fb16745bbfeab5b3f794bfcf28fa185ee8184906a049f0af8ad88ad4f440aa03d10017a143f7f5d6205e3de25d9d59cfa3851b9f2e81f5696c8a2a346b46a76c157a9c2ec305a56e0d7731f4171170433961c676df299d8c595faf5781699895fd001cb183f0542a53f04e059eb4aa707eb1ebec51596a61e4214457d3198eed0cd1c0fe925ad8fc6bcd34e0e0461ee7011d206c6498b0d22654c77579c9cad6d84edd07b81589b80dead8c40e53fffe3640728be6c57f1adecc1adae8789b3531cecd41f4e7f4fdba0c51531d5582c3f825cc4baf81d38a72ab443582fd97b24a4ac9d6c1678f5112c39bfa42e025e83c92e477964c88db0c102230ac7f4629e91dcb511bb7ade9fd16c786601f7194bf912cbed763641345d003c7f4b338765e3cdddfa403c98b5c030f06481f4598c8aa5a297abeb1492047cf5ad3c8496b451b942ff3336266c3b224372060d667f3d6346ba3004f5b9a598335fbc69ab72aa78c648cbf86d34d7d87a21e3675b42c696d20f83b50d8dc483eaa7a111f3b1534d4e39bc38e09196cc7d43fa342fa1233c4f07e63b8a1b464e3d7e0129d364e1556e6087b43e6dced704a2f793fe41e9f717c15c74c85b78c76b947e4ce7bb47e343b6ac8217d74f905bbdf1fee49a8beb58026eb33f2767416d12bc9838b2d1f102cbd24687614dd3a6e17f1367e92340e9641400d3882c9cd747a9447b4ccf8ebb10700132e285d8abc7b51413191a46b696898772325468360fef28752ae0335b0cff4d8aa52466cfc1ce30fd9ee0f7636af2696c47d23e8c8cdeddd2c9d3909f2e3f8d8538a1c26a9fb47e56892a3d0d4e1c9ceb9112a9dca53101795505354efe7a809cb4af82ea138c98c207b9900c5c9ed067cc8f724ee174489e410bb86821f0862bae558c20657a113c556316f8222ff65e9859371f0cf0c759ecf953da0cda9f4b302962e44</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">要密码，快滚.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>变长参数和参数默认值</title>
    <link href="/2022/05/02/CSharp/CSharp%E5%85%A5%E9%97%A8/%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC/"/>
    <url>/2022/05/02/CSharp/CSharp%E5%85%A5%E9%97%A8/%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>2022.5.2</p><span id="more"></span><h1 id="变长参数和参数默认值"><a href="#变长参数和参数默认值" class="headerlink" title="变长参数和参数默认值"></a>变长参数和参数默认值</h1><p>重点知识点：<br><strong>1 变长参数关键字 params</strong><br>作用： 可以传入n个同类型参数 n可以是0<br>注意：<br>    1.params 后面必须是数组 意味着只能是同一类型的可变参数<br>    2.变长参数只能有一个<br>    3.必须在所有参数后面写变长参数</p><p><strong>2 参数默认值（可选参数）</strong><br>作用：可以给参数默认值 使用时可以不传参 不传用默认的 传了用传的<br>注意：<br>    1.可选参数可以有多个<br>    2.正常参数必须写在可选参数前面，可选参数只能写在所有参数的后面</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><img src="/2022/05/02/CSharp/CSharp%E5%85%A5%E9%97%A8/%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC/exam.jpg" class=""><p>以下是答案：</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson9_变长参数和参数默认值练习题&#123;    internal class Program    &#123;        #region 练习题1        static void SumAndAvg(params int[] arr)        &#123;            int sum &#x3D; 0;            for (int i &#x3D; 0; i &lt; arr.Length; i++)            &#123;                sum +&#x3D; arr[i];            &#125;            double avg &#x3D; sum &#x2F; (double)arr.Length;            Console.WriteLine(&quot;它们的和为&#123;0&#125;,平均数为&#123;1&#125;&quot;, sum, avg);        &#125;        #endregion        #region 练习题2        static void OddEven(params int[] arr)        &#123;            int odd &#x3D; 0, even &#x3D; 0;            for (int i &#x3D; 0; i &lt; arr.Length; i++)            &#123;                if(arr[i] % 2 &#x3D;&#x3D; 0)                &#123;                    even +&#x3D; arr[i];                &#125;                else                &#123;                    odd +&#x3D; arr[i];                &#125;            &#125;            Console.WriteLine(&quot;奇数和为&#123;0&#125;,偶数和为&#123;1&#125;&quot;, odd, even);        &#125;        #endregion        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;变长参数和参数默认值练习题&quot;);            #region 练习题1            SumAndAvg(5, 9, 11, 52);            #endregion            #region 练习题2            OddEven(10, 11, 12);            #endregion        &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ref和out</title>
    <link href="/2022/05/02/CSharp/CSharp%E5%85%A5%E9%97%A8/ref%E5%92%8Cout/"/>
    <url>/2022/05/02/CSharp/CSharp%E5%85%A5%E9%97%A8/ref%E5%92%8Cout/</url>
    
    <content type="html"><![CDATA[<p>2022.5.1</p><span id="more"></span><p>#ref和out</p><p>重点知识点：<br>1.ref和out的作用: 解决值类型和引用类型 在函数内部 改值 或者 重新声明 能够影响外部传入的变量 让其也被修改<br>2.使用上: 就是在声明参数的时候 前面加上ref和out的 关键字即可 使用时同上<br>3.区别：<br> 1.ref传入的变量必须初始化  out不用<br> 2.out传入的变量必须在内部赋值  ref不用</p><p>#练习题</p><img src="/2022/05/02/CSharp/CSharp%E5%85%A5%E9%97%A8/ref%E5%92%8Cout/exam.jpg" class=""><p>以下是答案：</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">static bool Login(int user, int key, ref string info)    &#123;        if(user == 0)        &#123;            //用户名正确的逻辑            if(key == 0)            &#123;                //用户名正确且密码正确的逻辑                info = &quot;登录成功&quot;;            &#125;            else            &#123;                //密码错误的逻辑                info = &quot;密码错误&quot;;                return false;            &#125;        &#125;        else        &#123;            //用户名错误的逻辑            info = &quot;用户名错误&quot;;            return false;        &#125;               return true;    &#125;static void Main(string[] args)    &#123;        Console.WriteLine(&quot;请输入用户名和密码&quot;);            int user = int.Parse(Console.ReadLine());            int key = int.Parse(Console.ReadLine());            string info = &quot;&quot;; //ref需要初始化            while (!Login(user, key, ref info)) //若登录失败继续尝试            &#123;                Console.WriteLine(info); //登录失败直接进入循环 打印登陆失败                Console.WriteLine(&quot;请输入用户名和密码&quot;);                user = int.Parse(Console.ReadLine()); //不需要再声明                key = int.Parse(Console.ReadLine());            &#125;            Console.WriteLine(info);    &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月1日</title>
    <link href="/2022/05/01/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%881%E6%97%A5/"/>
    <url>/2022/05/01/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%88/2022%E5%B9%B45%E6%9C%881%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="8231443e481bad21d3be8c11f026cef33b9d2ec10d2c75db8a6a3fc9353e6db7">a03af1012de36d86e65bfb0d51f6ff1082829027e374e7685fe9ab85e3524a611ae1849435e4e7a720cff75f6e0c69420b45613e2699125232dbe72ca80048bebea598f361ba86018511cca15b95988dc0cfaef36e0d9831c314d5a5c0c42027b37202a638339207f929734f64e08597cbddc5ea522252e2e02962224d8f2610c567a9905f51b07d0b9ecc25ce9b92d845f910467ef77166d775f3ecd0d5e21bf953b08187237aa313add55b1c228dd7d053f127c9a6a47c0c5a7938ac994063ac4002df1fa06e05aafb90d8bc2640f6cd006d7ed7c8863170e64e1bd6245c77b0fa8e735e224b950e1f54e78b0133b701d1403fb2cfdf2d386b43e9fbaa1451076e4191f3d354e3fffc715fac93c09b38122dd8cb11d8342dc0c89192430adca4b08219e517801151b2a0f8c9d9db1c25359477c00a5f8a9d1f4dde7f15395f067821cdc6c518b824eb6db732a6f9509e2879bd5d893c34ef5dd9fb4feedd57143b5d8aaf6a95442b8ceaff1b20ed7a0103ef67d68f97923d95e97146672a06d3dbddf62d8d0308409f487798bfb2890628acb6da93b261a2be6b203fc5941ccf4602858ff06456f1cd8549bb19df0507e01adc30cf1edc3cf2ec7b1df2a01b64cbd75040011043907e573076bddaa0b8a1fd0278e802bee90f5473a88a8c185022aba3ed8be34c76a5f6841409c505a1b3068b32090cb5b1185e0bf33fc4b5a25b6b0dd4bbf90f8dbe9dcd98b38b25733197162851b604f16a5d7772dc986f3421c043d218bb4333b43d9982b085bbab19f29923bf644069879a756156a5ec5b6d9ac660e35e9544558afb91261123bcc30f7e00c6a468fe4f57c4a11fc966a618fc6f22037b00a3579d3f3ed4935bf7fa8ea29659083c3065e01531f9ca0aa7c185eb275f06844f98e1d86241cec7c6516f3c1490ef92db64b4894aa8b258b0ba055d641c53dbc0ac122fcf5d310d795b7943c3d1894ebd7906d91214d99dddb8546ee1ffc8f85958f09c8cde59fe895fc0b50b36ec620446c4ddc9685f8caccdebeca493bfe948808fb00921585db583e011fd37c3d175b970b75715e00d4b7e12ec96c492a95b96e523bb5e176bb0f49b3ff8ca86fdb500a752bda74eee760803b291021a3b9f0126cd7bb23dd1e72f470659f85b746c63aacba02862c6854f0b1ed71aad37a7828628896f1d5102453015e7769e691b07182728455dafcbc3e954aac72ef8a611d29a2392426ab51e80c901b6d0f46356365fa9660c731b71e7105a4a38d26fbffc6e804be1de7dafd2888b15a688c5d0b44b925821bb280a6ad0b3e82e48cec923663f4c22edb27946f90144f4df62e0c193bfa4186c0436989434570289d5a8a70a5823b41e640d330234ebaee4eceb1523b43b168b8a107765dd1b102c41cd200d3899fa241b87e8473e40b0d49ac9044249d8f74419b7507518041f3d7aad9e2152b0f8f425906095dd601697acd1a70bf3f5f2f64a0d38118e03282f3ae2a9ab8c9cc695c9f64a8cc722703e6e6805e21245b11f8f26228b91e66bd1b6f8d3ded0181491370dad82bdd46863138d11c8c6e4c70811bbb0afa15a450570fba043e2aa477441cf006111f916f0f80445a7ce1780af01a2b8688c4f70a758f6e7579d5d3cf9ddcc6a1dc3a83744c3ceb40f10fb072cb04940867ea5d2e7d7373bc2201d1c30a976745440597f87dd867d870c146ef3d4277dea046a21e2c758895343dde22f37061758a16095030c3f2664f9abb1f771ac28e2f55925974c7771f54557e447ebb7bee6449d22e52053925b248b05ba706590eedf6e24c1ea9f3685b83fd21e20dc9a8fdd87bb65266ddf72d99eaca5f7786afca9b98817f3c1a32ff87f776475024dd53cdbabc996921be1a50d5478a6f92cbd1f05885dce23af78eb58979c608fc64d3adf796861c673610fd9bf47793893da8bfcc7d0c9217244cb8768e699c45fb85d0658640db520170b1a420b72d890b4d056ef168bba17bd957af12f5239e8ae0687848c2e630234b4b46f680c1bce2cbd9711dabba8425ab03056c3a5f9592d7745499784fd25ade98ca511819ce01db178db801b75528f8dddb4aaf68cfbd76889f8720f774514aff1ef12734bf07f573b716d746e1ac572d62c788de740b599cfd6705a91db8c2d0974f2fafa47072dc231e1634008624e648489d915542f3bf2343b56b8b41482638b9cff93a60fd1d221550bfe947e4fafc8f7666803db2210081228e94e2e143133f3b851c8a2f5524e0c612da970f01576fd2f2c704bb10d79e52c7b75d8ca01c7a7f1aae45e43de5b208a64c4006038a8cb</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">要密码，快滚.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
