<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>类和对象</title>
    <link href="/2022/05/08/CSharp/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <url>/2022/05/08/CSharp/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>基本概念：<br>1.具有相同特征<br>2.具有相同行为<br>3.一类事物的抽象<br>4.类是对象的模板<br>5.可以通过类创建出对象<br>6.类的关键词 class</p><p>一般声明在 <strong>namespace</strong> 语句块中<br>声明语法：<br> <div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">访问修饰符 class 类名&#123;    &#x2F;&#x2F;封装    特征 成员变量    行为 成员方法    保护特征 成员属性    构造函数和析构函数    索引器    运算符重载    静态成员&#125;</code></pre></div></p><h1 id="（类）对象"><a href="#（类）对象" class="headerlink" title="（类）对象"></a>（类）对象</h1><p>基本概念：<br>1.<strong>类的声明</strong>和<strong>类对象（变量）声明</strong>是两个概念<br>2.<strong>类的声明</strong>类似<strong>枚举</strong>和<strong>结构体的声明</strong>（类的声明相当于声明了一个自定义变量类型）<br>3.对象是类创建出来的（相当于声明一个<strong>指定类的变量</strong>）<br>4.类创建对象的过程（一般称为<strong>实例化对象</strong>）<br>5.类对象都是<strong>引用类型</strong>的</p><p>声明语法：</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">类名 变量名;类名 变量名 &#x3D; null; &#x2F;&#x2F;null代表空类名 变量名 &#x3D; new 类名();</code></pre></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1.<strong>类的声明</strong>和<strong>类对象（变量）声明</strong>是两个概念<br>2.<strong>类的声明</strong>是声明对象的模板，用来抽象（形容）显示事物的<br>3.<strong>类对象（变量）声明</strong>是用来表示现实中的对象个体的</p><p>4.<strong>类</strong>是一个自定义的变量类型<br>5.实例化一个<strong>类对象</strong>是在声明变量</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/08/CSharp/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/%E7%BB%83%E4%B9%A0%E9%A2%98.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">练习题1 懒得做练习题2 A保持不变        GameObject A &#x3D; new GameObject(); &#x2F;&#x2F;新建栈 堆        GameObject B &#x3D; A; &#x2F;&#x2F;新建栈 指向A的堆        B &#x3D; null; &#x2F;&#x2F;B的栈 指向null的堆练习题3 A和B没关系        GameObject A &#x3D; new GameObject(); &#x2F;&#x2F;新建栈 堆        GameObject B &#x3D; A; &#x2F;&#x2F;新建栈 指向A的堆        B &#x3D; new GameObject(); &#x2F;&#x2F;B的栈 指向new的堆</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象编程</title>
    <link href="/2022/05/08/CSharp/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/05/08/CSharp/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>面向对象编程 面向过程编程</p><span id="more"></span><h1 id="面向过程编程"><a href="#面向过程编程" class="headerlink" title="面向过程编程"></a>面向过程编程</h1><p>一种<strong>以过程为中心</strong>的编程思想<br>分析出解决问题所需要的步骤<br>然后用函数把步骤一步一步实现<br>使用的时候一个一个一次调用</p><h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>面向对象是一种<strong>对现实世界理解和抽象</strong>的编程方法<br><strong>把相关的数据和方法组织为一个整体来看待</strong><br>从更高的层次来进行程序开发<br>更贴近事物的自然运行模式</p><p>万物皆对象  用程序来抽象（形容）对象  用面向对象的思想来编程</p><img src="/2022/05/08/CSharp/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E5%AF%B9%E8%B1%A1.png" class=""><p><strong>套路：</strong><br>用中文去形容一类对象<br>把一类对象的共同点提取出来<br>然后用程序语言把它翻译过来<br>带着对象的概念在程序中使用他们</p><h1 id="重要知识点"><a href="#重要知识点" class="headerlink" title="重要知识点"></a>重要知识点</h1><h2 id="面向对象关键知识"><a href="#面向对象关键知识" class="headerlink" title="面向对象关键知识"></a>面向对象关键知识</h2><p>类（class 关键词）</p><h2 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h2><p>重点中的重点：<br><strong>封装</strong> + <strong>继承</strong> + <strong>多态</strong><br><strong>封装</strong>：用程序语言来形容对象<br><strong>继承</strong>：复用封装对象的代码；儿子继承父亲，复用现成代码<br><strong>多态</strong>：同样行为的不同表现，儿子继承父亲的基金但是有不同的行为表现</p><h2 id="面向对象七大原则"><a href="#面向对象七大原则" class="headerlink" title="面向对象七大原则"></a>面向对象七大原则</h2><p>开闭原则<br>依赖倒转原则<br><strong>里式替换原则</strong><br>单一职责原则<br>接口隔离原则<br>合成复用原则<br>迪米特法则</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月8日</title>
    <link href="/2022/05/08/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%888%E6%97%A5/"/>
    <url>/2022/05/08/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%888%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="f59f778e162cd4c5575e8011cc98055fa0bff015c3ee6e202e70659d313c6c3d">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50fdd0ca3edc57389bd0e88084b7db202376ed899917c9c6c734af1f7eca42e06ef4ff0890be6f398558796f868b9f06ee655258737f6db070469b46f13f90d490fab7ed262b0674e752644fe7c26987bc8d8f98b1be0f67c09d7ed761c2f39431f9b5bf55e12b69d0873f8ee72fef88a00ffa617ea3d0cee8ec38a28f098431742f50e9fba2bdd55267e5781d681d47c7621c06254e363fd8f450a5b452e550941cb7bde91bee2ad2dadeef67388f660d4325433b8551d5498c44b50ae1c4ce8573f93da15e1bccd0368270193b6e43ec0bbfb7005c8ccad91008f1ba8dd3c2bc3f817203b2b153ed8b0fb3bb47321b923f8a0b40d5129b483c2eb3b3696f83c13570b18ec4f41c0060981769b4fddf506e84496b93e604bec7f5e9eab245635a58312a1db37ddbe9403b347965029d3609cb00b0963c4f7ea247324ba0a1360931d2cf439647cca7b900d9f7cb66f2fc70100efb41f96eaa24a625c2e6819c6988a6e4223414da010942d393cc9cdef09f2d0040e194370d0dae37a88aeeb44071abbc70cab22737f11086352de96310e23c022150e7804fea3160c52121198389667716f56947b839ddf07ce944b0c04dc9156d1e8f54cc2f56e462f7d484d5437ec4beefea3b5e894006f08d6fd290aed03347811ced529b6d5ab340e33887</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">要密码，快滚.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>飞行棋逻辑整理</title>
    <link href="/2022/05/07/CSharp/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86/"/>
    <url>/2022/05/07/CSharp/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>逻辑整理</p><span id="more"></span><img src="/2022/05/07/CSharp/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86-1.jpg" class=""><img src="/2022/05/07/CSharp/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86-2.jpg" class=""><img src="/2022/05/07/CSharp/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86-3.jpg" class=""><img src="/2022/05/07/CSharp/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86-4.jpg" class="">]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月7日</title>
    <link href="/2022/05/07/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%887%E6%97%A5/"/>
    <url>/2022/05/07/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%887%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="5b619cf13cf1e47245c9944edb189af53431bf3141868f33b1bc6c8529b0537d">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50fdd0ca3edc57389bd0e88084b7db2023fbfbe4a886cec053b0d69678e9bd693646e6fc5a95475d4199d73cf5baa89d2975c29f552c86b61ceb5cf6b8d828ed6db54c925b71bbee4d09b841d4bb0f64dcdcd9d240b83082bb804938681252d82c205164b429d4b7cc40521c2a1c9eb276a4827086157c40dd08c639db597f33df1d69e5990cbf1f0daa82a5abedef55f7d8553f67c6e8c5a24555e176ef3f138ca04a19a4c7db4590582dc6990c19f05b5144c85453f8460bc83ff67eaf1680acf0114d9671864f166d3b5c439aa618409638f886f77ee08119b5f0214d27e7db732bb546ec23bf3cb89d59bd45dbd52bc0d339aba3a38f0d42f6dfc00529ddf5a7876c11a1abf0629dbb98324236013694a91bf301af802b2c31917c3a2caf8e0ca3a33c9d6bd17e426e6ffd47dcb9f1ba2c7e447f08e50df23274fe72317fd37f824f76fb200e67a34e8bb75444dd5d793240fff557be54c992bffb19e0c39dba5b1470c114cee0d9856a170838db012709c926e9d7fbae7536b89d6d6239c8ad703e7435ec3a78a0fca41e9b75f5fe53ed49cc0670391375262a47344164b57d860bca9e476c35796b53c645e567fb2fd4ade582bab275248ba8483cce6035d594a8b3ce12d2ab35583ffc7fdec4a4b23ad4b03f77bbcbcfddc4a9a0a28504f5e1ba3dd8350ebee7fb69b537d8d1d5f9c76fcd9b97499bb88b13ed17196c3a3e62f4ff4471d017c87edb919258bc5d8a682c3abdeb500e8dea1bf57bc50a5a3afbfd880e5514001cfe65b8acdb8384761abb4e434ea4755fe3d55ede3c0fe47b8bf0197a7270464e8ba29ace47286981ba52e456c2016304385ec6e39603713d4fc571182313a552578017fbb8aa66e5b707c998a6f28ce3009764e5fb992c956cad0e48b08a49d4e3a71e3c4f4cdc5c00d2eb058bc7dbc42a3e95484617e1a3c04a7675745812016613fbd0494458e2b4deead739896655b0361c89b6e62cb1257e829076547d97646a2df3e42a35b79391779b4661e37221ba1ca42c5964ea8caa54673a10f82dd0d670173c0c0bda388f3901c0b73785df5c06bdd3a630</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">要密码，快滚.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>飞行棋实现</title>
    <link href="/2022/05/06/CSharp/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/05/06/CSharp/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>飞行棋</p><span id="more"></span><p><strong># 实现结果</strong></p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=553774900&bvid=BV17v4y1K7i2&cid=713732660&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace CSharp基础实践教学&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            #region 1 控制台初始化            int w &#x3D; 50;            int h &#x3D; 30;            ConsoleInit(w, h);            #endregion            #region 2 场景选择相关            &#x2F;&#x2F;申明一个 表示场景标识的 变量             E_SceneType nowSceneType &#x3D; E_SceneType.Begin;            while (true)            &#123;                switch (nowSceneType)                &#123;                    case E_SceneType.Begin:                        &#x2F;&#x2F;开始场景逻辑                        Console.Clear();                        &#x2F;&#x2F;来书写 开始场景相关的逻辑即可                        BeginOrEndScene(w, h, ref nowSceneType);                        break;                    case E_SceneType.Game:                        &#x2F;&#x2F;游戏场景逻辑                        Console.Clear();                        &#x2F;&#x2F;通过函数来处理游戏场景的逻辑内容                        GameScene(w, h, ref nowSceneType);                        break;                    case E_SceneType.End:                        &#x2F;&#x2F;结束场景逻辑                        Console.Clear();                        BeginOrEndScene(w, h, ref nowSceneType);                        break;                    default:                        break;                &#125;            &#125;            #endregion        &#125;        #region 1 控制台初始化        static void ConsoleInit(int w, int h)        &#123;            &#x2F;&#x2F;基础设置            &#x2F;&#x2F;光标的隐藏            Console.CursorVisible &#x3D; false;            &#x2F;&#x2F;舞台的大小            Console.SetWindowSize(w, h);            Console.SetBufferSize(w, h);        &#125;        #endregion        #region 3 开始场景逻辑 + 8 结束场景逻辑        static void BeginOrEndScene(int w, int h, ref E_SceneType nowSceneType)        &#123;            Console.ForegroundColor &#x3D; ConsoleColor.White;            Console.SetCursorPosition(nowSceneType &#x3D;&#x3D; E_SceneType.Begin ? w &#x2F; 2 - 3 : w &#x2F; 2 - 4, 8);            Console.Write(nowSceneType &#x3D;&#x3D; E_SceneType.Begin ? &quot;飞行棋&quot; : &quot;游戏结束&quot;);            &#x2F;&#x2F;当前选项的编号            int nowSelIndex &#x3D; 0;            bool isQuitBegin &#x3D; false;            &#x2F;&#x2F;开始场景逻辑处理循环            while (true)            &#123;                Console.SetCursorPosition(nowSceneType &#x3D;&#x3D; E_SceneType.Begin ? w &#x2F; 2 - 4 : w &#x2F; 2 - 5, 13);                Console.ForegroundColor &#x3D; nowSelIndex &#x3D;&#x3D; 0 ? ConsoleColor.Red : ConsoleColor.White;                Console.Write(nowSceneType &#x3D;&#x3D; E_SceneType.Begin ? &quot;开始游戏&quot; : &quot;回到主菜单&quot;);                Console.SetCursorPosition(w &#x2F; 2 - 4, 15);                Console.ForegroundColor &#x3D; nowSelIndex &#x3D;&#x3D; 1 ? ConsoleColor.Red : ConsoleColor.White;                Console.Write(&quot;退出游戏&quot;);                &#x2F;&#x2F;通过ReadKey可以得到一个输入的枚举类型                switch (Console.ReadKey(true).Key)                &#123;                    case ConsoleKey.W:                        --nowSelIndex;                        if (nowSelIndex &lt; 0)                        &#123;                            nowSelIndex &#x3D; 0;                        &#125;                        break;                    case ConsoleKey.S:                        ++nowSelIndex;                        if (nowSelIndex &gt; 1)                        &#123;                            nowSelIndex &#x3D; 1;                        &#125;                        break;                    case ConsoleKey.J:                        if (nowSelIndex &#x3D;&#x3D; 0)                        &#123;                            &#x2F;&#x2F;进入游戏场景                            &#x2F;&#x2F;1 改变当前场景ID                            nowSceneType &#x3D; nowSceneType &#x3D;&#x3D; E_SceneType.Begin ? E_SceneType.Game : E_SceneType.Begin;                            &#x2F;&#x2F;2 退出当前循环                            isQuitBegin &#x3D; true;                        &#125;                        else                        &#123;                            &#x2F;&#x2F;退出游戏                            Environment.Exit(0);                        &#125;                        break;                &#125;                &#x2F;&#x2F;通过标识决定 是否跳出 开始场景的循环                if (isQuitBegin)                &#123;                    break;                &#125;            &#125;        &#125;        #endregion        #region 游戏场景逻辑        static void GameScene(int w, int h, ref E_SceneType nowSceneType)        &#123;            &#x2F;&#x2F;绘制不变的基本信息            DrawWall(w, h);            &#x2F;&#x2F;绘制地图            &#x2F;&#x2F;初始化一张地图             Map map &#x3D; new Map(14, 3, 80);            map.Draw();            &#x2F;&#x2F;绘制玩家            Player player &#x3D; new Player(0, E_PlayerType.Player);            Player computer &#x3D; new Player(0, E_PlayerType.Computer);            DrawPlayer(player, computer, map);            bool isGameOver &#x3D; false;            &#x2F;&#x2F;游戏场景循环            while (true)            &#123;                &#x2F;&#x2F;之后的游戏逻辑                &#x2F;&#x2F;玩家扔色子逻辑                &#x2F;&#x2F;检测输入                &#x2F;&#x2F;Console.ReadKey(true);                &#x2F;&#x2F;&#x2F;&#x2F;扔色子的逻辑                &#x2F;&#x2F;isGameOver &#x3D; RandomMove(w, h, ref player, ref computer, map);                &#x2F;&#x2F;&#x2F;&#x2F;绘制地图                &#x2F;&#x2F;map.Draw();                &#x2F;&#x2F;&#x2F;&#x2F;绘制玩家                &#x2F;&#x2F;DrawPlayer(player, computer, map);                &#x2F;&#x2F;&#x2F;&#x2F;判断是否要结束游戏                &#x2F;&#x2F;if( isGameOver )                &#x2F;&#x2F;&#123;                &#x2F;&#x2F;    &#x2F;&#x2F;卡住程序 让顽疾按任意键                 &#x2F;&#x2F;    Console.ReadKey(true);                &#x2F;&#x2F;    &#x2F;&#x2F;改变场景ID                &#x2F;&#x2F;    nowSceneType &#x3D; E_SceneType.End;                &#x2F;&#x2F;    &#x2F;&#x2F;直接跳出循环                &#x2F;&#x2F;    break;                &#x2F;&#x2F;&#125;                &#x2F;&#x2F;玩家扔色子                if (PlayerRandoMove(w, h, ref player, ref computer, map, ref nowSceneType))                &#123;                    break;                &#125;                &#x2F;&#x2F;电脑扔色子                if (PlayerRandoMove(w, h, ref computer, ref player, map, ref nowSceneType))                &#123;                    break;                &#125;                &#x2F;&#x2F;电脑扔色子逻辑                &#x2F;&#x2F;检测输入                &#x2F;&#x2F;Console.ReadKey(true);                &#x2F;&#x2F;&#x2F;&#x2F;扔色子的逻辑                &#x2F;&#x2F;isGameOver &#x3D; RandomMove(w, h, ref computer, ref player, map);                &#x2F;&#x2F;&#x2F;&#x2F;绘制地图                &#x2F;&#x2F;map.Draw();                &#x2F;&#x2F;&#x2F;&#x2F;绘制玩家                &#x2F;&#x2F;DrawPlayer(player, computer, map);                &#x2F;&#x2F;&#x2F;&#x2F;判断是否要结束游戏                &#x2F;&#x2F;if (isGameOver)                &#x2F;&#x2F;&#123;                &#x2F;&#x2F;    &#x2F;&#x2F;卡住程序 让顽疾按任意键                 &#x2F;&#x2F;    Console.ReadKey(true);                &#x2F;&#x2F;    &#x2F;&#x2F;改变场景ID                &#x2F;&#x2F;    nowSceneType &#x3D; E_SceneType.End;                &#x2F;&#x2F;    &#x2F;&#x2F;直接跳出循环                &#x2F;&#x2F;    break;                &#x2F;&#x2F;&#125;            &#125;        &#125;        static bool PlayerRandoMove(int w, int h, ref Player p, ref Player otherP, Map map, ref E_SceneType nowSceneType)        &#123;            &#x2F;&#x2F;之后的游戏逻辑            &#x2F;&#x2F;玩家扔色子逻辑            &#x2F;&#x2F;检测输入            Console.ReadKey(true);            &#x2F;&#x2F;扔色子的逻辑            bool isGameOver &#x3D; RandomMove(w, h, ref p, ref otherP, map);            &#x2F;&#x2F;绘制地图            map.Draw();            &#x2F;&#x2F;绘制玩家            DrawPlayer(p, otherP, map);            &#x2F;&#x2F;判断是否要结束游戏            if (isGameOver)            &#123;                &#x2F;&#x2F;卡住程序 让顽疾按任意键                 Console.ReadKey(true);                &#x2F;&#x2F;改变场景ID                nowSceneType &#x3D; E_SceneType.End;                &#x2F;&#x2F;直接跳出循环            &#125;            return isGameOver;        &#125;        #endregion        #region 4 绘制不变内容（红墙 提示等等）        static void DrawWall(int w, int h)        &#123;            Console.ForegroundColor &#x3D; ConsoleColor.Red;            &#x2F;&#x2F;画墙            &#x2F;&#x2F;横着的墙            for (int i &#x3D; 0; i &lt; w; i +&#x3D; 2)            &#123;                &#x2F;&#x2F;最上方的墙                Console.SetCursorPosition(i, 0);                Console.Write(&quot;■&quot;);                &#x2F;&#x2F;最下方的墙                Console.SetCursorPosition(i, h - 1);                Console.Write(&quot;■&quot;);                &#x2F;&#x2F;中间的墙                Console.SetCursorPosition(i, h - 6);                Console.Write(&quot;■&quot;);                Console.SetCursorPosition(i, h - 11);                Console.Write(&quot;■&quot;);            &#125;            &#x2F;&#x2F;竖着的墙            for (int i &#x3D; 0; i &lt; h; i++)            &#123;                &#x2F;&#x2F;最左边                Console.SetCursorPosition(0, i);                Console.Write(&quot;■&quot;);                &#x2F;&#x2F;最右边                Console.SetCursorPosition(w - 2, i);                Console.Write(&quot;■&quot;);            &#125;            &#x2F;&#x2F;文字信息            Console.ForegroundColor &#x3D; ConsoleColor.White;            Console.SetCursorPosition(2, h - 10);            Console.Write(&quot;□:普通格子&quot;);            Console.ForegroundColor &#x3D; ConsoleColor.Blue;            Console.SetCursorPosition(2, h - 9);            Console.Write(&quot;‖:暂停，一回合不懂&quot;);            Console.ForegroundColor &#x3D; ConsoleColor.Red;            Console.SetCursorPosition(26, h - 9);            Console.Write(&quot;●:炸弹，倒退5格&quot;);            Console.ForegroundColor &#x3D; ConsoleColor.Yellow;            Console.SetCursorPosition(2, h - 8);            Console.Write(&quot;¤:时空隧道，随机倒退，暂停，换位置&quot;);            Console.ForegroundColor &#x3D; ConsoleColor.Cyan;            Console.SetCursorPosition(2, h - 7);            Console.Write(&quot;★:玩家&quot;);            Console.ForegroundColor &#x3D; ConsoleColor.Magenta;            Console.SetCursorPosition(12, h - 7);            Console.Write(&quot;▲:电脑&quot;);            Console.ForegroundColor &#x3D; ConsoleColor.DarkGreen;            Console.SetCursorPosition(22, h - 7);            Console.Write(&quot;◎:玩家和电脑重合&quot;);            Console.ForegroundColor &#x3D; ConsoleColor.White;            Console.SetCursorPosition(2, h - 5);            Console.Write(&quot;按任意键开始扔色子&quot;);        &#125;        #endregion        #region 7 绘制玩家        static void DrawPlayer(Player player, Player computer, Map map)        &#123;            &#x2F;&#x2F;重合时            if (player.nowIndex &#x3D;&#x3D; computer.nowIndex)            &#123;                &#x2F;&#x2F;得到重合的位置                Grid grid &#x3D; map.grids[player.nowIndex];                Console.SetCursorPosition(grid.pos.x, grid.pos.y);                Console.ForegroundColor &#x3D; ConsoleColor.DarkGreen;                Console.Write(&quot;◎&quot;);            &#125;            &#x2F;&#x2F;不重合的时候            else            &#123;                player.Draw(map);                computer.Draw(map);            &#125;        &#125;        #endregion        #region 8 扔色子 函数        &#x2F;&#x2F;擦除提示的函数        static void ClearInfo(int h)        &#123;            Console.SetCursorPosition(2, h - 5);            Console.Write(&quot;                                   &quot;);            Console.SetCursorPosition(2, h - 4);            Console.Write(&quot;                                   &quot;);            Console.SetCursorPosition(2, h - 3);            Console.Write(&quot;                                   &quot;);            Console.SetCursorPosition(2, h - 2);            Console.Write(&quot;                                   &quot;);        &#125;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 扔色子函数        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;w&quot;&gt;窗口的宽&lt;&#x2F;param&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;h&quot;&gt;窗口的高&lt;&#x2F;param&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;p&quot;&gt;扔色子的对象&lt;&#x2F;param&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;map&quot;&gt;地图信息&lt;&#x2F;param&gt;        &#x2F;&#x2F;&#x2F; &lt;returns&gt;默认返回false 代表没有结束&lt;&#x2F;returns&gt;        static bool RandomMove(int w, int h, ref Player p, ref Player otherP, Map map)        &#123;            &#x2F;&#x2F;擦除之前显示的提示信息            ClearInfo(h);            &#x2F;&#x2F;根据扔色子的玩家类型 决定信息的颜色            Console.ForegroundColor &#x3D; p.type &#x3D;&#x3D; E_PlayerType.Player ? ConsoleColor.Cyan : ConsoleColor.Magenta;            &#x2F;&#x2F;扔色子之前 判断 玩家是否处于暂停状态            if (p.isPause)            &#123;                Console.SetCursorPosition(2, h - 5);                Console.Write(&quot;处于暂停状态，&#123;0&#125;需要暂停一回合&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;你&quot; : &quot;电脑&quot;);                Console.SetCursorPosition(2, h - 4);                Console.Write(&quot;请按任意键，让&#123;0&#125;开始扔色子&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;电脑&quot; : &quot;你&quot;);                &#x2F;&#x2F;停止暂停                p.isPause &#x3D; false;                return false;            &#125;            &#x2F;&#x2F;扔色子目的 是改变 玩家或者电脑的位置  计算位置的变化            &#x2F;&#x2F;扔色子 随机一个1到6的数 加上去            Random r &#x3D; new Random();            int randomNum &#x3D; r.Next(1, 7);            p.nowIndex +&#x3D; randomNum;            &#x2F;&#x2F;打印扔的点数            Console.SetCursorPosition(2, h - 5);            Console.Write(&quot;&#123;0&#125;扔出的点数为:&#123;1&#125;&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;你&quot; : &quot;电脑&quot;, randomNum);            &#x2F;&#x2F;首先判断是否到终点了            if (p.nowIndex &gt;&#x3D; map.grids.Length - 1)            &#123;                p.nowIndex &#x3D; map.grids.Length - 1;                Console.SetCursorPosition(2, h - 4);                if (p.type &#x3D;&#x3D; E_PlayerType.Player)                &#123;                    Console.Write(&quot;恭喜你，你率先到达了终点&quot;);                &#125;                else                &#123;                    Console.Write(&quot;很遗憾，电脑率到达了终点&quot;);                &#125;                Console.SetCursorPosition(2, h - 3);                Console.Write(&quot;请按任意键结束游戏&quot;);                return true;            &#125;            else            &#123;                &#x2F;&#x2F;没有到终点 就判断 当前对象  到了一个怎么样的格子                Grid grid &#x3D; map.grids[p.nowIndex];                switch (grid.type)                &#123;                    case E_Grid_Type.Normal:                        &#x2F;&#x2F;普通格子不用处理                        Console.SetCursorPosition(2, h - 4);                        Console.Write(&quot;&#123;0&#125;到了一个安全位置&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;你&quot; : &quot;电脑&quot;);                        Console.SetCursorPosition(2, h - 3);                        Console.Write(&quot;请按任意键，让&#123;0&#125;开始扔色子&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;电脑&quot; : &quot;你&quot;);                        break;                    case E_Grid_Type.Boom:                        &#x2F;&#x2F;炸弹退格                        p.nowIndex -&#x3D; 5;                        &#x2F;&#x2F;不能比起点还小                        if (p.nowIndex &lt; 0)                        &#123;                            p.nowIndex &#x3D; 0;                        &#125;                        Console.SetCursorPosition(2, h - 4);                        Console.Write(&quot;&#123;0&#125;踩到了炸弹，退后5格&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;你&quot; : &quot;电脑&quot;);                        Console.SetCursorPosition(2, h - 3);                        Console.Write(&quot;请按任意键，让&#123;0&#125;开始扔色子&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;电脑&quot; : &quot;你&quot;);                        break;                    case E_Grid_Type.Pause:                        &#x2F;&#x2F;暂停一回合                        &#x2F;&#x2F;暂停目前 只有加一个对象的暂停标识  才能知道 下一回合它是不是不能扔色子                        &#x2F;&#x2F;下回合要暂停                        p.isPause &#x3D; true;                        Console.SetCursorPosition(2, h - 4);                        Console.Write(&quot;&#123;0&#125;到达了暂停点，你需要暂停一回合&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;你&quot; : &quot;电脑&quot;);                        Console.SetCursorPosition(2, h - 3);                        Console.Write(&quot;请按任意键，让&#123;0&#125;开始扔色子&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;电脑&quot; : &quot;你&quot;);                        break;                    case E_Grid_Type.Tunnel:                        Console.SetCursorPosition(2, h - 4);                        Console.Write(&quot;&#123;0&#125;踩到了时空隧道&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;你&quot; : &quot;电脑&quot;);                        &#x2F;&#x2F;随机                        randomNum &#x3D; r.Next(1, 91);                        &#x2F;&#x2F;触发 倒退                        if (randomNum &lt;&#x3D; 30)                        &#123;                            p.nowIndex -&#x3D; 5;                            if (p.nowIndex &lt; 0)                            &#123;                                p.nowIndex &#x3D; 0;                            &#125;                            Console.SetCursorPosition(2, h - 3);                            Console.Write(&quot;触发倒退5格&quot;);                        &#125;                        &#x2F;&#x2F;触发 暂停                        else if (randomNum &lt;&#x3D; 60)                        &#123;                            p.isPause &#x3D; true;                            Console.SetCursorPosition(2, h - 3);                            Console.Write(&quot;触发暂停一回合&quot;);                        &#125;                        &#x2F;&#x2F;触发换位置                        else                        &#123;                            int temp &#x3D; p.nowIndex;                            p.nowIndex &#x3D; otherP.nowIndex;                            otherP.nowIndex &#x3D; temp;                            Console.SetCursorPosition(2, h - 3);                            Console.Write(&quot;惊喜，惊喜，双方交换位置&quot;);                        &#125;                        Console.SetCursorPosition(2, h - 2);                        Console.Write(&quot;请按任意键，让&#123;0&#125;开始扔色子&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;电脑&quot; : &quot;你&quot;);                        break;                &#125;            &#125;            &#x2F;&#x2F;默认没有结束            return false;        &#125;        #endregion    &#125;    #region 2 场景选择相关    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 游戏场景枚举类型    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_SceneType    &#123;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 开始场景        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Begin,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 游戏场景        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Game,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 结束场景        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        End,    &#125;    #endregion    #region 5 格子结构体和格子枚举    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 格子类型 枚举    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_Grid_Type    &#123;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 普通格子        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Normal,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 炸弹        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Boom,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 暂停        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Pause,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 时空隧道 随机倒退 暂停 换位置        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Tunnel,    &#125;    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 位置信息结构体 包含xy位置    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    struct Vector2    &#123;        public int x;        public int y;        public Vector2(int x, int y)        &#123;            this.x &#x3D; x;            this.y &#x3D; y;        &#125;    &#125;    struct Grid    &#123;        &#x2F;&#x2F;格子的类型        public E_Grid_Type type;        &#x2F;&#x2F;格子的位置        public Vector2 pos;        &#x2F;&#x2F;初始化构造函数        public Grid(int x, int y, E_Grid_Type type)        &#123;            pos.x &#x3D; x;            pos.y &#x3D; y;            this.type &#x3D; type;        &#125;        public void Draw()        &#123;            &#x2F;&#x2F;提出来的目的 就是少写几行代码 因为他们不管哪种类型 都要设置了位置再画            Console.SetCursorPosition(pos.x, pos.y);            switch (type)            &#123;                &#x2F;&#x2F;普通格子 怎么画                case E_Grid_Type.Normal:                    Console.ForegroundColor &#x3D; ConsoleColor.White;                    Console.Write(&quot;□&quot;);                    break;                &#x2F;&#x2F;炸弹 怎么画                case E_Grid_Type.Boom:                    Console.ForegroundColor &#x3D; ConsoleColor.Red;                    Console.Write(&quot;●&quot;);                    break;                &#x2F;&#x2F;暂停 怎么画                case E_Grid_Type.Pause:                    Console.ForegroundColor &#x3D; ConsoleColor.Blue;                    Console.Write(&quot;‖&quot;);                    break;                &#x2F;&#x2F;时空隧道 怎么画                case E_Grid_Type.Tunnel:                    Console.ForegroundColor &#x3D; ConsoleColor.Yellow;                    Console.Write(&quot;¤&quot;);                    break;            &#125;        &#125;    &#125;    #endregion    #region 6 地图结构体    struct Map    &#123;        public Grid[] grids;        &#x2F;&#x2F;初始化中 初始了 各个格子的类型 和 位置        public Map(int x, int y, int num)        &#123;            grids &#x3D; new Grid[num];            &#x2F;&#x2F;用于位置改变计数的变量            &#x2F;&#x2F;表示X变化的次数            int indexX &#x3D; 0;            &#x2F;&#x2F;表示Y变化的次数            int indexY &#x3D; 0;            &#x2F;&#x2F;x的步长            int stepNum &#x3D; 2;            Random r &#x3D; new Random();            int randomNum;            for (int i &#x3D; 0; i &lt; num; i++)            &#123;                &#x2F;&#x2F;应该初始化 格子类型                randomNum &#x3D; r.Next(0, 101);                &#x2F;&#x2F;设置类型 普通格子                &#x2F;&#x2F;有85%几率 是普通自（首尾两个格子 必为普通格子）                if (randomNum &lt; 85 || i &#x3D;&#x3D; 0 || i &#x3D;&#x3D; num - 1)                &#123;                    grids[i].type &#x3D; E_Grid_Type.Normal;                &#125;                &#x2F;&#x2F;有5%的几率 是炸弹                else if (randomNum &gt;&#x3D; 85 &amp;&amp; randomNum &lt; 90)                &#123;                    grids[i].type &#x3D; E_Grid_Type.Boom;                &#125;                &#x2F;&#x2F;有5%的几率 是暂停                else if (randomNum &gt;&#x3D; 90 &amp;&amp; randomNum &lt; 95)                &#123;                    grids[i].type &#x3D; E_Grid_Type.Pause;                &#125;                &#x2F;&#x2F;有5%的几率 是时空隧道                else                &#123;                    grids[i].type &#x3D; E_Grid_Type.Tunnel;                &#125;                &#x2F;&#x2F;位置应该如何设置                grids[i].pos &#x3D; new Vector2(x, y);                &#x2F;&#x2F;每次循环都应该按一定规则去变化位置吧                &#x2F;&#x2F;加十次                if (indexX &#x3D;&#x3D; 10)                &#123;                    y +&#x3D; 1;                    &#x2F;&#x2F;加一次Y记一次数                    ++indexY;                    if (indexY &#x3D;&#x3D; 2)                    &#123;                        &#x2F;&#x2F;y加了2次过后 把x加的次数记0                        indexX &#x3D; 0;                        indexY &#x3D; 0;                        &#x2F;&#x2F;反向步长                        stepNum &#x3D; -stepNum;                    &#125;                &#125;                else                &#123;                    x +&#x3D; stepNum;                    &#x2F;&#x2F;加一次X记一次数                    ++indexX;                &#125;            &#125;        &#125;        public void Draw()        &#123;            for (int i &#x3D; 0; i &lt; grids.Length; i++)            &#123;                grids[i].Draw();            &#125;        &#125;    &#125;    #endregion    #region 7 玩家枚举和玩家结构体    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 玩家类型枚举    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_PlayerType    &#123;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 玩家        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Player,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 电脑        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Computer,    &#125;    struct Player    &#123;        &#x2F;&#x2F;玩家类型        public E_PlayerType type;        &#x2F;&#x2F;当前所在地图哪一个索引的格子        public int nowIndex;        &#x2F;&#x2F;是否暂停的标识        public bool isPause;        public Player(int index, E_PlayerType type)        &#123;            nowIndex &#x3D; index;            this.type &#x3D; type;            isPause &#x3D; false;        &#125;        public void Draw(Map mapInfo)        &#123;            &#x2F;&#x2F;必须要先得到地图 才能够 得到我在地图上的哪一个格子            &#x2F;&#x2F;从传入的地图中 得到 格子信息            Grid grid &#x3D; mapInfo.grids[nowIndex];            &#x2F;&#x2F;设置位置            Console.SetCursorPosition(grid.pos.x, grid.pos.y);            &#x2F;&#x2F;画 设置颜色 设置图标            switch (type)            &#123;                case E_PlayerType.Player:                    Console.ForegroundColor &#x3D; ConsoleColor.Cyan;                    Console.Write(&quot;★&quot;);                    break;                case E_PlayerType.Computer:                    Console.ForegroundColor &#x3D; ConsoleColor.Magenta;                    Console.Write(&quot;▲&quot;);                    break;            &#125;        &#125;    &#125;    #endregion&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月6日</title>
    <link href="/2022/05/06/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%886%E6%97%A5/"/>
    <url>/2022/05/06/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%886%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="66e42836cfa71681c04573568ab08bc0d5f74b441addf158500edc865fa3a5b6">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe509e5becb1c52418d004df21efc8656ad3164443d15e3426aec259f6651c69cb77793aad835379c9a1816cf1931da50b5899e97c2830c05d575a4743b34a35ff32f5a4fa29c0526e8fc982443375e9f8fd6cf277a101133b1272d3407d8f2a19168677137fd3b36ecb1f84c706fbed376ed6d5de7cdb5d9d656bb6126e326b737fa68e7c0373437510d1f392fed4168dc07d44dd069b31dc0c49f82d59730d8c02be06da9af3c2b3658b6e4bd123c1096bf72d2baee1bafdc331802a4cdde10c99339aa83cee8465cdb4214c73d0592d99c3572a9a58df9e20255525c044ef489eb748c5ab5c10e96e542aff20f36d562d56baa07a626b08bc94621d58c633558e65fabc41c2865abbd20076f1e9e2b7cfdb0f3cbabbfafe0f15a857cfe469025fd48e42886964ad80d51c8ee70fdfa8d1153535ed335a7ccd7aea7ca601bf16182c7e336042c92c7e43c7a64d491462e1b3182db1d033cf267647d687a6813e2f72540eaaccd76675fc21dbc5f2674702b1226313c83993f2a5ead960df1de82247f06e378f31be68a95a48b5504a6f783db90fa9f39c1b5fea7f3fc11be210edfcb3f58faccc325cd8a411d229dfc3cea4584c5f9f7637fc5d2c9e0aa59dac55966df62dbcb57c5a41a75f85d202bf4b0de68bf91bba94a41d986725ed6342d8dbacdf19274fa1e839e276af4191113d5033a2b7fbb07e99188b0289c9fc5619e46bb0bd84ad7095f7a431de37c130261578650cce1c5d29f5d6431d88acf65c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">要密码，快滚.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月5日</title>
    <link href="/2022/05/05/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%885%E6%97%A5/"/>
    <url>/2022/05/05/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%885%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="e511f33453d7f039779defafc86db8f6daff2f33133f2aff607c515a0d328970">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50a54d91deb0dd23a86bb3652d32d2d8603260b625ed51d891af3154cdc9e82226531c388ce184435c513a6bdf27303d625affca6eb12412c28000179a1585754fa6ec21d8e8f513522e8041ae60d72b5e464eb336c6cb9fc6271e69b627a3104a757008b0881f597a83821625f0409e9a3ccb67dbff38f2d551d650992fdeb62a40d368772d7320a2fb9bfa83e11bc8e179140c645e130803a6a971388b8d697e657b23739f21b5b3b1179d17b0d04480d65d24f6053a148f3167ea9698cd3b5811ee6e389ba9bf285337c5c643d9ce7f250862304135afb5cc37ee9fa66a39be4ca1c859708e8dc1beb13d004de352b37b1b0e40f61c18bf700a40fa2336fba7516c41ab191c27e86c22676bda861d0e296d91ee18e8c02c1e2417b66392be6c535f732e821a4436c374c5d8db6a170333841f4a9700469aedb6bce63d0f0553e01a782a004bd1157ccf8b033a090473ad734b4dd40916eabf04fe7f7bcaa98d2a7878bd3490632e4f7b9d33106db0db446c72822e848b1e2bf6e370b586743288fd41a4db74420f36101ca7157d1bd72a619372db36cf0d87d775f8a0a3cc7a41e139059cb35c0574c6f4a06fd8cc86830d23a785ecfa36ab81066b288f0efe4b425916390accf22d275216c40a4645e6a58f0790f36cd7a9bac537da2c79eddb817d221a971c55a089d4b3bb08427c298af5a6fa5501daf6eb83463199106dfe1efe1b3215cc3704fef4b1852c65775fb62f05c9be821f1d4e6a8b75123b1e26332e0de47278c5a94a1c3aadcfa12e37fd520d4e85d2125d93b261fde0aa86ca6a51331d9d3f0044b300393bacba389840f4352cdc91df6fffedf7399741c087b18fcb3c475849778d2c49e45a72a477f5a72949c95b155fc6de87de8b13a6b3d6adc150f0757026eb91717a6b800384eb7a1acfe45141cf0c9412ea129963a1e75022cb8f72317ea5185592198377a58464178e933ce316fa183200a7d89c12e1f5551774ca08bf667026c06c6f0e5d2104ddfad6fd51b9cea3c5d9a67e0a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">要密码，快滚.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSharp入门实践——简易飞行棋</title>
    <link href="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%A3%8B/"/>
    <url>/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%A3%8B/</url>
    
    <content type="html"><![CDATA[<p>控制台实现简易飞行棋</p><span id="more"></span><p><strong># 游戏逻辑流程图</strong><br>游戏逻辑题直接引用唐老狮课程里的流程图</p><p><strong>## 整体逻辑流程图</strong></p><img src="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%A3%8B/%E6%95%B4%E4%BD%93%E9%80%BB%E8%BE%91%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class=""><p><strong>## 开始场景流程图</strong></p><img src="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%A3%8B/%E5%BC%80%E5%A7%8B%E5%9C%BA%E6%99%AF%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class=""><p><strong>## 游戏场景流程图</strong></p><img src="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%A3%8B/%E5%BC%80%E5%A7%8B%E5%9C%BA%E6%99%AF%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class=""><p><strong>## 结束场景流程图</strong></p><img src="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%A3%8B/%E7%BB%93%E6%9D%9F%E5%9C%BA%E6%99%AF%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class=""><p><strong># 代码实现</strong></p><p>寄 不能实现前一个位置消失 结构体还没搞明白</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace CSharp基础实践教学&#123;    #region 格子结构体（写不来，看答案了）    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 格子类型枚举    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_GridType    &#123;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 普通格子        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Normal,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 炸弹        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Bomb,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 暂停        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Pause,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 时空隧道        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Tunnel,    &#125;    &#x2F;&#x2F;看答案的 可记住    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 位置信息结构体 包含x y位置    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    struct Vector2    &#123;        public int x;        public int y;        public Vector2(int x, int y)        &#123;            this.x &#x3D; x; this.y &#x3D; y;        &#125;    &#125;    &#x2F;&#x2F;格子结构体    struct Grid    &#123;        public E_GridType gridType; &#x2F;&#x2F;格子类型        public Vector2 position; &#x2F;&#x2F;格子位置        &#x2F;&#x2F;构造函数  输入格子位置  格子初始化        public Grid(E_GridType gridType, int x, int y)        &#123;            this.gridType &#x3D; gridType;            position.x &#x3D; x;             position.y &#x3D; y;        &#125;        &#x2F;&#x2F;画格子        public void Draw()        &#123;            &#x2F;&#x2F;控制光标位置  打印选项            Console.SetCursorPosition(position.x, position.y);            switch (gridType)            &#123;                &#x2F;&#x2F;普通格子                case E_GridType.Normal:                    Console.ForegroundColor &#x3D; ConsoleColor.White;                    Console.Write(&#39;□&#39;);                    break;                &#x2F;&#x2F;炸弹                case E_GridType.Bomb:                    Console.ForegroundColor &#x3D; ConsoleColor.Blue;                    Console.Write(&quot;‖&quot;);                    break;                &#x2F;&#x2F;暂停                case E_GridType.Pause:                    Console.ForegroundColor &#x3D; ConsoleColor.Red;                    Console.Write(&quot;●&quot;);                    break;                &#x2F;&#x2F;时空隧道                case E_GridType.Tunnel:                    Console.ForegroundColor &#x3D; ConsoleColor.White;                    Console.Write(&quot;¤&quot;);                    break;            &#125;        &#125;    &#125;    #endregion    #region 地图结构体（写不来，看答案了）    struct Map    &#123;        &#x2F;&#x2F;用一个格子结构体数组 表示地图里的所有格子        public Grid[] grids;        &#x2F;&#x2F;地图初始化构造函数        &#x2F;&#x2F;x, y为棋盘起始点        public Map(int x, int y)        &#123;            grids &#x3D; new Grid[84];            Random r &#x3D; new Random();            int randomNum;            for (int i &#x3D; 0; i &lt; 84; i++)            &#123;                &#x2F;&#x2F;应该初始化 格子类型                randomNum &#x3D; r.Next(0, 100);                &#x2F;&#x2F;设置类型 普通格子                &#x2F;&#x2F;有85%几率 是普通格子 (首尾两个格子 必为普通格子)                if(randomNum &lt; 85 || i &#x3D;&#x3D; 0 || i &#x3D;&#x3D; 95)                &#123;                    grids[i].gridType &#x3D; E_GridType.Normal;                &#125;                &#x2F;&#x2F;有5%几率 是炸弹                if (randomNum &gt;&#x3D; 85 &amp;&amp; randomNum &lt; 90)                &#123;                    grids[i].gridType &#x3D; E_GridType.Bomb;                &#125;                &#x2F;&#x2F;有5%几率 是暂停                if (randomNum &gt;&#x3D; 90 &amp;&amp; randomNum &lt; 95)                &#123;                    grids[i].gridType &#x3D; E_GridType.Pause;                &#125;                &#x2F;&#x2F;有5%几率 是时空隧道                if (randomNum &gt;&#x3D; 95 &amp;&amp; randomNum &lt; 100)                &#123;                    grids[i].gridType &#x3D; E_GridType.Tunnel;                &#125;                &#x2F;&#x2F;设置位置                grids[i].position &#x3D; new Vector2(x, y);                &#x2F;&#x2F;每次循环都应该一定规则去变化位置(每次少4个步长)                if( i &lt;&#x3D; 12 || (i &gt; 56 &amp;&amp; i &lt;&#x3D; 64)  )                &#123;                    y++;                &#125;                else if( (i &gt; 12 &amp;&amp; i &lt;&#x3D; 30) || (i &gt; 64 &amp;&amp; i &lt;&#x3D; 74) )                &#123;                    x +&#x3D; 2;                &#125;                else if( (i &gt; 30 &amp;&amp; i &lt;&#x3D; 42) || (i &gt; 74 &amp;&amp; i &lt;&#x3D; 78) )                &#123;                    y--;                &#125;                else if(( i &gt; 42 &amp;&amp; i &lt;&#x3D; 56) || (i &gt; 78 &amp;&amp; i &lt;&#x3D; 84) )                &#123;                    x -&#x3D; 2;                &#125;            &#125;        &#125;        public void Draw()        &#123;            for (int i &#x3D; 0; i &lt; grids.Length; i++)            &#123;                grids[i].Draw();            &#125;        &#125;    &#125;    #endregion    #region 玩家结构体    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 玩家类型    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_PlayerType    &#123;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 玩家        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        You,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 电脑        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        PC,    &#125;    struct Player    &#123;        public E_PlayerType playerType;        &#x2F;&#x2F;当前位置索引        public int nowIndex;        &#x2F;&#x2F;玩家初始化构造函数        public Player(E_PlayerType playerType, ref int nowIndex)        &#123;            this.playerType &#x3D; playerType;            this.nowIndex &#x3D; nowIndex;        &#125;        &#x2F;&#x2F;画玩家和电脑格子的逻辑 用索引得到所在地图上格子        public void DrawMove( Map mapinfo )        &#123;            &#x2F;&#x2F;从传入的地图得到格子信息            Grid grid &#x3D; mapinfo.grids[nowIndex];            &#x2F;&#x2F;先控制光标位置            Console.SetCursorPosition(grid.position.x, grid.position.y);            &#x2F;&#x2F;判断是画玩家还是电脑            switch(playerType)            &#123;                &#x2F;&#x2F;画玩家                case E_PlayerType.You:                    Console.ForegroundColor &#x3D; ConsoleColor.Cyan;                    Console.WriteLine(&quot;★&quot;);                    break;                case E_PlayerType.PC:                    Console.ForegroundColor &#x3D; ConsoleColor.Magenta;                    Console.WriteLine(&quot;▲&quot;);                    break;            &#125;        &#125;    &#125;    #endregion    internal class Program    &#123;        &#x2F;&#x2F;判断玩家和电脑是否重叠        static void DrawPlayer(Player you, Player PC, Map map)        &#123;            &#x2F;&#x2F;重合的话 Player结构体外部处理            if(you.nowIndex &#x3D;&#x3D; PC.nowIndex)            &#123;                &#x2F;&#x2F;得到重合的位置                Grid grid &#x3D; map.grids[you.nowIndex];                Console.SetCursorPosition(grid.position.x, grid.position.y);                Console.ForegroundColor &#x3D; ConsoleColor.Green;                Console.WriteLine(&quot;◎&quot;);            &#125;            &#x2F;&#x2F;不重合的话 Player结构体内部处理             else            &#123;                you.DrawMove(map);                PC.DrawMove(map);            &#125;        &#125;         static void Main(string[] args)        &#123;            #region 控制台基础设置            &#x2F;&#x2F;控制台大小设置  w表示宽  h表示高            int w &#x3D; 50;            int h &#x3D; 30;            ConsoleInit(w, h);            #endregion            #region 实现多个场景的转换            &#x2F;&#x2F;定义场景ID  初始从开始场景开始            &#x2F;&#x2F;开始场景为0  游戏场景为1  结束场景为2            int nowScene &#x3D; 0; ;            &#x2F;&#x2F;玩家获胜或者电脑获胜的信息            string gameOverInfo;            &#x2F;&#x2F;整体游戏逻辑死循环            while (true)            &#123;                &#x2F;&#x2F;用不同场景ID  进行不同的场景逻辑                &#x2F;&#x2F;用switch实现场景的转换                switch (nowScene)                &#123;                    &#x2F;&#x2F;开始场景                    case 0:                        &#x2F;&#x2F;实现开始场景逻辑                        #region 开始场景逻辑                        &#x2F;&#x2F;清空控制台  以后续添加文字与游戏                        Console.Clear();                        &#x2F;&#x2F;控制光标位置  打印标题                        Console.SetCursorPosition(w &#x2F; 2 - 5, 8);                        Console.Write(&quot;飞行棋小游戏&quot;);                        &#x2F;&#x2F;事先定义想要选择的选项ID 默认初始选择第一个选项(开始游戏)                        &#x2F;&#x2F;开始游戏为0  退出游戏为1                        int nowSelIndex &#x3D; 0;                        &#x2F;&#x2F;开始场景逻辑死循环                        while(true)                        &#123;                            #region 开始场景生成逻辑                                                        &#x2F;&#x2F;控制光标位置  打印选项                            Console.SetCursorPosition(w &#x2F; 2 - 3, 13);                            &#x2F;&#x2F;根据现在选中的选项改变选项的颜色(改变光标前景色)                            &#x2F;&#x2F;选中为红色 未选中为白色                            Console.ForegroundColor &#x3D; nowSelIndex &#x3D;&#x3D; 0 ? ConsoleColor.Red : ConsoleColor.White;                            Console.Write(&quot;开始游戏&quot;);                            &#x2F;&#x2F;逻辑同上                            Console.SetCursorPosition(w &#x2F; 2 - 3, 15);                            Console.ForegroundColor &#x3D; nowSelIndex &#x3D;&#x3D; 1 ? ConsoleColor.Red : ConsoleColor.White;                            Console.Write(&quot;退出游戏&quot;);                            &#x2F;&#x2F;定义玩家输入w为向上选择  输入s为向下选择  输入j为确定选择                            Console.SetCursorPosition(w &#x2F; 2 - 5, 20);                            Console.ForegroundColor &#x3D; ConsoleColor.Yellow;                            Console.Write(&quot;按w向上选择&quot;);                            Console.SetCursorPosition(w &#x2F; 2 - 5, 22);                            Console.ForegroundColor &#x3D; ConsoleColor.Yellow;                            Console.Write(&quot;按s向下选择&quot;);                            Console.SetCursorPosition(w &#x2F; 2 - 3, 24);                            Console.ForegroundColor &#x3D; ConsoleColor.Yellow;                            Console.Write(&quot;按j确定&quot;);                            #endregion                            #region 开始场景跳转逻辑                            &#x2F;&#x2F;因为break只能跳出最近的switch(即下文跳转场景的)  而为结束开始场景逻辑                              &#x2F;&#x2F;需要定义一个标识判断是否跳出开始场景逻辑死循环                            bool isQuitWhile &#x3D; false;                            &#x2F;&#x2F;获取玩家输入  且不显示玩家的输入                            char input &#x3D; Console.ReadKey(true).KeyChar;                            &#x2F;&#x2F;根据玩家输入  转换选中选项  与  确定选择                            switch(input)                            &#123;                                &#x2F;&#x2F;按w的逻辑  大小写Ww均可                                case &#39;W&#39;:                                case &#39;w&#39;:                                    &#x2F;&#x2F;实际上就是让选项ID变为0                                    --nowSelIndex;                                    &#x2F;&#x2F;且若已经是0 不能再减                                    if(nowSelIndex &lt; 0)                                    &#123;                                        nowSelIndex &#x3D; 0;                                    &#125;                                    break;                                &#x2F;&#x2F;按s的逻辑  大小写Ss均可                                case &#39;S&#39;:                                case &#39;s&#39;:                                    &#x2F;&#x2F;实际上就是让选项ID变为0                                    ++nowSelIndex;                                    &#x2F;&#x2F;且若已经是1 不能再加                                    if (nowSelIndex &gt; 1)                                    &#123;                                        nowSelIndex &#x3D; 1;                                    &#125;                                    break;                                &#x2F;&#x2F;按j的逻辑  大小写Jj均可                                case &#39;J&#39;:                                case &#39;j&#39;:                                                                       &#x2F;&#x2F;判断是进入哪个场景                                    &#x2F;&#x2F;进入游戏场景                                    if( nowSelIndex &#x3D;&#x3D; 0)                                    &#123;                                        &#x2F;&#x2F;将场景ID变为1                                        nowScene &#x3D; 1;                                        &#x2F;&#x2F;确定选择后就要进入其他场景  故必须跳出开始场景的死循环                                        &#x2F;&#x2F;即要使判断跳出标识置为true                                        isQuitWhile &#x3D; true;                                    &#125;                                    &#x2F;&#x2F;退出游戏                                    else if(nowSelIndex &#x3D;&#x3D; 1)                                    &#123;                                        &#x2F;&#x2F;关闭控制台(也不需要跳出循环了)                                        Environment.Exit(0);                                    &#125;                                    break;                            &#125;                            &#x2F;&#x2F;若isQuitWhile为true  则跳出开始场景循环                            if (isQuitWhile)                            &#123;                                break;                            &#125;                                #endregion                        &#125;                        #endregion                        break;                    &#x2F;&#x2F;游戏场景                    case 1:                        &#x2F;&#x2F;实现游戏场景逻辑                        #region 游戏场景逻辑                        #region 参数设置                        Console.Clear();                        &#x2F;&#x2F;退出while的标识                        bool isQuitGameWhile &#x3D; false;                        &#x2F;&#x2F;定义骰子的随机数                        Random d &#x3D; new Random();                        int dice;                        &#x2F;&#x2F;设置一个计数位选择是玩家动还是电脑动                        int count &#x3D; 0;                        &#x2F;&#x2F;设置玩家和电脑所在的格数 初始化为0                        int numYou &#x3D; 0;                        int numPC &#x3D; 0;                        &#x2F;&#x2F;设置玩家变量 电脑变量                        Player you &#x3D; new Player(E_PlayerType.You, ref numYou);                        Player PC &#x3D; new Player(E_PlayerType.PC, ref numPC);                        #endregion                        #region 红色墙壁                        DrawWall(w, h);                        #endregion                        #region 绘制棋盘                        Map map &#x3D; new Map(6, 3);                        map.Draw();                        #endregion                        #region 静态信息栏(每种格子类型的含义)                        Console.SetCursorPosition(2, h - 10);                        Console.ForegroundColor &#x3D; ConsoleColor.White;                        Console.WriteLine(&quot;□:普通格子&quot;);                        Console.SetCursorPosition(2, h - 9);                        Console.ForegroundColor &#x3D; ConsoleColor.Blue;                        Console.WriteLine(&quot;‖:暂停,一回合不动&quot;);                        Console.SetCursorPosition(26, h - 9);                        Console.ForegroundColor &#x3D; ConsoleColor.Red;                        Console.WriteLine(&quot;●:炸弹,倒退5格&quot;);                        Console.SetCursorPosition(2, h - 8);                        Console.ForegroundColor &#x3D; ConsoleColor.White;                        Console.WriteLine(&quot;¤:时空隧道,随机倒退,暂停,换位置&quot;);                        Console.SetCursorPosition(2, h - 7);                        Console.ForegroundColor &#x3D; ConsoleColor.Cyan;                        Console.WriteLine(&quot;★:玩家&quot;);                        Console.SetCursorPosition(12, h - 7);                        Console.ForegroundColor &#x3D; ConsoleColor.Magenta;                        Console.WriteLine(&quot;▲:电脑&quot;);                        Console.SetCursorPosition(22, h - 7);                        Console.ForegroundColor &#x3D; ConsoleColor.Green;                        Console.WriteLine(&quot;◎:玩家与电脑重合&quot;);                        #endregion                        #region 动态信息栏(你走几步 电脑走几步)                        Console.SetCursorPosition(2, h - 5);                        Console.ForegroundColor &#x3D; ConsoleColor.White;                        Console.WriteLine(&quot;按任意键开始扔骰子&quot;);                        #endregion                        &#x2F;&#x2F;先打印起始位置                        DrawPlayer(you, PC, map);                        &#x2F;&#x2F;玩家 电脑 是否暂停                        bool youPause &#x3D; false;                        bool PCPause &#x3D; false;                        &#x2F;&#x2F;游戏场景死循环 专门用来检测 玩家输入相关循环                        while (true)                        &#123;                                                            &#x2F;&#x2F;每次输入                            Console.ReadKey(true);                            dice &#x3D; d.Next(1, 7);                            if(youPause)                            &#123;                                &#x2F;&#x2F;玩家暂停一回合 让电脑走                                youPause &#x3D; false;                                count &#x3D; 1;                            &#125;                            if (PCPause)                            &#123;                                &#x2F;&#x2F;电脑暂停一回合 让玩家走                                PCPause &#x3D; false;                                count &#x3D; 0;                            &#125;                            switch (count)                            &#123;                                &#x2F;&#x2F;玩家移动                                case 0:                                    you.nowIndex +&#x3D; dice;                                    &#x2F;&#x2F;玩家的格子先超出地图数                                     if(you.nowIndex &gt; 83)                                    &#123;                                        gameOverInfo &#x3D; &quot;玩家获胜&quot;;                                        isQuitGameWhile &#x3D; true;                                        nowScene &#x3D; 2;                                        break;                                    &#125;                                    Grid grid1 &#x3D; map.grids[you.nowIndex];                                    switch (grid1.gridType)                                    &#123;                                        case E_GridType.Normal:                                            &#x2F;&#x2F;普通格子  切换到电脑移动                                            count++;                                            break;                                        case E_GridType.Bomb:                                            &#x2F;&#x2F;炸弹倒退5格                                            you.nowIndex -&#x3D; 5;                                            &#x2F;&#x2F;不能退出起点                                            if(you.nowIndex &lt; 0)                                            &#123;                                                you.nowIndex &#x3D; 0;                                            &#125;                                            break;                                        case E_GridType.Pause:                                            &#x2F;&#x2F;暂停一回合                                            youPause &#x3D; true;                                            break;                                        case E_GridType.Tunnel:                                            &#x2F;&#x2F;随机 倒退 暂停 和电脑交换位置                                            dice &#x3D; d.Next(1, 91);                                            if(dice &lt; 30) &#x2F;&#x2F;倒退                                            &#123;                                                you.nowIndex -&#x3D; 5;                                            &#125;                                            else if(dice &gt;&#x3D; 30 &amp;&amp; dice &lt;60) &#x2F;&#x2F;暂停                                            &#123;                                                youPause &#x3D; true;                                            &#125;                                            else &#x2F;&#x2F;和电脑交换位置                                            &#123;                                                int t &#x3D; you.nowIndex;                                                you.nowIndex &#x3D; PC.nowIndex;                                                PC.nowIndex &#x3D; t;                                            &#125;                                            break;                                    &#125;                                    DrawPlayer(you, PC, map);                                    &#x2F;&#x2F;切换到电脑移动                                                                    break;                                &#x2F;&#x2F;电脑移动                                case 1:                                    PC.nowIndex +&#x3D; dice;                                    if (PC.nowIndex &gt; 83)                                    &#123;                                        gameOverInfo &#x3D; &quot;电脑获胜&quot;;                                        isQuitGameWhile &#x3D; true;                                        nowScene &#x3D; 2;                                        break;                                    &#125;                                    DrawPlayer(you, PC, map);                                    Grid grid2 &#x3D; map.grids[PC.nowIndex];                                    switch (grid2.gridType)                                    &#123;                                        case E_GridType.Normal:                                            &#x2F;&#x2F;普通格子  切换到玩家移动                                            count--;                                            break;                                        case E_GridType.Bomb:                                            &#x2F;&#x2F;炸弹倒退5格                                            PC.nowIndex -&#x3D; 5;                                            &#x2F;&#x2F;不能退出起点                                            if (PC.nowIndex &lt; 0)                                            &#123;                                                PC.nowIndex &#x3D; 0;                                            &#125;                                            break;                                        case E_GridType.Pause:                                            &#x2F;&#x2F;暂停一回合                                            PCPause &#x3D; true;                                            break;                                        case E_GridType.Tunnel:                                            &#x2F;&#x2F;随机 倒退 暂停 和电脑交换位置                                            dice &#x3D; d.Next(1, 91);                                            if (dice &lt; 30) &#x2F;&#x2F;倒退                                            &#123;                                                PC.nowIndex -&#x3D; 5;                                            &#125;                                            else if (dice &gt;&#x3D; 30 &amp;&amp; dice &lt; 60) &#x2F;&#x2F;暂停                                            &#123;                                                PCPause &#x3D; true;                                            &#125;                                            else &#x2F;&#x2F;和电脑交换位置                                            &#123;                                                int t &#x3D; you.nowIndex;                                                you.nowIndex &#x3D; PC.nowIndex;                                                PC.nowIndex &#x3D; t;                                            &#125;                                            break;                                    &#125;                                    break;                            &#125;                                                        if (isQuitGameWhile)                            &#123;                                break;                            &#125;                        &#125;                        #endregion                            break;                    &#x2F;&#x2F;结束场景                    case 2:                        &#x2F;&#x2F;实现结束场景逻辑                        #region 结束场景逻辑                        &#x2F;&#x2F;清空控制台  以后续添加文字与游戏                        Console.Clear();                        &#x2F;&#x2F;控制光标位置  打印标题                        Console.SetCursorPosition(w &#x2F; 2 - 3, 8);                        Console.Write(&quot;Gameover&quot;);                        &#x2F;&#x2F;可变内容的显示 根据失败或成功 显示内容不同                        Console.ForegroundColor &#x3D; ConsoleColor.Green;                        Console.SetCursorPosition(w &#x2F; 2 - 4, 6);                                                &#x2F;&#x2F;事先定义想要选择的选项ID  默认初始选择第一个选项(重新开始)                        &#x2F;&#x2F;(重新开始为0  退出游戏为1)                        int nowSelEndIndex &#x3D; 0;                        &#x2F;&#x2F;开始场景逻辑死循环                        while (true)                        &#123;                            #region 结束场景生成逻辑                            &#x2F;&#x2F;控制光标位置  打印选项                            Console.SetCursorPosition(w &#x2F; 2 - 3, 13);                            &#x2F;&#x2F;根据现在选中的选项改变选项的颜色(改变光标前景色)                            &#x2F;&#x2F;选中为红色 未选中为白色                            Console.ForegroundColor &#x3D; nowSelEndIndex &#x3D;&#x3D; 0 ? ConsoleColor.Red : ConsoleColor.White;                            Console.Write(&quot;重新开始&quot;);                            &#x2F;&#x2F;逻辑同上                            Console.SetCursorPosition(w &#x2F; 2 - 3, 15);                            Console.ForegroundColor &#x3D; nowSelEndIndex &#x3D;&#x3D; 1 ? ConsoleColor.Red : ConsoleColor.White;                            Console.Write(&quot;退出游戏&quot;);                            &#x2F;&#x2F;定义玩家输入w为向上选择  输入s为向下选择  输入j为确定选择                            Console.SetCursorPosition(w &#x2F; 2 - 5, 20);                            Console.ForegroundColor &#x3D; ConsoleColor.Yellow;                            Console.Write(&quot;按w向上选择&quot;);                            Console.SetCursorPosition(w &#x2F; 2 - 5, 22);                            Console.ForegroundColor &#x3D; ConsoleColor.Yellow;                            Console.Write(&quot;按s向下选择&quot;);                            Console.SetCursorPosition(w &#x2F; 2 - 3, 24);                            Console.ForegroundColor &#x3D; ConsoleColor.Yellow;                            Console.Write(&quot;按j确定&quot;);                            #endregion                            #region 结束场景跳转逻辑                            &#x2F;&#x2F;因为break只能跳出最近的switch(即下文跳转场景的)  而为结束开始场景逻辑                              &#x2F;&#x2F;需要定义一个标识判断是否跳出开始场景逻辑死循环                            bool isQuitEndWhile &#x3D; false;                            &#x2F;&#x2F;获取玩家输入  且不显示玩家的输入                            char input &#x3D; Console.ReadKey(true).KeyChar;                            &#x2F;&#x2F;根据玩家输入  转换选中选项  与  确定选择                            switch (input)                            &#123;                                &#x2F;&#x2F;按w的逻辑  大小写Ww均可                                case &#39;W&#39;:                                case &#39;w&#39;:                                    &#x2F;&#x2F;实际上就是让选项ID变为0                                    --nowSelEndIndex;                                    &#x2F;&#x2F;且若已经是0 不能再减                                    if (nowSelEndIndex &lt; 0)                                    &#123;                                        nowSelEndIndex &#x3D; 0;                                    &#125;                                    break;                                &#x2F;&#x2F;按s的逻辑  大小写Ss均可                                case &#39;S&#39;:                                case &#39;s&#39;:                                    &#x2F;&#x2F;实际上就是让选项ID变为0                                    ++nowSelEndIndex;                                    &#x2F;&#x2F;且若已经是1 不能再加                                    if (nowSelEndIndex &gt; 1)                                    &#123;                                        nowSelEndIndex &#x3D; 1;                                    &#125;                                    break;                                &#x2F;&#x2F;按j的逻辑  大小写Jj均可                                case &#39;J&#39;:                                case &#39;j&#39;:                                    &#x2F;&#x2F;判断是进入哪个场景                                    &#x2F;&#x2F;进入游戏场景                                    if (nowSelEndIndex &#x3D;&#x3D; 0)                                    &#123;                                        &#x2F;&#x2F;将场景ID变为1                                        nowScene &#x3D; 1;                                        &#x2F;&#x2F;确定选择后就要进入其他场景  故必须跳出开始场景的死循环                                        &#x2F;&#x2F;即要使判断跳出标识置为true                                        isQuitEndWhile &#x3D; true;                                    &#125;                                    &#x2F;&#x2F;退出游戏                                    else if (nowSelEndIndex &#x3D;&#x3D; 1)                                    &#123;                                        &#x2F;&#x2F;关闭控制台(也不需要跳出循环了)                                        Environment.Exit(0);                                    &#125;                                    break;                            &#125;                            &#x2F;&#x2F;若isQuitEndWhile为true  则跳出结束场景循环                            if (isQuitEndWhile)                            &#123;                                break;                            &#125;                            #endregion                        &#125;                        #endregion                        break;                &#125;            &#125;            #endregion        &#125;        #region 控制台基础设置        static void ConsoleInit(int w, int h)        &#123;            &#x2F;&#x2F;隐藏光标            Console.CursorVisible &#x3D; false;            &#x2F;&#x2F;设置舞台（控制台）大小            Console.SetWindowSize(w, h);            &#x2F;&#x2F;设置缓冲区大小            Console.SetBufferSize(w, h);        &#125;        #endregion        #region 红色墙壁        static void DrawWall(int w, int h)        &#123;            &#x2F;&#x2F;设置颜色为红色            Console.ForegroundColor &#x3D; ConsoleColor.Red;            &#x2F;&#x2F;画墙            &#x2F;&#x2F;上方墙 下方墙 中间墙1 中间墙2            for (int i &#x3D; 0; i &lt;&#x3D; w - 2; i +&#x3D; 2)            &#123;                Console.SetCursorPosition(i, 0); &#x2F;&#x2F;上方墙                Console.Write(&#39;■&#39;);                Console.SetCursorPosition(i, h - 1); &#x2F;&#x2F;下方墙                Console.Write(&#39;■&#39;);                Console.SetCursorPosition(i, h - 11); &#x2F;&#x2F;中间墙1                Console.Write(&#39;■&#39;);                Console.SetCursorPosition(i, h - 6); &#x2F;&#x2F;中间墙2                Console.Write(&#39;■&#39;);            &#125;            &#x2F;&#x2F;左边墙 右边墙            for (int i &#x3D; 0; i &lt;&#x3D; h - 1; i++)            &#123;                Console.SetCursorPosition(0, i); &#x2F;&#x2F;左边墙                Console.Write(&#39;■&#39;);                Console.SetCursorPosition(w - 2, i); &#x2F;&#x2F;右边墙                Console.Write(&#39;■&#39;);            &#125;        &#125;        #endregion    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSharp入门总结</title>
    <link href="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/"/>
    <url>/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>入门总结</p><span id="more"></span><img src="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/summary.png" class="">]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSharp基础总结</title>
    <link href="/2022/05/04/CSharp/CSharp%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"/>
    <url>/2022/05/04/CSharp/CSharp%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>基础总结</p><span id="more"></span><img src="/2022/05/04/CSharp/CSharp%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/summary.png" class="">]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>选择排序</title>
    <link href="/2022/05/04/CSharp/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/05/04/CSharp/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>2022.5.4</p><span id="more"></span><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>重点知识点：<br><strong>选择排序</strong><br>1.基本概念： 新建中间商 遍历依次比较找出极值 放入目标位置<br>2.套路写法：两层循环（外层轮数 内层寻找 初始索引 记录极值）<br>3.优化： 已经完成比较的不参与比较  加一个bool标识判断是否已经有序</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><img src="/2022/05/04/CSharp/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/exam.png" class=""><p>以下是答案：</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson14_选择排序练习题&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;选择排序练习题&quot;);            #region 练习题1               &#x2F;&#x2F;生成随机数组            Random r &#x3D; new Random();            int[] arr &#x3D; new int[20];            for (int i &#x3D; 0; i &lt; arr.Length; i++)            &#123;                arr[i] &#x3D; r.Next(0, 101);            &#125;            &#x2F;&#x2F;选择排序升序排序            Console.WriteLine(&quot;选择排序升序排序结果:&quot;);            for (int m &#x3D; 0; m &lt; arr.Length; m++)            &#123;                int index &#x3D; 0;                int temp;                for (int n &#x3D; 0; n &lt; arr.Length - m; n++)                &#123;                    if (arr[index] &lt; arr[n])                    &#123;                        index &#x3D; n;                    &#125;                &#125;                if(index !&#x3D; arr.Length - m -1 )                &#123;                    temp &#x3D; arr[index];                    arr[index] &#x3D; arr[arr.Length - m - 1];                    arr[arr.Length - m - 1] &#x3D; temp;                &#125;            &#125;            for (int i &#x3D; 0; i &lt; arr.Length; i++)            &#123;                Console.Write(arr[i] + &quot; &quot;);            &#125;            &#x2F;&#x2F;中间间隔            Console.WriteLine();            Console.WriteLine(&quot;*************&quot;);            &#x2F;&#x2F;冒泡排序降序排序            Console.WriteLine(&quot;选择排序降序排序结果:&quot;);            for (int m &#x3D; 0; m &lt; arr.Length; m++)            &#123;                int index &#x3D; 0;                int temp;                for (int n &#x3D; 0; n &lt; arr.Length - m; n++)                &#123;                    if (arr[index] &gt; arr[n])                    &#123;                        index &#x3D; n;                    &#125;                &#125;                if (index !&#x3D; arr.Length - m - 1)                &#123;                    temp &#x3D; arr[index];                    arr[index] &#x3D; arr[arr.Length - m - 1];                    arr[arr.Length - m - 1] &#x3D; temp;                &#125;            &#125;            for (int i &#x3D; 0; i &lt; arr.Length; i++)            &#123;                Console.Write(arr[i] + &quot; &quot;);            &#125;            #endregion        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>冒泡排序</title>
    <link href="/2022/05/04/CSharp/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/05/04/CSharp/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>2022.5.4</p><span id="more"></span><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>重点知识点：<br><strong>冒泡排序</strong><br>1.基本概念： “无序”数组中两两相邻的数不断比较与交换直到“有序”<br>2.套路写法：两层循环（外层轮数 内层比较 满足则交换）<br>3.优化： 已经完成比较的不参与比较  加一个bool标识判断是否已经有序</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><img src="/2022/05/04/CSharp/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/exam.png" class=""><p>以下是答案：</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson13_冒泡排序练习题&#123;    internal class Program    &#123;        #region 练习题2        &#x2F;&#x2F;冒泡排序函数        static void PaiXu( int[] arr, bool upDown)        &#123;            &#x2F;&#x2F;小优化 在循环外声明变量 可以提高一些性能            bool isSort;            int temp;            for (int m &#x3D; 0; m &lt; arr.Length; m++)            &#123;                isSort &#x3D; false;                for (int n &#x3D; 0; n &lt; arr.Length - 1 - m; n++)                &#123;                    if(upDown)                    &#123;                        if (arr[n] &gt; arr[n + 1])                        &#123;                            isSort &#x3D; true;                            temp &#x3D; arr[n];                            arr[n] &#x3D; arr[n + 1];                            arr[n + 1] &#x3D; temp;                        &#125;                    &#125;                    else                    &#123;                        if (arr[n] &lt; arr[n + 1])                        &#123;                            isSort &#x3D; true;                            temp &#x3D; arr[n];                            arr[n] &#x3D; arr[n + 1];                            arr[n + 1] &#x3D; temp;                        &#125;                    &#125;                &#125;                if (!isSort)                &#123;                    break;                &#125;            &#125;            if (upDown)            &#123;                Console.WriteLine(&quot;冒泡排序升序排序结果:&quot;);            &#125;            else            &#123;                Console.WriteLine(&quot;冒泡排序降序排序结果:&quot;);            &#125;            for (int i &#x3D; 0; i &lt; arr.Length; i++)            &#123;                            Console.Write(arr[i] + &quot; &quot;);            &#125;        &#125;        #endregion        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;冒泡排序练习题&quot;);            #region 练习题1            &#x2F;&#x2F;判断是否已经有序 标识符            bool isSort &#x3D; false;            &#x2F;&#x2F;生成随机数组            Random r &#x3D; new Random();            int[] arr1 &#x3D; new int[20];            for (int i &#x3D; 0; i &lt; arr1.Length; i++)            &#123;                arr1[i] &#x3D; r.Next(0, 101);            &#125;            &#x2F;&#x2F;冒泡排序升序排序            Console.WriteLine(&quot;冒泡排序升序排序结果:&quot;);            for(int m &#x3D; 0; m &lt; arr1.Length; m++)            &#123;                isSort &#x3D; false;                for(int n &#x3D; 0; n &lt; arr1.Length - 1 - m; n++)                &#123;                    if(arr1[n] &gt; arr1[n + 1])                    &#123;                        isSort &#x3D; true;                        int temp &#x3D; arr1[n];                        arr1[n] &#x3D; arr1[n + 1];                        arr1[n + 1] &#x3D; temp;                    &#125;                &#125;                if( !isSort )                &#123;                    break;                &#125;            &#125;            for(int i &#x3D; 0; i &lt; arr1.Length; i++)            &#123;                Console.Write(arr1[i] + &quot; &quot;);            &#125;            &#x2F;&#x2F;中间间隔            Console.WriteLine();            Console.WriteLine(&quot;*************&quot;);            &#x2F;&#x2F;冒泡排序降序排序            Console.WriteLine(&quot;冒泡排序降序排序结果:&quot;);            for (int m &#x3D; 0; m &lt; arr1.Length; m++)            &#123;                isSort &#x3D; false;                for (int n &#x3D; 0; n &lt; arr1.Length - 1 - m; n++)                &#123;                    if (arr1[n] &lt; arr1[n + 1])                    &#123;                        isSort &#x3D; true;                        int temp &#x3D; arr1[n];                        arr1[n] &#x3D; arr1[n + 1];                        arr1[n + 1] &#x3D; temp;                    &#125;                &#125;                if (!isSort)                &#123;                    break;                &#125;            &#125;            for (int i &#x3D; 0; i &lt; arr1.Length; i++)            &#123;                Console.Write(arr1[i] + &quot; &quot;);            &#125;            #endregion            &#x2F;&#x2F;中间间隔            Console.WriteLine();            Console.WriteLine(&quot;*************&quot;);            #region 练习题2            &#x2F;&#x2F;生成数组            int[] arr2 &#x3D; new int[20];            for (int i &#x3D; 0; i &lt; arr2.Length; i++)            &#123;                arr2[i] &#x3D; r.Next(0, 101);            &#125;            &#x2F;&#x2F;true代表升序排序 false代表降序排序            PaiXu( arr2, true);            &#x2F;&#x2F;中间间隔            Console.WriteLine();            Console.WriteLine(&quot;*************&quot;);            PaiXu( arr2, false);            #endregion        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月4日</title>
    <link href="/2022/05/04/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%884%E6%97%A5/"/>
    <url>/2022/05/04/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%884%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="ca17d6d80839b79c53b590df5936d99722a2d8593f839772f3c9ff00bcc3861c">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe5022d3d41ced9faff4c414d720080b2e532c1575e70f40aaaa88040ab450a6d1b0981729a275468a2721b3c204a6438005e1b5dd0eda5f210f00659b2455b19b448bfeb7c8941de5e1738392fcd8a90658b21cee475b6f6f7850c67a821be6789a381b5c6361d290687a364526d955099a05abcd6ca8f1caef52449ea73fe9ecc01d01c4dac98b49289d9b265518c538098ab70dfc8a28cb57379f527e9bd0a41b7ed937d545fc2ec58cbcb8e1836d320435d2f561d0b922aeefd20c5a25dd8bd482b3affd7788f1026b0d164a7a1200be4ab783d22b509cc73df2d4a874d0927a13e57e9ec51d570395fa33de0e935b103a40adc0cfe9ff993878099917f32a5a19d88c26393c99c0a4890ce9ff8564a79291510b8245fc819b0234d92ced7002d06feb702682424bbe6ab3322e9c0dbd3577666fb907d3216a13cc3cbd10869f2c9845eac2453c3363f1347ed6930624116787e8057962cc5e876f1a8aa89cd91c6b0f18a816b0ad8802c2c893771c661759aa20f59fadb7f1040662ad22398e09d575ce8ed41d9aeab6db4151b2948e28c5229464590834ddad0a940e32364b2e3c8d14458afbdfc789483484c8f258adb5c3faa2f4d91357f7d6c79ca83bb3ac087144bec966eb987b987ef814a4311ab886fb10d891ec7a453742f3faf3cdbe9545b4e543ed1022974eb5a499fc1d5d4acf78fa639948aa942b79af2d9fb253092f62af74adf84cedc58e522c50d20e8ecfb3e11c34f5edaa8d51de69d203dbe77a37e2178d21bae9e228c01061321d43002bda5dcf3e0a6714af76808dad9a16423791a676c4e6fb251bd2609d5b1adea9a7feb76a4a3fb6abb284b7de4aa2d12819871ef1469d3c4fa40fd7117c4bdd71bcc12738ac3ac2ed6fbb81a546a73511aeb0fda205c809615aec05f7d10edd4a61249d735f01843ea532b2aff4fed3afb9befaf5273192217c3f4dc2b0688271f585c76f41dd161360351247a0120360a70861bc6567d68c936eb575392ac8ccd8d9d37301b545f139307c88d27958347d808655a4bcbd9e524012d1ecf357c9953130f6834dfda6fb569a3b0db2074370860cb42f99fe730320a5549908fb11d3e1ada8913328b09f8910e1b0f9be670d6f16ae41c08ddb2baa5ea8be39be72bef47f792fd312f6a591964a4fcf60ae91793f4da790894159b69ee8eda7d54e722f14ecab819cf37c204f11f609b2201122ff5e24782387000c3e22ae5c1bc01de55aa50a7345e37ab938f3f51990237004b7a81f2e5d7a75ac3b877d9619025b31d1ae3b07c8dd55b60c815f3a320b13854e8c7a3646e7b12a5dc8f6b29c451c03265998681ebce942f031eb2d72354bba0fc68a4f7482ae1d51833f71101d4175e13dfa242bbc4864f067ed446c8526a2449682d90e9ec80760a2ecdcc3018651157b6897825d906c9ddd2d926d9d75121c9ebaf9b4cc8911651a854785d2c17c1f607214a02f0532e9a27700168d4df41faa35855366c4e62864c05f153b16b0496363f215fac5c7c4238c9bbd1cb87567af61ff4f9b4bbc54decb3c5a7cd68ac1ab0c4791acf83d7c521134889163bf5fb9d549103823c9ad35cb00240f06330d3e4ddd534831ca1a61f5efdf96e5b192d1849f61a225db50ba046c62150b561f719fdb8a4b9e53dfae29a476b50442398bdf55d5f2b992b11adf99b1e2a972ff8d3032d37ea4a1b7857396b42e5f4f97327daa6683fa4a0e6967a7a2377b7dda7d678d53b85e993c07d2a475af2152156804da9e6234dd1ff032fa4d4fed908990a59ac9e3e457a5715f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">要密码，快滚.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月3日</title>
    <link href="/2022/05/04/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%883%E6%97%A5/"/>
    <url>/2022/05/04/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%883%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="eca6d1fe149299d16fdebff137629187afd2b07ff353739ed1229d83d3640d27">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe5009c12dd1b715f42596ff4c88e24a0cfe8922606d46efa74ddbd9f5d3b426f56687102603786378470a4ecaae8b2313d0c003aaefde25d0f4bfa6cf8adcc4fbaa0a568aa7648f307311400a354664366507492f645fe02049bb0be8437ca7c835fca64706458d6fdd363a529564b60a3b26384e67ab2e038ad4b5d30b6a9c4925856a93271e13ba94afa16c26633b31e9ee540bb1ddb9f30dbc9f02df3101ce70b7d2d6b666fd3296fee8a9d4e1cd30d4e2808d3d23569489143fe1ce520c639063e2260f47b9a0435d49c601b499354313d5749d8dedd8f136d00fe0e3e3c2e078e7d7b8e484c261a9f9daefd65ce671fa990edd217fb86de23e9982edc3d0881d85390fd9fecf94c8b90918bb57a8ba3336b474952f80f1a08fc8634c8bcc0cb6d38bb2402a896db95b4f7356a1e11ada26cd4796de4a3c305847a1a2cab31f9794c08599ff6db9b0c4e89cb8aada39df07c2787d825ab709670194aa34c42a28e6d2b353bc49a39d7206a416b5f9a1db7705a31fd3378793c16f46334dff3101d76794745deaf80cea915eab7185931cce95ed77726e596ed18cd8418533fff97e9920cd9c00a880649087d082db0273ff52138bb8bcd3c7e58f3aac7f95ce6315df7225142d7485580499691c74ab94a1bd67ab7090999d80461c634d04653ce41bf84b6d17cd9af5fb85f31a7f132c467cb8f634b56c0ef59186ec1f561eaa4256804a827ca8f556e7afea92a81664dabaebfb2922af74339be92e7467846da05585de7ea69713758bb31bfb9be3</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">要密码，快滚.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构体</title>
    <link href="/2022/05/03/CSharp/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <url>/2022/05/03/CSharp/%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<p>2022.5.3</p><span id="more"></span><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>重点知识点：<br><strong>结构体</strong><br>1.概念： 结构体 struct 是变量和函数的集合 用来表示特定的数据集合<br>2.访问修饰符：用来修饰变量和方法  public-&gt;外部可以调用   private-&gt;只能内部调用   不写默认private<br>3.构造函数：没有返回值 函数名和结构体名相同 可以重载 主要是帮助我们快速初始化结构体对象</p><p>注意：<br>1.在结构体中声明的变量不能初始化  只能在外部或者函数中赋值（初始化）<br>2.在结构体中声明的函数 不用加static</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><img src="/2022/05/03/CSharp/%E7%BB%93%E6%9E%84%E4%BD%93/exam.png" class=""><p>以下是答案：</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson12_结构体练习题&#123;    #region 练习题1    struct Student    &#123;               public string name;        public bool sex;        public int age;        public int lesson;        public string major;        public Student(string name, bool sex, int age, int lesson, string major)        &#123;            this.name &#x3D; name;                       this.sex &#x3D; sex;            this.age &#x3D; age;            this.lesson &#x3D; lesson;            this.major &#x3D; major;        &#125;        public void Information()        &#123;            Console.WriteLine(&quot;学员姓名&#123;0&#125;,性别&#123;1&#125;,年龄&#123;2&#125;,班级&#123;3&#125;,专业&#123;4&#125;&quot;, name, age, age, lesson, major);        &#125;    &#125;    #endregion    #region 练习题2    &#x2F;&#x2F;他们都是访问修饰符 用来修饰变量和方法    &#x2F;&#x2F;private 只能内部调用    &#x2F;&#x2F;public  外部可以调用    #endregion    #region 练习题3    struct Rectangular    &#123;        public int x;        public int y;        public Rectangular(int x, int y)        &#123;            this.x &#x3D; x;            this.y &#x3D; y;        &#125;        public void Information()        &#123;            Console.WriteLine(&quot;矩形的长为&#123;0&#125;,宽为&#123;1&#125;,面积为&#123;2&#125;,周长为&#123;3&#125;&quot;, x, y, x * y, 2 *(x + y));        &#125;    &#125;    #endregion    #region 练习题4    struct PlayerInfo    &#123;        public string name;        public E_Occupation occupation;                public PlayerInfo(string name, E_Occupation occupation)        &#123;            this.name &#x3D; name;            this.occupation &#x3D; occupation;                &#125;        public void AttackInformation()        &#123;            string o &#x3D; &quot;&quot;;            string s &#x3D; &quot;&quot;;            switch (occupation)            &#123;                case E_Occupation.Warrior:                    o &#x3D; &quot;战士&quot;;                    s &#x3D; &quot;冲锋&quot;;                    break;                case E_Occupation.Hunter:                    o &#x3D; &quot;猎人&quot;;                    s &#x3D; &quot;假死&quot;;                    break;                case E_Occupation.Witch:                    o &#x3D; &quot;法师&quot;;                    s &#x3D; &quot;奥术冲击&quot;;                    break;            &#125;            Console.WriteLine(&quot;&#123;0&#125;&#123;1&#125;施放了&#123;2&#125;&quot;, o, name, s);        &#125;    &#125;    enum E_Occupation    &#123;        Warrior,        Hunter,        Witch,    &#125;    #endregion    #region 练习题5    struct Monster    &#123;        public string name;        public int atk;        public Monster(string name)        &#123;            this.name &#x3D; name;            Random r &#x3D; new Random();            atk &#x3D; r.Next( 10, 30 );        &#125;        public void Atk()        &#123;            Console.WriteLine(&quot;&#123;0&#125;的攻击力是&#123;1&#125;&quot;, name, atk);        &#125;    &#125;    #endregion    #region 练习题7    struct UltraMan    &#123;        public string name;        public int atk;        public int def;        public int hp;        public UltraMan(string name, int atk, int def, int hp)        &#123;            this.name &#x3D; name;            this.atk &#x3D; atk;            this.def &#x3D; def;            this.hp &#x3D; hp;                   &#125;        &#x2F;&#x2F;结构体是值类型 想要在函数内部改变值类型信息 外部受影响 一定要用ref或out        public void Attack(ref Boss monster)        &#123;            &#x2F;&#x2F;奥特曼打怪兽的逻辑            monster.hp -&#x3D; atk - monster.def;            Console.WriteLine(&quot;&#123;0&#125;攻击了&#123;1&#125;，造成了&#123;2&#125;点伤害，&#123;1&#125;剩余血量&#123;3&#125;&quot;, name, monster.name, atk - monster.def, monster.hp);        &#125;    &#125;    struct Boss    &#123;        public string name;        public int atk;        public int def;        public int hp;        public Boss(string name, int atk, int def, int hp)        &#123;            this.name &#x3D; name;            this.atk &#x3D; atk;            this.def &#x3D; def;            this.hp &#x3D; hp;        &#125;        public void Attack(ref UltraMan Tiga)        &#123;            &#x2F;&#x2F;怪兽打奥特曼的逻辑            Tiga.hp -&#x3D; atk - Tiga.def;            Console.WriteLine(&quot;&#123;0&#125;攻击了&#123;1&#125;，造成了&#123;2&#125;点伤害，&#123;1&#125;剩余血量&#123;3&#125;&quot;, name, Tiga.name, atk - Tiga.def, Tiga.hp);        &#125;    &#125;    #endregion    internal class Program    &#123;                        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;结构体练习题&quot;);            #region 练习题1            Student s1 &#x3D; new Student(&quot;季宝&quot;, true, 23, 2, &quot;微电子&quot;);            Student s2 &#x3D; new Student(&quot;大逼&quot;, true, 23, 2, &quot;网安&quot;);            s1.Information();            s2.Information();            #endregion            #region 练习题3            Rectangular r1 &#x3D; new Rectangular (5, 4);            r1.Information();            #endregion            #region 练习题4            Console.Write(&quot;请输入玩家名字：&quot;);            string name &#x3D; Console.ReadLine();            Console.Write(&quot;请选择你的职业：（0战士，1猎人，2法师）&quot;);            try             &#123;                E_Occupation o &#x3D; (E_Occupation)int.Parse(Console.ReadLine());                PlayerInfo p1 &#x3D; new PlayerInfo(name ,o);                p1.AttackInformation();            &#125;            catch            &#123;                Console.WriteLine(&quot;请输入数字&quot;);            &#125;            #endregion            #region 练习题6            &#x2F;&#x2F;声明Monster数组            Monster[] monsters &#x3D; new Monster[10];            for (int i &#x3D; 0; i &lt; monsters.Length; i++)            &#123;                monsters[i] &#x3D; new Monster(&quot;怪兽&quot; + i);                monsters[i].Atk();            &#125;            #endregion            #region 练习题7            UltraMan Tiga &#x3D; new UltraMan(&quot;迪迦&quot;, 10, 5, 100);            Boss boss &#x3D; new Boss(&quot;哥斯拉&quot;, 8, 4, 100);            while(true)            &#123;                Tiga.Attack(ref boss);                if( boss.hp &lt;&#x3D; 0)                &#123;                    Console.WriteLine(&quot;迪迦胜利&quot;);                    break;                &#125;                boss.Attack(ref Tiga);                if (Tiga.hp &lt;&#x3D; 0)                &#123;                    Console.WriteLine(&quot;哥斯拉胜利&quot;);                    break;                &#125;                Console.WriteLine(&quot;按任意键继续&quot;);                Console.ReadKey(true);            &#125;            #endregion        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>递归函数</title>
    <link href="/2022/05/03/CSharp/%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/"/>
    <url>/2022/05/03/CSharp/%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>2022.5.3</p><span id="more"></span><h1 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h1><p>重点知识点：<br><strong>递归函数</strong><br>概念： 让函数自己调用自己<br>注意：<br>一个正确的递归函数<br>1.必须有结束调用的条件<br>2.用于条件判断的 这个条件必须改变 能够打到停止的目的</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><img src="/2022/05/03/CSharp/%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/exam.png" class=""><div class="code-wrapper"><pre><code class="csharp">using System;namespace Lesson11_递归函数练习题&#123;    internal class Program    &#123;        #region 练习题1        static void ZeroTen(int a)        &#123;            if(a &gt; 10)            &#123;                return;            &#125;            Console.WriteLine(a);            ZeroTen(++a);        &#125;        #endregion        #region 练习题2        static int Factorial(int a)        &#123;            if(a == 1)            &#123;                return 1;            &#125;            return a * Factorial(--a);//--a应写在后面, 或用a - 1            //若是 Factorial(--a) * a ,后面的a是已经减掉的a,得不到正确结果        &#125;        #endregion        #region 练习题3        static long SumFactorial(int a)        &#123;            if(a == 1)            &#123;                return 1;            &#125;            return Factorial(a) + SumFactorial(--a);        &#125;        #endregion        #region 练习题4        //自己写的        static double ZhuganLength1(int a)        &#123;            if(a == 0)            &#123;                return 100;            &#125;            return 0.5 * ZhuganLength1(--a);        &#125;        //答案        //一是长度 二是天数        static void ZhuganLength2(double length, int day = 0)        &#123;            length /= 2;            ++day;            //第十天砍了后的长度            if (day == 10)            &#123;                Console.WriteLine(&quot;第十天砍后竹竿长&#123;0&#125;米&quot;, length);                return;            &#125;                        ZhuganLength2(length, day);        &#125;        #endregion        #region 练习题5        //看答案的 想不出来短路怎么写        static bool PrintNum(int a)        &#123;            Console.WriteLine(a);                       return a == 200 || PrintNum(a + 1);             //逻辑短路，若逻辑或前面的为真，不执行逻辑或后面的        &#125;                #endregion        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;递归函数练习题&quot;);            //ZeroTen(0);            Console.WriteLine(Factorial(5));            Console.WriteLine(SumFactorial(10));            Console.WriteLine(ZhuganLength1(10));            ZhuganLength2(100, 0);            PrintNum(1);        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏设想(更新中)</title>
    <link href="/2022/05/03/%E9%A1%B9%E7%9B%AE/%E6%B8%B8%E6%88%8F%E8%AE%BE%E6%83%B3-%E6%9B%B4%E6%96%B0%E4%B8%AD/"/>
    <url>/2022/05/03/%E9%A1%B9%E7%9B%AE/%E6%B8%B8%E6%88%8F%E8%AE%BE%E6%83%B3-%E6%9B%B4%E6%96%B0%E4%B8%AD/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="085b8f3c7f5217256b375c6ae6075e8a8adae91a0ade8f8a94c33da807588fd2">1432a7b75e994fca526a11f4c4c29edb5d95ddd08071f06d8e2b1881f40addc49717d4ad2129bf03f288d888dddd593047eece5bda476a758cc60ea414b92c2fde57109810737be6114d7bc1b6b7562288492faa485ce10d9f6299e57b851357b155e4efdd34cbdd97c62497dc707a8984ec16459a2b29863b8efb819d6be55fee9506e4cffd6a89bbbd6344b2f51a0b1deb0385f3209dfde7e16b2730acd43ef49c7653d1401cc12f99952648c7e9fac2e3d036f71ac2a224d882c9eb52b53e8ce41ad4adcb845a1ece03152a88f6b9b4a60f385b7cd2bb197f64876a288ef21ea0f1cd6c1413b5bb87c41430ede2ee3757bf646cb9be07686a61467b31f274ec251a3402c81ab754e4f64b4371f59d3e48b066a9d4374932d26748038e8972751dbd5ccf58182e5c1ffdd89532c2b4d16f4e9e2f1d2ca1aff8bf2b9f1a02ec8cb9b08156183203b1e6d5d9e33805bdfdcf86d2d455b22f3cf0c5256eeeba4ecd62b87719f83f61c86654cd68f2d2cca26593c99c9d37ac15226c4abb48fd006cebb943c3977b2e1e46f10646380aed592825f2f183df4476ec6f707913e8fe88cf823b72bf2aec4dc26fc020a783d26174557db927ca6c764208fa1f0de861d954ea17ba42cba643a0d82b2a34bbe7d1add7f69f822495de81deabf3f37c59366a1ad681568c2d6c73d0fbbe10b4f00148cd62c7e8c8ca89963dfdd89ea0201c6163f7a9d843737c71d4c25a133621e9b429eac7b530ca1162fa2a9c8f83a78239efbf362a28152fd1812b3bd1306bc1ce235d6944e5c6352f6a6d6d14cda004f50ae8f27c35d7eb6ebe68e6246b1766d92f34bbd91f1aafd140c0bdc584aa53d91b49fc7bde567c308953bb3021801af6fcec8d469dd0f7c38b11f9383c63f733c54f7ec71d8221103ac971dd97a1510cb199dad83bda9253e38f3f945571</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">要密码，快滚.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数重载</title>
    <link href="/2022/05/03/CSharp/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/"/>
    <url>/2022/05/03/CSharp/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<p>2022.5.2</p><span id="more"></span><h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><p>重点知识点：<br><strong>函数重载</strong><br>概念： 同一个语句块中，函数名相同，参数数量、类型、顺序不同的函数 就称为函数重载<br>注意： 和返回值无关<br>作用： 一般用来处理不同参数的同一类型的逻辑处理</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><img src="/2022/05/03/CSharp/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/exam.jpg" class=""><p>以下是答案：</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson10_函数重载练习题&#123;    internal class Program    &#123;        #region 练习题1        static int CompareNum(int a, int b)        &#123;            return a &gt; b ? a : b;        &#125;        static float CompareNum(float a, float b)        &#123;            return a &gt; b ? a : b;        &#125;        static double CompareNum(double a, double b)        &#123;            return a &gt; b ? a : b;        &#125;        #endregion        #region 练习题2        static int CompareArray(int[] arr)        &#123;            int max &#x3D; arr[0];            for (int i &#x3D; 1; i &lt; arr.Length; i++)            &#123;                if (arr[i] &gt; max)                    max &#x3D; arr[i];            &#125;            return max;        &#125;        static float CompareArray(float[] arr)        &#123;            float max &#x3D; arr[0];            for (int i &#x3D; 1; i &lt; arr.Length; i++)            &#123;               if (arr[i] &gt; max)                   max &#x3D; arr[i];            &#125;            return max;        &#125;        static double CompareArray(double[] arr)        &#123;            double max &#x3D; arr[0];            for (int i &#x3D; 1; i &lt; arr.Length; i++)            &#123;                f (arr[i] &gt; max)                   max &#x3D; arr[i];            &#125;            return max;        &#125;        #endregion        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;函数重载练习题&quot;);            #region 练习题1            Console.WriteLine(CompareNum(5, 7));            Console.WriteLine(CompareNum(10.9f, 4.5f));            Console.WriteLine(CompareNum(20.975, 100.45));            #endregion            #region 练习题2            int[] arrInt &#x3D; &#123; 1, 4, 5, 8, 6 &#125;;            Console.WriteLine(CompareArray(arrInt));            float[] arrFloat &#x3D; &#123; 2.1f, 4.5f, 5.9f, 8.1f, 5.8f &#125;;            Console.WriteLine(CompareArray(arrFloat));            double[] arrDouble &#x3D; &#123; 1.2, 4.5, 5.8, 8.4, 6.6, 8.5 &#125;;            Console.WriteLine(CompareArray(arrDouble));            #endregion        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月2日</title>
    <link href="/2022/05/02/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%882%E6%97%A5/"/>
    <url>/2022/05/02/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%882%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="491f82e74d100b7c0ea7a128893e0938270b929bd3c36f691cdf1082d62df28d">a03af1012de36d86e65bfb0d51f6ff10488d28acf4ffb3e9d40e31ff66292b18d63fe0d726a396877e15d0f45ea8c4d0fca64270b3af481bbf674539be9d74ef68c82a089e06187f209c1d9148866c6889149615508e1920a0ba4dfede99cd4f1c78d484984659bc16451c78231727151c61eb8e511e88202c667f6492a364b4675af00dab110af61f89478fb7bf1e08ab42759f2346284503e36031ddd429d25b0534f43dda5bdafe4e506c1c70035c6cadad563a3c2357e939054059579347b9934247a362a556c365ea249a8dc505ce1d6d8ca02cfccd72b2a108d0eb68d21f51ea413ffdda474e96f5fc9814f7bcc309066ecda23a2402bfb054e09fd25585ec506d740893f0a92fefe328df54c6c5e30ccee78c493458af915a8bd62d591845f1826a4e9bb303d3f4ffa2a0a630ea2eeca8a0aa24bf1fac84529eca1eca00b428e66ee56674f67df6893fb3b6638bf6072f6e9a9070d033dbce154ec5f4f8cf9a7a4f71745f97e5632413ce634d8752541d453cc1f8efc43cb6e55f4f5387885b68fb16745bbfeab5b3f794bfcf28fa185ee8184906a049f0af8ad88ad4f440aa03d10017a143f7f5d6205e3de25d9d59cfa3851b9f2e81f5696c8a2a346b46a76c157a9c2ec305a56e0d7731f4171170433961c676df299d8c595faf5781699895fd001cb183f0542a53f04e059eb4aa707eb1ebec51596a61e4214457d3198eed0cd1c0fe925ad8fc6bcd34e0e0461ee7011d206c6498b0d22654c77579c9cad6d84edd07b81589b80dead8c40e53fffe3640728be6c57f1adecc1adae8789b3531cecd41f4e7f4fdba0c51531d5582c3f825cc4baf81d38a72ab443582fd97b24a4ac9d6c1678f5112c39bfa42e025e83c92e477964c88db0c102230ac7f4629e91dcb511bb7ade9fd16c786601f7194bf912cbed763641345d003c7f4b338765e3cdddfa403c98b5c030f06481f4598c8aa5a297abeb1492047cf5ad3c8496b451b942ff3336266c3b224372060d667f3d6346ba3004f5b9a598335fbc69ab72aa78c648cbf86d34d7d87a21e3675b42c696d20f83b50d8dc483eaa7a111f3b1534d4e39bc38e09196cc7d43fa342fa1233c4f07e63b8a1b464e3d7e0129d364e1556e6087b43e6dced704a2f793fe41e9f717c15c74c85b78c76b947e4ce7bb47e343b6ac8217d74f905bbdf1fee49a8beb58026eb33f2767416d12bc9838b2d1f102cbd24687614dd3a6e17f1367e92340e9641400d3882c9cd747a9447b4ccf8ebb10700132e285d8abc7b51413191a46b696898772325468360fef28752ae0335b0cff4d8aa52466cfc1ce30fd9ee0f7636af2696c47d23e8c8cdeddd2c9d3909f2e3f8d8538a1c26a9fb47e56892a3d0d4e1c9ceb9112a9dca53101795505354efe7a809cb4af82ea138c98c207b9900c5c9ed067cc8f724ee174489e410bb86821f0862bae558c20657a113c556316f8222ff65e9859371f0cf0c759ecf953da0cda9f4b302962e44</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">要密码，快滚.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>变长参数和参数默认值</title>
    <link href="/2022/05/02/CSharp/%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC/"/>
    <url>/2022/05/02/CSharp/%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>2022.5.2</p><span id="more"></span><h1 id="变长参数和参数默认值"><a href="#变长参数和参数默认值" class="headerlink" title="变长参数和参数默认值"></a>变长参数和参数默认值</h1><p>重点知识点：<br><strong>1 变长参数关键字 params</strong><br>作用： 可以传入n个同类型参数 n可以是0<br>注意：<br>    1.params 后面必须是数组 意味着只能是同一类型的可变参数<br>    2.变长参数只能有一个<br>    3.必须在所有参数后面写变长参数</p><p><strong>2 参数默认值（可选参数）</strong><br>作用：可以给参数默认值 使用时可以不传参 不传用默认的 传了用传的<br>注意：<br>    1.可选参数可以有多个<br>    2.正常参数必须写在可选参数前面，可选参数只能写在所有参数的后面</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><img src="/2022/05/02/CSharp/%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC/exam.jpg" class=""><p>以下是答案：</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson9_变长参数和参数默认值练习题&#123;    internal class Program    &#123;        #region 练习题1        static void SumAndAvg(params int[] arr)        &#123;            int sum &#x3D; 0;            for (int i &#x3D; 0; i &lt; arr.Length; i++)            &#123;                sum +&#x3D; arr[i];            &#125;            double avg &#x3D; sum &#x2F; (double)arr.Length;            Console.WriteLine(&quot;它们的和为&#123;0&#125;,平均数为&#123;1&#125;&quot;, sum, avg);        &#125;        #endregion        #region 练习题2        static void OddEven(params int[] arr)        &#123;            int odd &#x3D; 0, even &#x3D; 0;            for (int i &#x3D; 0; i &lt; arr.Length; i++)            &#123;                if(arr[i] % 2 &#x3D;&#x3D; 0)                &#123;                    even +&#x3D; arr[i];                &#125;                else                &#123;                    odd +&#x3D; arr[i];                &#125;            &#125;            Console.WriteLine(&quot;奇数和为&#123;0&#125;,偶数和为&#123;1&#125;&quot;, odd, even);        &#125;        #endregion        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;变长参数和参数默认值练习题&quot;);            #region 练习题1            SumAndAvg(5, 9, 11, 52);            #endregion            #region 练习题2            OddEven(10, 11, 12);            #endregion        &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ref和out</title>
    <link href="/2022/05/02/CSharp/ref%E5%92%8Cout/"/>
    <url>/2022/05/02/CSharp/ref%E5%92%8Cout/</url>
    
    <content type="html"><![CDATA[<p>2022.5.1</p><span id="more"></span><p>#ref和out</p><p>重点知识点：<br>1.ref和out的作用: 解决值类型和引用类型 在函数内部 改值 或者 重新声明 能够影响外部传入的变量 让其也被修改<br>2.使用上: 就是在声明参数的时候 前面加上ref和out的 关键字即可 使用时同上<br>3.区别：<br> 1.ref传入的变量必须初始化  out不用<br> 2.out传入的变量必须在内部赋值  ref不用</p><p>#练习题</p><img src="/2022/05/02/CSharp/ref%E5%92%8Cout/exam.jpg" class=""><p>以下是答案：</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">static bool Login(int user, int key, ref string info)    &#123;        if(user == 0)        &#123;            //用户名正确的逻辑            if(key == 0)            &#123;                //用户名正确且密码正确的逻辑                info = &quot;登录成功&quot;;            &#125;            else            &#123;                //密码错误的逻辑                info = &quot;密码错误&quot;;                return false;            &#125;        &#125;        else        &#123;            //用户名错误的逻辑            info = &quot;用户名错误&quot;;            return false;        &#125;               return true;    &#125;static void Main(string[] args)    &#123;        Console.WriteLine(&quot;请输入用户名和密码&quot;);            int user = int.Parse(Console.ReadLine());            int key = int.Parse(Console.ReadLine());            string info = &quot;&quot;; //ref需要初始化            while (!Login(user, key, ref info)) //若登录失败继续尝试            &#123;                Console.WriteLine(info); //登录失败直接进入循环 打印登陆失败                Console.WriteLine(&quot;请输入用户名和密码&quot;);                user = int.Parse(Console.ReadLine()); //不需要再声明                key = int.Parse(Console.ReadLine());            &#125;            Console.WriteLine(info);    &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月1日</title>
    <link href="/2022/05/01/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%881%E6%97%A5/"/>
    <url>/2022/05/01/%E6%97%A5%E8%AE%B0/2022%E5%B9%B45%E6%9C%881%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="8231443e481bad21d3be8c11f026cef33b9d2ec10d2c75db8a6a3fc9353e6db7">a03af1012de36d86e65bfb0d51f6ff1082829027e374e7685fe9ab85e3524a611ae1849435e4e7a720cff75f6e0c69420b45613e2699125232dbe72ca80048bebea598f361ba86018511cca15b95988dc0cfaef36e0d9831c314d5a5c0c42027b37202a638339207f929734f64e08597cbddc5ea522252e2e02962224d8f2610c567a9905f51b07d0b9ecc25ce9b92d845f910467ef77166d775f3ecd0d5e21bf953b08187237aa313add55b1c228dd7d053f127c9a6a47c0c5a7938ac994063ac4002df1fa06e05aafb90d8bc2640f6cd006d7ed7c8863170e64e1bd6245c77b0fa8e735e224b950e1f54e78b0133b701d1403fb2cfdf2d386b43e9fbaa1451076e4191f3d354e3fffc715fac93c09b38122dd8cb11d8342dc0c89192430adca4b08219e517801151b2a0f8c9d9db1c25359477c00a5f8a9d1f4dde7f15395f067821cdc6c518b824eb6db732a6f9509e2879bd5d893c34ef5dd9fb4feedd57143b5d8aaf6a95442b8ceaff1b20ed7a0103ef67d68f97923d95e97146672a06d3dbddf62d8d0308409f487798bfb2890628acb6da93b261a2be6b203fc5941ccf4602858ff06456f1cd8549bb19df0507e01adc30cf1edc3cf2ec7b1df2a01b64cbd75040011043907e573076bddaa0b8a1fd0278e802bee90f5473a88a8c185022aba3ed8be34c76a5f6841409c505a1b3068b32090cb5b1185e0bf33fc4b5a25b6b0dd4bbf90f8dbe9dcd98b38b25733197162851b604f16a5d7772dc986f3421c043d218bb4333b43d9982b085bbab19f29923bf644069879a756156a5ec5b6d9ac660e35e9544558afb91261123bcc30f7e00c6a468fe4f57c4a11fc966a618fc6f22037b00a3579d3f3ed4935bf7fa8ea29659083c3065e01531f9ca0aa7c185eb275f06844f98e1d86241cec7c6516f3c1490ef92db64b4894aa8b258b0ba055d641c53dbc0ac122fcf5d310d795b7943c3d1894ebd7906d91214d99dddb8546ee1ffc8f85958f09c8cde59fe895fc0b50b36ec620446c4ddc9685f8caccdebeca493bfe948808fb00921585db583e011fd37c3d175b970b75715e00d4b7e12ec96c492a95b96e523bb5e176bb0f49b3ff8ca86fdb500a752bda74eee760803b291021a3b9f0126cd7bb23dd1e72f470659f85b746c63aacba02862c6854f0b1ed71aad37a7828628896f1d5102453015e7769e691b07182728455dafcbc3e954aac72ef8a611d29a2392426ab51e80c901b6d0f46356365fa9660c731b71e7105a4a38d26fbffc6e804be1de7dafd2888b15a688c5d0b44b925821bb280a6ad0b3e82e48cec923663f4c22edb27946f90144f4df62e0c193bfa4186c0436989434570289d5a8a70a5823b41e640d330234ebaee4eceb1523b43b168b8a107765dd1b102c41cd200d3899fa241b87e8473e40b0d49ac9044249d8f74419b7507518041f3d7aad9e2152b0f8f425906095dd601697acd1a70bf3f5f2f64a0d38118e03282f3ae2a9ab8c9cc695c9f64a8cc722703e6e6805e21245b11f8f26228b91e66bd1b6f8d3ded0181491370dad82bdd46863138d11c8c6e4c70811bbb0afa15a450570fba043e2aa477441cf006111f916f0f80445a7ce1780af01a2b8688c4f70a758f6e7579d5d3cf9ddcc6a1dc3a83744c3ceb40f10fb072cb04940867ea5d2e7d7373bc2201d1c30a976745440597f87dd867d870c146ef3d4277dea046a21e2c758895343dde22f37061758a16095030c3f2664f9abb1f771ac28e2f55925974c7771f54557e447ebb7bee6449d22e52053925b248b05ba706590eedf6e24c1ea9f3685b83fd21e20dc9a8fdd87bb65266ddf72d99eaca5f7786afca9b98817f3c1a32ff87f776475024dd53cdbabc996921be1a50d5478a6f92cbd1f05885dce23af78eb58979c608fc64d3adf796861c673610fd9bf47793893da8bfcc7d0c9217244cb8768e699c45fb85d0658640db520170b1a420b72d890b4d056ef168bba17bd957af12f5239e8ae0687848c2e630234b4b46f680c1bce2cbd9711dabba8425ab03056c3a5f9592d7745499784fd25ade98ca511819ce01db178db801b75528f8dddb4aaf68cfbd76889f8720f774514aff1ef12734bf07f573b716d746e1ac572d62c788de740b599cfd6705a91db8c2d0974f2fafa47072dc231e1634008624e648489d915542f3bf2343b56b8b41482638b9cff93a60fd1d221550bfe947e4fafc8f7666803db2210081228e94e2e143133f3b851c8a2f5524e0c612da970f01576fd2f2c704bb10d79e52c7b75d8ca01c7a7f1aae45e43de5b208a64c4006038a8cb</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">要密码，快滚.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
