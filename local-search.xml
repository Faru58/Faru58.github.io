<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Inspector窗口可编辑的变量</title>
    <link href="/2022/07/02/Unity/Unity%E5%85%A5%E9%97%A8/Inspector%E7%AA%97%E5%8F%A3%E5%8F%AF%E7%BC%96%E8%BE%91%E7%9A%84%E5%8F%98%E9%87%8F/"/>
    <url>/2022/07/02/Unity/Unity%E5%85%A5%E9%97%A8/Inspector%E7%AA%97%E5%8F%A3%E5%8F%AF%E7%BC%96%E8%BE%91%E7%9A%84%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<p>Inspector窗口可编辑的变量</p><span id="more"></span><h1 id="Inspector窗口可编辑的变量"><a href="#Inspector窗口可编辑的变量" class="headerlink" title="Inspector窗口可编辑的变量"></a>Inspector窗口可编辑的变量</h1><p>Inspector窗口可编辑的变量就是脚本中的成员变量</p><h2 id="私有和保护的变量无法在窗口中显示编辑"><a href="#私有和保护的变量无法在窗口中显示编辑" class="headerlink" title="私有和保护的变量无法在窗口中显示编辑"></a>私有和保护的变量无法在窗口中显示编辑</h2><h2 id="让私有和保护的变量可以在窗口中显示编辑"><a href="#让私有和保护的变量可以在窗口中显示编辑" class="headerlink" title="让私有和保护的变量可以在窗口中显示编辑"></a>让私有和保护的变量可以在窗口中显示编辑</h2><p>加上强制序列化字段特性 [SerializeField]<br>所谓序列化就是把一个对象保存到一个文件或数据库字段中去</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">[SerializeField]private int privateInt;[SerializeField]protected string protectedStr;</code></pre></div><h2 id="公共的变量可以在窗口中显示编辑"><a href="#公共的变量可以在窗口中显示编辑" class="headerlink" title="公共的变量可以在窗口中显示编辑"></a>公共的变量可以在窗口中显示编辑</h2><h2 id="让公共的变量无法在窗口中显示编辑"><a href="#让公共的变量无法在窗口中显示编辑" class="headerlink" title="让公共的变量无法在窗口中显示编辑"></a>让公共的变量无法在窗口中显示编辑</h2><p>加上特性 [HideInInspector]</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">[HideInInspector]public int publicInt2;</code></pre></div><h2 id="大部分类型都可以在窗口中显示编辑"><a href="#大部分类型都可以在窗口中显示编辑" class="headerlink" title="大部分类型都可以在窗口中显示编辑"></a>大部分类型都可以在窗口中显示编辑</h2>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年7月2日</title>
    <link href="/2022/07/02/diary/2022.7/2022%E5%B9%B47%E6%9C%882%E6%97%A5/"/>
    <url>/2022/07/02/diary/2022.7/2022%E5%B9%B47%E6%9C%882%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="4dcf8a4344492cffd30b2c24ea2fb1a41ae9cf78fa88934ecebba7167a539335">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50fdd0ca3edc57389bd0e88084b7db20230e08519736a6dd1d06db6fd82096dcc82c87bf6d9dd3fd8a4479d58ade1c7d5fa311fb33cf2463ad1d91ea504e3f0bc405632f0a6553bc1d95512944325d55c50f14d3e5522f81ebfbc112e778d48d3497dd83914ef55fdcd8410bee70ef1279a10dad7607029668c4143a19b09a4f2cfbf4b0104d7712f9625f415db4f86175889a9ba4c99c8d30e405033777f408969007594cd2848a9241d5fc4670afd043fba0ff77b9977e4cdf961ada90d27a5b83d1a194ebba6c98e0e165a26c3cea6e9cdad07e586aba543d8339d2b44153d122438ba5f134290a4bc68bab51969336e385e3b0ee961cfb7091f8c99f89863581d1e9389cdf8a53085e11b7390ee295b934ea0390e239b59d7da53c017bc252ec5f4965ff29fa73ae3fe8fe7d7d183da1a7abf8f4e2c8a723e42222f208375be29faa9817476c42739ab37f367bf64df8ec4a1b7abec9951a63e2c85d666014aa5764731a6c2ee04cc6f7bed0508a71872c24263e0ed5928cf4649153a2010988de84d14702b33b5eff476260bda177</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年7月1日</title>
    <link href="/2022/07/01/diary/2022.7/2022%E5%B9%B47%E6%9C%881%E6%97%A5/"/>
    <url>/2022/07/01/diary/2022.7/2022%E5%B9%B47%E6%9C%881%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="68e6ccc4d009df53a37bb6fe44652851f45a8505d382edbc6d07eccb6a5e9cbe">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe5023727a6834d30b10648e5d953f06c0febe288bc3a327dc78b614ffd3c47935898224bcfbc12d67dbb29c352afee07b453e42b124d653c065f368885022d3931db2f8308deaf99ab0661625b03213aa2e160f7455b00173588bd14ec413692b38941aa28fb004e33762c79a3fbb13407ea95c028f813eb64d286d23afcf8177fb88187544f798f90329401068723f068ae2ba22753a56cfe37b9cadb897c0e03c0c4e8eb4025ed671a783db662c5ed1b085b10b3bdaff184426b901c212230c9c8f502907a9f1bd32e9413cc4e01f65156607281ad0fdfa1d3bad36e7edf8501e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字典</title>
    <link href="/2022/07/01/DataStructure/List/%E5%AD%97%E5%85%B8/"/>
    <url>/2022/07/01/DataStructure/List/%E5%AD%97%E5%85%B8/</url>
    
    <content type="html"><![CDATA[<p>字典</p><span id="more"></span><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><h2 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h2><p>散列函数hash()：映射 词条空间 -&gt; 地址空间</p><p>一个好的散列函数越是随机，越是没有规律，则越好<br>应满足以下4个条件：</p><ol><li>确定</li><li>快速</li><li>满射</li><li>均匀</li></ol><p>除余法： hash(key) &#x3D; key % M<br>MAD法： hash(key) &#x3D; (a * key + b) % M<br>平方取中<br>折叠法<br>伪随机数法<br>多项式法</p><p>但都有可能会出现冲突</p><h2 id="排解冲突"><a href="#排解冲突" class="headerlink" title="排解冲突"></a>排解冲突</h2><h3 id="独立链"><a href="#独立链" class="headerlink" title="独立链"></a>独立链</h3><p>优点：</p><ol><li>无需为每个桶预备槽位</li><li>任意的多次冲突都能解决</li><li>删除操作实现简单、统一<br>缺点：</li><li>空间未必连续分布</li><li>系统缓存几乎失效</li></ol><h3 id="开放定址"><a href="#开放定址" class="headerlink" title="开放定址"></a>开放定址</h3><p>散列表所占用的空间在物理上始终是地址连读的一块<br>为每个桶实现约定若干备用桶，构成一个查找链</p><p>查找：沿查找链，逐个转向下一桶单元，直到命中成功或抵达一个空桶(失败)</p><h3 id="线性试探"><a href="#线性试探" class="headerlink" title="线性试探"></a>线性试探</h3><p>为此可进行线性试探：一旦冲突，则试探后一紧邻桶单元</p><p>优点：</p><ol><li>无需附加的(指针、链表或溢出区)空间</li><li>查找链具有局部性，可充分利用系统缓存，有效减少I&#x2F;O<br>缺点：<br>操作时间 &gt; O(1)， 冲突增多</li></ol><p>而直接删除会切断查找链，为此进行懒惰删除，即<br>仅做删除标记，查找链不必续接</p><h3 id="平方试探"><a href="#平方试探" class="headerlink" title="平方试探"></a>平方试探</h3><p>为使数据不至聚集，可以平方数为距离，确定下一试探桶单元<br>表长取4k+3的素数</p><p>优点：缓解数据聚集<br>缺点：若涉及外存，I&#x2F;O将激增</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年6月30日</title>
    <link href="/2022/06/30/diary/2022.6/2022%E5%B9%B46%E6%9C%8830%E6%97%A5/"/>
    <url>/2022/06/30/diary/2022.6/2022%E5%B9%B46%E6%9C%8830%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="6a6ad597524c362cd0efbdd5859b82a1396e5bbb7dab16b62ff24ed7b683430d">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe5074ec90bec109f688a82cad6a1ccfc801e71101cdb300ea02c5347d7c1fa45aa560fc4b26c89afaec08ca949458e7eea07566984c7bd3baa6dcf63f996d65355ea06e2018251d12c77fc8e9cc5d987f9d6dd17a96c88b71de3250bad343ca02430ad9c5569079cab5c64f7c230b213ca865ab85bf8934fdc04b71cdc508686a98a4393b4d5070528c4915eee46b7d4d3e53d98425509e2491f58a06935ed12cf6466a673f29aa19acb23644da9213b98d2bfe095e81c2810e304fbdfb4692c06d952cb215c71b7a3f1a9d3fa5bfcd09114204aa092f80268ae1ad01361ed9eac5e97617afbcccca78941473ca9ebfe50ca7845ad3bf8bd6d1f04445ac0335b50d7ba219a8eb1f480dcc97c358ddbdaa52eff4cf2ea6f6ab785b96863a313177f2377b42f4bbf87bc6b52c96da5441d4964d0de4eeff44d6d03caac6b2318436ebf775549724f9ff8705365b4df49dbe677f988d2c9d1e65f416447ab74dd67c55</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年6月29日</title>
    <link href="/2022/06/29/diary/2022.6/2022%E5%B9%B46%E6%9C%8829%E6%97%A5/"/>
    <url>/2022/06/29/diary/2022.6/2022%E5%B9%B46%E6%9C%8829%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="e0194172888bca04eee1726ada76ea183650dabdaacae29c34f42db2027ff110">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe507ad714b7d694638672ec89b6453f8a87b85928b7fa01b9f47005a794a5ede05ed5f11109de9923aa500ecaeb7706b8bb615978697a3dc151c59fd996b0aea83ac467c99014e100607eb5797b8f0954ec205ce6e1a610b73c1cb2764ca6dc2bccb8b7104f4ca67be1f0bdd28be50e6916c0e03c8117ac3bd8479742255da811c74c17106f0846442e439f076f02a02ec00052d89cbb0b348877a7beb84431520df34500126fcd190f5d7dbc6c77eb382e3bdb35569523a034aa3af2bb62ebce6ca950874813f47f852a788bc7281ad51bb740a5f524310d014d91ed7d13f7c5d27cb0717fd4f199ff936426add325d5f7eb317383f6f295f50532595f3562c88bf849cd0624887990aa2ea2576dd7cbc75e6f1e2c874f8b52364a9b1a911403d52413af69afd28181a3be119f86bfe6c8657df191b44ccc59c9374901b5714e86</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年6月28日</title>
    <link href="/2022/06/28/diary/2022.6/2022%E5%B9%B46%E6%9C%8828%E6%97%A5/"/>
    <url>/2022/06/28/diary/2022.6/2022%E5%B9%B46%E6%9C%8828%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="1628c19aeb69772e0e07e77d045648aa6e735d3c07b237e8ca52a078ed2372e7">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50abb750919ea0d3de915f14a4f4cdb3c2a1d497a94095c6ecc3e5ae6c5bcc3ebaa5540579e774a89165cb3de32a96479dc4038eb8bca7d3e4bda624b03ccdffa4c80756e60b9df17d2a1f77e6d7b7e2a4d4e3e5e2228fb57964633d289e5021c46c4ce1062cf6a1c4b1961184be11d6b47fe58665f609245e4535e68a6c27b10e82830c5d52f995da0171ceec356e36cac07efb83d809c66bf852bba648d2a284f84d7477a96d1d62c71a19a743a0242e6886ad119532110822f988542d02e2ae2bb4532e64d93c38a6c2d74fbd773e4cd2907a3d4248f62789801922bd250627</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年6月27日</title>
    <link href="/2022/06/27/diary/2022.6/2022%E5%B9%B46%E6%9C%8827%E6%97%A5/"/>
    <url>/2022/06/27/diary/2022.6/2022%E5%B9%B46%E6%9C%8827%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="79758f84566bc3e3cd8e63bb4eb9f38d032622856ddc508a446b5d5cc69326f6">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50c7c38e5c9e63ba5ca989017b5f77bb552386bd891d828faccba4c554d6bf75729bc39cd02c78b35b6c213f78df528c9d4a388e043de1cea39b91294d6dee98156a92ddc00b61843f925565250b917cf9a0e2ee253e93a34de530b1b29bf1e72a4f91fb8a385d7799987326c4c88c2f9d286d826be760b206cde75939cfac120efba61ef4a2d42f5ce23ed24c64a9c946f44d90184ef9c1a82f1d7e50d4ee1c3013601473130a2f746efa207155890767</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高级搜索树</title>
    <link href="/2022/06/27/DataStructure/Tree/%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2022/06/27/DataStructure/Tree/%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>高级搜索树</p><span id="more"></span><h1 id="高级搜索树"><a href="#高级搜索树" class="headerlink" title="高级搜索树"></a>高级搜索树</h1><h2 id="伸展树"><a href="#伸展树" class="headerlink" title="伸展树"></a>伸展树</h2><p>局部性(locality)：刚被访问过的数据，极有可能很快地再次被访问<br>连续的m次查找，采用Avl共需O(mlogn)时间<br>节点v一旦被访问，随机转移至树根(逐层伸展)，自下而上逐层单旋</p><p>最坏情况：旋转次数呈<strong>周期性</strong>的<strong>算术级数</strong>演变，每一周期累计Ω(n^2),分摊Ω(n)</p><h3 id="双层伸展"><a href="#双层伸展" class="headerlink" title="双层伸展"></a>双层伸展</h3><p>向上追溯两层，而非一层<br>反复考察祖孙三代，根据他们的相对位置，经<strong>两次旋转</strong>使得v上升两层，成为树根</p><p>子孙异侧：与AVL树双旋完全等效，与逐层伸展别无二致<br>子孙同侧：从祖父节点开始旋转</p><p>折叠效果：一旦访问坏节点，对应路径的长度随即减半，单趟伸展操作分摊O(logn)时间</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>优点：</p><ol><li>无需记录节点高度或平衡因子(优于AVL)</li><li>分摊复杂度O(logn)与AVL树相当</li><li>局部性强，缓存命中率极高时(k &lt;&lt; n &lt;&lt; m)，效率甚至可以更高(自适应的O(logk))，任何连续的m次查找都可在O(mlogk + nlogn)时间内完成</li></ol><p>缺点：<br>仍不能保证单次最坏情况的出现，不适用于对效率敏感的场合</p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h2><p>物理上，存储器容量越大&#x2F;小，访问速度就越慢&#x2F;快</p><ol><li>不同容量存储器，访问速度差异悬殊，为避免1次外存访问，宁愿访问内存10次，100次，…<br>多数存储系统，都是分级组织的(caching)，最常用的数据尽可能放在更高层、更小的存储器</li><li>从磁盘中读写1B和读写1KB几乎一样快(批量式访问)</li></ol><h3 id="B-树：结构"><a href="#B-树：结构" class="headerlink" title="B-树：结构"></a>B-树：结构</h3><p>B-树的每一个节点包含多个分支<br>它实际上是一个平衡的多路搜索树，经过适当合并，得到超级节点<br>每2代合并：4路，每3代合并：8路，…，每d代合并：m &#x3D; 2^d 路和 m - 1 个关键码<br>多级存储系统中使用B-树，可针对外部查找，大大减少I&#x2F;O次数，具体视磁盘的数据块大小而定</p><p>m阶B-树，即m路平衡搜索树(m &gt;&#x3D; 2)</p><ol><li>外部节点的深度统一相等</li><li>所有叶节点的深度统一相等</li><li>树高h &#x3D; 外部节点的深度</li></ol><p>内部节点各有：</p><ol><li>不超过 m - 1 个关键码</li><li>不超过 m 个分支</li></ol><p>内部节点的分支数 n + 1 也不能太少</p><ol><li>树根 2 &lt;&#x3D; n + 1</li><li>其余 [m &#x2F; 2] &lt;&#x3D; n + 1</li></ol><p>超级节点(BTNode)的内部可以实现为两个向量</p><ol><li>n个关键码</li><li>n + 1个分支引用</li></ol><h3 id="B-树：查找"><a href="#B-树：查找" class="headerlink" title="B-树：查找"></a>B-树：查找</h3><p>反复在关键码向量中顺序查找<br>最大树高： log[m &#x2F; 2](N &#x2F; 2) ~ O(longmN)<br>最小树高： logmN - 1 ~ Ω(logmN)<br>BBST高度的 1 &#x2F; (log2m - 1)</p><h3 id="B-树：插入"><a href="#B-树：插入" class="headerlink" title="B-树：插入"></a>B-树：插入</h3><p>因插入而上溢后的分裂处理</p><p>分裂： 上溢时，指针停留向量的中位数关键码上升一层，并以其左右两边作为左右孩子<br>再分裂： 上溢缺陷可能会传播，但只能逐层向上且最高到根<br>复杂度 0(h)</p><h3 id="B-树：删除"><a href="#B-树：删除" class="headerlink" title="B-树：删除"></a>B-树：删除</h3><p>因删除而下溢后的合并处理</p><p>先判断是否可以旋转，再决定是否合并</p><p>旋转： 节点下溢时，比恰好包含[m &#x2F; 2] - 2个key 和 [m &#x2F; 2] - 1个分支<br>若左孩子下溢且右孩子有足够关键码不至于下溢，则该节点的该关键码转给左孩子节点，右孩子的最左关键码转给该节点<br>当无法满足旋转的条件时，进行合并<br>合并： 将该关键码下移与其左右孩子的关键码拼接，该节点的关键码 - 1<br>有可能会出现反复向上合并的现象，但最多不到树根</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>任意一次动态操作引发的结构变化量不致超过O(1)</p><p>O(1)重构：大量共享，少量更新，每个版本的新增复杂度，仅为O(logn)<br>就树形结构拓扑而言，相邻版本之间的差异不能超过O(1)</p><p>所有AVL树可以染成红黑树，但并不是所有红黑树都是AVL树</p><h3 id="红黑树：结构"><a href="#红黑树：结构" class="headerlink" title="红黑树：结构"></a>红黑树：结构</h3><p>由红黑两类节点组成的BST(统一增设外部节点NULL,使之成为真二叉树)</p><ol><li>树根：必为黑色</li><li>外部节点：均为黑色</li><li>其余节点：若为红色，则只能有黑色孩子和黑色父亲</li><li>外部节点到根：途中黑节点数量相等</li></ol><p>提升变换：把红节点提升至父节点的高度，所有底层的节点沿同一水平高度平齐分布，黑节点与其红孩子合并为超级节点<br>故 红黑树等价于(2,4)-树</p><p>B-树平衡 &#x3D;&gt; 红黑树平衡<br>定理：包含n个内部节点的红黑树T<br>高度h &#x3D; O(logn), log2(n + 1) &lt;&#x3D; h &lt;&#x3D; 2 * log2(n + 1)</p><p>接口：</p><h3 id="红黑树：搜索"><a href="#红黑树：搜索" class="headerlink" title="红黑树：搜索"></a>红黑树：搜索</h3><p>继承BST</p><h3 id="红黑树：插入"><a href="#红黑树：插入" class="headerlink" title="红黑树：插入"></a>红黑树：插入</h3><p>会出现双红缺陷</p><p>RR-1：插入节点的叔父节点为黑</p><ol><li>参考AVL树算法做局部3+4重构</li><li>染色：b转黑，a、c转红<br>B-树拓扑结构不变，只变色，复杂度为O(1)</li></ol><p>RR-2：叔父节点为红<br>此时会出现双红缺陷(在B-树中等效于超级节点发生上溢)<br>p与u转黑，g转红(在B-树中等效于节点分裂，关键码g上升一层)</p><p>双红缺陷复杂度：重构、染色均属常数时间的局部操作，故只需统计其总次数<br>每一次插入都可在O(logn)时间内完成，至多要</p><ol><li>O(logn)次节点染色</li><li>一次3+4重构</li></ol><h3 id="红黑树：删除"><a href="#红黑树：删除" class="headerlink" title="红黑树：删除"></a>红黑树：删除</h3><p>会出现双黑缺陷<br>双黑缺陷：删除的节点x为黑，顶替的孩子r也为黑，全树黑深度改变(等效于B-树中x节点下溢)<br>考察删除x后r的兄弟s和r的父亲p</p><p>BB-1：s为黑，且至少有一个红孩子t</p><ol><li>3+4重构：t,s,p重命名为a,b,c</li><li>r保持黑，a、c染黑，b继承p<br>(与zig-zag类似)</li></ol><p>BB-2R：s为黑，且两个孩子均为黑，p为红<br>r保持黑，s转红，p转黑<br>(与合并类似)<br>合并前p的左右关键码有且仅有一个黑色，红黑树全局恢复</p><p>BB-2B：s为黑，且两个孩子均为黑，p为黑<br>s转红，r、p保持黑<br>(下层下溢引发上层下溢)</p><p>BB-3：s为红，其孩子均为黑<br>红s转黑，黑p转红<br>(zag(p),zig(p))<br>此转换将转为BB-1或BB-2R，不会转为BB-2B<br>再经一轮，红黑树全局恢复</p><p>双黑缺陷复杂度：重构、染色均属常数时间的局部操作，故只需统计其总次数<br>每一次插入都可在O(logn)时间内完成，至多要</p><ol><li>O(logn)次节点染色</li><li>一次3+4重构</li><li>一次单旋</li></ol>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年6月26日</title>
    <link href="/2022/06/26/diary/2022.6/2022%E5%B9%B46%E6%9C%8826%E6%97%A5/"/>
    <url>/2022/06/26/diary/2022.6/2022%E5%B9%B46%E6%9C%8826%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="2c2af33b8bfa9d06a2b2de21e889d0b6809fc712475e2525aa071d00fc4820d4">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe5098306ebfcb83a3085b668fcba048aa0c911866639062c0e1c816d1b93de604238404a9e8b570f48b57ace99f7cda040b726a818216d08c53db7929f5baf1f1bbc056c4e327b56eb3e7892f97d94a48603084ebb24346d4393def78789f5674f7baf1579ba99e7ac989443cdf791e512f44eff71581114f181f00c94ef3e6d494c4a0eedc42c747a981ac15dedec59544</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生命周期函数</title>
    <link href="/2022/06/26/Unity/Unity%E5%85%A5%E9%97%A8/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/"/>
    <url>/2022/06/26/Unity/Unity%E5%85%A5%E9%97%A8/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>生命周期函数</p><span id="more"></span><h1 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h1><h2 id="帧的概念"><a href="#帧的概念" class="headerlink" title="帧的概念"></a>帧的概念</h2><p>游戏的本质就是一个死循环<br>每一次循环处理游戏逻辑就会更新一次画面<br>之所以能看到画面在动是因为切换画面的速度达到一定时人眼就会认为画面是流畅的<br>一帧就是执行一次循环</p><p>fps(Frame Per Second)即每秒钟帧数<br>一般我们说的60帧30帧意思是1秒更新60次30次画面<br>1s &#x3D; 1000ms<br>60帧：1帧为 1000ms&#x2F;60 ≈ 16.66ms<br>30帧：1帧为 1000ms&#x2F;30 ≈ 33.33ms</p><p>人眼舒适放松时可视帧数为24帧</p><p>游戏卡顿的原因：<br>跑一帧游戏逻辑中的计算量过大<br>或者CPU不给力，不能在一帧的时间内处理完所有游戏逻辑</p><p>unity底层已经帮助我们做好了死循环<br>需要利用unity的生命周期函数执行游戏逻辑</p><h2 id="生命周期函数的概念"><a href="#生命周期函数的概念" class="headerlink" title="生命周期函数的概念"></a>生命周期函数的概念</h2><p>所有继承MonoBehavior的脚本 最终都会挂载到GameObject游戏对象上<br>生命周期函数就是该脚本对象衣服的GameObject对象从出生到消亡的整个生命周期中<br>会通过反射自动调用的一些特殊函数</p><p>unity记录了一个GameObject对象衣服了哪些脚本<br>会自动的得到这些对象，通过反射去执行一些固定名字的函数</p><p>注意：生命周期函数的访问修饰符一般为private和protected<br>因为不需要在外部自己调用生命周期函数 unity自己帮助我们调用的</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System.Collections;using System.Collections.Generic;using UnityEngine;public class Lesson生命周期函数 : MonoBehaviour&#123;    &#x2F;&#x2F;当对象(自己这个类对象)被创建时，才会调用该生命周期函数    &#x2F;&#x2F;类似构造函数的存在，我们可以在一个类对象创建时进行一下初始化操作    private void Awake()    &#123;        &#x2F;&#x2F;在unity中打印信息的两种方式        &#x2F;&#x2F;1.没有继承MonoBehaviour类的时候        &#x2F;&#x2F;Debug.Log(&quot;123&quot;);        &#x2F;&#x2F;Debug.LogError(&quot;出错&quot;);        &#x2F;&#x2F;Debug.LogWarning(&quot;警告&quot;);        &#x2F;&#x2F;2.继承MonoBehaviour类的时候 有一个现成的方法可以使用        print(&quot;Awake&quot;);    &#125;    &#x2F;&#x2F;想要当一个对象被激活时，进行一些逻辑处理，就可以写在这个函数中    private void OnEnable()    &#123;        print(&quot;OnEnable&quot;);    &#125;    &#x2F;&#x2F;主要作用还是用于初始化信息的，但是相对于Awake来说要晚一点    &#x2F;&#x2F;因为他是在对象进行第一次帧更新之前才会执行的    void Start()    &#123;        print(&quot;Start&quot;);    &#125;    &#x2F;&#x2F;它主要是用于 进行物理帧更新    &#x2F;&#x2F;它是每一帧执行的 但是这里的帧和游戏帧有所不同    private void FixedUpdate()    &#123;        &#x2F;&#x2F;改变 Edit\Project Settings\Time\Fixed Timestep 可以改变更新速度        print(&quot;FixedUpdate&quot;);    &#125;    &#x2F;&#x2F;主要是用于处理游戏核心逻辑更新的函数    void Update()    &#123;        print(&quot;Update&quot;);    &#125;    &#x2F;&#x2F;一般这个更新是用来处理 摄像机位置更新相关内容的    &#x2F;&#x2F;Update和LateUpdate之间 unity进行了一些处理动画相关的更新    private void LateUpdate()    &#123;        print(&quot;LateUpdate&quot;);    &#125;    &#x2F;&#x2F;对象失活的函数处理    private void OnDisable()    &#123;        print(&quot;OnDisable&quot;);    &#125;    &#x2F;&#x2F;对象销毁时调用    private void OnDestroy()    &#123;        print(&quot;OnDestroy&quot;);    &#125;&#125;&#125;</code></pre></div><h2 id="生命周期函数支持继承多态"><a href="#生命周期函数支持继承多态" class="headerlink" title="生命周期函数支持继承多态"></a>生命周期函数支持继承多态</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这些生命周期函数，如果不需要在里面写逻辑，那么就不要在脚本中声明出来</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/06/26/Unity/Unity%E5%85%A5%E9%97%A8/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><p>Awake -&gt; OnEnable -&gt; Start -&gt; FixedUpdate -&gt; Update -&gt; LateUpdate -&gt; OnDisable -&gt; OnDestory</p><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><p>unity帮助我们记录了场景上的所有GameObject对象以及各个关联的脚本对象，在游戏执行的特定时机(对象创建时，失活激活时，帧更新时)，他会通过函数名反射得到脚本对象中对应的生命周期函数，然后在这些特定时机执行他们</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年6月25日</title>
    <link href="/2022/06/25/diary/2022.6/2022%E5%B9%B46%E6%9C%8825%E6%97%A5/"/>
    <url>/2022/06/25/diary/2022.6/2022%E5%B9%B46%E6%9C%8825%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="481a0bdf577d37da9853dce86c6307f26e38c4f81f261525fd343b502d1c48ab">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50b15c372e5e78839a27e9a76ad4deeb9284d11ec657562fee661305fe34e0b0ff0a5c311ee5eeb7cf658915b9c99f0d3d6371c37250dbae6f03e20dd217723a1faf4c253d6608bda16a76a85704c8413bf7b06727ba40754d0c17f3ac20262565496b3c981ab306df8661fca3e8981ebc26c8569068afc38efa7ff50fad690b50192c586c916fc04107bd1a4cbe33302618191994a53521fa50496d7b44c5692f33f46609e05557ebf48d4413e65673bb8278af598fe3adc092d2ddca56628d3d0be4b07421696034bbb3b84f2ce2fbee67acb684a8454f905c12b3c923d2e059cadf8911d8bc6ab01c3ad53fb7477b6901157bc8ee527104894a68a95dcd6cd558ab3e707f1eab1ad8989fb9976b804d6459b725158dae2aaa07c8a5884d4104</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年6月24日</title>
    <link href="/2022/06/24/diary/2022.6/2022%E5%B9%B46%E6%9C%8824%E6%97%A5/"/>
    <url>/2022/06/24/diary/2022.6/2022%E5%B9%B46%E6%9C%8824%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="0dc4c865a82d56523a64e6468fd2b5ab30d40e306d6d0e47b5590b0b1a74bcb4">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50d65263e7513481dc56266ffad57fcfaf564a00c2986007bd0524d5a2120cbff063b7c9a76411c127225c26f7c8b5a2226fe5912ffe2d4550d9a4e6e5c15bfd4f2f27299ea3b3f5df8b8c4ec4357a1cffc47c7f26e43744349507fb8256cfa6e4</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年6月23日</title>
    <link href="/2022/06/23/diary/2022.6/2022%E5%B9%B46%E6%9C%8823%E6%97%A5/"/>
    <url>/2022/06/23/diary/2022.6/2022%E5%B9%B46%E6%9C%8823%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="9fdcf02f2765edafb29a6db7456dbb80248c83e9d3bf9ff6c23283671fd29886">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe5070532c8e4114bd9c03d18d2a56193c5e1f09f8c3d2f234a13cc7981f259bf6f59462fc009c94e30f07638068339268e801fb0fefad4a5445b1557a3e31caf43c4e774c022ad81ee5c8ba14d307f05c0e07b58ad814c8e9895f903bb5755d3cad3ba4db274f14124ee5227425c8f309a71ac82351b97dad957e09bf61b096352331f158744d8f07dc489b90d40554ea373c1afee6dfddc81df275a93fabaaf89b91a4f6a40e2a12f12b1037a7a85426fb3e5051ce66ac62c8ae49f8518c9008442f8db475e222d0406292ebb11fccda837796b0dee662b5edc6774cf8faf76185dc766803ea14f278d2347508adf4022def9d03c1b9179b136347010dac5ea15187e4dd75ce8f86e1c5120c6169b96da9583cf9f31ba3f376a7b76caf54af85d653560da62cfc56eb5ae8ab112e3a4b48a648aa6cf09c7b0a4f2702f966f38175d88226b0f405340628036a5121c786dc9333ba0cfa91ffbc53171b347331cf6a9c3ea4e12b55b790b272e2e0667aef7f1f6dedfec255c0b9768e73b4a16a04bdbc8e97d06c203fb692ca71cfe9d4f42f95dec4e68225cafccb71d1760c6cd88a253dc404d8d111ee574ab9896612022ee2688524b1c693d4cadc8ffbd17472234f38ef01397e326986088198bd44e2a6d713d915045667de5636d04f7afc996e0d4d510ca125a387397d03270beb83cb60f6332ecb8095a9aa42e2a0e9692d041addecb68d372820075e38db2cc64c35751ea5257c10a5a5c63d53d03c6bdc1b09df0402d9342f6fd66fcfd11a412287</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年6月22日</title>
    <link href="/2022/06/22/diary/2022.6/2022%E5%B9%B46%E6%9C%8822%E6%97%A5/"/>
    <url>/2022/06/22/diary/2022.6/2022%E5%B9%B46%E6%9C%8822%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="94fde847809bc5787c49372735a2dae99c48cdf92525bbab77e4ba8c96c5b0b5">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe500c1a2d71992cefe312d1a6e87b777fcf78cc60ba4fc20f8eb54f4d0ac77c469a600e6d8d61ae21f80cb802b2633947d6638a312d0e5a333cfb255c553ef473c4e405c0ddae268d3711bb9ec599b4a1b464927370cfcb7df2c7be3ab0947dc1e963512838f5200a835b48d4c04c633d565c93a5c2ccef5e9a92972bb93351d4a6a1be5fcd3eef150b3dc2f05e636eb106e101eb4f7171fa646c3a45d046fa7ef13e4485b921b599869ad76c2e5e44d25646a925c6e93c6ee95a0a8b08752c976fbecc8d3987f9fc18fb57564fa461090137ec84770cf6aabe6e089a7e0276b014d7998ba3e0c59fa5b944f97a2a4005c27dbfc58a1731e47e4e54aca474021ef9665a0ac15100cf68c9751e4904a671dc702ed2ebeb311f1c1674727642642c37afdaa2e098b4929c014f834e84211281800c4dbd2b9cf18ae9b32fcc2ef2d478e3d4400639dc40485e77186a40902cee99ec273a2203c71bec65c062cca975ac544039570f36c166d7bebc4fe007cc066f430caa09dca42862d28a2089cf1834a7ca8c6c169d986868be6908aeb8c66fe96c65d4cd6ff42e98a1c53d68ae6f7ee213767402b66677a42ea198562f8f49</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>脚本基本规则</title>
    <link href="/2022/06/22/Unity/Unity%E5%85%A5%E9%97%A8/%E8%84%9A%E6%9C%AC%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99/"/>
    <url>/2022/06/22/Unity/Unity%E5%85%A5%E9%97%A8/%E8%84%9A%E6%9C%AC%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99/</url>
    
    <content type="html"><![CDATA[<p>脚本基本规则</p><span id="more"></span><h1 id="脚本基本规则"><a href="#脚本基本规则" class="headerlink" title="脚本基本规则"></a>脚本基本规则</h1><p>设置编程用工具：<br>Edit&#x2F;Preferences&#x2F;External Tools</p><h2 id="创建规则"><a href="#创建规则" class="headerlink" title="创建规则"></a>创建规则</h2><ol><li>不在VS中创建脚本了</li><li>可以放在Assets文件夹下的任何位置(建议同一文件夹管理)</li><li>类名和文件名必须一致，不然不能挂载(因为反射机制创建对象，会通过文件名去找Type)</li><li>建议不要使用中文名</li><li>没有特殊需求，不用管命名空间</li><li>创建的脚本默认继承MonoBehavior</li></ol><h2 id="MonoBehavior基类"><a href="#MonoBehavior基类" class="headerlink" title="MonoBehavior基类"></a>MonoBehavior基类</h2><ol><li>创建的脚本默认都继承MonoBehavior，继承了它才能够挂载在GameObject上</li><li>继承了MonoBehavior的脚本不能new，只能挂载</li><li>继承了MonoBehavior的脚本不要去写构造函数，因为我们不会去new，写构造函数没有任何意义</li><li>继承了MonoBehavior的脚本可以在一个对象上挂多个(如果没有加DisallowMultipleComponent特性)</li><li>继承MonoBehavior的类也可以再次被继承，遵循面向对象继承多态的规则</li></ol><h2 id="不继承MonoBehavior的类"><a href="#不继承MonoBehavior的类" class="headerlink" title="不继承MonoBehavior的类"></a>不继承MonoBehavior的类</h2><ol><li>不继承MonoBehavior的类，不能挂载在GameObject上</li><li>不继承MonoBehavior的类，想怎么写怎么写，如果要使用需要自己new</li><li>不继承MonoBehavior的类，一般是单例模式的类(用于管理模块)，或者数据结构类(用于存储数据)</li><li>不继承MonoBehavior的类，不用保留默认出现的几个函数</li></ol><h2 id="执行的先后顺序"><a href="#执行的先后顺序" class="headerlink" title="执行的先后顺序"></a>执行的先后顺序</h2><p>选中脚本，在Inspector窗口中选择Execution Order，点击+号可以加入脚本的运行顺序</p><h2 id="默认脚本内容"><a href="#默认脚本内容" class="headerlink" title="默认脚本内容"></a>默认脚本内容</h2><p>Editor\Data\Resources\ScriptTemplates</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/06/22/Unity/Unity%E5%85%A5%E9%97%A8/%E8%84%9A%E6%9C%AC%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><p>因为MonoBehavior不能new，只能挂<br>我们不会通过构造函数实例化对象，写构造函数没有意义</p><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><ol><li>这是unity定好的规则</li><li>继承MonoBehavior的类只能挂载在GameObject上配合使用</li></ol><h2 id="题3"><a href="#题3" class="headerlink" title="题3"></a>题3</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;&#x2F; &lt;summary&gt;&#x2F;&#x2F;&#x2F; 玩家信息类&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;public class PlayerInfo&#123;    public string name;    public bool sex;    public int atk;    public int def;    public int hp;    public int maxHp;&#125;</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;&#x2F; &lt;summary&gt;&#x2F;&#x2F;&#x2F; 怪物管理类&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;public class MonsterMgr&#123;    private static MonsterMgr instance &#x3D; new MonsterMgr();    private static MonsterMgr Instance &#x3D;&gt; instance;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉搜索树</title>
    <link href="/2022/06/22/DataStructure/Tree/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2022/06/22/DataStructure/Tree/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>二叉搜索树</p><span id="more"></span><h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><p>二叉搜索树(binary serach tree, BST)<br>扩展为平衡二叉搜索树(balanced binary serach tree, BBST)</p><h2 id="循关键码访问"><a href="#循关键码访问" class="headerlink" title="循关键码访问"></a>循关键码访问</h2><p>数据项之间，按照格子的<strong>关键码</strong>(key)彼此区分  (call-by-key)<br>条件：关键码之间支持<strong>大小比较</strong>与<strong>相等比对</strong></p><p>节点 ≈ 词条 ≈ 关键码</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>顺序性： 任意节点均不小于&#x2F;不大于其左&#x2F;右后代<br>虽是局部特征刻画，但能推广到整体</p><p>注：</p><ol><li>只含单个节点的二叉树一定是BST</li><li>即使只有单分支，但满足顺序性，也是BST</li></ol><p>单调性： BST的<strong>中序</strong>遍历序列，必然<strong>单调</strong>非降</p><h2 id="BST：查找"><a href="#BST：查找" class="headerlink" title="BST：查找"></a>BST：查找</h2><p>减而治之：从根节点出发，逐步缩小查找范围，直到发现目标(指向_hot父节点，目标是它的孩子)&#x2F;或寻找到空null<br>对照中序遍历序列，可以看做整个仿效有序向量的二分查找</p><h2 id="BST：插入"><a href="#BST：插入" class="headerlink" title="BST：插入"></a>BST：插入</h2><p>通过查找达到需插入的父节点(_hot)，返回父节点下的空引用，进行插入</p><h2 id="BST：删除"><a href="#BST：删除" class="headerlink" title="BST：删除"></a>BST：删除</h2><p>单分支情况（待删除节点至多只有一个孩子）：若没有孩子则直接Remove，有孩子则把指向的_hot位置内容改为孩子内容</p><p>双分支情况：找到待删除节点的后续节点，与之交换，若该后续节点存在孩子，再与之孩子交换，而_hot会指向实际删除节点的父亲<br>实际删除的是  中序遍历下的直接后续节点 &#x3D; 右子树中左侧分支的最后一个节点</p><h1 id="平衡二叉搜索树-BBST"><a href="#平衡二叉搜索树-BBST" class="headerlink" title="平衡二叉搜索树(BBST)"></a>平衡二叉搜索树(BBST)</h1><h2 id="平衡"><a href="#平衡" class="headerlink" title="平衡"></a>平衡</h2><p>对于一个关键码总数为n：<br>可能<strong>随机生成</strong>(有重复)的BST为 n! 个，平均高度为 O(logn)<br>可能<strong>随机组成</strong>(互异拓扑)的BST为 Catalan(n) 个，平均高度为 O(√n)</p><h2 id="理想平衡"><a href="#理想平衡" class="headerlink" title="理想平衡"></a>理想平衡</h2><p>节点数目固定时，兄弟子树高度越接近平衡，全树也倾向于更低<br>由n个节点组成的二叉树，高度不低于 O(logn)<br>当恰为 O(logn) 时，成为理想平衡</p><h2 id="适度平衡"><a href="#适度平衡" class="headerlink" title="适度平衡"></a>适度平衡</h2><p>由于理解平衡出现概率极低，维护成本过高<br>因此适当放松标准，令高度渐进地不超过 O(logn)<br>如此构造的BST称为平衡二叉搜索树(BBST)</p><h2 id="等价变换"><a href="#等价变换" class="headerlink" title="等价变换"></a>等价变换</h2><p>利用中序遍历序列的歧义性，将BST转换为等价的BBST<br>(上下可变，左右不乱)<br>旋转调整：<br>以节点v顺时针( zig(v) )<br>以节点v逆时针( zag(v) )</p><p>等价变换不应超过 O(logn) 次</p><h1 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h1><p>通过重平衡(rebalance)使得每次变换都不会改变平衡二叉搜索树的特性<br>重点为：</p><ol><li>如何界定一种适度平衡特性</li><li>一整套重平衡的技巧和算法</li></ol><p>特点：</p><ol><li>存在平衡因子： balFac(v) &#x3D; height(lc(v)) - height(rc(v)), 且 | balFac(v) | &lt;&#x3D; 1</li><li>左右两个子树都是BBST(子树为空，高度为-1)</li></ol><p>由此，BBST中适度平衡的概念可转换为</p><ol><li>height(AVL) &#x3D; O( logn )</li><li>n &#x3D; Ω(2^height(AVL))</li></ol><p>接口：</p><ol><li>理想平衡：Balanced(x)</li><li>平衡因子：BalFac(x)</li><li>AVL平衡条件：AvlBalanced(x)</li><li>AVL类作为BST的派生类，继承接口：查找(沿用)、插入(重写)、删除(重写)</li></ol><p>注意：</p><ol><li>插入可能导致插入节点的父节点及其祖父节点全失衡</li><li>删除至多导致一个节点失衡</li></ol><p>若是左孩子则左旋，若是右孩子则右旋<br>单旋：只向一边旋转(zigzig&#x2F;zagzag)<br>双旋：会向两边旋转(zigzag&#x2F;zagzig)</p><h2 id="AVL：插入"><a href="#AVL：插入" class="headerlink" title="AVL：插入"></a>AVL：插入</h2><p>同时可有<strong>多个失衡</strong>节点<br>最低者g不低于<strong>x祖父</strong>(_hot指向)<br>g经单旋调整后复衡，子树<strong>高度复原</strong>，更高祖先也必平衡，<strong>全树复衡</strong><br>时间复杂度O(logn)</p><h2 id="AVL：删除"><a href="#AVL：删除" class="headerlink" title="AVL：删除"></a>AVL：删除</h2><p>调整后的新树高度可能会缩短<br>同时至多一个失衡节点g，首个可能就是x的父节点<br>g经单旋调整后复衡，子树<strong>高度未必复原</strong>，更高祖先<strong>仍可能失衡</strong><br>因有失衡传播现象，可能需做O(logn)次调整</p><p>_hot指向被删除节点的父节点<br>删后，从_hot触发逐层向上，依次检查各代祖先<br>一旦发现失衡，调整恢复平衡AvlBalanced</p><h2 id="AVL：3-4重构"><a href="#AVL：3-4重构" class="headerlink" title="AVL：3+4重构"></a>AVL：3+4重构</h2><p>3+4重构算法(connect34)<br>让g(x)为最低的失衡节点，若祖孙三代(g p v)<br>按中序遍历次序，将其重命名为(a &lt; b &lt; c)<br>它们总共拥有4棵互不相交(可能为空)的子树<br>按中序遍历次序，将其命名为(T0 &lt; T1 &lt; T2 &lt; T3)</p><h2 id="AVL：旋转"><a href="#AVL：旋转" class="headerlink" title="AVL：旋转"></a>AVL：旋转</h2><p>旋转(RemoveAt)：调用3+4重构</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>优点：无论查找&#x2F;删除&#x2F;插入，最坏情况下复杂度为O(logn),内存O(n)<br>缺点：</p><ol><li>需要借助平衡因子(改造元素结构&#x2F;需要额外封装)</li><li>实测性能与理论性能差异大</li><li>单次动态调整后，全树拓扑结构的变化量可能高达O(logn)</li></ol>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>预设体和资源包的导入导出</title>
    <link href="/2022/06/21/Unity/Unity%E5%85%A5%E9%97%A8/%E9%A2%84%E8%AE%BE%E4%BD%93%E5%92%8C%E8%B5%84%E6%BA%90%E5%8C%85%E7%9A%84%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"/>
    <url>/2022/06/21/Unity/Unity%E5%85%A5%E9%97%A8/%E9%A2%84%E8%AE%BE%E4%BD%93%E5%92%8C%E8%B5%84%E6%BA%90%E5%8C%85%E7%9A%84%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<p>预设体和资源包的导入导出</p><span id="more"></span><h1 id="预设体和资源包的导入导出"><a href="#预设体和资源包的导入导出" class="headerlink" title="预设体和资源包的导入导出"></a>预设体和资源包的导入导出</h1><h2 id="预设体-预制体"><a href="#预设体-预制体" class="headerlink" title="预设体(预制体)"></a>预设体(预制体)</h2><p>预设体(预制体)是预先设置好的物体<br>后缀为prefab</p><p>创建预设体： 把制作好的组合体拖入到Assets文件夹中<br>修改预设体： 选中Hierarchy中想要修改的预设体，Prefab那一栏中Overrides可以选择 Revert All(重置所有) 或 Apply All(接受所有修改)<br>删除预设体： 点击Open Prefab，进入预设体Scene进行操作(会改变所有的预设体)  &#x2F;  右键Hierarchy中想要修改的预设，选择Unpack Prefab，解除预设体进行修改(只改变当前的对象)</p><h2 id="资源包的导入和导出"><a href="#资源包的导入和导出" class="headerlink" title="资源包的导入和导出"></a>资源包的导入和导出</h2><p>在Project窗口的空处，右键<br>Import Package: 导入资源包<br>Export Package: 导出资源包</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年6月21日</title>
    <link href="/2022/06/21/diary/2022.6/2022%E5%B9%B46%E6%9C%8821%E6%97%A5/"/>
    <url>/2022/06/21/diary/2022.6/2022%E5%B9%B46%E6%9C%8821%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="1747fd9a6f6b04878066c1cf6d6c971001e15d2b185b655da29aa60e42568789">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50f7e9898aee545da037b32ace90f226f72ec9b8e9f85c412ec8f68f7086def86a856a3f0051bd0db5bd36b5f6ff4edd0ea744beebfe2358eaf21e08901701fcf38dc104255e30aba999399550deb88a9f46db74fa35545672de3645915c713ec17dcb01386984fce71a12e2249a514fe8b35eef47d9d4e569a458861c7a1b7a92d66cc5ac4e3ecfef75e6403709b0826e19b7c474742f9500eb8a7104ef4a23bf9e00b245a545787992bac63ba6f9912a0ce1ee5c77a14b0fdcef922b1a775fbee660d28b7c39af1ccf8f3469a1aac1f2a29328fdb1004b7f2f541138f8eb82ad58cf9b09c1a2845d728b59539092fe7be7027a95fb6ddb61cbea51d79db17ff84795bf3c95a06544b3f7fa574d67d5432f2e600b311d5e3bb988581381e1443131a84b488e3135d54af1c26f46e634878df9923e60bd6344ff422cea160b2682f41034f94d5c2f697415959beced48a6db4a35acaeeecd3c39c5bc1c079fc9e28190b77e9f5a80a43360e8a19353d0c9ba08ae896197dcbbd466a4560b5bf247</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反射机制和游戏场景</title>
    <link href="/2022/06/20/Unity/Unity%E5%85%A5%E9%97%A8/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%92%8C%E6%B8%B8%E6%88%8F%E5%9C%BA%E6%99%AF/"/>
    <url>/2022/06/20/Unity/Unity%E5%85%A5%E9%97%A8/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%92%8C%E6%B8%B8%E6%88%8F%E5%9C%BA%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<p>反射机制和游戏场景</p><span id="more"></span><h1 id="反射机制和游戏场景"><a href="#反射机制和游戏场景" class="headerlink" title="反射机制和游戏场景"></a>反射机制和游戏场景</h1><h2 id="场景中对象的本质"><a href="#场景中对象的本质" class="headerlink" title="场景中对象的本质"></a>场景中对象的本质</h2><p>GameObject类对象是Unity引擎提供的，作为场景中所有对象的根本<br>在游戏场景中出现一个对象，不管是图片、模型、音效、摄像机等等都是依附于GameObject对象的</p><p>举例体现：<br>前提：Unity已经实现了对象查找和关联</p><ol><li>修改Inspector面板中Transform的内容<br>利用反射：已知对象，类名，变量名，通过反射为该对象设置变量值</li><li>新建一个脚本后，添加给一个指定的GameObject对象<br>利用反射：已知类名，可以获取所有公共成员，故可以在Inspector面板上创建各公共字段信息</li></ol><h2 id="游戏场景的本质"><a href="#游戏场景的本质" class="headerlink" title="游戏场景的本质"></a>游戏场景的本质</h2><p>游戏场景文件后缀为.unity<br>它的本质就是一个配置文件<br>Unity有一套自己识别处理它的机制<br>本质就是把场景对象相关信息读取出来，通过反射来创建各个对象关联各个脚本对象</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>unity的工作机制<br>本质就是利用反射，动态的创建GameObject对象并且关联各种C#脚本对象在其之上<br>让不同的GameObject对象各司其职扮演好自己的角色<br>根据unity提供以及我们书写的剧本(C#脚本)，呈现一出游戏戏剧</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年6月20日</title>
    <link href="/2022/06/20/diary/2022.6/2022%E5%B9%B46%E6%9C%8820%E6%97%A5/"/>
    <url>/2022/06/20/diary/2022.6/2022%E5%B9%B46%E6%9C%8820%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="e6ceb9adc66a49f5d94a9f4b4acf26ce97731701b2d8f2e5dab55de3890d1365">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe506c3b09322422576395ab679632643e7f84c4be0dd9ea5fc1248408384266ee181352923f338df02dd88cc50b2e3f1039df660e1fa81cf418a070b42bb07fcf05f6ef23264a1b7d3055cd54a362ec8baeee0fb421557dc4ede399c404debade6b1427265ce5dff556ea114dd516b203b036c8e64e461d081ad4d3a4d212846cd9f1b915ed44b4ff112af9b8403961ccdd260f0b7e19fcc463782ca68c51a3089f90ed8c996ef130b95307ae33f09214ac8f3e86eb1219948169cbcbbdf3f562fce9aee63b3b64cdb6c2a29ca7cad16235c141b5627377c2312885fe49d2b5c47c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图</title>
    <link href="/2022/06/20/DataStructure/Tree/%E5%9B%BE/"/>
    <url>/2022/06/20/DataStructure/Tree/%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p>图</p><span id="more"></span><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>G &#x3D; (V; E)  其中V为点, E为边</p><p>邻接(adjacency): 点-点关系<br>关联(incidence): 点-边关系</p><h2 id="无向图和有向图"><a href="#无向图和有向图" class="headerlink" title="无向图和有向图"></a>无向图和有向图</h2><p>无向图(undigraph): 若邻接顶点u和v的次序无所谓, 则(u, v)为无向边(undirected edge), 所有边均无方向的图，即无向图<br>有向图(digraph): 图中均为有向边，边有头和尾</p><p>路径 π &#x3D; &lt;v0, v1, …, vk&gt; , 长度 |π| &#x3D; k<br>简单路径: 不含重复节点</p><p>环路<br>简单环路: 不经过重复边<br>欧拉环路: 经过每个顶点一次<br>哈密尔顿环路: 经过所有边一次</p><h2 id="BFS-DFS和拓扑排序"><a href="#BFS-DFS和拓扑排序" class="headerlink" title="BFS, DFS和拓扑排序"></a>BFS, DFS和拓扑排序</h2><p>BFS:<br>复杂度: 理论上 O(n^2 + e), 实际上 O(n + e)</p><p>DFS:<br>两类时间dtime, ftime, 递归， 多可达域<br>嵌套引理: 祖先的活跃期覆盖后代<br>Tree的边的数量总是 &#x3D; 定点数 - 联通分量的数量 </p><p>拓扑排序:<br>有向无环图必有拓扑排序<br>零入度点 顺序输出: 从入度为0的顶点开始，压入栈，并取一个空队列，迭代<br>零出度点 逆序输出: 从出度为0的顶点开始，压入栈，迭代</p><h1 id="图应用"><a href="#图应用" class="headerlink" title="图应用"></a>图应用</h1><h2 id="双连通分量"><a href="#双连通分量" class="headerlink" title="双连通分量"></a>双连通分量</h2><p>双连通分量(biconnected component, 简称bcc)<br>在一个无向图中，若任意两点间至少存在两条“点不重复”的路径，则说这个图是点双连通的（简称双连通,biconnected）<br>在一个无向图中，点双连通的极大子图称为点双连通分量（简称双连通分量,Biconnected Component,BCC）</p><p>点双连通和边双连通：</p><ol><li>连通的概念：在无向图中，所有点能互相到达</li><li>连通分量：互相联通的子图</li><li>点双连通：删掉一个点之后，图仍联通</li><li>边双连通：删掉一条边之后，图仍联通</li></ol><p>性质：</p><ol><li>任意两点间至少存在两条点不重复的路径等价于图中删去任意一个点都不会改变图的连通性，即BCC中无割点</li><li>若BCC间有公共点，则公共点为原图的割点</li><li>无向连通图中割点一定属于至少两个BCC，非割点只属于一个BCC</li></ol><p>对于每个BCC，它在DFS树中最先被发现的点一定是割点或DFS树的树根</p><h2 id="优先级搜索"><a href="#优先级搜索" class="headerlink" title="优先级搜索"></a>优先级搜索</h2><p>优先级搜索(Priority First Search)<br>不同的遍历算法的区别，取决于顶点的选取策略。不同的顶点选取策略，取决于存放和提供顶点的数据结构。<br>每个顶点都有初始的优先级数，并可能随着算法的推进而调整。通常的习惯是，优先级数越大&#x2F;小，优先级越低&#x2F;高<br>特别的，priority(v) &#x3D;&#x3D; INT_MAX, 意味着v的优先级最低</p><p>Dijkstra算法：最短路径树</p><ol><li><p>给定：连通有向图G及其中的顶点u和v</p></li><li><p>找到：从u到v的最短路径及其长度</p></li><li><p>给定顶点s，计算s到其余各个顶点的最短路径及长度</p></li><li><p>套用PFS框架，为将Tk扩充至Tk+1，只需选出优先级最高的跨边ek及其对应顶点vk，并将其加入Tk，随后更新Vk\Vk+1中所有顶点的优先级数</p></li><li><p>注意，优先级数随后可能改变的顶点，必与vk邻接</p></li><li><p>因此，只需枚举vk的每一邻接顶点v，并取priority(v) &#x3D; min(priority(v), priority(vk) + ||vk, v||)</p></li><li><p>以上完全符合PFS框架，唯一要做的工作无非是按照prioUpdater()规范，编写一个优先级更新器</p></li></ol><p>prim算法：最小生成树<br>最小支撑树：</p><ol><li>连通网络N &#x3D; (V; E)的子图T &#x3D; (V; F)</li><li>支撑&#x2F;spanning &#x3D; 覆盖N中所有顶点</li><li>树，连通且无环，|V| &#x3D; |F| + 1;加边出单环，再删除同环边即恢复为树；删边不连通，再加联通边即恢复为树</li><li>同一网络的支撑树不唯一，对负边也适用</li></ol><p>割&amp;极短跨边<br>设（U; V \ U）是N的一个割(Cut），即将点集划分为两个集合<br>若uv是该割的一条极短跨边，则必存在一颗包含uv的MST</p><p>递增式构造,套用PFS框架</p><ol><li>选出优先级最高的跨边ek及其对应顶点vk，并将其加入Tk，随后，更新V\Vk中所有顶点的优先级</li><li>注意，优先级数随后可能改变的顶点，必与vk邻接</li><li>因此，只需枚举vk的每一邻接顶点v，并取priority(v) &#x3D; min(priority(v), ||vk, v||)</li><li>以上完全符合PFS规范，唯一要做的就是按照prioUpdate()规范，编写一个改变优先级的函数</li></ol>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工具栏和父子关系</title>
    <link href="/2022/06/19/Unity/Unity%E5%85%A5%E9%97%A8/%E5%B7%A5%E5%85%B7%E6%A0%8F%E5%92%8C%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB/"/>
    <url>/2022/06/19/Unity/Unity%E5%85%A5%E9%97%A8/%E5%B7%A5%E5%85%B7%E6%A0%8F%E5%92%8C%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<p>工具栏和父子关系</p><span id="more"></span><h1 id="工具栏和父子关系"><a href="#工具栏和父子关系" class="headerlink" title="工具栏和父子关系"></a>工具栏和父子关系</h1><h2 id="工具栏"><a href="#工具栏" class="headerlink" title="工具栏"></a>工具栏</h2><p>GameObject&#x2F;Move To View ： 将选中对象移动到目前摄像机对着的位置<br>GameObject&#x2F;Align With View ： 将选中对象移动到目前摄像机的位置</p><p>Flie中的重要选项：<br>BuildSetting（工程发布打包）</p><p>Edit中的重要选项： </p><ol><li>Project Setting（工程各系统设置）</li><li>Preferences（首选项，可设置编程软件）</li></ol><p>GameObject中的重要选项：</p><ol><li>Move To View</li><li>Align With View </li><li>Align View to Selected</li></ol><h2 id="父子关系"><a href="#父子关系" class="headerlink" title="父子关系"></a>父子关系</h2><p>对象间的父子关系</p><ol><li>子对象会随着父对象的变化而变化</li><li>子对象Inspector窗口中Transform信息是相对父对象的</li><li>Scene上方 Pivot 和 Global 的作用</li></ol><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/06/19/Unity/Unity%E5%85%A5%E9%97%A8/%E5%B7%A5%E5%85%B7%E6%A0%8F%E5%92%8C%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB/exam.png" class=""><img src="/2022/06/19/Unity/Unity%E5%85%A5%E9%97%A8/%E5%B7%A5%E5%85%B7%E6%A0%8F%E5%92%8C%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB/answer.png" class="">]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Inspector和Console窗口</title>
    <link href="/2022/06/19/Unity/Unity%E5%85%A5%E9%97%A8/Inspector%E5%92%8CConsole%E7%AA%97%E5%8F%A3/"/>
    <url>/2022/06/19/Unity/Unity%E5%85%A5%E9%97%A8/Inspector%E5%92%8CConsole%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<p>Inspector和Console窗口</p><span id="more"></span><h1 id="Inspector和Console窗口"><a href="#Inspector和Console窗口" class="headerlink" title="Inspector和Console窗口"></a>Inspector和Console窗口</h1><p>Inspector检查窗口：查看场景中游戏对象关联的C#脚本信息<br>Console控制台窗口：用于查看调试信息的窗口，报错、警告、测试打印都可以显示在其中</p><h2 id="Inspector检查窗口"><a href="#Inspector检查窗口" class="headerlink" title="Inspector检查窗口"></a>Inspector检查窗口</h2><p>不选择场景中游戏对象或不进行任何相关设置，该界面不会显示任何信息<br>当选择场景中游戏对象事，该界面将显示和该游戏对象关联的C#脚本 </p><p>红色部分： 游戏对象基本设置<br>蓝色部分： 关联的C#脚本<br>绿色部分： 脚本的公共成员变量</p><h2 id="Console窗口"><a href="#Console窗口" class="headerlink" title="Console窗口"></a>Console窗口</h2><p>该窗口将显示代码编译过程中，或者游戏运行过程中的报错、警告、测试信息，主要用于查错和调试用</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年6月19日</title>
    <link href="/2022/06/19/diary/2022.6/2022%E5%B9%B46%E6%9C%8819%E6%97%A5/"/>
    <url>/2022/06/19/diary/2022.6/2022%E5%B9%B46%E6%9C%8819%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="ac685fee2d9669f76b50d8738d1bd28787ea7a2d503056269da87bd6da19929c">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe502f360968c9feb9ddee6ab236ae2f7ae823dc9f5a9a035dfc5de9d8a029587c37a7364c96ab8d87affe73cde16feadc9256dc57054a5a94d707f154f58e9488335fcd4695156765853140f34f4a630f4cd308eb9b62b79825bac9ea0ebcca80969aa3532da0f428b61ba9c7de568e8982d6808f623d88724f0c1ed6576698e7211a1720f85c00deeeb8731daddbf0bee395f8b24b6bba340ceb1e49e7f76cb371070392c48106ef5ec02309de5e46155f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年6月18日</title>
    <link href="/2022/06/18/diary/2022.6/2022%E5%B9%B46%E6%9C%8818%E6%97%A5/"/>
    <url>/2022/06/18/diary/2022.6/2022%E5%B9%B46%E6%9C%8818%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="c65ba0cbe0277d1784c7764ea9ad6a05e433f21236963e9d3882141ea4d0746f">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50f3d9befd224da50ebd33ddda44ff86e0cd4783699ae90746d09355e830d1bd3500866b3cde6b5e215ae7012472f79c8f1d90f6f4055551c836439e7458c3993d88bff2d4be74098c21f5ec1d53c458e2ef613d02a3e42b5684a7ebb982b4b564ea82e277a03cf1a9a65d32e9f46f2a66a5be837627cb0e23bdb04656fad4474414d6b32ec3b3816e808407aa36a10a7b0c26a0918fc1d273c50db711d0d7faa8d473915741011c76b550e2ea31b76332e8f6833fecf03f5565e457c9ee044836b198f72d3f77533d48fe7ea7b46fa540e0d106314187fdecd656202bfb97a5c492302aed1f9f071a2ca133b77479ffdafd44e8a957aa34c30fb71fd3c92bcfa87ae53cc2d1c712a10b49326cc36b9e987731255254f0f76becf99323ba7633d6d83c098db543a87221b275923afa283f486fd7296d0b7ef387b3da71ba5c4018f8ce52dc428ee0d0ff79601736da9155837bd72a0f40df50a1781ee376a7c20d3d58b7383fcd7d7e4512e1b8024e2090</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Game和Project窗口</title>
    <link href="/2022/06/18/Unity/Unity%E5%85%A5%E9%97%A8/Game%E5%92%8CProject%E7%AA%97%E5%8F%A3/"/>
    <url>/2022/06/18/Unity/Unity%E5%85%A5%E9%97%A8/Game%E5%92%8CProject%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<p>Game和Project窗口</p><span id="more"></span><h1 id="Game和Project窗口"><a href="#Game和Project窗口" class="headerlink" title="Game和Project窗口"></a>Game和Project窗口</h1><p>Game游戏窗口： 游戏画面窗口，玩家能看到的画面内容<br>Project工程窗口： 工程资源窗口，所有的工程资源都会在该窗口中显示，显示的内容为Assets文件夹中的所有内容</p><h2 id="Game游戏窗口"><a href="#Game游戏窗口" class="headerlink" title="Game游戏窗口"></a>Game游戏窗口</h2><p>Game游戏窗口中显示的内容是场景中<strong>摄像机</strong>拍摄范围内的游戏对象，是玩家通过屏幕能看到的东西</p><ol><li>引擎中运行游戏</li><li>暂停运行</li><li>逐帧运行</li></ol><ol><li><em>Warn if No Cameras Rendering</em><br>场景中没有摄像机时会发出警告</li><li><em>Clear Every Frame in Edit Mode</em><br>游戏未播放时，也更新Game窗口，避免显示问题</li><li><em>Maximize</em><br>场景最大化</li><li><em>Close Tab</em><br>关闭窗口</li></ol><h2 id="Project工程窗口"><a href="#Project工程窗口" class="headerlink" title="Project工程窗口"></a>Project工程窗口</h2><p>窗口中显示的内容主要是Assets文件夹中的所有内容，主要用来管理资源脚本文件，所有游戏资源都会显示在该窗口中</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/06/18/Unity/Unity%E5%85%A5%E9%97%A8/Game%E5%92%8CProject%E7%AA%97%E5%8F%A3/exam.png" class="">]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年6月17日</title>
    <link href="/2022/06/17/diary/2022.6/2022%E5%B9%B46%E6%9C%8817%E6%97%A5/"/>
    <url>/2022/06/17/diary/2022.6/2022%E5%B9%B46%E6%9C%8817%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="16401207982d456154fe8e3e884cea2dbcbe585ce8c056aab4e27250008f05a8">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50a5541d2fd46387588d34f754efbe0a053b4979b79e7b4be6011b9c58517a9acc505dce8ae22f9ccee80b40f256ea422cc6fb6af7785063815e8879bc5898c652de1e80af8669deb5876fa77f1d77937ec53de9e021a43e1ae36584cb0db4b5a3c25fe569b9283370f0c00efc105d4ca2d5747dbf2f1c8a41617db5b0dbffada913df00680ac26ecbce1b5787c4b8da77f5058672b158db4f34cbe8530ad26b73cf16a505d132416a54579e39a0df1b061bc91953e38bd8d5cb472ae3c8054369fbb62d9ef4803298154111860779fa76912a167fe0526a3662f6ff77c84f2455678adf3d028d43dfe82bb9ebdf7b4864e31833c22721b441aca627d8427b0311bd9de132994c5fc4e9f8f15f30790aa44b8b315b85d00b96174dd0a629bbeb47e1e18dc36d1437564f53e51cd80da1c441dc3a421451e458a15aae6b2a55a8d759360bd9967d312d5329f75aade46742f164d95c32f193569f47364bef95b03cc8980f5307517c413e053068f4425cf2587cf630ddb7234318410ed42ef07d33b39172c4a643e651a95a0266b602e9330e81b56b9911200e0666644ae72080aba3730aae63db0aee39eb0797ac109d3430436ea869103b334e3eccbc728cf261a2a2d6bf5afebdea345fcc480f2bf99d53d203abbc7307bd0cacd39132651f697a47471ce50ca4c5283fa7ed1f5598f7eb6c501af4d4dd765f0426d675c8910150b555c1369b0a94d3ddf0ee2f82170202b6992c6c41a565d8e5d3d0c54f412b45ddf943583b32b11df53e63024f9f5751db0d06b23043db0aa9c13f25d494d4ffd11db53e351010c2f4d419e909126f7f9d8bfb8fa228191a923792f1ec9dd5f66a90d15e267db00e2f23b8666d25e2366de13c19683bd4c7a3226089c1b8951aa164badfe59a8951ba0e16dfcadb5773658508c6d3c0b702e7798087f306a3c0eea47300e10fbf4696303db8028aacec9b1c7faea603e2f1757306af33584d220b7f256e7b904610416651d3968de4a57a8377b67c753472a1e98428acf97441a7808c73e577c28c7c72909a50cde91b43cd66a1444543cd9f44de29373bdf4f93c04fdc3f083c55e3aebc6dfc3470befac9554c849c2b42b2379bfa2dbb737bb4219d1166082e8901c80f66686c6ea6564d2020410c068952e3b3c6352c7c40415255c1d66b9a01b2cf3f5175b2e94ebd97ab0b350ac3f7aa6cf2ee43219f17a918c8a63d920d83826be344a2db61430db2e34e7b372f4162e057393529af0745aeb3b06a054ee9ad54b768b8e2dfe032894850aae0f200b0177708cf91025fd4f1ea972a8889f56778a4724a1ceb6e8285205d6459c496f4b2ac91d517d54c70e007a7b8daa42026f68b7d4a70a879a7135a93efe0e85ba922eedbf809e5e0d471d693bbd03320a1b93731d830c7b917981f28b85d5cc0890104859430eb7165808a3f860e765bbac9e1eb3da22d77410d0b5ecad22f5ba3f34637b33f2f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2022/06/17/DataStructure/Tree/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/06/17/DataStructure/Tree/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>二叉树</p><span id="more"></span><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>树是一个半线性的数据结构(连通无环图)<br>任意子树的高度 &#x3D; 根节点的高度</p><p>度2的树至少3节点，如果只有一个孩子不区分左右</p><p>二叉树即为每个节点均设两个引用</p><p>父+子结构存储n个节点的树，需要空间O(n)</p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>二叉树(binary tree)是有根有序的<br>二叉树可以空，有孩子必区分左右，可以只有左或右</p><h2 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h2><p>先序遍历(preorder)<br>沿着左子树向下遍历<br>沿着右子树向上遍历</p><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>中序遍历(inorder)<br>从最左的节点开始访问，沿右斜向上的方向访问<br>有右子树进右子树</p><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p>后序遍历(postorder)<br>从左右都无法向下的几点开始访问</p><h2 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h2><p>用Queue存储</p><p>根节点先入队<br>while(队列 !&#x3D; null)<br>{<br>    取出首节点访问;<br>    if(有左子节点) 左子节点入队;<br>    if(有右子节点) 右子节点入队;<br>}</p><p>[先序&#x2F;后序]+中序<br>[先序+后序]*真遍历</p><h2 id="Huffman算法"><a href="#Huffman算法" class="headerlink" title="Huffman算法"></a>Huffman算法</h2><p>PFC编码:.</p><ol><li>字符编码不必等长</li><li>不同字符编码互不为前缀</li></ol><p>最优带权编码数：<br>频率高&#x2F;低的字符，应尽可能放在高&#x2F;低处，<br>可通过适当交换，同样靠要缩短wald(T)</p><p>合并树达到最优解</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scene和Hierarchy窗口</title>
    <link href="/2022/06/16/Unity/Unity%E5%85%A5%E9%97%A8/Scene%E5%92%8CHierarchy%E7%AA%97%E5%8F%A3/"/>
    <url>/2022/06/16/Unity/Unity%E5%85%A5%E9%97%A8/Scene%E5%92%8CHierarchy%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<p>Scene和Hierarchy窗口</p><span id="more"></span><h1 id="Scene和Hierarchy窗口"><a href="#Scene和Hierarchy窗口" class="headerlink" title="Scene和Hierarchy窗口"></a>Scene和Hierarchy窗口</h1><h2 id="窗口布局"><a href="#窗口布局" class="headerlink" title="窗口布局"></a>窗口布局</h2><p>右上角 Layout</p><h2 id="Hierarchy层级窗口"><a href="#Hierarchy层级窗口" class="headerlink" title="Hierarchy层级窗口"></a>Hierarchy层级窗口</h2><p>可以在Hierarchy窗口中，创建或拖入各种游戏对象<br>比如：模型、光源、图片、UI等等内容<br>层级窗口中显示的就是一个场景中的所有对象</p><p>窗口中右键&#x2F;点击左上角+号键，可以创建、操作对象</p><p>F2: 对象改名<br>Ctrl+C: 复制<br>Ctrl+V: 粘贴<br>Ctrl+D: 克隆一个<br>Delete: 删除</p><h2 id="Scene场景窗口"><a href="#Scene场景窗口" class="headerlink" title="Scene场景窗口"></a>Scene场景窗口</h2><p>窗口上方工具条内容</p><ol><li>渲染模式</li><li>2D&#x2F;3D视图切换</li><li>光源&#x2F;音效&#x2F;特效显示开启</li><li>辅助线显示</li><li>辅助功能，控制场景上提示图标等</li><li>搜索</li><li>场景轴向</li></ol><h2 id="场景中的操作"><a href="#场景中的操作" class="headerlink" title="场景中的操作"></a>场景中的操作</h2><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>所有的游戏对象都会出现在Scene场景窗口和Hierarchy层级窗口中<br>需要掌握的就是熟练快捷地在Scene窗口中操作游戏物体(位置旋转缩放)</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/06/16/Unity/Unity%E5%85%A5%E9%97%A8/Scene%E5%92%8CHierarchy%E7%AA%97%E5%8F%A3/exam.png" class=""><img src="/2022/06/16/Unity/Unity%E5%85%A5%E9%97%A8/Scene%E5%92%8CHierarchy%E7%AA%97%E5%8F%A3/Mycar.png" class="">]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年6月16日</title>
    <link href="/2022/06/16/diary/2022.6/2022%E5%B9%B46%E6%9C%8816%E6%97%A5/"/>
    <url>/2022/06/16/diary/2022.6/2022%E5%B9%B46%E6%9C%8816%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="ee1198f6c34b7ab873f2b081a85355ced2e3f85bcc1c5816248136bc5142e39e">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe5053b33ce9069442044ac73741f30ec7eb0ecbafbe2f9b1b9406d13b00537a27f9cb47575eab54dde3bb24fcbdf69400727aceae684c0812635c256518c1746c200225b5d7f63b4346ae1cee33aa2d6a578d19f587d5393c1c8dc1cad04533d09affb0328d5e28e42dc4906bf2677f0878e26a5104fb0e99cc3f4d29a8925749f3735c9e64b935dae2b045060c514e96dffe13ffea441e36d97fafeb9e869ca74d1bbcd0c326fc006b21dc7ed860d70831dee57a6212f4b51984d62a77484329c4439e4e16fdc8d6e1b4f92f37a2935de7ac8c47c3a8b9f2e71310fe136e7dbae7</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈和队列</title>
    <link href="/2022/06/16/DataStructure/Vector/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <url>/2022/06/16/DataStructure/Vector/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>栈和队列</p><span id="more"></span><h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h2 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈 Stack"></a>栈 Stack</h2><p>后进先出(LIFO)<br>可用于：1.逆序输出  2.递归嵌套  3.延迟缓冲  4.栈式计算</p><p>进制转换</p><p>括号匹配：采用栈可便捷地推广至多种括号并存的情况</p><p>栈混洗(stack permutation)： &lt;a1, a2, … ,an] &#x3D; A  其中 &lt; 代表栈顶，] 代表栈底<br>总计数： <br>合法括号匹配栈混洗</p><p>中缀表达式求值： 优先级表  乘加括，同符相乘栈内优</p><p>逆波兰表达式 RPN (Reverse Polish Notation)：<br>不适用括号，即可表示带优先级的运算关系</p><h2 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列 Queue"></a>队列 Queue</h2><p>先进先出(FIFO)<br>后进后出(LILO)</p><p>不同n位二进制数个数 &#x3D; 2^n<br>对小括号所能构成的合法括号匹配个数 &#x3D; Catakan(n)<br>{1, 2, 3, …, n}的不同栈混洗个数 &#x3D; Catakan(n)<br>含n个运算符的中缀表达式，运算符栈push次数 &lt;&#x3D; n</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年6月15日</title>
    <link href="/2022/06/15/diary/2022.6/2022%E5%B9%B46%E6%9C%8815%E6%97%A5/"/>
    <url>/2022/06/15/diary/2022.6/2022%E5%B9%B46%E6%9C%8815%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="d525efc2b230a0f97f9df66ece80e12052b33bd225265389e707cac6767cca6c">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50ecab829110ede2524b195b26a687cebadcdb6d4681849ee9f2a8e051c80c7f2bb4bd4a88a3d9e3fffe3fecbf55175a61ca977a67733bda548f96b87419d9105753881d1194274a717fb934dc919c2a4aae5e34a5f9c5b570f7bb8869644a379fd498ae1553c9c43e08337c8ccc406044ad459826b56f732c38bb0fc0b2d572cd13f4b4ab79261352cc8f69cc2248c42b1a8fcf1b82dd2ffcd3f88882dcbed36320c3767ab4dbff7d064b3a2faa344eecbcf63de29bd5c27b9e2201192a92fc4661c65194895224990baaa51b51e0bfa9430bb56377bd7b51295d4ce7c0fad616a6d61604aeffb992a2cfb71b8e2efd9eb3807072da5b027585e8aaab9c8c815582928d70a876b0e978ecdd9ded4ad37cd32262b472be19d5da128098076babe3389a1136a23e7d2c053e21f92c68cef7caa46ad580505b37ac2880bb2de779a9841bff0e57f503e95d38aa95db340a2805f08b4d02c17b9df6ebeb8f2a5f523df22e4e8fd1b550f7cf1efb2267022d76874f831f77d2bc4b69adb91eea5c068d0c473c4938c94efe900215e636d24823b419290867aa59af62298eac81a4b6849de3052ebdcdca633fd987c12994e067c19f10d92141c700b78c44ad36978bf749cb10915aeec4b106af93af254e4d69</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口与实现</title>
    <link href="/2022/06/15/DataStructure/Vector/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/06/15/DataStructure/Vector/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>接口与实现</p><span id="more"></span><h1 id="接口与实现"><a href="#接口与实现" class="headerlink" title="接口与实现"></a>接口与实现</h1><h2 id="从静态到动态"><a href="#从静态到动态" class="headerlink" title="从静态到动态"></a>从静态到动态</h2><p>操作方式根据是否修改数据可分为：</p><ol><li>静态： 仅读取，数据结构的内容及组成一般不变(get, search等)</li><li>动态： 需写入，数据结构的局部或整体将改变(insert, remove等)</li></ol><p>数据元素的存储与组织方式也可分为：</p><ol><li>静态： 数据空间整体创建或销毁，数据元素的<strong>物理存储次序</strong>与<strong>逻辑次序</strong>严格一致，可支持高效的静态操作</li><li>动态： 为各数据元素动态的分配和回收的物理空间，逻辑上相邻的元素记录彼此的物理地址，在逻辑上形成一个整体，可支持高效的动态操作</li></ol><h2 id="从列表到向量"><a href="#从列表到向量" class="headerlink" title="从列表到向量"></a>从列表到向量</h2><p>列表(list)是采用动态存储策略的典型结构，其中的各元素成为节点(node)，在<strong>逻辑</strong>上构成一个线性序列<br>相邻节点彼此互称为前驱(predecessor)或后继(successor)，前驱或后继若存在，则必然唯一<br>没有前驱&#x2F;后继的节点称为首(first&#x2F;front)节点&#x2F;末(last&#x2F;rear)节点</p><h2 id="从秩到位置"><a href="#从秩到位置" class="headerlink" title="从秩到位置"></a>从秩到位置</h2><p>向量支持循秩访问(call-by-rank)<br>根据数据元素的秩可以在O(1)时间内直接确定其物理地址<br>列表也可以通过秩定位，但循秩访问的成本较高，一般使用循位置访问(call-by-position)</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有序查找</title>
    <link href="/2022/06/14/DataStructure/Vector/%E6%9C%89%E5%BA%8F%E6%9F%A5%E6%89%BE/"/>
    <url>/2022/06/14/DataStructure/Vector/%E6%9C%89%E5%BA%8F%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<p>有序查找</p><span id="more"></span><h1 id="有序查找"><a href="#有序查找" class="headerlink" title="有序查找"></a>有序查找</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>binSearch 反复确定中点<br>递归次数： O( log n )<br>查找长度： O( 1.50 * log n )</p><p>但还有改进空间：<br>转向左右分支前的关键码<strong>比较次数</strong>不等，而<strong>递归深度</strong>却相同<br>若能通过<strong>递归深度</strong>的不均衡，对转向成本的不均衡进行<strong>补偿</strong>，平均查找长度应能进一步缩短</p><h2 id="Fibonacci查找"><a href="#Fibonacci查找" class="headerlink" title="Fibonacci查找"></a>Fibonacci查找</h2><p>按黄金分割比切分<br>查找长度： O( 1.44 * log n )</p><h2 id="直接改进二分查找"><a href="#直接改进二分查找" class="headerlink" title="直接改进二分查找"></a>直接改进二分查找</h2><p>将中点的判断归入右侧分支<br>待查找区间缩短至1<br>[lo, mi), [mi, hi)</p><h2 id="再次改进二分查找"><a href="#再次改进二分查找" class="headerlink" title="再次改进二分查找"></a>再次改进二分查找</h2><p>区间宽度缩短至0<br>[lo, mi), (mi, hi)</p><h2 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h2><p>Interpolation Search</p><p>假设：已知有序算法中各元素随机分布的规律<br>则 [lo, hi) 内各元素应大致按照线性趋势增长<br>通过猜测轴点mi，可以极大地提高收敛速度</p><p>最坏情况 O(n)</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>大规模：插值查找 （缩小规模，将问题规模缩小到足够小）<br>中规模：二分查找<br>小规模：顺序查找</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年6月14日</title>
    <link href="/2022/06/14/diary/2022.6/2022%E5%B9%B46%E6%9C%8814%E6%97%A5/"/>
    <url>/2022/06/14/diary/2022.6/2022%E5%B9%B46%E6%9C%8814%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="348e8cd34b2294512220628aa4dc827ed079f7a7cee34f06faadcff5e83ff23f">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe5015a6898243a759b1cf6f35a8161fcb4e824514fe2b7e9ecc053dfe632722ab60e17001aefcca9ad4b38497be7d23a43ec81d3b5d37369b8908920a18bdb1c2bf417419b2eed8535c2f189945426d2fb636f82ea4a308c7880c5420b2ddd465ec994e1e7a042f514139f941529c36c9486d7c18317850759d0ac5fc708a7b99735e22e516b650d606d9fa16d62aa414954f0d50d95ee8d7b73398e049373f65542c34e27e8b0b8d6dbb52a023bcde5e00cd57bb2ad57ab0adc90c1b0bd35aa53c966572b76b4ece27fd4c790b13b7214f9e83f40164ecef3e0e12de0589a1e4f45fd93df44cee4649d12bc75da9e62541a6771ed2cc5b54f2f42b257e463af0b20248017296e4860d3c01ccd5b023598aeb93cd67921d736b2f445cfef1bcc00965b18a0cbf625b0f6a03246f50d59bb7cfb755f617a1663a4cf2663eeeecd0e8a2157a8b3cf6a82398f921fdf3337f90b9ad0ea28548d03cc20e44501dd0b14a7ddbc4d26e9e77a66a907aa78b6d72a5e9073627b357241b5861b2272043786cc1b7863810c0b24101ca3ae79c896bdcddc9a69a17a02a8ae8d61509203084d908e54dd6ba08c57c50d663e481893d37427918df8c49be85a17292abb9befdb10d0aee6461d65b738cb5906c5df5500a86a1c168690b858e6f70940f5e76243bfa9d7a9100eb664ee452c686b8fd495b7631b5369c11d9658733125c0023d3116a5bc9cd158154b1a5a925031a4b40939e6c566d57ef6545ae41c07d88490ae89129c1be1bd2b33c406f7823f4e38147089ce4fd3323b8de3696898d0d9f818bcfe2ea7f0a1a180fad83ba87b661116939f59e344d462a8dd5fdaf511d997f9178c70a856e68cf16952eba282eeca08e5cf1d67cbd7ea661f0289c96f1d78b3dbd718234754b9aad91a4e00276b4e63522bc53f10eb8b3d032d5abaa8434b9531efeba1b72db90b0001d79345490b0e9f8def7f5c8eab6a0b238bd543cfafaf71a9a617a86d97ca69c1e34d1d9090bfac34fc6eca02b341b2118708cca8256fcf2eb21d6bc1015160e5f21971b3912d1a452bb3a14f035d372034e52c4f0cd3826b9e5be58986921924192e0d588093c9ade63d8b88b4ca2c53332ecfa2557a3c4eea6559563d7b53a48d05bd4f4d615d6f39986ea4d31621c97b5732180e68914af2ec656c427f77b3cdd4d90b48746ae7132755f239195f8144eb8b4d6bb1fc518cef848f34f6220db9b81cc18e739737aff70c520f78135240b4491962422183a0c49f4af75ecbfe1d356e6f46be5e80d683f53a0ed8bb64d8076f091912122854e06bcb76ec6bd8585c1319d5607c633729f78a8b2bd9a7adff2369379c14d788140c4b6044596d5e2987e312eb83fd6c9881578409bef60e7e9271ab04383809118b31d6e707d2eb3c60f1996e1446c5ba24d383c14217991660d1e614daaf2cf48029bab94a265451c5eb5fbee7bdbd6bc0da7b59efafff1c96422aafd2dd9b41712599550776b6cb9cf085cca13b9e8e44d000a6e7d235b5bf276068537e0b82d8a09ef249642695306676bb8556483697fdef31cfa5833682fdcf2d7bd270ce5a253a2f0956df946cc7fb12667d73931848810db86972c9775d29e36f2872d292145100ebbca6a829bfcb905c3d6ea88f4f3b3ffed179fc87a08acd2bf46609b172858875b71b83450b591956e2e418f745aaba714ceb57195f8bf9f1880aba2fd01062b7f6e64afdffaa058d515e5a03b392b44093ebdad06d3dcdbce28ba57c503894e2e1e4ffe9ef4e18b71b0432743c52007053ed75b169aa450a8aa9c0e070690e71672b5633a66847544e168c120bd69123e8d76f1feb32a86f42c5dca0c76278e26b036fe2f8edebb8911ff6629b14ff13e71e642562eb8b51d81e967120aaac6bd6b95a6de3b00fb4abb555274df03104da4788ace0574b6a1b96b305cbb0394008dd846aae5b543de63f2bbfbe700ae8435a47c44858077ddab0f8a429bc5e2a597630268d9050df124f04d9be3107ce87c3d1b4931ea08e79e8b22c37dcd7cfd3dcbfa30dab6701d22e97402c6e2f439a3aecd24b11fc21480c590309c8bd528f68b2156eaab8327402d729c88e1effbbfbcbd646df3b3a8db73b779c2d82ffa83c772dc6339eab40c3dd256d09094fc183282c97b015209bd24d21c525d058296501a7c872d7f24cb0f3d374531c41569b0ee6e368ba457d60fb0ae16f47181c988fb587986fd5fc1cbcf4b10fb58b1e5aed690f4d004333ba16debfcd36a3c704ba6a464ede606e828f98a3f77adf83eafeb270abf07</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>唯一化</title>
    <link href="/2022/06/14/DataStructure/Vector/%E5%94%AF%E4%B8%80%E5%8C%96/"/>
    <url>/2022/06/14/DataStructure/Vector/%E5%94%AF%E4%B8%80%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>唯一化</p><span id="more"></span><h1 id="唯一化"><a href="#唯一化" class="headerlink" title="唯一化"></a>唯一化</h1><p>有序向量的唯一化<br>Remove()能保证唯一性，但是低效</p><p>低效的根源在于：同一元素可作为被删除元素的后继多次前移<br>启示：若能以重复区间为单位，<strong>成批</strong>删除雷同元素，性能必将改进</p><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;typename T&gt; int vector T :: uniquify()&#123;    rank i &#x3D; 0, j &#x3D; 0; &#x2F;&#x2F;各对互异“相邻”元素的秩    while( ++j &lt; _size ) &#x2F;&#x2F;逐一扫描，直至末元素        &#x2F;&#x2F;跳过雷同者；发现不同元素时，向前移至紧邻于前者右侧        if( _elem[i] !&#x3D; _elem[j] ) _elem[++i] &#x3D; _elem[j];    _size &#x3D; ++i; shrink(); &#x2F;&#x2F;直接截除尾部多余元素    return j - i; &#x2F;&#x2F;向量规模变化量，即被删除的元素总数&#125; &#x2F;&#x2F;注意：通过remove(lo, hi)批量删除，依旧达不到最高效率</code></pre></div><p>共计迭代 n - 1 次，每次常数时间，累计 O(n) 时间</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>俄罗斯方块</title>
    <link href="/2022/06/13/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/"/>
    <url>/2022/06/13/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<p>俄罗斯方块</p><span id="more"></span><h1 id="俄罗斯方块"><a href="#俄罗斯方块" class="headerlink" title="俄罗斯方块"></a>俄罗斯方块</h1><h2 id="BlockInfo"><a href="#BlockInfo" class="headerlink" title="BlockInfo"></a>BlockInfo</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 俄罗斯方块&#123;    internal class BlockInfo    &#123;        &#x2F;&#x2F;方块信息坐标的容器,必须要初始化        private List&lt;Position[]&gt; blockPosList &#x3D; new List&lt;Position[]&gt;();         public BlockInfo(E_DrawType type)        &#123;            switch (type)            &#123;                case E_DrawType.Cube:                    blockPosList.Add(new Position[3] &#123;                         new Position(2, 0),                        new Position(0, 1),                        new Position(2, 1)                     &#125;);                    break;                case E_DrawType.Line:                    &#x2F;&#x2F;初始化 长条形状的4种形态的坐标信息                    blockPosList.Add(new Position[3] &#123;                        new Position(0, -1),                        new Position(0, 1),                        new Position(0, 2)                    &#125;); &#x2F;&#x2F;blockPosList索引[0]                    blockPosList.Add(new Position[3] &#123;                        new Position(-4, 0),                        new Position(-2, 0),                        new Position(2, 0)                    &#125;); &#x2F;&#x2F;blockPosList索引[1]                    blockPosList.Add(new Position[3] &#123;                        new Position(0, -2),                        new Position(0, -1),                        new Position(0, 1)                    &#125;); &#x2F;&#x2F;blockPosList索引[2]                    blockPosList.Add(new Position[3] &#123;                        new Position(-2, 0),                        new Position(2, 0),                        new Position(4, 0)                    &#125;); &#x2F;&#x2F;blockPosList索引[3]                    break;                case E_DrawType.Tank:                    blockPosList.Add(new Position[3] &#123;                        new Position(-2, 0),                        new Position(0, 1),                        new Position(2, 0)                    &#125;); &#x2F;&#x2F;blockPosList索引[0]                    blockPosList.Add(new Position[3] &#123;                        new Position(-2, 0),                        new Position(0, -1),                        new Position(0, 1)                    &#125;); &#x2F;&#x2F;blockPosList索引[1]                    blockPosList.Add(new Position[3] &#123;                        new Position(-2, 0),                        new Position(0, -1),                        new Position(2, 0)                    &#125;); &#x2F;&#x2F;blockPosList索引[2]                    blockPosList.Add(new Position[3] &#123;                        new Position(0, -1),                        new Position(0, 1),                        new Position(2, 0)                    &#125;); &#x2F;&#x2F;blockPosList索引[3]                    break;                case E_DrawType.Left_Ladder:                    blockPosList.Add(new Position[3] &#123;                        new Position(0, -1),                        new Position(2, 1),                        new Position(2, 0)                    &#125;); &#x2F;&#x2F;blockPosList索引[0]                    blockPosList.Add(new Position[3] &#123;                        new Position(-2, 1),                        new Position(2, 0),                        new Position(0, 1)                    &#125;); &#x2F;&#x2F;blockPosList索引[1]                    blockPosList.Add(new Position[3] &#123;                        new Position(-2, -1),                        new Position(-2, 0),                        new Position(0, 1)                    &#125;); &#x2F;&#x2F;blockPosList索引[2]                    blockPosList.Add(new Position[3] &#123;                        new Position(0, -1),                        new Position(2, -1),                        new Position(-2, 0)                    &#125;); &#x2F;&#x2F;blockPosList索引[3]                    break;                case E_DrawType.Right_Ladder:                    blockPosList.Add(new Position[3] &#123;                        new Position(-2, 1),                        new Position(0, -1),                        new Position(-2, 0)                    &#125;); &#x2F;&#x2F;blockPosList索引[0]                    blockPosList.Add(new Position[3] &#123;                        new Position(-2, -1),                        new Position(0, -1),                        new Position(2, 0)                    &#125;); &#x2F;&#x2F;blockPosList索引[1]                    blockPosList.Add(new Position[3] &#123;                        new Position(2, 0),                        new Position(0, 1),                        new Position(2, -1)                    &#125;); &#x2F;&#x2F;blockPosList索引[2]                    blockPosList.Add(new Position[3] &#123;                        new Position(2, 1),                        new Position(0, 1),                        new Position(-2, 0)                    &#125;); &#x2F;&#x2F;blockPosList索引[3]                    break;                case E_DrawType.Left_Long_Ladder:                    blockPosList.Add(new Position[3] &#123;                        new Position(-2, -1),                        new Position(0, 1),                        new Position(0, -1)                    &#125;); &#x2F;&#x2F;blockPosList索引[0]                    blockPosList.Add(new Position[3] &#123;                        new Position(-2, 0),                        new Position(2, 0),                        new Position(2, -1)                    &#125;); &#x2F;&#x2F;blockPosList索引[1]                    blockPosList.Add(new Position[3] &#123;                        new Position(0, 1),                        new Position(0, -1),                        new Position(2, 1)                    &#125;); &#x2F;&#x2F;blockPosList索引[2]                    blockPosList.Add(new Position[3] &#123;                        new Position(2, 0),                        new Position(-2, 1),                        new Position(-2, 0)                    &#125;); &#x2F;&#x2F;blockPosList索引[3]                    break;                case E_DrawType.Right_Long_Ladder:                    blockPosList.Add(new Position[3] &#123;                        new Position(2, -1),                        new Position(0, -1),                        new Position(0, 1)                    &#125;); &#x2F;&#x2F;blockPosList索引[0]                    blockPosList.Add(new Position[3] &#123;                        new Position(-2, 0),                        new Position(2, 0),                        new Position(2, 1)                    &#125;); &#x2F;&#x2F;blockPosList索引[1]                    blockPosList.Add(new Position[3] &#123;                        new Position(-2, 1),                        new Position(0, -1),                        new Position(0, 1)                    &#125;); &#x2F;&#x2F;blockPosList索引[2]                    blockPosList.Add(new Position[3] &#123;                        new Position(-2, -1),                        new Position(-2, 0),                        new Position(2, 0)                    &#125;); &#x2F;&#x2F;blockPosList索引[3]                    break;            &#125;        &#125;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 提供给外部根据索引快速获取位置偏移信息的        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;index&quot;&gt;第几种形态的索引&lt;&#x2F;param&gt;        &#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt;        public Position[] this[int index]        &#123;            get            &#123;                if(index &lt; 0)                    return blockPosList[0];                else if(index &gt;&#x3D; blockPosList.Count)                    return blockPosList[blockPosList.Count - 1];                else                    return blockPosList[index];            &#125;        &#125;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 提供给外部获取形态有几种        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        public int Count &#123; get &#x3D;&gt; blockPosList.Count; &#125;    &#125;&#125;</code></pre></div><h2 id="Carrier"><a href="#Carrier" class="headerlink" title="Carrier"></a>Carrier</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 俄罗斯方块&#123;    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 变形方向枚举    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_ChangeType    &#123;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 逆时针        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Left,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 顺时针        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Right,    &#125;    internal class Carrier    &#123;        private List&lt;DrawObject&gt; blocks;        private Dictionary&lt;E_DrawType, BlockInfo&gt; dic;        private BlockInfo nowBlockInfo;        private int nowInfoIndex;        public Carrier()        &#123;            dic &#x3D; new Dictionary&lt;E_DrawType, BlockInfo&gt;()            &#123;                &#123; E_DrawType.Cube, new BlockInfo(E_DrawType.Cube) &#125;,                &#123; E_DrawType.Line, new BlockInfo(E_DrawType.Line) &#125;,                &#123; E_DrawType.Tank, new BlockInfo(E_DrawType.Tank) &#125;,                &#123; E_DrawType.Left_Ladder, new BlockInfo(E_DrawType.Left_Ladder) &#125;,                &#123; E_DrawType.Right_Ladder, new BlockInfo(E_DrawType.Right_Ladder) &#125;,                &#123; E_DrawType.Left_Long_Ladder, new BlockInfo(E_DrawType.Left_Long_Ladder) &#125;,                &#123; E_DrawType.Right_Long_Ladder, new BlockInfo(E_DrawType.Right_Long_Ladder) &#125;,            &#125;;            RandomCreateBlock();        &#125;                    &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 随机创建一个方块        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        public void RandomCreateBlock()        &#123;            Random r &#x3D; new Random();            E_DrawType t &#x3D; (E_DrawType)r.Next(1, 8);            &#x2F;&#x2F;新建方块 &#x3D; 创建4个小方块            blocks &#x3D; new List&lt;DrawObject&gt;()            &#123;                new DrawObject(t),                new DrawObject(t),                new DrawObject(t),                new DrawObject(t),            &#125;;            &#x2F;&#x2F;初始化原点方块，每次都从中间出来            blocks[0].pos &#x3D; new Position(24, -5);            &#x2F;&#x2F;取出方块形态信息            nowBlockInfo &#x3D; dic[t];            &#x2F;&#x2F;随机确定现在是哪种形态,之后旋转改变            nowInfoIndex &#x3D; r.Next(0, dic.Count);            Position[] pos &#x3D; nowBlockInfo[nowInfoIndex];            for (int i &#x3D; 0; i &lt; pos.Length; i++)            &#123;                &#x2F;&#x2F;取出来的坐标是相对原点方块的坐标                blocks[i + 1].pos &#x3D; blocks[0].pos + pos[i];            &#125;        &#125;        public void Draw()        &#123;            for (int i &#x3D; 0; i &lt; blocks.Count; i++)            &#123;                blocks[i].Draw();            &#125;        &#125;        public void CleanDraw()        &#123;            for (int i &#x3D; 0; i &lt; blocks.Count; i++)            &#123;                blocks[i].CleanDraw();            &#125;        &#125;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 变形旋转的方法        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;type&quot;&gt;旋转的方向&lt;&#x2F;param&gt;        public void Change(E_ChangeType type)        &#123;            CleanDraw();            switch(type)            &#123;                case E_ChangeType.Left:                    --nowInfoIndex;                    if (nowInfoIndex &lt; 0)                        nowInfoIndex &#x3D; nowBlockInfo.Count - 1;                    break;                case E_ChangeType.Right:                    ++nowInfoIndex;                    if(nowInfoIndex &gt;&#x3D; nowBlockInfo.Count)                        nowInfoIndex &#x3D; 0;                    break;            &#125;            &#x2F;&#x2F;设置剩下三个小方块位置            Position[] pos &#x3D; nowBlockInfo[nowInfoIndex];            for (int i &#x3D; 0; i &lt; pos.Length; i++)            &#123;                &#x2F;&#x2F;取出来的坐标是相对原点方块的坐标                blocks[i + 1].pos &#x3D; blocks[0].pos + pos[i];            &#125;            Draw();        &#125;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 判断是否可以进行变形        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;type&quot;&gt;变形方向&lt;&#x2F;param&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;map&quot;&gt;地图信息&lt;&#x2F;param&gt;        &#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt;        public bool CanChange(E_ChangeType type, Map map)        &#123;            &#x2F;&#x2F;用一个临时变量记录当前索引，不变化当前索引            int nowIndex &#x3D; nowInfoIndex;            switch (type)            &#123;                case E_ChangeType.Left:                    --nowIndex;                    if (nowIndex &lt; 0)                        nowIndex &#x3D; nowBlockInfo.Count - 1;                    break;                case E_ChangeType.Right:                    ++nowIndex;                    if (nowIndex &gt;&#x3D; nowBlockInfo.Count)                        nowIndex &#x3D; 0;                    break;            &#125;            Position[] nowPos &#x3D; nowBlockInfo[nowIndex];            &#x2F;&#x2F;判断是否超出地图边界            Position tempPos;            for (int i &#x3D; 0; i &lt; nowPos.Length; i++)            &#123;                tempPos &#x3D; blocks[0].pos + nowPos[i];                if( tempPos.x &lt; 2 ||                    tempPos.x &gt;&#x3D; Game.w - 2 ||                    tempPos.y &gt;&#x3D; Game.h - 6 )                &#123;                    return false;                &#125;            &#125;            &#x2F;&#x2F;判断是否和地图上的动态方块重合            for (int i &#x3D; 0; i &lt; nowPos.Length; i++)            &#123;                tempPos &#x3D; blocks[0].pos + nowPos[i];                for (int j &#x3D; 0; j &lt; map.dynamicWalls.Count; j++)                &#123;                    if(tempPos &#x3D;&#x3D; map.dynamicWalls[j].pos)                    &#123;                        return false;                    &#125;                &#125;            &#125;            return true;        &#125;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 左右移动的函数        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;type&quot;&gt;左或者右&lt;&#x2F;param&gt;        public void MoveRL(E_ChangeType type)        &#123;            CleanDraw();            Position movePos &#x3D; new Position(type &#x3D;&#x3D; E_ChangeType.Left ? -2 : 2, 0);            for (int i &#x3D; 0; i &lt; blocks.Count; i++)            &#123;                blocks[i].pos +&#x3D; movePos;            &#125;                      Draw();        &#125;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 移动之前判断是否可以左右移动        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;type&quot;&gt;移动的方向&lt;&#x2F;param&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;map&quot;&gt;&lt;&#x2F;param&gt;        public bool CanMoveRl(E_ChangeType type, Map map)        &#123;            Position movePos &#x3D; new Position(type &#x3D;&#x3D; E_ChangeType.Left ? -2 : 2, 0);            &#x2F;&#x2F;动过后的结果不能直接改变，用一个临时变量存着            Position pos;            for (int i &#x3D; 0; i &lt; blocks.Count; i++)            &#123;                pos &#x3D; blocks[i].pos + movePos;                if( pos.x &lt; 2 || pos.x &gt;&#x3D; Game.w - 2 )                    return false;            &#125;            for (int i &#x3D; 0; i &lt; blocks.Count; i++)            &#123;                pos &#x3D; blocks[i].pos + movePos;                for (int j &#x3D; 0; j &lt; map.dynamicWalls.Count; j++)                &#123;                    if (pos &#x3D;&#x3D; map.dynamicWalls[j].pos)                    &#123;                        return false;                    &#125;                &#125;            &#125;            return true;        &#125;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 自动向下移动        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        public void AutoMove()        &#123;            CleanDraw();            Position downMove &#x3D; new Position(0, 1);            for (int i &#x3D; 0; i &lt; blocks.Count; i++)            &#123;                blocks[i].pos +&#x3D; downMove;            &#125;            Draw();        &#125;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 判断是否停下自动向下移动        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;map&quot;&gt;&lt;&#x2F;param&gt;        &#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt;        public bool CanAutoMove(Map map)        &#123;            Position movePos &#x3D; new Position(0, 1);            &#x2F;&#x2F;动过后的结果不能直接改变，用一个临时变量存着            Position pos;            for (int i &#x3D; 0; i &lt; blocks.Count; i++)            &#123;                pos &#x3D; blocks[i].pos + movePos;                if (pos.y &gt;&#x3D; Game.h - 6)                &#123;                    map.AddWalls(blocks);                    RandomCreateBlock();                    return false;                &#125;                           &#125;            for (int i &#x3D; 0; i &lt; blocks.Count; i++)            &#123;                pos &#x3D; blocks[i].pos + movePos;                for (int j &#x3D; 0; j &lt; map.dynamicWalls.Count; j++)                &#123;                    if (pos &#x3D;&#x3D; map.dynamicWalls[j].pos)                    &#123;                        map.AddWalls(blocks);                        RandomCreateBlock();                        return false;                    &#125;                &#125;            &#125;            return true;        &#125;    &#125;&#125;</code></pre></div><h2 id="DrawObject"><a href="#DrawObject" class="headerlink" title="DrawObject"></a>DrawObject</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 俄罗斯方块&#123;    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 绘制类型，根据不同类型改变绘制方块的颜色    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_DrawType    &#123;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 墙壁        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Wall,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 正方形        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Cube,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 直线        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Line,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 坦克        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Tank,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 左梯子        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Left_Ladder,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 右梯子        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Right_Ladder,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 左长梯子        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Left_Long_Ladder,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 右长梯子        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Right_Long_Ladder,    &#125;    class DrawObject : IDraw    &#123;        public Position pos;        public E_DrawType type;        public DrawObject(E_DrawType type)        &#123;            this.type &#x3D; type;        &#125;        public DrawObject(E_DrawType type, int x, int y) : this(type)        &#123;            this.pos &#x3D; new Position(x, y);        &#125;        public void CleanDraw()        &#123;            &#x2F;&#x2F;若在屏幕外不需要绘制            if (pos.y &lt; 0)                return;            Console.SetCursorPosition(pos.x, pos.y);            Console.Write(&quot;  &quot;);        &#125;        public void Draw()        &#123;            &#x2F;&#x2F;若在屏幕外不需要绘制            if (pos.y &lt; 0)                return;            Console.SetCursorPosition(pos.x, pos.y);            &#x2F;&#x2F;设置颜色            switch (type)            &#123;                case E_DrawType.Wall:                    Console.ForegroundColor &#x3D; ConsoleColor.Red;                    break;                case E_DrawType.Cube:                    Console.ForegroundColor &#x3D; ConsoleColor.Blue;                    break;                case E_DrawType.Line:                    Console.ForegroundColor &#x3D; ConsoleColor.Green;                    break;                case E_DrawType.Tank:                    Console.ForegroundColor &#x3D; ConsoleColor.Cyan;                    break;                case E_DrawType.Left_Ladder:                case E_DrawType.Right_Ladder:                    Console.ForegroundColor &#x3D; ConsoleColor.Magenta;                    break;                case E_DrawType.Left_Long_Ladder:                case E_DrawType.Right_Long_Ladder:                    Console.ForegroundColor &#x3D; ConsoleColor.DarkYellow;                    break;            &#125;            Console.Write(&quot;■&quot;);        &#125;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 切换方块类型（变成墙壁）        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;type&quot;&gt;想要变成的方块类型&lt;&#x2F;param&gt;        public void ChangeType(E_DrawType type)        &#123;            this.type &#x3D; type;        &#125;    &#125;&#125;</code></pre></div><h2 id="IDraw"><a href="#IDraw" class="headerlink" title="IDraw"></a>IDraw</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 俄罗斯方块&#123;    interface IDraw    &#123;        void Draw();    &#125;&#125;</code></pre></div><h2 id="Position"><a href="#Position" class="headerlink" title="Position"></a>Position</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 俄罗斯方块&#123;    struct Position    &#123;        public int x;        public int y;        public Position(int x, int y)        &#123;            this.x &#x3D; x; this.y &#x3D; y;        &#125;        public static bool operator &#x3D;&#x3D; (Position p1, Position p2)        &#123;            if(p1.x &#x3D;&#x3D; p2.x &amp;&amp; p1.y &#x3D;&#x3D; p2.y)                return true;            return false;        &#125;        public static bool operator !&#x3D;(Position p1, Position p2)        &#123;            if (p1.x &#x3D;&#x3D; p2.x &amp;&amp; p1.y &#x3D;&#x3D; p2.y)                return false;            return true;        &#125;        public static Position operator +(Position p1, Position p2)        &#123;            Position p &#x3D; new Position(p1.x + p2.x, p1.y + p2.y);            return p;        &#125;    &#125;&#125;</code></pre></div><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 俄罗斯方块&#123;    internal class Map : IDraw    &#123;        &#x2F;&#x2F;固定墙壁        private List&lt;DrawObject&gt; fixedWalls &#x3D; new List&lt;DrawObject&gt;();        &#x2F;&#x2F;动态墙壁        public List&lt;DrawObject&gt; dynamicWalls &#x3D; new List&lt;DrawObject&gt;();        &#x2F;&#x2F;记录每一层有多少小方块的容器，索引就是第几行        private int[] recordInfo;        public int w &#x3D; 0;        public int h;        public int score &#x3D; 0;        private GameScene nowGameScene;        &#x2F;&#x2F;重载一次无参构造去初始化固定墙壁        public Map( GameScene nowGameScene )        &#123;            this.nowGameScene &#x3D; nowGameScene;            h &#x3D; Game.h - 6;            &#x2F;&#x2F;重点：记录行号的容器            recordInfo &#x3D; new int[h];            &#x2F;&#x2F;底下墙壁            for (int i &#x3D; 0; i &lt; Game.w; i +&#x3D; 2)            &#123;                fixedWalls.Add(new DrawObject(E_DrawType.Wall, i, Game.h - 6));                w++;            &#125;                        &#x2F;&#x2F;两边墙壁            for (int i &#x3D; 0; i &lt; Game.h - 6; i++)            &#123;                fixedWalls.Add(new DrawObject(E_DrawType.Wall, 0, i));                fixedWalls.Add(new DrawObject(E_DrawType.Wall, Game.w - 2, i));            &#125;        &#125;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 绘制墙壁        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        public void Draw()        &#123;            &#x2F;&#x2F;画静态墙壁            for (int i &#x3D; 0; i &lt; fixedWalls.Count; i++)            &#123;                fixedWalls[i].Draw();            &#125;            &#x2F;&#x2F;画动态墙壁            for (int i &#x3D; 0; i &lt; dynamicWalls.Count; i++)            &#123;                dynamicWalls[i].Draw();            &#125;        &#125;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 擦除动态墙壁，以便下移        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        public void CleanDynamicWalls()        &#123;            for (int i &#x3D; 0; i &lt; dynamicWalls.Count; i++)            &#123;                dynamicWalls[i].CleanDraw();            &#125;        &#125;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 提供给外部添加动态方块的函数        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;walls&quot;&gt;&lt;&#x2F;param&gt;        public void AddWalls(List&lt;DrawObject&gt; walls)        &#123;            for (int i &#x3D; 0; i &lt; walls.Count; i++)            &#123;                walls[i].ChangeType(E_DrawType.Wall);                dynamicWalls.Add(walls[i]);                &#x2F;&#x2F;在动态墙壁添加时，若出地图，则停止                if(walls[i].pos.y &lt;&#x3D; 0)                &#123;                    &#x2F;&#x2F;关闭输入线程                    nowGameScene.StopTheard();                    Game.ChangeScene(E_SceneType.End);                    break;                &#125;                recordInfo[Game.h - 7 - walls[i].pos.y]++;            &#125;            CleanDynamicWalls();            CheckClear();            Draw();        &#125;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 检测是否消层        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        public void CheckClear()        &#123;            List&lt;DrawObject&gt; delList &#x3D; new List&lt;DrawObject&gt;();            for (int i &#x3D; 0; i &lt; recordInfo.Length; i++)            &#123;                if(recordInfo[i] &#x3D;&#x3D; w - 2)                &#123;                    for (int j &#x3D; 0; j &lt; dynamicWalls.Count; j++)                    &#123;                        if( i &#x3D;&#x3D; Game.h - 7 - dynamicWalls[j].pos.y )                        &#123;                            &#x2F;&#x2F;为了安全移除，添加一个待移除列表                            delList.Add(dynamicWalls[j]);                        &#125;                        else if( i &lt; Game.h - 7 - dynamicWalls[j].pos.y )                        &#123;                            &#x2F;&#x2F;把该行上面的方块下移，即纵坐标+1                            dynamicWalls[j].pos.y++;                        &#125;                    &#125;                    &#x2F;&#x2F;移除待移除列表里的方块                    for (int j &#x3D; 0; j &lt; delList.Count; j++)                    &#123;                        dynamicWalls.Remove(delList[j]);                                           &#125;                    &#x2F;&#x2F;记录小方块数量的数组从上到下迁移                    for (int j &#x3D; i; j &lt; recordInfo.Length - 1; j++)                    &#123;                        recordInfo[j] &#x3D; recordInfo[j + 1];                    &#125;                    score++;                    &#x2F;&#x2F;通过递归，实现一次移除多行                    recordInfo[recordInfo.Length - 1] &#x3D; 0;                    CheckClear();                    break;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div><h2 id="InputThread"><a href="#InputThread" class="headerlink" title="InputThread"></a>InputThread</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading;using System.Threading.Tasks;namespace 俄罗斯方块&#123;    internal class InputThread    &#123;        &#x2F;&#x2F;线程成员变量        Thread inputThread;        &#x2F;&#x2F;输入检测事件        public event Action inputEvent;        &#x2F;&#x2F;单例模式        private static InputThread instance &#x3D; new InputThread();        public static InputThread Instance        &#123;            get &#123; return instance; &#125;        &#125;        private InputThread()        &#123;            inputThread &#x3D; new Thread(InputCheck);            inputThread.IsBackground &#x3D; true;            inputThread.Start();        &#125;        private void InputCheck()        &#123;            while (true)            &#123;                inputEvent?.Invoke();            &#125;        &#125;    &#125;&#125;</code></pre></div><h2 id="BeginOrEndBaseScene"><a href="#BeginOrEndBaseScene" class="headerlink" title="BeginOrEndBaseScene"></a>BeginOrEndBaseScene</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 俄罗斯方块&#123;    &#x2F;&#x2F;抽象基类    abstract class BeginOrEndBaseScene:ISceneUpdate    &#123;        protected int nowSelIndex;        protected string strTitle;        protected string strOne;        public abstract void EnterJDoSomething();        public void Update()        &#123;            Console.ForegroundColor &#x3D; ConsoleColor.White;            &#x2F;&#x2F;显示标题            Console.SetCursorPosition( Game.w &#x2F; 2 - strTitle.Length, 5);            Console.WriteLine(strTitle);            &#x2F;&#x2F;显示下方选项            Console.SetCursorPosition(Game.w &#x2F; 2 - strOne.Length, 8);            Console.ForegroundColor &#x3D; nowSelIndex &#x3D;&#x3D; 0 ? ConsoleColor.Red : ConsoleColor.White;            Console.WriteLine(strOne);            Console.SetCursorPosition(Game.w &#x2F; 2 - 4, 10);            Console.ForegroundColor &#x3D; nowSelIndex &#x3D;&#x3D; 1 ? ConsoleColor.Red : ConsoleColor.White;            Console.WriteLine(&quot;结束游戏&quot;);            &#x2F;&#x2F;检测输入            switch(Console.ReadKey(true).Key)            &#123;                case ConsoleKey.W:                    --nowSelIndex;                    if(nowSelIndex &lt; 0)                    &#123;                        nowSelIndex &#x3D; 0;                    &#125;                    break;                case ConsoleKey.S:                    ++nowSelIndex;                    if (nowSelIndex &gt; 1)                    &#123;                        nowSelIndex &#x3D; 1;                    &#125;                    break;                case ConsoleKey.J:                    EnterJDoSomething();                    break;            &#125;        &#125;    &#125;&#125;</code></pre></div><h2 id="BeginScene"><a href="#BeginScene" class="headerlink" title="BeginScene"></a>BeginScene</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 俄罗斯方块&#123;    internal class BeginScene:BeginOrEndBaseScene    &#123;        public BeginScene()        &#123;            strTitle &#x3D; &quot;俄罗斯方块&quot;;            strOne &#x3D; &quot;开始游戏&quot;;        &#125;        public override void EnterJDoSomething()        &#123;            if(nowSelIndex &#x3D;&#x3D; 0)            &#123;                Game.ChangeScene(E_SceneType.Game);            &#125;            else            &#123;                Environment.Exit(0);            &#125;        &#125;    &#125;&#125;</code></pre></div><h2 id="EndScene"><a href="#EndScene" class="headerlink" title="EndScene"></a>EndScene</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 俄罗斯方块&#123;    internal class EndScene : BeginOrEndBaseScene    &#123;        public EndScene()        &#123;            strTitle &#x3D; &quot;结束游戏&quot;;            strOne &#x3D; &quot;回到开始界面&quot;;        &#125;        public override void EnterJDoSomething()        &#123;            if (nowSelIndex &#x3D;&#x3D; 0)            &#123;                Game.ChangeScene(E_SceneType.Begin);            &#125;            else            &#123;                Environment.Exit(0);            &#125;        &#125;    &#125;&#125;</code></pre></div><h2 id="Game"><a href="#Game" class="headerlink" title="Game"></a>Game</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 俄罗斯方块&#123;    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 场景类型枚举    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_SceneType    &#123;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 开始场景        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Begin,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 游戏场景        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Game,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 结束场景        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        End,    &#125;    class Game    &#123;        &#x2F;&#x2F;游戏窗口宽高        public const int w &#x3D; 50;        public const int h &#x3D; 35;        &#x2F;&#x2F;当前选中的场景        public static ISceneUpdate nowScene;        &#x2F;&#x2F;初始化的方法        public Game()        &#123;            Console.CursorVisible &#x3D; false;            Console.SetWindowSize(w, h);            Console.SetBufferSize(w, h);            ChangeScene(E_SceneType.Begin);        &#125;        &#x2F;&#x2F;游戏开始的方法        public void Start()        &#123;            &#x2F;&#x2F;游戏主循环 负责游戏场景的更新            while(true)            &#123;                &#x2F;&#x2F;判断当前游戏场景不为空 就更新                if(nowScene !&#x3D; null)                &#123;                    nowScene.Update();                &#125;            &#125;        &#125;        &#x2F;&#x2F;切换场景的方法        public static void ChangeScene(E_SceneType type)        &#123;            &#x2F;&#x2F;切场景之前，应该清空上一个场景的内容            Console.Clear();            switch (type)            &#123;                case E_SceneType.Begin:                    nowScene &#x3D; new BeginScene();                    break;                case E_SceneType.Game:                    nowScene &#x3D; new GameScene();                    break;                case E_SceneType.End:                    nowScene &#x3D; new EndScene();                    break;            &#125;        &#125;    &#125;&#125;</code></pre></div><h2 id="GameScene"><a href="#GameScene" class="headerlink" title="GameScene"></a>GameScene</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading;using System.Threading.Tasks;namespace 俄罗斯方块&#123;    class GameScene: ISceneUpdate    &#123;        Map map;        Carrier carrier;        &#x2F;&#x2F;Thread inputThread;        &#x2F;&#x2F;bool isRunning &#x3D; true;        public GameScene()        &#123;                       map &#x3D; new Map(this);            carrier &#x3D; new Carrier();            &#x2F;&#x2F;添加输入事件监听            InputThread.Instance.inputEvent +&#x3D; CheckInputThread;            &#x2F;&#x2F;inputThread &#x3D; new Thread(CheckInputThread);            &#x2F;&#x2F;inputThread.IsBackground &#x3D; true;            &#x2F;&#x2F;inputThread.Start();        &#125;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 停止线程        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        public void StopTheard()        &#123;            &#x2F;&#x2F;isRunning &#x3D; false;            &#x2F;&#x2F;inputThread &#x3D; null;            &#x2F;&#x2F;移除输入事件监听            InputThread.Instance.inputEvent -&#x3D; CheckInputThread;        &#125;        private void CheckInputThread()        &#123;            while (true)            &#123;                &#x2F;&#x2F;在控制台中 检测玩家输入 让程序不被检测卡主                &#x2F;&#x2F;判断 有没有键盘输入 如果有 才为true                if (Console.KeyAvailable)                &#123;                    &#x2F;&#x2F;为避免影响主线程 在输入后加锁                    lock(carrier)                    &#123;                        &#x2F;&#x2F;检测输入输出 不能再 间隔帧里面去处理 应该每次都检测 这样才准确                        switch (Console.ReadKey(true).Key)                        &#123;                            case ConsoleKey.S:                                if (carrier.CanAutoMove(map))                                    carrier.AutoMove();                                break;                            case ConsoleKey.A:                                if (carrier.CanMoveRl(E_ChangeType.Left, map))                                    carrier.MoveRL(E_ChangeType.Left);                                break;                            case ConsoleKey.D:                                if (carrier.CanMoveRl(E_ChangeType.Right, map))                                    carrier.MoveRL(E_ChangeType.Right);                                break;                            case ConsoleKey.LeftArrow:                                if (carrier.CanChange(E_ChangeType.Left, map))                                    carrier.Change(E_ChangeType.Left);                                break;                            case ConsoleKey.RightArrow:                                if (carrier.CanChange(E_ChangeType.Right, map))                                    carrier.Change(E_ChangeType.Right);                                break;                        &#125;                    &#125;                                   &#125;            &#125;        &#125;        public void Update()        &#123;            lock(carrier)            &#123;                map.Draw();                carrier.Draw();                if (carrier.CanAutoMove(map))                    carrier.AutoMove();                Console.SetCursorPosition(2, Game.h - 4);                Console.ForegroundColor &#x3D; ConsoleColor.White;                Console.WriteLine(&quot;当前得分：&#123;0&#125;&quot;, map.score);            &#125;                      Thread.Sleep(350);                          &#125;    &#125;&#125;</code></pre></div><h2 id="ISceneUpdate"><a href="#ISceneUpdate" class="headerlink" title="ISceneUpdate"></a>ISceneUpdate</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 俄罗斯方块&#123;    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 场景更新接口    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    internal interface ISceneUpdate    &#123;        void Update();    &#125;&#125;</code></pre></div><h2 id="Program"><a href="#Program" class="headerlink" title="Program"></a>Program</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace 俄罗斯方块&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Game game &#x3D; new Game();            game.Start();        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年6月13日</title>
    <link href="/2022/06/13/diary/2022.6/2022%E5%B9%B46%E6%9C%8813%E6%97%A5/"/>
    <url>/2022/06/13/diary/2022.6/2022%E5%B9%B46%E6%9C%8813%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="edab2d62481158c741a9014af4cde14d9eb5c78b89ab9c839135dbf1c90e1aaf">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe508c5cf8c2d6a5630118106f36d44e8b7ec41547e933ea8e73e6f49e3997254baa099816e4f299d58a7a015a7768acb6e168ffaabddb0341d6cfa15f534faad094e75effd3ff3bd8279f630c68b99f25dd905057633a33f408e59e7f7723b00d76d20ba89e5c70ee1003995b8da1de2c1c4c8883ed9403a089b564dac32ed1e3d823047668001ccda3d906def0904c87ffd36b55792f3009204a61ab0404994b0a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年6月12日</title>
    <link href="/2022/06/12/diary/2022.6/2022%E5%B9%B46%E6%9C%8812%E6%97%A5/"/>
    <url>/2022/06/12/diary/2022.6/2022%E5%B9%B46%E6%9C%8812%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="ec39a1af7b223d7dc6dcb19f5aa8403cd3c7d9e738c3cf8d4236e1b5b2258a49">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50576d415b6e9707d8ee3d8b21c8cc5ffae8360c7749d3bbe6ac1c82f6e08a73aa742c05f973f3cfad3b20b29fe1fc723b6eb5c6dd9b5fac865cb17920a0d362fe</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年6月11日</title>
    <link href="/2022/06/12/diary/2022.6/2022%E5%B9%B46%E6%9C%8811%E6%97%A5/"/>
    <url>/2022/06/12/diary/2022.6/2022%E5%B9%B46%E6%9C%8811%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="c20dfa11c4db08ec811b1a04e7fbfb152754e7cb7a90343b8be7503ff69a0c69">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe508b6d7ce86004fdd44d2d1618d39f5d99e8792f64775ea32f2e5ecfe1acc29df7e82b3bfbce8b764bf0345a8b77c090becf045a9f063c263f3acb0370c40a4533be3e27575311494373fc33ff5bedd5b1c3aa7b5094680ff397492723bec5dbe6055154761e151502f43f2cdc53ceda137d146ab497e3a429071f27d97dc43a74f6b346f8d1b9196a8cce4d3e50240fc49a92aa8adb0458c2c5b9e026f10580c65d3b165af8390eb1f1d6e6d94c328d70edc52c530d7fe70356a634b3f518efd2cac4ac8466fc04a37edfb67fd3fa1434913cbbe34cab465272a510902b399c5f4efe27899338a7d6372a544f3ec6e934b76e7e872b575bf577303b62d523b5c55e69d5c6dff81a4576f0eb350975654721a0f59e1ec5a0f00b0030f422fd52f5627e06b04763e706f3a73baf7ea25e781c2baed7346036f2309a02b26277bdf00e041a35ede287c6562a44fda5d5b394633e5b7dfed3dff38d88e263aafeaf03ad2a3064307be3b51aaea0fe3aa68e2544df6a62b9d02771b37749bd008f0a47684394bf9b3f02f77a31d21594741008965627ae9a4e102beb82b4f771e6c9b87e08b3c9adf95ddc3fbb386d6557e37e40b12d47f4d6d4aa7b03b0be8e017cb4d10bcd472923c9b9d94004d6bba3130081ccb5ac037a56ac7d0447a70516b79b9481c8109490dff34bfdf40fca3aa401bb30993e6d8d0fceec36072b609d52974b5cdd62c393ffbbd9d748992c16fd91a90ed01176a37cecefac1f6fcc5ef29fa9e270d0dceb3aea2c06d0aab255abdb6f1924281bcc18ba7e33686f02a334829fef6c8844bf99c17c1f2879b1aa62ff1833b981153f4433acb874d2d1f2622682558530834f4d279252535cdeec4b65604e350d2e4a2728771c9f7084b8c9a2096f71f25daab7d0c456beb33d67c482ad7068e45b2bfaf2153b8a9e8c0dd03c88b338389e42243148f7293f527b1ea9efc60f60638686d7ddc40a06fef6aa653935ff362706706d3c42ec96ddd6052c556c3915b6673e1447575a5ea79a82605a2ae537da7b1012ff382c73e4952adb24ff610875effd03995323ad4659e2efc677ea315bb91958784cb8d3caccff24e079afa5d8601bc2d8ad410988ae16b11ecd094ab50f8577a721dd3e0e670bcf1eb9981927b19877c627bd7226cac28a0aa2752a2d419da820b9f926413fe8f55259246ba7ea180d8c8e21cb74ff0c19</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆排序</title>
    <link href="/2022/06/11/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/06/11/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>堆排序</p><span id="more"></span><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>构建二叉树，大堆顶调整，堆顶往后放，不停变堆顶<br>关键规则： 最大的非叶子节点索引 &#x3D; 数组长度 &#x2F; 2 - 1<br>父节点和叶子节点： 父节点为i，左节点为2i+1，右节点为2i+2</p><h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><p>套路写法：<br>三个函数</p><ol><li>堆顶比较（一个父节点，两个子节点，三个节点的比较）</li><li>构建大堆顶（大堆顶是即是一种每个子叶都完成堆顶比较的状态）</li><li>堆排序（最后循环排序，每次交换还需通过堆顶比较检查）</li></ol><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson27_堆排序&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            int[] array &#x3D; new int[] &#123; 8, 7, 1, 5, 4, 2, 6, 3, 9 &#125;;            HeapSort(array);            for (int i &#x3D; 0; i &lt; array.Length; i++)            &#123;                Console.WriteLine(array[i]);            &#125;        &#125;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 叶子比较（三角关系）        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;array&quot;&gt;需要排序的数组&lt;&#x2F;param&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;nowIndex&quot;&gt;当前作为根节点的索引&lt;&#x2F;param&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;arrayLength&quot;&gt;哪些位置未被确定&lt;&#x2F;param&gt;        static void HeapCompare(int[] array, int nowIndex, int arrayLength)        &#123;            &#x2F;&#x2F;左右子叶节点            int left &#x3D; 2 * nowIndex + 1;            int right &#x3D; 2 * nowIndex + 2;            int maxIndex &#x3D; nowIndex;            &#x2F;&#x2F;先比左，再比右， 且索引不能溢出            if(left &lt; arrayLength &amp;&amp;                array[left] &gt; array[maxIndex])            &#123;                maxIndex &#x3D; left;            &#125;            else if(right &lt; arrayLength &amp;&amp;                array[right] &gt; array[maxIndex])            &#123;                maxIndex &#x3D; right;            &#125;            if( maxIndex !&#x3D; nowIndex)            &#123;                int temp &#x3D; array[maxIndex];                array[maxIndex] &#x3D; array[nowIndex];                array[nowIndex] &#x3D; temp;                &#x2F;&#x2F;通过递归 看是否影响了叶子节点的三角关系                HeapCompare(array, maxIndex, arrayLength);            &#125;        &#125;        &#x2F;&#x2F;构建大堆顶        static void BuildMaxHeap(int[] array)        &#123;            &#x2F;&#x2F;从最大的非叶子节点索引开始，不断往前构建大堆顶            for (int i &#x3D; array.Length &#x2F; 2 - 1; i &gt;&#x3D; 0; i--)            &#123;                HeapCompare(array, i, array.Length);            &#125;        &#125;        &#x2F;&#x2F;结合大堆顶和节点比较实现堆排序，把堆顶不停往后移动        static void HeapSort(int[] array)        &#123;            BuildMaxHeap(array);            for (int i &#x3D; array.Length - 1; i &gt; 0 ; i--)            &#123;                           int temp &#x3D; array[i];                array[i] &#x3D; array[0];                array[0] &#x3D; temp;                HeapCompare(array, 0, i);            &#125;        &#125;    &#125;&#125;</code></pre></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>堆是一类特殊的数<br>堆的通用特点就是父节点会大于或小于所有子节点<br>只利用了堆的特点来解决排序问题</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/2022/06/11/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/06/11/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>快速排序</p><span id="more"></span><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>选取基准，产生左右标识，左右比基准，满足则换位<br>排完一次基准定位，左右递归直到有序</p><h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><p>套路写法：基准值变量，左右游标记录<br>三层while循环</p><ol><li>游标不停左右移动，重合则结束，结束定基准</li><li>递归排左右，错位则结束</li><li>左右互访，while循环外定基准</li></ol><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson26_快速排序&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            int[] array &#x3D; new int[] &#123; 8, 7, 1, 5, 4, 2, 6, 3, 9 &#125;;            QuickSort(array, 0, array.Length - 1);            for (int i &#x3D; 0; i &lt; array.Length; i++)            &#123;                Console.WriteLine(array[i]);            &#125;        &#125;        static void QuickSort(int[] array, int left, int right)        &#123;            if (left &gt;&#x3D; right)                return;            int temp &#x3D; array[left];            int tempLeft &#x3D; left;            int tempRight &#x3D; right;                     while(tempLeft !&#x3D; tempRight)            &#123;                &#x2F;&#x2F;先从右边开始，比基准值大，则继续寻找，否则将该右移到左边                while(tempLeft &lt; tempRight &amp;&amp;                    array[tempRight] &gt; temp)                &#123;                    tempRight--;                &#125;                array[tempLeft] &#x3D; array[tempRight];                &#x2F;&#x2F;再从左边开始，比基准值小，则继续寻找，否则将该左移到刚才右边移动的位置                while (tempLeft &lt; tempRight &amp;&amp;                    array[tempLeft] &lt; temp)                &#123;                    tempLeft++;                &#125;                array[tempRight] &#x3D; array[tempLeft];            &#125;            &#x2F;&#x2F;tempLeft和tempRight相等，插入基准值            array[tempLeft] &#x3D; temp;            &#x2F;&#x2F;递归左边            QuickSort(array, left, tempRight - 1);            &#x2F;&#x2F;递归右边            QuickSort(array, tempLeft + 1, right);        &#125;    &#125;&#125;</code></pre></div><p>注意：while循环中的判断条件中，索引值的判断(sortIndex &gt;&#x3D; 0)一定要在前<br>若是在后，sortIndex变为-1时(noSortNum &lt; array[sortIndex])中array的索引会直接报错<br>今后的有关数组的循环若是有改变索引值，因注意让索引值的判断在前</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>归并排序和快速排序都会用到递归<br>相同点：<br>它们都会把数组分成几部分<br>不同点：</p><ol><li>归并排序递归过程中会产生新数组用于合并；快速排序不会产生新数组</li><li>归并排序是拆分数组完毕后再进行排序；快速排序是边排序边拆分</li></ol>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年6月10日</title>
    <link href="/2022/06/10/diary/2022.6/2022%E5%B9%B46%E6%9C%8810%E6%97%A5/"/>
    <url>/2022/06/10/diary/2022.6/2022%E5%B9%B46%E6%9C%8810%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="6bc1d365cb505031f7d0615a01ead992992e320de866b2991de778ec103cb45f">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50fdd0ca3edc57389bd0e88084b7db2023f26cc975401d5edbf40ed2d1f3fbeb3d6c2d8176456882886755f387fc6c633227c1a373ef78f5454959de0ecb4fedce49c214b9792dc1939719f927621bd2d2f93958981f3abf7d690bc5fc0cb56edd4102a4a4fcc2b0729fa23350dca237514040c6178be5a97e408de9a52bb19989bfa369360c9957df9ef5cc62496cca0669ea8f9d3924111d74c06154476deb1fcb21ec93dc33387027194c844a1d0616e1b9eb75d2295efd89e7859f3c7586b9d29e5e42dd81a17d47c6c51c482eb239d47599d8e1853be9971ad02f2ff3a9e4eea501a44672392832db21c3ffbecde436830bf0598e51c12d8317246272e4ee403bfe69b694e6bda9e9a487aca9df9154deb0c82504f1b2b5199d3317d6634544b8a4b6ec394c0908c29f5359a784ed</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>归并排序</title>
    <link href="/2022/06/10/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/06/10/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>归并排序</p><span id="more"></span><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并 &#x3D; 递归 + 合并</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>数组分左右：左右元素相比较，满足条件放入新数组，一侧用完放对面<br>递归不停分：分完再排序，排序结束往上走，边走边合并，走到头顶出结果</p><p>归并排序分成两部分：</p><ol><li>基本排序规则：左右元素进行比较，依次放入新数组中，一侧没有了另一侧直接放入新数组</li><li>递归平分数组：不停进行分割，长度小于2停止，开始比较，一层一层向上比</li></ol><h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><p>实现升序</p><ol><li>第一步：基本排序规则</li><li>第二步：递归平分数组</li></ol><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson25_归并排序&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            int[] array &#x3D; new int[] &#123; 8, 7, 1, 5, 4, 2, 6, 3, 9 &#125;;            array &#x3D; Merge(array);            for (int i &#x3D; 0; i &lt; array.Length; i++)            &#123;                Console.WriteLine(array[i]);            &#125;        &#125;        &#x2F;&#x2F;基本排序规则        static int[] Sort(int[] left, int[] right)        &#123;            int[] arrNew &#x3D; new int[left.Length + right.Length];            int leftIndex &#x3D; 0;            int rightIndex &#x3D; 0;            for (int i &#x3D; 0; i &lt; arrNew.Length; i++)            &#123;                &#x2F;&#x2F;左侧放完了，之后放右侧                if(leftIndex &gt;&#x3D; left.Length)                &#123;                    arrNew[i] &#x3D; right[rightIndex];                    rightIndex++;                &#125;                else if(rightIndex &gt;&#x3D; right.Length)                &#123;                    arrNew[i] &#x3D; left[leftIndex];                    leftIndex++;                &#125;                else if(left[leftIndex] &gt; right[rightIndex])                &#123;                    arrNew[i] &#x3D; right[rightIndex];                    rightIndex++;                &#125;                else if(left[leftIndex] &lt; right[rightIndex])                &#123;                     arrNew[i] &#x3D; left[leftIndex];                    leftIndex++;                &#125;                          &#125;            return arrNew;        &#125;        &#x2F;&#x2F;递归平分        static int[] Merge(int[] array)        &#123;            if(array.Length &lt; 2)                return array;            &#x2F;&#x2F;1.数组分两段，得到一个中间索引            int mid &#x3D; array.Length &#x2F; 2;            &#x2F;&#x2F;2.初始化左右数组            &#x2F;&#x2F;左数组            int[] left &#x3D; new int[mid];            &#x2F;&#x2F;右数组            int[] right &#x3D; new int[array.Length - mid];            &#x2F;&#x2F;左右初始化内容            for (int i &#x3D; 0; i &lt; array.Length; i++)            &#123;                if(i &lt; mid)                &#123;                    left[i] &#x3D; array[i];                &#125;                else                &#123;                    right[i - mid] &#x3D; array[i];                &#125;            &#125;            &#x2F;&#x2F;3.递归再分再排序            return Sort(Merge(left), Merge(right));         &#125;    &#125;&#125;</code></pre></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>理解递归逻辑<br>一开始不会执行Sort函数，要先找到最小容量的数组，才会回头递归调用Sort进行排序</p></li><li><p>基本原理<br>归并 &#x3D; 递归 + 合并<br>数组分左右：左右元素相比较，满足条件放入新数组，一侧用完放对面<br>递归不停分：分完再排序，排序结束往上走，边走边合并，走到头顶出结果</p></li><li><p>套路写法<br>两个函数<br>一个基本排序规则<br>一个递归平分数组</p></li><li><p>注意事项<br>排序规则函数在平分数组函数的内部 return调用</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>希尔排序</title>
    <link href="/2022/06/10/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/06/10/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>希尔排序</p><span id="more"></span><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>插入排序的升级版</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>将整个待排序序列，分割成为若干子序列，分别进行插入排序<br>希尔排序对插入排序的升级主要就是加入了一个步长的概念，通过步长每次可以把原序列分为多个子序列<br>对子序列进行插入排序，在极限情况下可以有效降低普通插入排序的时间复杂度，提升算法效率</p><h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><p>实现升序<br>比插入排序多一层循环，同时每次更换都是移动一共步长的单位<br>默认步长 &#x3D; 数组长度 &#x2F; 2, 之后每一次步长都是上一次步长&#x2F;2，步长小于1时结束<br>注意：每次得到步长后，都会把该步长下所有序列都进行插入排序</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson24_希尔排序&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            int[] array &#x3D; new int[] &#123; 8, 7, 1, 5, 4, 2, 6, 3, 9 &#125;;            ShellSort(array);            for (int i &#x3D; 0; i &lt; array.Length; i++)            &#123;                Console.WriteLine(array[i]);            &#125;        &#125;        static void ShellSort(int[] array)        &#123;                  for (int step &#x3D; array.Length &#x2F; 2; step &gt; 0; step &#x2F;&#x3D; 2)            &#123;                for (int i &#x3D; step; i &lt; array.Length; i++)                &#123;                    int sortIndex &#x3D; i - step;                    int noSortNum &#x3D; array[i];                    while (sortIndex &gt;&#x3D; 0 &amp;&amp; noSortNum &lt; array[sortIndex])                    &#123;                        array[sortIndex + step] &#x3D; array[sortIndex];                        sortIndex -&#x3D; step;                    &#125;                    array[sortIndex + step] &#x3D; noSortNum;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div><p>注意：while循环中的判断条件中，索引值的判断(sortIndex &gt;&#x3D; 0)一定要在前<br>若是在后，sortIndex变为-1时(noSortNum &lt; array[sortIndex])中array的索引会直接报错<br>今后的有关数组的循环若是有改变索引值，因注意让索引值的判断在前</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>设置步长<br>步长不断&#x2F;2缩小，直到1时结束排序</p></li><li><p>三层循环<br>第一层循环：获取步长<br>第二层循环：获取未排序区的元素<br>第三层循环：找到想要插入的位置</p></li><li><p>具体排序方式<br>插入排序的应用</p></li><li><p>注意事项<br>步长确定后，会将所有子序列进行插入排序</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>插入排序</title>
    <link href="/2022/06/09/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/06/09/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>插入排序</p><span id="more"></span><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>对于一个无序序列，将其分为两个区域：排序区、未排序区，通过一个索引值做分水岭<br>未排序区元素与排序区元素比较，将未排序区元素插入到合适位置，直到未排序区清空</p><h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><p>实现升序<br>前提规则：排序开始前，首先认为第一个元素在排序区中，其他所有元素在未排序区中<br>排序开始后：每次将未排序区第一个元素取出，用于和排序区中元素比较（从后往前），若满足条件（较大或较小），则排序区中元素往后移动一个位置<br>注意：所有数字都在一个数组中，所谓的两个区域是一个分水岭索引</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson23_插入排序&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            int[] array &#x3D; new int[] &#123; 8, 7, 1, 5, 4, 2, 6, 3, 9 &#125;;            InsertSort(array);            for (int i &#x3D; 0; i &lt; array.Length; i++)            &#123;                Console.WriteLine(array[i]);            &#125;        &#125;        static void InsertSort(int[] array)        &#123;            for (int i &#x3D; 1; i &lt; array.Length; i++)            &#123;                int sortIndex &#x3D; i - 1;                int noSortNum &#x3D; array[i];                while (sortIndex &gt;&#x3D; 0 &amp;&amp; noSortNum &lt; array[sortIndex])                &#123;                    array[sortIndex + 1] &#x3D; array[sortIndex];                    --sortIndex;                &#125;                array[sortIndex + 1] &#x3D; noSortNum;            &#125;        &#125;    &#125;&#125;</code></pre></div><p>注意：while循环中的判断条件中，索引值的判断(sortIndex &gt;&#x3D; 0)一定要在前<br>若是在后，sortIndex变为-1时(noSortNum &lt; array[sortIndex])中array的索引会直接报错<br>今后的有关数组的循环若是有改变索引值，因注意让索引值的判断在前</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>两层循环<br>第一层循环：依次取出未排序区的元素进行排序<br>第二层循环：找到想要插入的位置</p></li><li><p>第一层循环从1开始遍历<br>将数组分为两个区域<br>默认第一个元素在已排序区</p></li><li><p>使用while循环<br>满足条件才比较，否则说明插入位置已确定</p></li><li><p>直接往后移位置<br>每轮未排序数已记录，不需担忧丢失</p></li><li><p>最后需要使索引值+1<br>在循环的最后扔减了一次索引值</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年6月9日</title>
    <link href="/2022/06/09/diary/2022.6/2022%E5%B9%B46%E6%9C%889%E6%97%A5/"/>
    <url>/2022/06/09/diary/2022.6/2022%E5%B9%B46%E6%9C%889%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="b044f210c0eb2c88ed9c27b89936022989287bc87626d5a056b4b3b1c62f3913">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50eba07a9a235632a8b7b0b218e3ea35ba9f59265b68abe7c4b7756ad162c48ecf4e4efe363830c455c5b953d1a4f50793cbaefe26d85cbc8443529401f55010a1f096d27ee9b258601f75451379d77126cb33b72217564b7997a05a021a3d833519c0b817cb8aca57547a5b79ae2f9e08af1b05f08854d36f61e01bb060bb43828f8190824226f5adb48c1a2c084fafe349c3dda4de3145392cf376882864bcefdd7143b9ef8f046bc27d7c56fe34102de7fd7cd06baf45d34e68b05a97075b3e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>值类型和引用类型2</title>
    <link href="/2022/06/08/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B2/"/>
    <url>/2022/06/08/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B2/</url>
    
    <content type="html"><![CDATA[<p>值类型和引用类型2</p><span id="more"></span><h1 id="值类型和引用类型2"><a href="#值类型和引用类型2" class="headerlink" title="值类型和引用类型2"></a>值类型和引用类型2</h1><p>值类型：<br>无符号、有符号、浮点数、特殊、枚举、结构体</p><p>引用类型：<br>string、数组、class、interface、委托</p><h2 id="如何判断-值类型和引用类型"><a href="#如何判断-值类型和引用类型" class="headerlink" title="如何判断 值类型和引用类型"></a>如何判断 值类型和引用类型</h2><p>F12进到类型的内部去查看<br>class -&gt; 引用类型<br>struct -&gt; 值类型</p><h2 id="语句块"><a href="#语句块" class="headerlink" title="语句块"></a>语句块</h2><p>命名空间<br>   ↓<br>类、接口、结构体<br>   ↓<br>函数、属性、索引器、运算符重载等（类、接口、结构体）<br>   ↓<br>条件分支、循环</p><p>上层语句块：类、结构体<br>中层语句块：函数<br>底层语句块：条件分支、循环等</p><p>逻辑代码写在中层和底层</p><p>上层语句块中声明成员变量<br>中、底层语句块中声明临时变量</p><h2 id="变量的生命周期"><a href="#变量的生命周期" class="headerlink" title="变量的生命周期"></a>变量的生命周期</h2><p>编程时大部分都是 临时变量<br>在中底层声明的临时变量，在语句块执行结束后，没有被记录的对象将被回收或变成垃圾<br>值类型：被系统自动回收<br>引用类型：栈上用于存地址的房间被系统自动回收，堆中具体内容变成垃圾，待下次GC回收</p><p>要想不被回收或者不变垃圾，必须将其记录下来：<br>在更高层级记录 &#x2F; 使用静态全局变量记录</p><h2 id="结构体中的值和引用"><a href="#结构体中的值和引用" class="headerlink" title="结构体中的值和引用"></a>结构体中的值和引用</h2><p>结构体本身是值类型<br>前提：该结构体没有作为其他类的成员<br>在结构体中的值，栈中存储值的内容<br>在结构体中的引用，堆中存储引用具体的内容</p><p>引用类型始终存储在堆中<br>真正通过结构体使用其中引用类型时只是顺藤摸瓜</p><h2 id="类中的值和引用"><a href="#类中的值和引用" class="headerlink" title="类中的值和引用"></a>类中的值和引用</h2><p>类本身是引用类型<br>在类中的值，堆中存储具体的值<br>在类中的引用，堆中存储具体的值</p><p>值类型跟着大哥走，引用类型一根筋</p><h2 id="数组中的存储规则"><a href="#数组中的存储规则" class="headerlink" title="数组中的存储规则"></a>数组中的存储规则</h2><p>数组本身是引用类型<br>值类型数组，堆中房间存具体内容<br>引用类型数组，堆中房间存地址</p><h2 id="结构体继承接口"><a href="#结构体继承接口" class="headerlink" title="结构体继承接口"></a>结构体继承接口</h2><p>利用里式替换原则，用接口容器装载结构体存在装箱拆箱</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>特殊语法</title>
    <link href="/2022/06/08/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E7%89%B9%E6%AE%8A%E8%AF%AD%E6%B3%95/"/>
    <url>/2022/06/08/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E7%89%B9%E6%AE%8A%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>特殊语法</p><span id="more"></span><h1 id="特殊语法"><a href="#特殊语法" class="headerlink" title="特殊语法"></a>特殊语法</h1><h2 id="var隐式类型"><a href="#var隐式类型" class="headerlink" title="var隐式类型"></a>var隐式类型</h2><p>var是一种特殊的变量类型<br>它可以用来表示任意类型的变量<br>注意：</p><ol><li>var不能作为类的成员 只能用于临时变量声明时（一般写在函数语句块中）</li><li>var必须初始化</li></ol><h2 id="设置对象初始值"><a href="#设置对象初始值" class="headerlink" title="设置对象初始值"></a>设置对象初始值</h2><p>声明对象时<br>可以通过直接写大括号的形式初始化公共成员变量和属性<br>先执行构造函数，再执行大括号</p><h2 id="设置集合初始值"><a href="#设置集合初始值" class="headerlink" title="设置集合初始值"></a>设置集合初始值</h2><p>声明集合对象时<br>也可以通过大括号直接初始化内部属性</p><h2 id="匿名类型"><a href="#匿名类型" class="headerlink" title="匿名类型"></a>匿名类型</h2><p>var变量可以声明为自定义的匿名类型</p><h2 id="可空类型"><a href="#可空类型" class="headerlink" title="可空类型"></a>可空类型</h2><ol><li><p>值类型不能赋值为null</p></li><li><p>声明时 在值类型后面加?可以赋值为空</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">int? n &#x3D; null;int? c &#x3D; 3;</code></pre></div></li><li><p>判断是否为空</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">if( c.HasValue )&#123;    Console.WriteLine(c);    Console.WriteLine(c.Value);&#125;</code></pre></div></li><li><p>安全获取可空类型值</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">int? value &#x3D; null;&#x2F;&#x2F;4.1-如果为空，默认返回值类型的默认值Console.WriteLine(value.GetValueOrDefault());&#x2F;&#x2F;4.2-也可以指定一个默认值Console.WriteLine(value.GetValueOrDefault(100));&#x2F;&#x2F;?相当于是一种语法糖 能够自动去判断是否为null&#x2F;&#x2F;如果为null就不会执行也不报错object o &#x3D; null;o?.ToString();int[] arrayInt &#x3D; null;Console.WriteLine(arrayInt?[0]);Action action &#x3D; null;action?.Invoke();</code></pre></div></li></ol><h2 id="空合并操作符"><a href="#空合并操作符" class="headerlink" title="空合并操作符"></a>空合并操作符</h2><p>空合并操作符 ??<br>左边值 ?? 右边值<br>如果左边值为null就返回右边值，反之<br>只要是可以为null的类型都能用</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">int? intV &#x3D; null;int intI &#x3D; intV ?? 100 ;string str &#x3D; null;str &#x3D; str ?? &quot;hahaha&quot;;</code></pre></div><h2 id="内插字符串"><a href="#内插字符串" class="headerlink" title="内插字符串"></a>内插字符串</h2><p>关键符号 $<br>用$来构造字符串，让字符串中可以拼接变量</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">string st &#x3D; &quot;天天向上&quot;;Console.WriteLine($&quot;好好学习,&#123;st&#125;&quot;);</code></pre></div><h2 id="单句逻辑简略写法"><a href="#单句逻辑简略写法" class="headerlink" title="单句逻辑简略写法"></a>单句逻辑简略写法</h2>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年6月8日</title>
    <link href="/2022/06/08/diary/2022.6/2022%E5%B9%B46%E6%9C%888%E6%97%A5/"/>
    <url>/2022/06/08/diary/2022.6/2022%E5%B9%B46%E6%9C%888%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="2aa2a112af096da7941ef9d5ace83db534d0f7454c49fa15b611acea0437afed">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe506adb6fa8b87e21b2fd70e028d7df70fae1b0b8ac5b2b913d82f154f5ec6432433c15f50cf1dcd6ce7989e620855dca875ad2614c8656c586a84f41b84a48160b09188201ea00b67df2e2743f309612768e57872a827b2d171885ce99aa933d42cce54d96df727cfc031c0eab596babd48149e7aed8672a6372ac577f542446274625f478bc49f6715af88ffe685e500e25cee9200f713068599739eec5dc00a74ba8ec9b2774ffb1cbcf048f361b08d13a3d2d4eb66290b2402037e41b5af2c231875bcb59b0486e251b229b3e9fa3f925256116b129b8f49b795957bd6a0bee</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>迭代器</title>
    <link href="/2022/06/08/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <url>/2022/06/08/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>迭代器</p><span id="more"></span><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>迭代器(iterator)有时又称光标(cursor)，是程序设计的软件设计模式<br>迭代器模式提供一个方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的标识</p><p>在表现效果上看，它是一个可以在容器对象(例如链表或数组)上遍历访问的接口<br>设计人员无需关心容器对象的内存分配的实现细节<br>可以用foreach遍历的类，都是实现了迭代器的</p><h2 id="标准迭代器的实现方法"><a href="#标准迭代器的实现方法" class="headerlink" title="标准迭代器的实现方法"></a>标准迭代器的实现方法</h2><p>关键接口： IEnumerator, IEnumerable<br>命名空间： using System.Collections;<br>可以通过同时继承IEnumerator和IEnumerable实现其中的方法</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class CustomList : IEnumerable, IEnumerator&#123;    private int[] list;    &#x2F;&#x2F;从-1开始的光标，用于表示数据到了哪个位置    private int cursor &#x3D; -1;    public CustomList()    &#123;        list &#x3D; new int[] &#123;1, 2, 3, 4, 5, 6, 7, 8&#125;;    &#125;    &#x2F;&#x2F;IEnumerable的方法    public IEnumerator GetEnumerator()    &#123;        Reset();        return this;    &#125;    &#x2F;&#x2F;IEnumerator的方法    public object Current     &#123;        get        &#123;            return list[cursor];        &#125;    &#125;    public bool MoveNext()    &#123;        &#x2F;&#x2F;移动光标        ++cursor;        &#x2F;&#x2F;是否溢出  溢出就不合法        return cursor &lt; list.Length;    &#125;    public void Reset()    &#123;        cursor &#x3D; -1;    &#125;&#125;class Program&#123;    CustomList list &#x3D; new CustomList();    &#x2F;&#x2F;foreach本质：1.先获取in后面这个对象的IEnumerator 其中的GetEnumerator方法来获取    &#x2F;&#x2F;2.执行得到这个IEnumerator对象中的 MoveNext方法    &#x2F;&#x2F;3.只要MoveNext方法的返回值为true 就回去得到Current复制给item    foreach(int item in list)    &#123;        Console.WriteLine(item);    &#125;&#125;</code></pre></div><h2 id="用-yield-return-语法糖实现迭代器"><a href="#用-yield-return-语法糖实现迭代器" class="headerlink" title="用 yield return 语法糖实现迭代器"></a>用 yield return 语法糖实现迭代器</h2><p>yield return 是C#提供给我们的语法糖（糖衣语法）<br>主要作用就是讲复杂逻辑简单化，增加程序的可读性，从而煎炒程序代码出错的几率</p><p>关键接口： IEnumerable<br>命名空间： using System.Collections;<br>让想要通过foreach遍历的自定义类实现接口中的方法GetEnumerator即可</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class CustomList2 : IEnumerable&#123;    private int[] list;    public CustomList2()    &#123;        list &#x3D; new int[] &#123;1, 2, 3, 4, 5, 6, 7, 8&#125;;    &#125;    public IEnumerator GetEnumerator()    &#123;        for(int i &#x3D; 0; i &lt; list.Length; i++)        &#123;            &#x2F;&#x2F;yield关键字 配合迭代器使用            &#x2F;&#x2F;可以理解为 暂时返回 保留当前的状态            yield return list[i];        &#125;    &#125;&#125;class Program&#123;    CustomList2 list2 &#x3D; new CustomList2();    foreach(int item in list2)    &#123;        Console.WriteLine(item);    &#125;&#125;</code></pre></div><h2 id="用-yield-return-语法糖为泛型类实现迭代器"><a href="#用-yield-return-语法糖为泛型类实现迭代器" class="headerlink" title="用 yield return 语法糖为泛型类实现迭代器"></a>用 yield return 语法糖为泛型类实现迭代器</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class CustomList&lt;T&gt; : IEnumerable&#123;    private T[] array;    public CustomList(params T[] array)    &#123;        this.array &#x3D; array;    &#125;    public IEnumerator GetEnumerator()    &#123;        for(int i &#x3D; 0; i &lt; array.Length; i++)        &#123;            yield return array[i];        &#125;    &#125;&#125;class Program&#123;    CustomList&lt;string&gt; list &#x3D; new CustomList&lt;string&gt;(&quot;1&quot;,&quot;22&quot;,&quot;333&quot;);    foreach(string item in list)    &#123;        Console.WriteLine(item);    &#125;&#125;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/06/08/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E8%BF%AD%E4%BB%A3%E5%99%A8/exam.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections;namespace Lesson22_迭代器&#123;    class CustomList : IEnumerable, IEnumerator    &#123;        private int[] list;        private int cursor &#x3D; -1;        public CustomList()        &#123;            list &#x3D; new int[] &#123;1, 2, 3, 4, 5, 6, 7, 8&#125;;        &#125;        &#x2F;&#x2F;第一种        public IEnumerator GetEnumerator()        &#123;            Reset();            return this;        &#125;        public object Current        &#123;            get            &#123;                return list[cursor];            &#125;        &#125;        public bool MoveNext()        &#123;            ++cursor;            return cursor &lt; list.Length;        &#125;        public void Reset()        &#123;            cursor &#x3D; -1;        &#125;        &#x2F;&#x2F;第二种        public IEnumerator GetEnumerator()        &#123;            for (int i &#x3D; 0; i &lt; list.Length; i++)            &#123;                yield return list[i];            &#125;        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            CustomList list &#x3D; new CustomList();            foreach (int item in list)            &#123;                Console.WriteLine(item);            &#125;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反射和特性—特性</title>
    <link href="/2022/06/07/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E5%8F%8D%E5%B0%84%E5%92%8C%E7%89%B9%E6%80%A7%E2%80%94%E7%89%B9%E6%80%A7/"/>
    <url>/2022/06/07/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E5%8F%8D%E5%B0%84%E5%92%8C%E7%89%B9%E6%80%A7%E2%80%94%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>特性</p><span id="more"></span><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>特性是一种允许我们向程序的程序集添加元数据的语言结构<br>它是用于保存程序结构信息的某种特殊类型的类</p><p>特性提供功能强大的方法以将声明信息与C#代码（类型、方法、属性等）相关联<br>特性与程序实体相关联后，即可在运行时使用反射查询特性信息</p><p>特性的目的是告诉编译器把程序结构的某组元数据嵌入程序集中<br>它可以防止在几乎所有的声明中（类、变量、函数等等声明）</p><h2 id="自定义特性"><a href="#自定义特性" class="headerlink" title="自定义特性"></a>自定义特性</h2><p>继承特性基类 Attribute</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class MyCustomAttribute : Attribute&#123;    &#x2F;&#x2F;特性中的成员 一般根据需求来写    public string info;    public MyCustomAttribute(string info)    &#123;        this.info &#x3D; info;    &#125;&#125;</code></pre></div><h2 id="特性的使用"><a href="#特性的使用" class="headerlink" title="特性的使用"></a>特性的使用</h2><p>本质上就是在调用特性类的构造函数<br>写在类、函数、变量的上一行，表示他们具有该特性信息</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">[MyCustom(&quot;构造函数需要传入的成员&quot;)]class MyClass : Attribute&#123;    [MyCustom(&quot;  &quot;)]    public int value;    [MyCustom(&quot;  &quot;)]    public void TestFun([MyCustom(&quot;  &quot;)] int a)    &#123;    &#125;&#125;class Program&#123;    static void Main( string[] args )    &#123;        MyClass mc &#x3D; new MyClass();        Type t &#x3D; mc.GetType();        &#x2F;&#x2F;判断是否使用了某个特性：参数1：特性的类型；参数2：代表是否搜索继承链（属性和时间忽略此参数）        if(t.IsDefined(typeof(MyCustomAttribute)), false)        &#123;            Console.WriteLine(&quot;该类型应用了MyCustom特性&quot;);        &#125;        &#x2F;&#x2F;取Type元数据中的所有特性        object[] array &#x3D; t.GetCustomAttributes(true);    &#125;&#125;</code></pre></div><h2 id="限制自定义特性的使用范围"><a href="#限制自定义特性的使用范围" class="headerlink" title="限制自定义特性的使用范围"></a>限制自定义特性的使用范围</h2><p>通过为特性类 加特性 限制其使用范围</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple &#x3D; true, Inherited &#x3D; false)]</code></pre></div><p>第一个参数 AttributeTargets - 特性能用在哪些地方<br>第二个参数 AllowMultiple - 是否允许多个特性实例用在同一个目标上<br>第三个参数 Inherited - 特性能否被派生类和重写成员继承</p><h2 id="系统自带特性-过时特性"><a href="#系统自带特性-过时特性" class="headerlink" title="系统自带特性-过时特性"></a>系统自带特性-过时特性</h2><p>过时特性 obsolete<br>用于提示用户 使用的方法等成员已经过时 建议使用新方法<br>一般加在函数前的特性</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">[Obsolete(&quot;&#x2F;&#x2F;&quot;, true)]</code></pre></div><p>第一个参数 调用过时方法时提示的内容<br>第二个参数 true-使用该方法时会报错; false-使用该方法会警告</p><h2 id="系统自带特性-调用者信息特性"><a href="#系统自带特性-调用者信息特性" class="headerlink" title="系统自带特性-调用者信息特性"></a>系统自带特性-调用者信息特性</h2><p>需要引用命名空间 using System.Runtime.CompilerServices;</p><p>CallerFilePath特性 - 被调用的文件路径<br>CallerLineNumber特性 - 被调用的行数<br>CallerNumberName特性 - 被调用的函数名</p><p>一般作为函数参数的特性</p><h2 id="系统自带特性-条件编译特性"><a href="#系统自带特性-条件编译特性" class="headerlink" title="系统自带特性-条件编译特性"></a>系统自带特性-条件编译特性</h2><p>条件编译特性 Conditional<br>它会和预处理指令 #define配合使用</p><p>需要引用命名空间 using System.Diagnostics;<br>主要可以用在一些调试代码上<br>有时想执行有时不想执行的代码上</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">[Obsolete(&quot;函数名&quot;)]</code></pre></div><h2 id="系统自带特性-外部Dll包函数特性"><a href="#系统自带特性-外部Dll包函数特性" class="headerlink" title="系统自带特性-外部Dll包函数特性"></a>系统自带特性-外部Dll包函数特性</h2><p>DllImport<br>需要引用命名空间 using System.Runtime.InteropServices;</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">[DllImport(&quot;***.dll&quot;)]</code></pre></div><p>用来标记非.Net(C#)的函数，表明该函数在一个外部的Dll中定义<br>一般用来调用 C或者C++的Dll包写好的方法</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/06/07/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E5%8F%8D%E5%B0%84%E5%92%8C%E7%89%B9%E6%80%A7%E2%80%94%E7%89%B9%E6%80%A7/exam.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Reflection;namespace Lesson21_反射和特性_特性&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Assembly assembly &#x3D; Assembly.LoadFrom(@&quot;F:\CSharp学习\CSharp进阶教学\类库测试\bin\Debug\类库测试&quot;);            Type[] types &#x3D; assembly.GetTypes();            foreach (Type t in types)            &#123;                Console.WriteLine(t);            &#125;            Type playerType &#x3D; assembly.GetType(&quot;类库测试.Player&quot;);            object playerObj &#x3D; Activator.CreateInstance(playerType);            Console.WriteLine(playerObj);            FieldInfo[] fields &#x3D; playerType.GetFields();            foreach (FieldInfo field in fields)            &#123;                Console.WriteLine(field);            &#125;            &#x2F;&#x2F;首先得到自定义特性的type            Type attribute &#x3D; assembly.GetType(&quot;类库测试.MyCustomAttribute&quot;);            &#x2F;&#x2F;赋值名字            FieldInfo fieldStr &#x3D; playerType.GetField(&quot;name&quot;);            if(fieldStr.GetCustomAttribute(attribute) !&#x3D; null)            &#123;                Console.WriteLine(&quot;非法操作，随意修改name成员&quot;);            &#125;            else            &#123;                fieldStr.SetValue(playerObj, &quot;123123&quot;);            &#125;                   &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反射和特性—反射</title>
    <link href="/2022/06/07/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E5%8F%8D%E5%B0%84%E5%92%8C%E7%89%B9%E6%80%A7%E2%80%94%E5%8F%8D%E5%B0%84/"/>
    <url>/2022/06/07/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E5%8F%8D%E5%B0%84%E5%92%8C%E7%89%B9%E6%80%A7%E2%80%94%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<p>反射</p><span id="more"></span><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="程序集"><a href="#程序集" class="headerlink" title="程序集"></a>程序集</h2><p>程序集是经由编译器编译得到的，供进一步编译执行的那个中间产物<br>在WINDOWS系统中，它一般表现为后缀为.dll(库文件) 或者是 .exe(可执行文件)</p><p>即 程序集就是代码集合，最终会被编译器翻译为一个程序集供别人使用</p><h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><p>元数据就是用来描述数据的数据<br>程序中的类，类中的函数、变量等等信息就是程序的元数据<br>有关程序以及类型的数据被称为 元数据，它们保存在程序集中</p><h2 id="反射的概念"><a href="#反射的概念" class="headerlink" title="反射的概念"></a>反射的概念</h2><p>程序正在运行时，可以查看其他程序集或者自身的元数据<br>反射：一个运行的程序查看本身或者其他程序的元数据的行为</p><h2 id="反射的作用"><a href="#反射的作用" class="headerlink" title="反射的作用"></a>反射的作用</h2><p>因为反射可以在程序编译后获得信息，所以它提高了程序的拓展性和灵活性<br>1.程序运行时得到所有元数据，包括元数据的特性<br>2.程序运行时实例化对象，操作对象<br>3.程序运行时创建新对象，用这些对象执行任务</p><h2 id="反射的语法"><a href="#反射的语法" class="headerlink" title="反射的语法"></a>反射的语法</h2><h3 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h3><p>Type(类的信息类)<br>它是反射功能的基础，是访问元数据的主要方式<br>使用Type的成员获取有关类型声明的信息，有关类型的成员（如构造函数、方法、字段、属性和类的事件）</p><h4 id="获取Type："><a href="#获取Type：" class="headerlink" title="获取Type："></a>获取Type：</h4><p>1.万物之父object中的GetType()可以获取对象的Type</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">int a &#x3D; 1;Type type &#x3D; a.GetType();</code></pre></div><p>2.通过typeof关键字传入类名，也可以得到对象的Type</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Type type2 &#x3D; typeof(int);</code></pre></div><p>3.通过类的名字，也可以获取类型<br>注意：类名必须包含命名空间，不然找不到</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Type type3 &#x3D; Type.GetType(&quot;System.Int32&quot;);</code></pre></div><p>type所指的类型都是堆内同一个地址</p><h4 id="得到类的程序集信息"><a href="#得到类的程序集信息" class="headerlink" title="得到类的程序集信息"></a>得到类的程序集信息</h4><p>可以通过Type可以得到类型所在程序集信息</p><h4 id="获取类中的所有公共成员"><a href="#获取类中的所有公共成员" class="headerlink" title="获取类中的所有公共成员"></a>获取类中的所有公共成员</h4><p>首先得到Type，然后得到所有公共成员，需要引用命名空间 using System.Reflection;</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System.Reflection;    Type t &#x3D; typeof(Test);    MemberInfo[] infos &#x3D; t.GetMembers();</code></pre></div><h4 id="获取类的公共构造函数并调用"><a href="#获取类的公共构造函数并调用" class="headerlink" title="获取类的公共构造函数并调用"></a>获取类的公共构造函数并调用</h4><ol><li><p>获取所有构造函数</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">ConstructorInfo[] ctors &#x3D; t.GetConstructors();</code></pre></div></li><li><p>获取其中一个构造函数，并执行<br>得到构造函数要传入Type数组，数组中内容按顺序是参数类型<br>执行构造函数传入object数组，表示按顺序传入的参数</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;2.1-得到无参构造ConstructorInfo info &#x3D; t.GetConstructor( new Type[0] );&#x2F;&#x2F;执行无参构造，无参构造没有参数传入nullTest obj &#x3D; info.Invoke(null) as Test;&#x2F;&#x2F;2.2-得到有参构造ConstructorInfo info2 &#x3D; t.GetConstructor( new Type[] &#123; typeof(int) &#125; );&#x2F;&#x2F;obj &#x3D; info2.Invoke( new object[] &#123; 2 &#125; ) as Test;</code></pre></div></li></ol><h4 id="获取类的公共成员变量"><a href="#获取类的公共成员变量" class="headerlink" title="获取类的公共成员变量"></a>获取类的公共成员变量</h4><ol><li><p>得到所有公共成员变量</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">FieldInfo[] fieldInfos &#x3D; t.GetFields();</code></pre></div></li><li><p>得到指定名称的公共成员变量</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">FieldInfo infoJ &#x3D; t.GetField(&quot;j&quot;);</code></pre></div></li><li><p>通过反射获取和设置对象的值</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;3.1-通过反射获取对象的某个变量的值infoJ.GetValue(test);&#x2F;&#x2F;3.2-通过反射设置指定对象的某个变量的值infoJ.SetValue(tset, 100);</code></pre></div></li></ol><h4 id="获取类的公共成员方法"><a href="#获取类的公共成员方法" class="headerlink" title="获取类的公共成员方法"></a>获取类的公共成员方法</h4><p>通过Type类中的GetMethod方法，得到类中的方法<br>MethodInfo是方法的反射信息</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Type strType &#x3D; typeof(string);</code></pre></div><ol><li>如果存在方法重载 用Type数组表示参数类型</li></ol><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">MethodInfo[] methods &#x3D; strType.GetMethods();MethodInfo subStr &#x3D; strType.GetMethod(&quot;Substring&quot;, new Type[] &#123; typeof(int), typeof(int) &#125; );</code></pre></div><ol start="2"><li>调用该方法<br>注意：如果是静态方法 Invoke中第一个参数传null即可<div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">string str &#x3D; &quot;Hello,world!&quot;;&#x2F;&#x2F;第一个参数是被使用方法的对象object result &#x3D; subStr.Invoke(str, new object[]&#123; 7, 5 &#125; );</code></pre></div></li></ol><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>得枚举 GetEnumName GetEnumNames<br>得事件 GetEvent GetEvents<br>得接口 GetInterface GetInterfaces<br>得属性 GetProperty GetPropertys<br>等等</p><h3 id="Activator"><a href="#Activator" class="headerlink" title="Activator"></a>Activator</h3><p>用于快速实例化对象的类<br>用于将Type对象快捷实例化为对象<br>先得到Type，然后快速实例化一个对象</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Type testType &#x3D; typeof(Test);&#x2F;&#x2F;1.无参构造Test testObj &#x3D; Activator.CreateInstance(testType) as Test;&#x2F;&#x2F;2.有参构造testObj &#x3D; Activator..CreateInstance(testType, 99) as Test;testObj &#x3D; Activator..CreateInstance(testType, 99, &quot;123&quot;) as Test;</code></pre></div><h3 id="Assembly"><a href="#Assembly" class="headerlink" title="Assembly"></a>Assembly</h3><p>程序集类：主要用来加载其他程序集，加载后才能用Type来使用其他程序集中的信息<br>如果想要使用不是自己程序集中的内容，需要先加载程序集，比如dll文件<br>简单的可以把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量、函数或类</p><h4 id="三种加载程序集的函数："><a href="#三种加载程序集的函数：" class="headerlink" title="三种加载程序集的函数："></a>三种加载程序集的函数：</h4><ol><li><p>一般用来加载在同一文件下的其他程序集</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Assembly assembly2 &#x3D; Assembly.Load(&quot;程序集名称&quot;);</code></pre></div></li><li><p>一般用来加载不在同一文件夹下的其他程序集</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Assembly assembly &#x3D; Assembly.LoadFrom(&quot;包含程序集清单的文件的名称或路径&quot;);Assembly assembly3 &#x3D; Assembly.LoadFile(&quot;要加载的文件的完全限定路径&quot;);</code></pre></div></li></ol><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ol><li>先加载一个指定程序集</li><li>再加载程序集中的一个类对象，之后才能使用反射</li><li>通过反射，实例化一个icon对象</li><li>首先得到枚举Type，来得到可以传入的参数</li><li>直接实例化对象</li><li>通过反射得到对象中的方法</li></ol><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Assembly assembly &#x3D; Assembly.LoadFrom(@&quot;F:\CSharp学习\CSharp进阶教学\Lesson18_多线程\bin\Debug\net5.0\Lesson18_多线程&quot;);Type[] types &#x3D; assembly.GetTypes();foreach (Type t in types)&#123;    Console.WriteLine(t.FullName);&#125;    Type icon &#x3D; assembly.GetType(&quot;Lesson18_多线程.Icon&quot;);MemberInfo[] members &#x3D; icon.GetMembers();foreach (MemberInfo member in members)&#123;    Console.WriteLine(member);&#125;Type moveDir &#x3D; assembly.GetType(&quot;Lesson18_多线程.E_MoveDir&quot;);FieldInfo right &#x3D; moveDir.GetField(&quot;Right&quot;);&#x2F;&#x2F;先得到枚举的type，再得到枚举的成员变量，最后得到枚举具体的值（.GetValue(null)）object iconObj &#x3D; Activator.CreateInstance(icon, 10, 5, right.GetValue(null));MethodInfo move &#x3D; icon.GetMethod(&quot;Move&quot;);MethodInfo draw &#x3D; icon.GetMethod(&quot;Draw&quot;);MethodInfo clear &#x3D; icon.GetMethod(&quot;Clear&quot;);Console.Clear();while (true)&#123;    Thread.Sleep(1000);    clear.Invoke(iconObj, null);    move.Invoke(iconObj, null);    draw.Invoke(iconObj, null);&#125;</code></pre></div><h2 id="创建类库"><a href="#创建类库" class="headerlink" title="创建类库"></a>创建类库</h2><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/06/07/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E5%8F%8D%E5%B0%84%E5%92%8C%E7%89%B9%E6%80%A7%E2%80%94%E5%8F%8D%E5%B0%84/exam.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Reflection;using System.Threading;namespace Lesson20_反射和特性_反射&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Assembly assembly &#x3D; Assembly.LoadFrom(@&quot;F:\CSharp学习\CSharp进阶教学\类库测试\bin\Debug\类库测试&quot;);            Type[] types &#x3D; assembly.GetTypes();            foreach (Type t in types)            &#123;                Console.WriteLine(t);            &#125;            Type player &#x3D; assembly.GetType(&quot;类库测试.Player&quot;);            object playerObj &#x3D; Activator.CreateInstance(player);            Console.WriteLine(playerObj);        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年6月7日</title>
    <link href="/2022/06/07/diary/2022.6/2022%E5%B9%B46%E6%9C%887%E6%97%A5/"/>
    <url>/2022/06/07/diary/2022.6/2022%E5%B9%B46%E6%9C%887%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="77c1d18e869b326726a5e46bc768b65004bbaa536b146b10922677673f40bd0b">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe506e3bbc3039a6aa643d94bba3c0a5944c3b85422045f6e2203dc4ff2ad82f203258b39147c160eea54b80296653ea7f41991a00d9b75f386aea9e6e57e45d9a8263cdaa43ee74fd463c354dfc87e6a9d3e5df441a19c1d7b6db03032748aa13a5d4130e98c4568eeb888c57b79df6ddc4bdad31e113eb0f219ef6d90c3f652c54</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>预处理器指令</title>
    <link href="/2022/06/06/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E6%8C%87%E4%BB%A4/"/>
    <url>/2022/06/06/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>预处理器指令</p><span id="more"></span><h1 id="预处理器指令"><a href="#预处理器指令" class="headerlink" title="预处理器指令"></a>预处理器指令</h1><h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><p>编译器是一种翻译程序<br>它用于将源语言程序翻译成目标语言程序<br>源语言程序：C#、C、C++、Java<br>目标语言程序：二进制数表示的伪机器代码写的程序</p><h2 id="预处理器指令-1"><a href="#预处理器指令-1" class="headerlink" title="预处理器指令"></a>预处理器指令</h2><p>预处理器指令:<br>1.指导编译器在实际编译开始之前对信息进行预处理<br>2.都是以#开始<br>3.不是语句，所以不以；结束</p><h2 id="常见的预处理器指令"><a href="#常见的预处理器指令" class="headerlink" title="常见的预处理器指令"></a>常见的预处理器指令</h2><ol><li>#define<br>定义了一个符号，类似一个没有值的变量</li></ol><p>#undef<br>取消define定义的符号，让其失效<br>两者都是写在脚本文件最前面<br>一般配合 if指令使用 或配合特性</p><p>判断所在平台:PC&#x2F;iOS&#x2F;Android</p><ol start="2"><li><p>#if #elif #else #endif<br>和if语句规则一样，一般配合#define定义的符号使用<br>可以配合逻辑与或<br>用于告诉编译器进行编译代码的流程控制</p></li><li><p>#warning #error<br>告诉编译器是报警告还是报错<br>一般还是配合#if使用</p></li></ol><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/06/06/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E6%8C%87%E4%BB%A4/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><p>#define<br>#undef<br>#if<br>#elif<br>#else<br>#endif<br>#warning<br>#error</p><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">#define Unity5#define Unity2017#define Unity2020using System;namespace Lesson19_预处理器指令&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Console.WriteLine(Calc(10, 5));        &#125;        static int Calc(int a, int b)        &#123;#if Unity5            return a + b;#elif Unity2017            return a * b;#else            return a - b;#endif        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年6月6日</title>
    <link href="/2022/06/06/diary/2022.6/2022%E5%B9%B46%E6%9C%886%E6%97%A5/"/>
    <url>/2022/06/06/diary/2022.6/2022%E5%B9%B46%E6%9C%886%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="e8ad5cbc8151b5779d77ef9357a282809511dac15d30b66661487256f11fc9b4">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50fdd0ca3edc57389bd0e88084b7db2023f7942cd8762e524c0666b6efe70c1762acc788116f6736bc674e211a2d0d06aa3ce76477735d2e1334d977d8ce4380eb9e3d0da3c5390f5b8f7aa2b9df82da58d4dec6c57342a6e787f0b0b75312fa0dbc3f2cd6b7bb96b1b78302777cdd8bc0ab8795ca7aca95a4e22202f800b68d42d1a43c68f5b5a63560a665c5da373993</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程</title>
    <link href="/2022/06/05/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2022/06/05/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>多线程</p><span id="more"></span><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程(process)：</p><ol><li>计算机中的程序关于某数据集合上的一次运行活动</li><li>系统进行资源费配和调度的基本单位</li><li>操作系统结构的基础</li></ol><p>打开一个应用程序就是在操作系统上开启了一个进程<br>进程之间可以相互独立运行，互不干扰<br>进程之间也可以相互访问、操作</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是操作系统能够进行运算调度的最小单位<br>它被包含在进程之中，是进程中的实际运作单位<br>一条线程指的是进程中的一个单一顺序的控制流，一个进程中可以并发多个线程<br>目前写的程序都在主线程中</p><p>简单理解：代码从上到下运行的一条“管道”</p><h2 id="多线程-1"><a href="#多线程-1" class="headerlink" title="多线程"></a>多线程</h2><p>通过代码开启新的线程<br>可以同时运行代码的多条“管道” 就叫多线程</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>线程类 Thread</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Threading;namespace Lesson18_多线程&#123;    internal class Program    &#123;        static bool isRunning &#x3D; true;        static void Main(string[] args)        &#123;            &#x2F;&#x2F;1.声明一个新的线程（线程执行的代码需要封装到一个函数中）            Thread t &#x3D; new Thread(NewThreadLogic);            &#x2F;&#x2F;2.启动线程            t.Start();            &#x2F;&#x2F;3.设置为后台线程（当前台线程都结束了的时候，整个程序也就结束了）            &#x2F;&#x2F;（后台线程不会防止应用程序的进程被终止掉，如果不设置为后台进程，可能导致进程无法正常关闭）            t.IsBackground &#x3D; true;            &#x2F;&#x2F;4.关闭释放一个线程（如果开启的线程中不是死循环，而是可以结束的逻辑，那就不需要刻意的关闭它）            &#x2F;&#x2F;（如果是死循环，想要终止这个线程，有两种方式）            &#x2F;&#x2F;4-1.死循环中bool标识            Console.ReadKey();            isRunning &#x3D; false;            Console.ReadKey();            &#x2F;&#x2F;4-2.通过线程提供的方法（注意在.Net core版本中无法终止，会报错）            t.Abort();            &#x2F;&#x2F;5.线程休眠（让线程休眠多少毫秒；在哪个线程里执行，就休眠哪个线程）            Thread.Sleep(1000);        &#125;        static void NewThreadLogic() &#x2F;&#x2F;不能有输入        &#123;            while(isRunning)            &#123;                Thread.Sleep(1000);                Console.WriteLine(&quot;新开线程代码逻辑&quot;);            &#125;        &#125;    &#125;&#125;</code></pre></div><h2 id="线程之间共享数据"><a href="#线程之间共享数据" class="headerlink" title="线程之间共享数据"></a>线程之间共享数据</h2><p>多个线程使用的内存是共享的，都属于该应用程序（进程）<br>所以要注意 当多线程 同时操作同一片内存区域时可能会出问题<br>可以通过加锁的形式避免问题</p><p>为了避免不必要的逻辑顺序执行的查错</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">static object obj &#x3D; new object();lock(obj)&#123;    &#x2F;&#x2F;想锁的逻辑&#125;</code></pre></div><h2 id="多线程的意义"><a href="#多线程的意义" class="headerlink" title="多线程的意义"></a>多线程的意义</h2><p>可以用多线程专门处理一些复杂耗时的逻辑<br>比如 寻路、网络通信 等等</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/06/05/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E5%A4%9A%E7%BA%BF%E7%A8%8B/exam.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Threading;namespace Lesson18_多线程&#123;    enum E_MoveDir    &#123;        Up,        Down,        Left,        Right,    &#125;    class Icon    &#123;        public int x, y;        public E_MoveDir dir;        &#x2F;&#x2F;构造函数        public Icon(int x, int y, E_MoveDir dir)        &#123;            this.x &#x3D; x;            this.y &#x3D; y;            this.dir &#x3D; dir;        &#125;        &#x2F;&#x2F;清空上一个        public void Clear()        &#123;            Console.SetCursorPosition(x, y);            Console.Write(&quot;  &quot;);        &#125;        &#x2F;&#x2F;画移动后的        public void Draw()        &#123;            Console.SetCursorPosition(x, y);            Console.ForegroundColor &#x3D; ConsoleColor.Red;            Console.Write(&quot;■&quot;);        &#125;        &#x2F;&#x2F;移动        public void Move()        &#123;            switch (this.dir)            &#123;                case E_MoveDir.Up:                    --y;                    break;                case E_MoveDir.Down:                    ++y;                    break;                case E_MoveDir.Left:                    x -&#x3D; 2;                    break;                case E_MoveDir.Right:                    x +&#x3D; 2;                    break;            &#125;        &#125;        public void ChangeDir(E_MoveDir dir)        &#123;            this.dir &#x3D; dir;        &#125;    &#125;    internal class Program    &#123;        static Icon icon;         static bool isRunning &#x3D; true;        static void Main(string[] args)        &#123;            icon &#x3D; new Icon(10, 10, E_MoveDir.Right);            icon.Draw();            Console.CursorVisible &#x3D; false;            Thread t &#x3D; new Thread(ChangeDirLogic);            t.Start();            t.IsBackground &#x3D; true;                                  while (true)            &#123;                Thread.Sleep(500);                icon.Clear();                icon.Move();                icon.Draw();                           &#125;                  &#125;        static void ChangeDirLogic()        &#123;            while (isRunning)            &#123;                switch (Console.ReadKey(true).Key)                &#123;                    case ConsoleKey.W:                        icon.ChangeDir(E_MoveDir.Up);                        break;                    case ConsoleKey.S:                        icon.ChangeDir(E_MoveDir.Down);                        break;                    case ConsoleKey.A:                        icon.ChangeDir(E_MoveDir.Left);                        break;                    case ConsoleKey.D:                        icon.ChangeDir(E_MoveDir.Right);                        break;                &#125;            &#125;                    &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年6月5日</title>
    <link href="/2022/06/05/diary/2022.6/2022%E5%B9%B46%E6%9C%885%E6%97%A5/"/>
    <url>/2022/06/05/diary/2022.6/2022%E5%B9%B46%E6%9C%885%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="cb4ad14b9f1a2afe9c8cedc103bf5e754f655a60f191a3b1da230e419fbc390e">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe5096e8f1a7b4feb0815812d017ca37abd670db0ed34c612cf76d4910e575a06cf5a923a3f541ff3c8de04607438097a9af2e0eb62956286e1037a6e19c5ae81993ef8ce068042072c3dc94e0aef20273d4eaf102c1e2095586fd9e5202267516b5ae18cc95628b4b27f66cbf7d49c707364cd06dcbfee074bbc8b8e1efa0d0c7b03d0bb139b27e4c5ca833c6ceec9f322e8a40275410847d635b6faa66e73d492206a9dfe17f2675dc18a949db3a28d44a1f51fdfd20b12e504085131e86f0bc220cef1eb7417f32b54e7c42fc64a2970926391de3847c70e583bd7f5e839ba214ae75fe82ea0d1e3a1f785a1bae09e2f00f5871fc13ebd3bc8e52622b91aa7d465c78d6379fcae390429462665c9749ec34dda026a425701b2a491889eacf84df380e46466723e801f65ffd7fa244af2dd6d0159df5b6178526e02c050be9a1e509d52cfc1285e803f71339def736151a529ba15d6e81d32f8ded6a9bceabfde4623f96a3f7cf0cdc48198f7b636b78406dac9b569104bccfa08240311141a60808843c1ab5e836c2cdfea10513bcc27ba5f6b0647137b78b684cf9d8e332af6b96f662edb2b3117843075ec0873d4c306f32ad66fe6dc87497d3083acc467927</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>协变逆变</title>
    <link href="/2022/06/04/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E5%8D%8F%E5%8F%98%E9%80%86%E5%8F%98/"/>
    <url>/2022/06/04/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E5%8D%8F%E5%8F%98%E9%80%86%E5%8F%98/</url>
    
    <content type="html"><![CDATA[<p>协变逆变</p><span id="more"></span><h1 id="协变逆变"><a href="#协变逆变" class="headerlink" title="协变逆变"></a>协变逆变</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>协变：和谐的变换，自然的变化<br>因为里式替换原则，父类可以装子类<br>所以子类变父类，比如 string变成object<br>这个感受是和谐的</p><p>逆变：逆常规的变化，不正常的变化<br>因为里式替换原则，父类可以装子类，但是子类不能装父类<br>所以父类变子类，比如 object变成string<br>这个感受是不和谐的</p><p>协变和逆变是用来修饰泛型的<br>协变：out   逆变：in<br>用于在泛型中修饰泛型字母的<br>只有泛型接口和泛型委托能使用</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol><li>返回值 和 参数</li></ol><p>(1) 用out修饰的泛型 只能作为返回值</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">delegate T TestOut &lt;out T&gt;();</code></pre></div><p>(2) 用in修饰的泛型 只能作为参数</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">delegate void TestIn &lt;in T&gt;(T t);</code></pre></div><ol start="2"><li>结合里式替换原则去理解</li></ol><p>(1) 协变</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">delegate T TestOut &lt;out T&gt;();class Father&#123;&#125;class Son : Father&#123;&#125;class Program&#123;    static void Main()    &#123;        &#x2F;&#x2F;协变 父类泛型委托装子类泛型委托        &#x2F;&#x2F;看起来就是 son -&gt; father        TestOut&lt;Son&gt; os &#x3D; () &#x3D;&gt;        &#123;            return new Son();        &#125;;        TestOut&lt;Father&gt; of &#x3D; os;        Father f &#x3D; of(); &#x2F;&#x2F;实际上返回的是 os里面装的函数 返回的是Son    &#125;&#125;</code></pre></div><p>(2) 逆变</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">delegate void TestIn &lt;in T&gt;(T t);class Father&#123;&#125;class Son : Father&#123;&#125;class Program&#123;    static void Main()    &#123;        &#x2F;&#x2F;逆变 子类泛型委托装父类泛型委托        &#x2F;&#x2F;看起来就是 father -&gt; son        TestIn&lt;Father&gt; iF &#x3D; (value) &#x3D;&gt;        &#123;                    &#125;;        TestIn&lt;Son&gt; iS &#x3D; iF;        iS(new Son()); &#x2F;&#x2F;实际上 调用的是iF    &#125;&#125;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/06/04/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E5%8D%8F%E5%8F%98%E9%80%86%E5%8F%98/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><p>协变和逆变是用来修饰泛型替代符的，且只能用于泛型委托和泛型接口中</p><ol><li><p>out修饰的泛型类型只能作为返回值类型，in修饰的泛型类型只能作为参数类型<br>out协变，in逆变</p></li><li><p>遵循里式替换原则，用out和in修饰的泛型委托可以相互装载</p></li></ol><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">delegate T TestOut &lt;out T&gt;();delegate void TestIn &lt;in T&gt;(T t);class Father&#123;&#125;class Son : Father&#123;&#125;class Program&#123;    static void Main()    &#123;        &#x2F;&#x2F;协变 父类泛型委托装子类泛型委托        &#x2F;&#x2F;看起来就是 son -&gt; father        TestOut&lt;Son&gt; os &#x3D; () &#x3D;&gt;        &#123;            return new Son();        &#125;;        TestOut&lt;Father&gt; of &#x3D; os;        Father f &#x3D; of(); &#x2F;&#x2F;实际上返回的是 os里面装的函数 返回的是Son        &#x2F;&#x2F;逆变 子类泛型委托装父类泛型委托        &#x2F;&#x2F;看起来就是 father -&gt; son        TestIn&lt;Father&gt; iF &#x3D; (value) &#x3D;&gt;        &#123;                    &#125;;        TestIn&lt;Son&gt; iS &#x3D; iF;        iS(new Son()); &#x2F;&#x2F;实际上 调用的是iF    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>List排序</title>
    <link href="/2022/06/04/CSharp/CSharp%E8%BF%9B%E9%98%B6/List%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/06/04/CSharp/CSharp%E8%BF%9B%E9%98%B6/List%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>List排序</p><span id="more"></span><h1 id="List排序"><a href="#List排序" class="headerlink" title="List排序"></a>List排序</h1><h2 id="List自带排序方法"><a href="#List自带排序方法" class="headerlink" title="List自带排序方法"></a>List自带排序方法</h2><p>系统自带的变量(int, double ,float, …)可以直接Sort</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">List&lt;int&gt; list &#x3D; new List&lt;int&gt;();&#x2F;&#x2F;升序排序list.Sort();&#x2F;&#x2F;ArrayList中也有Sort方法</code></pre></div><h2 id="自定义类的排序"><a href="#自定义类的排序" class="headerlink" title="自定义类的排序"></a>自定义类的排序</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Item : IComparable&lt;Item&gt;&#123;    public int money;    public Item(int money)    &#123;        this.money &#x3D; money;    &#125;    public int CompareTo(Item other)    &#123;        &#x2F;&#x2F;返回值的含义        &#x2F;&#x2F;大于0：放在传入对象的后面        &#x2F;&#x2F;等于0：保持当前位置不变        &#x2F;&#x2F;小于0：放在传入对象的前面        if(this.money &gt; other.money)            &#123;            return 1;        &#125;        else         &#123;            return -1;        &#125;    &#125;&#125;List&lt;Item&gt; listItem &#x3D; new List&lt;Item&gt;();  listItem.Sort();</code></pre></div><h2 id="通过委托函数进行排序"><a href="#通过委托函数进行排序" class="headerlink" title="通过委托函数进行排序"></a>通过委托函数进行排序</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class shopItem &#123;    public int id;    public shopItem(int id)    &#123;        this.id &#x3D; id;    &#125;&#125;List&lt;shopItem&gt; listShopItem &#x3D; new List&lt;shopItem&gt;();  listShopItem.Sort(SortShopItem);static int SortShopItem( shopItem a, shopItem b ) &#123;    &#x2F;&#x2F;传入的两个对象为列表中的两个对象    &#x2F;&#x2F;左边的a和右边的b比较 a比b大就放在b的后面（前面）    if( a.id &gt; b.id )    &#123;        return 1;    &#125;    else    &#123;        return -1;    &#125;&#125;&#x2F;&#x2F;也可以直接匿名函数listShopItem.Sort(delegate( shopItem a, shopItem b )&#123;    if( a.id &gt; b.id )    &#123;        return 1;    &#125;    else    &#123;        return -1;    &#125;&#125;);&#x2F;&#x2F;甚至lambda表达式(配合三目运算符)listShopItem.Sort((a, b) &#x3D;&gt; &#123; return a.id &gt; b.id ? 1 : -1; &#125;);</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/06/04/CSharp/CSharp%E8%BF%9B%E9%98%B6/List%E6%8E%92%E5%BA%8F/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;namespace Lesson16_List排序&#123;    class Monster    &#123;        public int atk;        public int def;        public int hp;        public Monster(int atk, int def, int hp)        &#123;            this.atk &#x3D; atk;            this.def &#x3D; def;            this.hp &#x3D; hp;        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            List&lt;Monster&gt; monsters &#x3D; new List&lt;Monster&gt;();            Random r &#x3D; new Random();            for (int i &#x3D; 0; i &lt; 10; i++)            &#123;                monsters.Add(new Monster(r.Next(20, 50), r.Next(10, 30), r.Next(100, 200)));            &#125;            Console.WriteLine(&quot;输入1按攻击排序，输入2按防御排序，输入3按血量排序，输入4反转&quot;);            try            &#123;                int inputIndex &#x3D; int.Parse(Console.ReadLine());                switch (inputIndex)                &#123;                    case 1:                        monsters.Sort((a, b) &#x3D;&gt; &#123; return a.atk &gt; b.atk ? 1 : -1; &#125;);                        break;                    case 2:                        monsters.Sort((a, b) &#x3D;&gt; &#123; return a.def &gt; b.def ? 1 : -1; &#125;);                        break;                    case 3:                        monsters.Sort((a, b) &#x3D;&gt; &#123; return a.hp &gt; b.hp ? 1 : -1; &#125;);                        break;                    case 4:                        monsters.Reverse();                        break;                &#125;                for (int i &#x3D; 0; i &lt; monsters.Count; i++)                &#123;                    Console.WriteLine(&quot;怪兽&#123;0&#125;的攻击力&#123;1&#125;，防御力&#123;2&#125;，血量&#123;3&#125;&quot;, i, monsters[i].atk, monsters[i].def, monsters[i].hp);                &#125;            &#125;            catch            &#123;                Console.WriteLine(&quot;请输入正确的数字&quot;);            &#125;        &#125;    &#125;&#125;</code></pre></div><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;namespace Lesson16_List排序&#123;    class Item    &#123;        public int type;        public string name;        public int quality;        public Item(int type, string name, int quality)        &#123;            this.type &#x3D; type;            this.name &#x3D; name;            this.quality &#x3D; quality;        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            List&lt;Item&gt; items &#x3D; new List&lt;Item&gt;();            Random r &#x3D; new Random();            Console.WriteLine(&quot;排序权重：类型 &gt; 品质 &gt; 名字长度&quot;);            for (int i &#x3D; 0; i &lt; 10; i++)            &#123;                items.Add(new Item(r.Next(1, 7), &quot;Item&quot; + r.Next(1, 300), r.Next(10, 100)));                Console.WriteLine(&quot;物品类型&#123;0&#125;，名字&#123;1&#125;，品质&#123;2&#125;&quot;, items[i].type, items[i].name, items[i].quality);            &#125;            items.Sort((a, b) &#x3D;&gt;            &#123;                if (a.type !&#x3D; b.type)                &#123;                    return a.type &gt; b.type ? 1 : -1;                &#125;                else if (a.quality !&#x3D; b.quality)                &#123;                    return a.quality &gt; b.quality ? -1 : 1;                &#125;                else                &#123;                    return (a.name).Length &gt; (b.name).Length ? 1 : -1;                &#125;            &#125;);            Console.WriteLine(&quot;&quot;);            for (int i &#x3D; 0; i &lt; 10; i++)            &#123;                Console.WriteLine(&quot;物品类型&#123;0&#125;，名字&#123;1&#125;，品质&#123;2&#125;&quot;, items[i].type, items[i].name, items[i].quality);            &#125;        &#125;    &#125;&#125;</code></pre></div><h2 id="题3"><a href="#题3" class="headerlink" title="题3"></a>题3</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;namespace Lesson16_List排序&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Dictionary&lt;int, int&gt; dic &#x3D; new Dictionary&lt;int, int&gt;();            dic.Add(1, 88);            dic.Add(2, 56);            dic.Add(3, 66);            dic.Add(4, 45);            dic.Add(5, 23);            dic.Add(6, 76);            List&lt;KeyValuePair&lt;int, int&gt;&gt; list &#x3D; new List&lt;KeyValuePair&lt;int, int&gt;&gt;();            foreach (KeyValuePair&lt;int, int&gt; item in dic)            &#123;                list.Add(item);            &#125;                        list.Sort(( a, b ) &#x3D;&gt;            &#123;                return a.Value - b.Value;            &#125;);            for (int i &#x3D; 0; i &lt; list.Count; i++)            &#123;                Console.WriteLine(list[i].Key + &quot; &quot; + list[i].Value);            &#125;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年6月4日</title>
    <link href="/2022/06/04/diary/2022.6/2022%E5%B9%B46%E6%9C%884%E6%97%A5/"/>
    <url>/2022/06/04/diary/2022.6/2022%E5%B9%B46%E6%9C%884%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="a72d7eae4229be0ec93b6b44e4f62e416ee4770c8b358c0731b7dd07b75c6661">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe502c7f0c62ed20fcf2210812afb4fab0bcb7a12c9a592d2ebbeee8fed8de7a9fa4051050f7bc52309d2e9466293c8943dfceee16df3f5e1ba62c86ba862bbbcb423955bdc2ed57401f61ebc0d12331ab505793601f2bdc88dfa083ab42b980654f379fbb7fdc5bad8b94cdf56ff1f68d5783bc640ac209acec7780155fa3feac1e11c56d8d6a9e2e6ce7467054a84f78fc6f2e59b6ade6d79728976c3da584e8ae5ad45343e86c8d9d0cbcf381c5c49ddd5910286a6059931035cb35f8ce608b5acae0f0467e9dd65ae4813d146e7d22ea73b55345092dde31a102385366c08625385b0d85065dfe911634bcdf4104d7384a182eac07c3ba14b3e7ca7f0d3cca9e9b6ab0dd1fa1d7742f731b343badecd2a3b64fea81b0729bde66bb5f95c663ea69e527f32d4a18e7878315d58936e9ab5a15065afa92f9d133ac57c96893bf07e2566709598037304cea10a67163c4270df68138dabd702004ade7e3daffa98731c314ec26dfa9cf8148b1cc6fe251c4591e584b3c943682584a38131f3df7f6279477f235076174c954cab3cc0877d3a430e1f29265eafe8b7bc68f08e706857ff7fc1e76cc6a0f9c529d76b1f3c2c7951e8f4bb2e07c08a69e32f0a5840fd83c2f15cc54535a8937181f4a4505f5cb3f2ce105ab4c1194d014d3de59f2648e5f71c28952512f3f60ad6418232a5d6eee61621cfed02e9232d450166895d80c869ab3df50c4a4144ef731cf594cd34320f5008f8e3fdda512904d55924455f9fddd95c5b723baa87830908282cc9f2d843de99b9a4ddc4e425016d2b23384b15d2f0a2ad083c02ff4bc96422f5066cf48d715ecdae8de930b49062a14e646fb68c8e32e368fb263dded48ec9884eb70191bad74a6607ad636d5c20325a76092adc58b56d0b62c400a0143f911e470ce82aaa2ed9f19078818ce9fac4ce6fafbb317fd7bcd91007c1329dfdf18e5e7a2aedd1b3c6fee17d231183ab6d66e473c78678feb354d06b6ad7bf1c4b9ed1a3b5bdb75d4262f4859a611fa998b1189173cccdb2632575b0d4e825133b77d5e88adf9b55066ab6474e3a3f3b7f91af630a9ace51df3ccb1b42853d12fc91a1e43e973a8c413a45d9abf2cb74c8b2f465baa5a5d16267c2f566452d51014f0578365ce82e6e46e5ce333bbba7222b06a3e9ff1c8ac2a86aadfd9d70d6cbceea79f77dbb8b35e7b951276d4ddfcfad5e4b4385001cd67177d1f61921432dcb61d0edb7a734793f1cda07706087e9d27a3e197bcf5be8f773d7f7e27322eff3c54b9ccad45e3eb2377a59515b15630894cff9fae90a8c6ac0643a32c9c16e4ee6ea02fad41c8cf24cdd3cb6863901ad17998a05bd46e66cc913e535c5944a4fc2e9fb7711d0e70a9c3f64737cd2736acf6299f1a7abcd4d6ca512fcbc287de2f083d2a998a9409a462dd061b14baf59d3777d5ddb2695f37ea0a6cb6896ee8573246</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lambda表达式</title>
    <link href="/2022/06/03/CSharp/CSharp%E8%BF%9B%E9%98%B6/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2022/06/03/CSharp/CSharp%E8%BF%9B%E9%98%B6/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>Lambda表达式</p><span id="more"></span><h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Lambda表达式 可以理解为 匿名函数的简写<br>除了写法不同外 使用上和匿名函数一模一样<br>都是配合委托和事件使用的</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;lambda表达式(参数列表) &#x3D;&gt;&#123;    &#x2F;&#x2F;函数体&#125;;</code></pre></div><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>1.无参无返回</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Action a &#x3D; () &#x3D;&gt;&#123;    Console.WriteLine(&quot;无参无返回值的lambda表达式&quot;);&#125;;a();</code></pre></div><p>2.有参</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Action&lt;int&gt; a2 &#x3D; (int value) &#x3D;&gt;&#123;    Console.WriteLine(&quot;有参无返回值的lambda表达式&#123;0&#125;&quot;, value);&#125;;a2(100);</code></pre></div><p>3.甚至参数类型都可以省略 默认与委托容器或者事件容器一致</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Action&lt;int&gt; a3 &#x3D; (value) &#x3D;&gt;&#123;    Console.WriteLine(&quot;省略参数类型的lambda表达式&#123;0&#125;&quot;, value);&#125;;a3(500);</code></pre></div><p>4.有返回值</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Func&lt;string, int&gt; a4 &#x3D; (value) &#x3D;&gt;&#123;    Console.WriteLine(&quot;有返回值的lambda表达式&#123;0&#125;&quot;, value);    return 1;&#125;a4(&quot;700&quot;);</code></pre></div><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>内层函数可以引用包含在他外层的函数的变量<br>即使外层函数的执行已经中止<br>注意：<br>该变量提供的值并非变量创建时的值，而是父函数范围内的最终值</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Test&#123;    public event Action action;    public Test()    &#123;        int value &#x3D; 10;        &#x2F;&#x2F;这里就形成了闭包        &#x2F;&#x2F;当构造函数执行完毕时 声明的临时变量value被匿名函数占用        &#x2F;&#x2F;并没有进行gc value的生命周期被改变        action &#x3D; () &#x3D;&gt;        &#123;            Console.WriteLine(value);        &#125;        &#x2F;&#x2F;因为i是临时变量 只能保存外层函数的最终值 即10        for(i &#x3D; 0; i &lt; 10; i++)        &#123;            action +&#x3D; () &#x3D;&gt;            &#123;                Console.WriteLine(i);            &#125;        &#125;    &#125;&#125;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/06/03/CSharp/CSharp%E8%BF%9B%E9%98%B6/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/exam.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson15_Lambda表达式&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Print()();        &#125;        static Action Print()        &#123;            Action action &#x3D; null;            for (int i &#x3D; 0; i &lt;&#x3D; 10; i++)            &#123;                &#x2F;&#x2F;此index非彼index                int index &#x3D; i;                action +&#x3D; () &#x3D;&gt;                &#123;                    Console.WriteLine(index);                &#125;;            &#125;            return action;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>匿名函数</title>
    <link href="/2022/06/03/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"/>
    <url>/2022/06/03/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>匿名函数</p><span id="more"></span><h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>没有名字的函数<br>匿名函数的使用主要是配合委托和事件进行使用<br>脱离委托和事件 是不会使用匿名函数的</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">delegate ( 参数列表 )&#123;    &#x2F;&#x2F;函数逻辑&#125;;</code></pre></div><p>何时使用：<br>1.函数中传递委托参数时<br>2.委托或事件赋值时</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>1.无参无返回</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;这样声明匿名函数 只是在声明函数而已 还没有调用Action a &#x3D; delegate()&#123;    Console.WriteLine(&quot;匿名函数逻辑&quot;);&#125;;&#x2F;&#x2F;这里使用委托的时候 才是在调用a();</code></pre></div><p>2.有参</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Action&lt;int, string&gt; b &#x3D; delegate (int a, string b)&#123;    Console.WriteLine(a);    Console.WriteLine(b);&#125;;b(100, &quot;頑張れ&quot;);</code></pre></div><p>3.有返回值</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Func&lt;string&gt; c &#x3D; delegate()&#123;    return &quot;頑張れ&quot;;&#125;;Console.WriteLine(c());</code></pre></div><p>4.一般情况会作为函数参数传递 或者 作为函数返回值</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Test&#123;    public Action action;        &#x2F;&#x2F;作为参数传递时    public void Do(int a, Action fun)    &#123;        Console.WriteLine(a);        fun();    &#125;    &#x2F;&#x2F;作为返回值    public Action GetFun()    &#123;        return delegate()        &#123;            Console.WriteLine(&quot;函数内部返回的一个匿名函数的逻辑&quot;);        &#125;;    &#125;&#125;Test t &#x3D; new Test();&#x2F;&#x2F;第一种 一步到位t.Do(100, delegate()&#123;    Console.WriteLine(&quot;随参数传入的匿名函数的逻辑&quot;);&#125;);&#x2F;&#x2F;第二种 先把匿名函数用委托存起来Action ac &#x3D; delegate()&#123;    Console.WriteLine(&quot;随参数传入的匿名函数的逻辑&quot;);&#125;t.Do(50, ac);&#x2F;&#x2F;第一种 一步到位t.GetFun()();&#x2F;&#x2F;第二种 先把匿名函数用委托存起来Action ac2 &#x3D; t.GetFun;ac2();</code></pre></div><h2 id="匿名函数的缺点"><a href="#匿名函数的缺点" class="headerlink" title="匿名函数的缺点"></a>匿名函数的缺点</h2><p>添加到委托或事件容器中后 不记录 无法单独移除</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/06/03/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/exam.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson14_匿名函数&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Console.WriteLine(Multiplication(10)(4));        &#125;        static Func&lt;int, int&gt; Multiplication(int num1)        &#123;            &#x2F;&#x2F;这种写法会改变num1的生命周期            return delegate(int num2)            &#123;                return num1 * num2;            &#125;;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年6月3日</title>
    <link href="/2022/06/03/diary/2022.6/2022%E5%B9%B46%E6%9C%883%E6%97%A5/"/>
    <url>/2022/06/03/diary/2022.6/2022%E5%B9%B46%E6%9C%883%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="8ac09535a612818f57f91254e83fc5e41f4a79a09ee746fe2a4d06cdee67b475">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe5085a89ceaebaa4af3ab036a556bac27c4eb9f83b4e350c4bc8613fe83a3d46d21a5dd9c1698a6029adea202061145bf51cbe56ed02de3f1eb1e4dca20d089f3b50e4a6e2034288eeea4c207bcaaa2879f774c0b398a6d384d6664f4312b27542e9766714371756e6a911978d9ce2d5a9db7039e47ac947a7fe0b7aa2f239417061a870daa109435bba9825113a64123174cebcf17934fc0bda5a7944c3f5491f13189bd5011f3d710f0313c04a57efa4d12543cebcddc9a8f57e7b164a0c7dec2d1b8107e6f78db9ce500656113c9f3cc963c4a3f6f3719a1a87b74153d0521dfd94ee702b905a31da7a44527643c41b5d3b14c6d7b67b7112d7f26b98e4176dc548e0843f4b370b20a2e6e0991adfba67e103f3ff6c7b45d5282af834daf59af940eedb0ee46ddf6334bf2277d9bcaca46c7aa9586f7a4c3bd8e62c9d2b2636b2a3346f47ae45fe9e1d88140dd0d6af414f63540b6bb945b6497b21697ef4845c94147c9044e2e35045fd7277f1f6c99621759ea97ee7f273e1dfb444f42fa9fda71c2dc2ba2606bb62dfe588ba7dbcc1c74361b49ba4849cc0af08746b269da</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事件</title>
    <link href="/2022/06/03/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E4%BA%8B%E4%BB%B6/"/>
    <url>/2022/06/03/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>事件</p><span id="more"></span><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>事件是基于委托的存在<br>事件是委托的安全包裹 让委托的使用更具有安全性<br>事件是一种特殊的变量类型</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">访问修饰符 event 委托类型 事件名;</code></pre></div><p>事件的使用：<br>1.事件是作为成员变量存在于类中<br>2.委托怎么用 事件就这么勇</p><p>事件相对于委托的区别：<br>1.不能在类外部赋值 但可以通过加（+&#x3D;）、减(-&#x3D;)去添加、删除记录的函数<br>2.不能在类外部调用 只能在类的内部封装调用</p><p>注意：<br>它只能作为成员存在于类和接口以及结构体中</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"></code></pre></div><h2 id="使用事件的原因"><a href="#使用事件的原因" class="headerlink" title="使用事件的原因"></a>使用事件的原因</h2><p>1.防止外部随意调用委托<br>2.防止外部随意置空委托<br>3.事件相当于对委托进行了一次封装 让其更加安全</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/06/03/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E4%BA%8B%E4%BB%B6/exam.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson13_事件&#123;    class Calorifier    &#123;        public event Action&lt;int&gt; alarmEvent;        public int temperature &#x3D; 0;        public void Heating()        &#123;            int index &#x3D; 0;            while (true)            &#123;                if (index++ % 99999999 &#x3D;&#x3D; 0)                &#123;                    temperature++;                    if (temperature &gt;&#x3D; 100)                    &#123;                        break;                    &#125;                    else                    &#123;                        if (alarmEvent !&#x3D; null)                        &#123;                            alarmEvent(temperature);                        &#125;                        &#x2F;&#x2F;alarmEvent &#x3D; null;                    &#125;                    index &#x3D; 0;                &#125;            &#125;                   &#125;    &#125;    class Warner : Calorifier    &#123;        public void Warning(int temperature)        &#123;            Console.WriteLine(&quot;水温已经到&#123;0&#125;°了&quot;, temperature);        &#125;    &#125;    class Moniter : Calorifier    &#123;        public void Hint(int temperature)        &#123;            if(temperature &lt; 95)            &#123;                Console.WriteLine(&quot;水还未烧开&quot;);            &#125;            else if (temperature &lt;&#x3D; 100 &amp;&amp; temperature &gt;&#x3D; 95)            &#123;                Console.WriteLine(&quot;水已经烧开&quot;);            &#125;        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Calorifier calorifier &#x3D; new Calorifier();            Warner warner &#x3D; new Warner();            Moniter moniter &#x3D; new Moniter();            calorifier.alarmEvent +&#x3D; warner.Warning;            calorifier.alarmEvent +&#x3D; moniter.Hint;            calorifier.Heating();        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>委托</title>
    <link href="/2022/06/02/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E5%A7%94%E6%89%98/"/>
    <url>/2022/06/02/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E5%A7%94%E6%89%98/</url>
    
    <content type="html"><![CDATA[<p>委托</p><span id="more"></span><h1 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>委托是函数（方法）的容器，可以理解为表示函数（方法）的变量类型，可以用来存储、传递函数（方法）<br>委托本质是一个类，用来定义函数（方法）的类型（返回值和参数的类型）<br>不同的函数（方法）必须对应各自“格式”一致的委托</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>关键字： delegate</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>访问修饰符 delegate 返回值 委托名(参数列表);<br>可以声明在namespace和class语句块中 更多的写在namespace中<br>    函数声明语法前 + delegate</p><h3 id="定义自定义委托"><a href="#定义自定义委托" class="headerlink" title="定义自定义委托"></a>定义自定义委托</h3><p>访问修饰符默认不写为public 在别的命名空间中也能使用<br>private 其他命名空间就不能使用了<br>一般使用public<br>同一个命名空间中委托不能重名</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">delegate void MyFun();delegate int MyFun2(int value);</code></pre></div><h3 id="使用定义好的委托"><a href="#使用定义好的委托" class="headerlink" title="使用定义好的委托"></a>使用定义好的委托</h3><p>委托变量是函数的容器</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">static void Fun()&#123;    Console.WriteLine(&quot;&quot;);&#125;MyFun f &#x3D; new MyFun(Fun);f.Invoke();MyFun f2 &#x3D; Fun;f2();</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">static int Fun2(int value)&#123;    return value;&#125;MyFun2 f3 &#x3D; new MyFun2(Fun2);f3.Invoke();MyFun2 f4 &#x3D; Fun2;f4(1);</code></pre></div><p>委托常用在：<br>1.作为类的成员<br>2.作为函数的参数</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Test&#123;    public MyFun fun;    public MyFun2 fun2;    public void TestFun( MyFun fun, MyFun2 fun2 )    &#123;        &#x2F;&#x2F;先处理一些别的逻辑 当这些逻辑处理完了 再执行传入的函数        &#x2F;&#x2F;        &#x2F;&#x2F;fun();        &#x2F;&#x2F;fun2(i);        this.fun &#x3D; fun;        this.fun2 &#x3D; fun2;    &#125;&#125;Test t &#x3D; new Test();t.TestFun(Fun, Fun2);</code></pre></div><h2 id="委托变量可以存储多个函数（多播函数）"><a href="#委托变量可以存储多个函数（多播函数）" class="headerlink" title="委托变量可以存储多个函数（多播函数）"></a>委托变量可以存储多个函数（多播函数）</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">MyFun ff &#x3D; Fun;if( ff !&#x3D; null )&#123;    ff();&#125;</code></pre></div><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public void AddFun( MyFun fun, MyFun2 fun2 )&#123;    this.fun +&#x3D; fun;    this.fun2 +&#x3D; fun2;&#125;</code></pre></div><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public void RemoveFun( MyFun fun, MyFun2 fun2 )&#123;    this.fun -&#x3D; fun;    this.fun2 -&#x3D; fun2;&#125;</code></pre></div><h2 id="系统定义好的委托"><a href="#系统定义好的委托" class="headerlink" title="系统定义好的委托"></a>系统定义好的委托</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;无参无返回值Action action &#x3D; Fun;action +&#x3D; Fun;action();</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;支持泛型的 可以让返回值和参数可变Func&lt;string&gt; funcString &#x3D; Fun4;Func&lt;int&gt; funcInt &#x3D; Fun5;</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;可以传n个参数的 系统提供1-16个参数Action&lt;int, string, bool&gt; action &#x3D; Fun;</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;可以传n个参数的 有返回值的&#x2F;&#x2F;第一个是in传入的, 第二个是out输出的Func&lt;int, int&gt; func2 &#x3D; Fun;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/06/02/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E5%A7%94%E6%89%98/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson12_委托&#123;    abstract class Person    &#123;        public abstract void Eat();    &#125;    class Mother : Person    &#123;        public Action beginEat;        public override void Eat()        &#123;            Console.WriteLine(&quot;妈妈吃饭&quot;);        &#125;        public void Cook()        &#123;            Console.WriteLine(&quot;妈妈做饭&quot;);            &#x2F;&#x2F;执行委托函数            if(beginEat !&#x3D; null)            &#123;                beginEat();            &#125;        &#125;    &#125;    class Father : Person    &#123;        public override void Eat()        &#123;            Console.WriteLine(&quot;爸爸吃饭&quot;);        &#125;    &#125;    class Child : Person    &#123;        public override void Eat()        &#123;            Console.WriteLine(&quot;孩子吃饭&quot;);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Mother mother &#x3D; new Mother();            Father father &#x3D; new Father();            Child child &#x3D; new Child();            mother.beginEat +&#x3D; father.Eat;            mother.beginEat +&#x3D; child.Eat;            mother.beginEat +&#x3D; mother.Eat;            mother.Cook();        &#125;    &#125;&#125;</code></pre></div><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson12_委托&#123;    class Monster    &#123;        public Action&lt;Monster&gt; die;        public int money &#x3D; 10;        public void Dead()        &#123;            if (die !&#x3D; null)            &#123;                die(this);            &#125;            &#x2F;&#x2F;一般情况下 委托关联的函数 有加就有减 或直接清空            die &#x3D; null;        &#125;    &#125;    class Player    &#123;        private int nowMoney &#x3D; 0;        public void MonsterDie( Monster monster )        &#123;            nowMoney +&#x3D; monster.money;            Console.WriteLine(&quot;当前面板显示&#123;0&#125;钱&quot;, nowMoney);        &#125;    &#125;    class Panel    &#123;        private int nowMoney &#x3D; 0;        public void MonsterDie( Monster monster )        &#123;            nowMoney +&#x3D; monster.money;            Console.WriteLine(&quot;当前面板显示&#123;0&#125;钱&quot;, nowMoney);        &#125;    &#125;    class Achievement    &#123;        private int nowKill&#x3D; 0;        public void MonsterDie(Monster monster)        &#123;            nowKill++;            Console.WriteLine(&quot;当前击杀&#123;0&#125;怪物&quot;, nowKill);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Monster monster &#x3D; new Monster();            Player player &#x3D; new Player();            Panel panel &#x3D; new Panel();            Achievement achievement &#x3D; new Achievement();            monster.die +&#x3D; player.MonsterDie;            monster.die +&#x3D; panel.MonsterDie;            monster.die +&#x3D; achievement.MonsterDie;            monster.Dead();        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年6月2日</title>
    <link href="/2022/06/02/diary/2022.6/2022%E5%B9%B46%E6%9C%882%E6%97%A5/"/>
    <url>/2022/06/02/diary/2022.6/2022%E5%B9%B46%E6%9C%882%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="3f674ad1b1e9b354278eab65484b8a1b0b0b8aeb35a855e16af5d253931f279a">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50d4c0829a8a79ea3b44ecdd1bc8d55452b7de7125734c0d2f68e9acbe835a2e34a1f614394817bb7248cdc1e6c40213ba3798cf05ca05426e08e085f3a3a174480e8d0711d74f00da9cd7d69e81ddc13e6db9dc927147744dc7258eb6756e9f776e37134ce5c84ce19e26dc72cd50460187110ce2b49999aa7de8e37d420426c1</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>泛型栈和队列</title>
    <link href="/2022/06/01/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E6%B3%9B%E5%9E%8B%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <url>/2022/06/01/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E6%B3%9B%E5%9E%8B%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>泛型栈和队列</p><span id="more"></span><h1 id="泛型栈和队列"><a href="#泛型栈和队列" class="headerlink" title="泛型栈和队列"></a>泛型栈和队列</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System.Collections.Generic;    Stack&lt;int&gt; stack &#x3D; new Stack&lt;int&gt;();    Queue&lt;int&gt; queue &#x3D; new Queue&lt;int&gt;();</code></pre></div><p>具体方法与Stack和Queue一样</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/06/01/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E6%B3%9B%E5%9E%8B%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/exam.png" class=""><p>普通线性表：数组，list，linkedlist<br>数组：固定不变的一组数据<br>list：经常改变，经常通过下标查找<br>linkedlist：不确定长度的，经常临时插入改变，查找不多</p><p>先进后出：Stack<br>对于一些可以利用先进后出存储特点的逻辑<br>比如：UI面板显隐规则</p><p>先进先出：Queue<br>对于一些可以利用先进先出存储特点的逻辑<br>比如：消息队列，有了就往里放，然后依次处理</p><p>键值对：Dictionary<br>需要频繁查找的，有对应关系的数据<br>比如一些数据存储，ID对应数据内容<br>道具ID - 道具信息<br>怪物ID - 怪物对象<br>等等</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LinkedList</title>
    <link href="/2022/06/01/CSharp/CSharp%E8%BF%9B%E9%98%B6/LinkedList/"/>
    <url>/2022/06/01/CSharp/CSharp%E8%BF%9B%E9%98%B6/LinkedList/</url>
    
    <content type="html"><![CDATA[<p>LinkedList</p><span id="more"></span><h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>List是一个C#为我们封装好的类，<br>它的本质是一个可变类型的泛型双向链表。</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System.Collections.Generic;    LinkedList&lt;类型&gt; linkedlist &#x3D; new LinkedList&lt;类型&gt;();</code></pre></div><p>两个类： 链表本身LinkedList   链表节点类LinkedListNode</p><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;在链表尾部添加节点linkedlist.AddLast(类型);&#x2F;&#x2F;在链表头部添加节点linkedlist.AddFirst(类型);&#x2F;&#x2F;在某一个节点后添加节点LinkedListNode&lt;类型&gt; node &#x3D; LinkedList.Find(类型);node.AddAfter(类型);&#x2F;&#x2F;在某一个节点前添加节点LinkedListNode&lt;类型&gt; node &#x3D; LinkedList.Find(类型);node.AddBefore(类型);</code></pre></div><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;移除头节点linkedlist.RemoveFirst();&#x2F;&#x2F;移除尾节点linkedlist.RemoveLast();&#x2F;&#x2F;移除指定节点linkedlist.Remove(类型);&#x2F;&#x2F;清空链表linkedlist.Clear();</code></pre></div><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;查询头节点LinkedListNode&lt;类型&gt; first &#x3D; LinkedList.First;&#x2F;&#x2F;查询尾节点LinkedListNode&lt;类型&gt; last &#x3D; LinkedList.Last;&#x2F;&#x2F;找到指定值的节点（无法通过下标找，只能遍历查找）LinkedListNode&lt;类型&gt; node &#x3D; LinkedList.Find(类型);&#x2F;&#x2F;判断是否存在 boollinkedlist.Contains(类型)</code></pre></div><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;直接改指定位置的元素LinkedListNode&lt;类型&gt; node &#x3D; LinkedList.Find(类型);node.value &#x3D; 类型;</code></pre></div><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;数组长度list.Count&#x2F;&#x2F;数组容量list.Capacity&#x2F;&#x2F;foreach遍历foreach (类型 item in linkedlist)&#123;    &#x2F;&#x2F;直接取value    Console.WriteLine(item);&#125;&#x2F;&#x2F;从头到尾遍历LinkedListNode&lt;类型&gt; nowNode &#x3D; LinkedList.First;while( nowNode !&#x3D; null )&#123;    Console.WriteLine(nowNode.value);    nowNode &#x3D; nowNode.Next;&#125;&#x2F;&#x2F;从尾到头遍历LinkedListNode&lt;类型&gt; nowNode &#x3D; LinkedList.Last;while( nowNode !&#x3D; null )&#123;    Console.WriteLine(nowNode.value);    nowNode &#x3D; nowNode.Previous;&#125;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/06/01/CSharp/CSharp%E8%BF%9B%E9%98%B6/LinkedList/exam.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;namespace Lesson10_LinkedList&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            LinkedList&lt;int&gt; list &#x3D; new LinkedList&lt;int&gt;();            Random r &#x3D; new Random();            for (int i &#x3D; 0; i &lt; 10; i++)            &#123;                list.AddLast(r.Next(100));            &#125;            &#x2F;&#x2F;正向遍历            LinkedListNode&lt;int&gt; node &#x3D; list.First;            while (node !&#x3D; null)            &#123;                Console.Write(node.Value + &quot; &quot;);                node &#x3D; node.Next;            &#125;            Console.WriteLine(&quot;&quot;);            &#x2F;&#x2F;反向遍历            node &#x3D; list.Last;            while (node !&#x3D; null)            &#123;                Console.Write(node.Value + &quot; &quot;);                node &#x3D; node.Previous;            &#125;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>顺序存储和链式存储</title>
    <link href="/2022/06/01/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%92%8C%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    <url>/2022/06/01/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%92%8C%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<p>顺序存储和链式存储</p><span id="more"></span><h1 id="顺序存储和链式存储"><a href="#顺序存储和链式存储" class="headerlink" title="顺序存储和链式存储"></a>顺序存储和链式存储</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>线性表是一种数据结构，是由n个具有相同特效的数据元素的有限序列<br>比如数组、ArrayList、Stack、Queue、链表等等</p><p>顺序存储和链式存储 是数据结构中的两种存储结构</p><h2 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h2><p>数组、ArrayList、Stack、Queue、List 等<br>但 数组、Stack、Queue的 组织规则不同</p><p>顺序存储：<br>用一组<strong>地址连续</strong>的存储单元一次存储线性表的各个数据元素</p><h2 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h2><p>单向链表、双向链表、循环链表 等</p><p>链式存储（又称链接存储）：<br>用一组任意的存储单元存储线性表中的各个数据元素</p><h2 id="单向链表实现"><a href="#单向链表实现" class="headerlink" title="单向链表实现"></a>单向链表实现</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class LinkedNode&lt;T&gt;&#123;    public T value;    public LinkedNode&lt;T&gt; nextNode;    public LinkedNode(T value)    &#123;        this.value &#x3D; value;    &#125;&#125;class LinkedList&lt;T&gt;&#123;    public LinkedNode&lt;T&gt; head;    public LinkedNode&lt;T&gt; tail;    public void Add(T value)    &#123;        LinkedNode&lt;T&gt; node &#x3D; new LinkedNode&lt;T&gt;(value);        if(head &#x3D;&#x3D; null)        &#123;            head &#x3D; node;            tail &#x3D; node;        &#125;        else        &#123;            tail.nextNode &#x3D; node;            tail &#x3D; node;        &#125;    &#125;    public void Remove(T value)    &#123;        if(head &#x3D;&#x3D; null)        &#123;            return;        &#125;        else if(head.value.Equals(value))        &#123;            head &#x3D; head.nextNode;            &#x2F;&#x2F;如果头节点变空，那说明只有一个节点，尾结点也要空            if(head &#x3D;&#x3D; null)            &#123;                tail &#x3D; null;            &#125;            return;        &#125;        LinkedNode&lt;T&gt; node &#x3D; head;        while(node.nextNode !&#x3D; null)        &#123;            if(node.value.Equals(value))            &#123;                node.nextNode &#x3D; node.nextNode.nextNode;                break;            &#125;            node &#x3D; node.nextNode;        &#125;    &#125;&#125;</code></pre></div><h2 id="顺序存储和链式存储的优缺点"><a href="#顺序存储和链式存储的优缺点" class="headerlink" title="顺序存储和链式存储的优缺点"></a>顺序存储和链式存储的优缺点</h2><p>增：链式存储 计算上 优于 顺序存储 （中间插入时链式不用想顺序一样去移动位置）<br>删：链式存储 计算上 优于 顺序存储 （中间删除时链式不用想顺序一样去移动位置）<br>查：顺序存储 使用上 优于 链式存储 （数组可以直接通过下标得到元素，链式需要遍历）<br>改：顺序存储 使用上 优于 链式存储 （数组可以直接通过下标得到元素，链式需要遍历）</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/06/01/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%92%8C%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><p>数组、栈、队列、链表、树、图、堆、散列表</p><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><p>顺序存储：<br>用一组<strong>地址连续</strong>的存储单元一次存储线性表的各个数据元素<br>链式存储（又称链接存储）：<br>用一组任意的存储单元存储线性表中的各个数据元素</p><h2 id="题3"><a href="#题3" class="headerlink" title="题3"></a>题3</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson9_顺序存储和链式存储&#123;    class LinkedNode&lt;T&gt;    &#123;        public T value;        public LinkedNode&lt;T&gt; nextNode;        public LinkedNode&lt;T&gt; frontNode;        public LinkedNode(T value)        &#123;            this.value &#x3D; value;        &#125;    &#125;    class LinkedList&lt;T&gt;    &#123;        private int count &#x3D; 0;        private LinkedNode&lt;T&gt; head;        private LinkedNode&lt;T&gt; tail;        public int Count            &#123; get &#123; return count; &#125; &#125;        public LinkedNode&lt;T&gt; Head            &#123; get &#123; return head; &#125; &#125;        public LinkedNode&lt;T&gt; Tail            &#123; get &#123; return tail; &#125; &#125;        public void Add(T value)        &#123;            LinkedNode&lt;T&gt; node &#x3D; new LinkedNode&lt;T&gt;(value);            if(head &#x3D;&#x3D; null)            &#123;                head &#x3D; node;                tail &#x3D; node;            &#125;            else            &#123;                &#x2F;&#x2F;连到尾部                tail.nextNode &#x3D; node;                &#x2F;&#x2F;双向连前面                node.frontNode &#x3D; tail;                tail &#x3D; node;            &#125;            ++count;        &#125;        public void RemoveAt(int index)        &#123;            LinkedNode&lt;T&gt; tempNode &#x3D; head;            int tempCount &#x3D; 0;            &#x2F;&#x2F;判断有没有头            if (head &#x3D;&#x3D; null)            &#123;                Console.WriteLine(&quot;链表为空，无法删除&quot;);                return;            &#125;            &#x2F;&#x2F;判断是否越界            if (index &gt;&#x3D; count)            &#123;                Console.WriteLine(&quot;只有&#123;0&#125;个节点&quot;, count);                return;            &#125;            else if(index &lt; 0)            &#123;                Console.WriteLine(&quot;请输入正确的正整数&quot;);                return;            &#125;            else            &#123;                for (int i &#x3D; 0; i &lt; index; i++)                &#123;                    tempNode &#x3D; tempNode.nextNode;                &#125;                if (tempNode &#x3D;&#x3D; head)                &#123;                    head &#x3D; tempNode.nextNode;                    head.frontNode &#x3D; null;                &#125;                else if (tempNode &#x3D;&#x3D; tail)                &#123;                    tail &#x3D; tempNode.frontNode;                    tail.nextNode &#x3D; null;                &#125;                else                &#123;                    &#x2F;&#x2F;删除的节点的前一个节点连着后一个节点                    tempNode.frontNode.nextNode &#x3D; tempNode.nextNode;                    &#x2F;&#x2F;删除的节点的后一个节点连着前一个节点                    tempNode.nextNode.frontNode &#x3D; tempNode.frontNode;                &#125;                --count;                &#x2F;&#x2F;while(true)                &#x2F;&#x2F;&#123;                &#x2F;&#x2F;    if(tempCount &#x3D;&#x3D; index)                &#x2F;&#x2F;    &#123;                &#x2F;&#x2F;        if(tempNode.frontNode !&#x3D; null)                &#x2F;&#x2F;        &#123;                &#x2F;&#x2F;            tempNode.frontNode.nextNode &#x3D; tempNode.nextNode;                &#x2F;&#x2F;        &#125;                &#x2F;&#x2F;        if (tempNode.nextNode !&#x3D; null)                &#x2F;&#x2F;        &#123;                &#x2F;&#x2F;            tempNode.nextNode.frontNode &#x3D; tempNode.frontNode;                &#x2F;&#x2F;        &#125;                &#x2F;&#x2F;        if(index &#x3D;&#x3D; 0)                &#x2F;&#x2F;        &#123;                &#x2F;&#x2F;            head &#x3D; head.nextNode;                &#x2F;&#x2F;        &#125;                &#x2F;&#x2F;        if(index &#x3D;&#x3D; count - 1)                &#x2F;&#x2F;        &#123;                &#x2F;&#x2F;            tail &#x3D; tail.frontNode;                &#x2F;&#x2F;        &#125;                &#x2F;&#x2F;        break;                &#x2F;&#x2F;        --count;                &#x2F;&#x2F;    &#125;                &#x2F;&#x2F;    tempNode &#x3D; tempNode.nextNode;                &#x2F;&#x2F;    tempCount++;                &#x2F;&#x2F;&#125;            &#125;                    &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            LinkedList&lt;int&gt; list &#x3D; new LinkedList&lt;int&gt;();            list.Add(1);            list.Add(2);            list.Add(3);            list.Add(4);            LinkedNode&lt;int&gt; node &#x3D; list.Head;            &#x2F;&#x2F;正向遍历            while(node !&#x3D; null)            &#123;                Console.Write(node.value);                node &#x3D; node.nextNode;            &#125;            Console.WriteLine(&quot;&quot;);            &#x2F;&#x2F;反向遍历            node &#x3D; list.Tail;            while (node !&#x3D; null)            &#123;                Console.Write(node.value);                node &#x3D; node.frontNode;            &#125;            Console.WriteLine(&quot;&quot;);            list.RemoveAt(1);            &#x2F;&#x2F;正向遍历            node &#x3D; list.Head;            while (node !&#x3D; null)            &#123;                Console.Write(node.value);                node &#x3D; node.nextNode;            &#125;            Console.WriteLine(&quot;&quot;);            &#x2F;&#x2F;反向遍历            node &#x3D; list.Tail;            while (node !&#x3D; null)            &#123;                Console.Write(node.value);                node &#x3D; node.frontNode;            &#125;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年6月1日</title>
    <link href="/2022/06/01/diary/2022.6/2022%E5%B9%B46%E6%9C%881%E6%97%A5/"/>
    <url>/2022/06/01/diary/2022.6/2022%E5%B9%B46%E6%9C%881%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="5b54890c877d7b4c0f134a3f6c9e3be8b1c68ba90b800d2c13ca744db55132c1">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50b288bc91ee7b4bdb0528294bd9891ed4e409f14cf933b3be0b9fc9aaa1127d0592710b8aba39567caf477fd33ada3322a3e50913d027fe793d26756bc8710000dce524e22ef4104a15af2aeced7c161268c42285e78963783c5da734de84db4b66ad5254bf41b3c0bad15602f75507a2f3c98a52118cd630e22fa1654ced68f214106ac154ec270047ed4b38c04efd8dd3246b44eeae22d2199ab8265ad71c93f5429825116d700a5baf1b7140c39154f732fb5e75a6f3f17d5752bef961631e45f82dc61e133a8abf73fafb64c64b26d7958f9c3a235f4c934048a23c048f99c4836fed46a1d365ba46b2ebfc8f57bc750bc8a15aedcc328208bf6ad1385e098974c3c6629b42172b4b15951a075d87cb5676841be2c2a332272a167aec189f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dictionary</title>
    <link href="/2022/05/31/CSharp/CSharp%E8%BF%9B%E9%98%B6/Dictionary/"/>
    <url>/2022/05/31/CSharp/CSharp%E8%BF%9B%E9%98%B6/Dictionary/</url>
    
    <content type="html"><![CDATA[<p>Dictionary</p><span id="more"></span><h1 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h1><p>Dictionary可理解为拥有泛型的Hashtable<br>它也是基于键的哈希代码组织起来的 键&#x2F;值对<br>键&#x2F;值对类型从Hashtable的object类型变为了可以自己指定的泛型</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System.Collections.Generic;    Dictionary&lt;键类型, 值类型&gt; dictionary &#x3D; new Dictionary&lt;键类型, 值类型&gt;();</code></pre></div><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;往表中加一对(键, 值)dictionary.Add(键类型的对象, 值类型的对象);&#x2F;&#x2F;不能有相同键</code></pre></div><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;只能通过键去删除dictionary.Remove(键类型的对象); &#x2F;&#x2F;键&#x2F;&#x2F;删除不存在的键不会报错也不能删除&#x2F;&#x2F;清空dictionary.Clear();</code></pre></div><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;通过键查看对应的值，找不到会报错dictionary[键类型的对象]; &#x2F;&#x2F;键&#x2F;&#x2F;查看元素是否存在hashtable中(bool)dictionary.ContainsKey(键类型的对象); &#x2F;&#x2F;键dictionary.ContainsValue(值类型的对象); &#x2F;&#x2F;值</code></pre></div><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><p>只能改键对应的值内容，无法修改键</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">dictionary[键类型的对象] &#x3D; 新的值类型的对象;</code></pre></div><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;键值对的对数dictionary.Count&#x2F;&#x2F;迭代器遍历所有的键foreach (键类型 item in dictionary.Keys)&#123;    Console.WriteLine(&quot;&#123;0&#125;:&#123;1&#125;&quot;, item, dictionary[item]);&#125;&#x2F;&#x2F;迭代器遍历所有的值foreach (值类型 item in dictionary.Values)&#123;    Console.WriteLine(item);&#125;&#x2F;&#x2F;迭代器遍历所有的键值对foreach (KeyValuePair&lt;键类型, 值类型&gt; item in dictionary)&#123;    Console.WriteLine(&quot;&#123;0&#125;:&#123;1&#125;&quot;, item.Key, item.Value);&#125;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/31/CSharp/CSharp%E8%BF%9B%E9%98%B6/Dictionary/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;namespace Lesson8_Dictionary&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            try            &#123;                Console.WriteLine(&quot;请输入一个三位以内的数&quot;);                Console.WriteLine(GetInfo(int.Parse(Console.ReadLine())));            &#125;            catch            &#123;                Console.WriteLine(&quot;请输入正确的数字&quot;);            &#125;        &#125;        static string GetInfo(int num)        &#123;            Dictionary&lt;int, string&gt; dic &#x3D; new Dictionary&lt;int, string&gt;();            dic.Add(0, &quot;零&quot;);            dic.Add(1, &quot;壹&quot;);            dic.Add(2, &quot;贰&quot;);            dic.Add(3, &quot;叁&quot;);            dic.Add(4, &quot;肆&quot;);            dic.Add(5, &quot;伍&quot;);            dic.Add(6, &quot;陆&quot;);            dic.Add(7, &quot;柒&quot;);            dic.Add(8, &quot;捌&quot;);            dic.Add(9, &quot;玖&quot;);            string str &#x3D; &quot;&quot;;            int b &#x3D; num &#x2F; 100;            if (b !&#x3D; 0)            &#123;                str +&#x3D; dic[b];            &#125;            int s &#x3D; num % 100 &#x2F; 10;            if(str !&#x3D; &quot;&quot; || s !&#x3D; 0)            &#123;                str +&#x3D; dic[s];            &#125;            int g &#x3D; num % 10;            str +&#x3D; dic[g];            return str;        &#125;    &#125;&#125;</code></pre></div><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;namespace Lesson8_Dictionary&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Dictionary&lt;char, int&gt; dic &#x3D; new Dictionary&lt;char, int&gt;();            string str &#x3D; &quot;Welcome to Unity World!&quot;;            str &#x3D; str.ToLower();            for (int i &#x3D; 0; i &lt; str.Length; i++)            &#123;                if( dic.ContainsKey(str[i]))                &#123;                    dic[str[i]]++;                &#125;                else                &#123;                    dic.Add(str[i], 1);                &#125;                &#125;            foreach (char item in dic.Keys)            &#123;                Console.WriteLine(&quot;字母&#123;0&#125;出现了&#123;1&#125;次&quot;, item, dic[item]);            &#125;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>List</title>
    <link href="/2022/05/31/CSharp/CSharp%E8%BF%9B%E9%98%B6/List/"/>
    <url>/2022/05/31/CSharp/CSharp%E8%BF%9B%E9%98%B6/List/</url>
    
    <content type="html"><![CDATA[<p>List</p><span id="more"></span><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>List是一个C#为我们封装好的类，<br>它的本质是一个可变类型的泛型数组。</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System.Collections.Generic;    List&lt;类型&gt; list &#x3D; new List&lt;类型&gt;();</code></pre></div><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;增加一个元素list.Add(类型);&#x2F;&#x2F;批量增加，把另一个list容器中的元素加到后面list.AddRange(另一个list);</code></pre></div><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;移出指定元素，从头找，找到删array.Remove(元素);&#x2F;&#x2F;移除指定位置元素array.RemoveAt(索引值);&#x2F;&#x2F;清空数组array.Clear();</code></pre></div><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;得到指定位置的元素Console.WriteLine(list[0]);&#x2F;&#x2F;查询元素是否存在array.Contains(元素); &#x2F;&#x2F;存在为真,不存在为假&#x2F;&#x2F;正向查找元素位置,正向第一个找到的位置array.IndexOf(元素); &#x2F;&#x2F;返回索引值,没找到返回-1 &#x2F;&#x2F;正向查找元素位置,反向第一个找到的位置array.LastIndexOf(元素); &#x2F;&#x2F;返回索引值,没找到返回-1 </code></pre></div><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;直接改指定位置的元素array[索引值] &#x3D; 元素;</code></pre></div><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;数组长度list.Count&#x2F;&#x2F;数组容量list.Capacity&#x2F;&#x2F;遍历for( i &#x3D; 0; i &lt; list.Count; i++ )&#123;    &#x2F;&#x2F;需要的逻辑&#125;&#x2F;&#x2F;迭代器遍历 把array里的元素放到item里foreach (object item in list)&#123;    &#x2F;&#x2F;需要的逻辑 &#125;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/31/CSharp/CSharp%E8%BF%9B%E9%98%B6/List/exam.png" class=""><h1 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h1><p>ArrayList是一个object类型的数组，会出现装箱拆箱<br>List是一个泛型类，会直接定好类型，不会出现装箱拆箱</p><h1 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h1><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;namespace Lesson7_List&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            List&lt;int&gt; list &#x3D; new List&lt;int&gt;();            list.Add(10);            list.Add(9);            list.Add(8);            list.Add(7);            list.Add(6);            list.Add(5);            list.Add(4);            list.Add(3);            list.Add(2);            list.Add(1);            list.RemoveAt(4);            foreach (int i in list)            &#123;                Console.WriteLine(i);            &#125;        &#125;    &#125;&#125;</code></pre></div><h1 id="题3"><a href="#题3" class="headerlink" title="题3"></a>题3</h1><p>子类默认先调用父类的无参构造函数</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;namespace Lesson7_List&#123;    abstract class Monster    &#123;        &#x2F;&#x2F;静态列表 不会改变        public static List&lt;Monster&gt; monsters &#x3D; new List&lt;Monster&gt;();        public Monster()        &#123;            monsters.Add(this);        &#125;        abstract public void Atk();    &#125;    class Boss : Monster    &#123;        public override void Atk()        &#123;            Console.WriteLine(&quot;Boss攻击&quot;);        &#125;    &#125;    class Goblin : Monster    &#123;        public override void Atk()        &#123;            Console.WriteLine(&quot;Goblin攻击&quot;);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Boss boss1 &#x3D; new Boss();            Boss boss2 &#x3D; new Boss();            Goblin goblin1 &#x3D; new Goblin();            Goblin goblin2 &#x3D; new Goblin();            for (int i &#x3D; 0; i &lt; Monster.monsters.Count; i++)            &#123;                Monster.monsters[i].Atk();            &#125;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月31日</title>
    <link href="/2022/05/31/diary/2022.5/2022%E5%B9%B45%E6%9C%8831%E6%97%A5/"/>
    <url>/2022/05/31/diary/2022.5/2022%E5%B9%B45%E6%9C%8831%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="7449399fa491da47b53a9a8ef770f67540731192631d3816acb044e49da245c4">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50827eb88e76e5b7252b59da810bd88ec56cd6c3cb9fc41f65ff8e1abf03c11befacc8d888eca9bd903a440117993f3ffca1c7c27b8ef3de34b11171a3e22e0e849759db59eda7d3700424065de857d38619c04cb29e5bdbafa8a9ccfab2abf7697e68e4d07b390519ff2db96b518cecd2dd153a877347bed9a2101ba3c35786e85060b92a7290f80801954c041c7696d482ebfacc1255d0eff23b99d3a2b407b9a7afc97f69087aa51181af537f37d6a266326a27d74b24e15c15a34882d324bf0fa6f42cb57f9ecb8ab5b93cb3a8dfc4550add626eb44d970f99cf45e9e62eea9b175cf0b3f2327ed3a2590d34a41d02fb326ff05db6e728955e5040c759af581f61f5ae18693c44d57ab90dbf91044fb5acbb5963d9b7c28dcda2b3d04081355dcb5956c8799bfad85c7ceeb204f4e017e93307a9689df2bbbcc7268e8690d384b914d9fb2773d8323866f80c534d28c5fec04875abd9a4d2b7f2547e85295c16b1382807ae696a9f51092d99002e55610ac1f449f605878beb5749d6b9adfb</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>泛型约束</title>
    <link href="/2022/05/30/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F/"/>
    <url>/2022/05/30/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F/</url>
    
    <content type="html"><![CDATA[<p>泛型约束</p><span id="more"></span><h1 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>让泛型的类型有一定的限制<br>关键字：where<br>泛型约束共有6种<br>1.值类型                            where 泛型字母:struct<br>2.引用类型                          where 泛型字母:class<br>3.存在无参公共构造函数               where 泛型字母:new()<br>4.某个类本身或者其派生类             where 泛型字母:类名<br>5.某个接口的派生类型                 where 泛型字母:接口名<br>6.另一个泛型类型本身或者派生类型      where 泛型字母:另一个泛型字母</p><p>where 泛型字母:(约束的类型)</p><h2 id="各个泛型约束"><a href="#各个泛型约束" class="headerlink" title="各个泛型约束"></a>各个泛型约束</h2><p>1.值类型约束</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Test1&lt;T&gt; where T:struct&#123;    public T value;    public void TestFun&lt;K&gt;(K k) where K:struct    &#123;    &#125;&#125;&#x2F;&#x2F;int 和 float 都是struct类型（值类型，初值不能为空）Test1&lt;int&gt; t1 &#x3D; new Test1&lt;int&gt;();t1.TestFun&lt;float&gt;(1.3f);</code></pre></div><p>2.引用类型约束</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Test2&lt;T&gt; where T:class&#123;    public T value;    public void TestFun&lt;K&gt;(K k) where K:class    &#123;    &#125;&#125;&#x2F;&#x2F;Random 和 object 都是class类型Test2&lt;Random&gt; t2 &#x3D; new Test2&lt;Random&gt;();t2.TestFun&lt;object&gt;(new object());</code></pre></div><p>3.存在无参公共构造函数约束（非抽象类）</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Test3&lt;T&gt; where T:new()&#123;    public T value;    public void TestFun&lt;K&gt;(K k) where K:new()    &#123;    &#125;&#125;class Test1&#123;&#125;class Test2&#123;    public Test2(int a)    &#123;    &#125;&#125;&#x2F;&#x2F;Test1可以（有公共无参构造函数） Test2不行（公共有参、私有无参、抽象类都不行）Test3&lt;Test1&gt; t3 &#x3D; new Test3&lt;Test1&gt;();</code></pre></div><p>4.某个类本身或者其派生类 约束</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Test4&lt;T&gt; where T:Test1&#123;    public T value;    public void TestFun&lt;K&gt;(K k) where K:Test1    &#123;    &#125;&#125;class Test3 : Test1&#123;&#125;&#x2F;&#x2F;Test1可以（类） Test3可以（派生类） Test2不行Test4&lt;Test1&gt; t4 &#x3D; new Test4&lt;Test1&gt;();Test4&lt;Test3&gt; t4 &#x3D; new Test4&lt;Test3&gt;();</code></pre></div><p>5.某个接口的派生类型约束</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">interface IFly&#123;&#125;class Test4 : IFly&#123;&#125;class Test5&lt;T&gt; where T:IFly&#123;    public T value;    public void TestFun&lt;K&gt;(K k) where K:IFly    &#123;    &#125;&#125;&#x2F;&#x2F;IFly可以（接口） Test4可以（派生类） Test5&lt;IFly&gt; t5 &#x3D; new Test5&lt;IFly&gt;();t5.value &#x3D; new Test4(); &#x2F;&#x2F;里式替换Test4&lt;Test4&gt; t5 &#x3D; new Test4&lt;Test4&gt;();</code></pre></div><p>6.另一个泛型类型本身或者派生类型约束</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;T要么是U,要么是U的派生类型class Test6&lt;T,U&gt; where T:U&#123;    public T value;    public void TestFun&lt;K,V&gt;(K k) where K:V    &#123;    &#125;&#125;&#x2F;&#x2F;Test4是IFly的派生类型 Test6&lt;Test4, IFly&gt; t6 &#x3D; new Test6&lt;Test4, IFly&gt;();</code></pre></div><h2 id="约束的组合使用"><a href="#约束的组合使用" class="headerlink" title="约束的组合使用"></a>约束的组合使用</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Test7&lt;T&gt; where T:class, new()&#123;&#125;</code></pre></div><h2 id="多个泛型有约束"><a href="#多个泛型有约束" class="headerlink" title="多个泛型有约束"></a>多个泛型有约束</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Test8&lt;T,K&gt; where T:class, new() where K:struct&#123;    &#125;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/30/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson6_泛型约束&#123;    class SingleBase&lt;T&gt; where T : new()    &#123;        private static T instance &#x3D; new T();        public static T Instance        &#123;            get &#123; return instance; &#125;        &#125;    &#125;    &#x2F;&#x2F;继承的子类一定要有公共无参构造函数    class GameMgr : SingleBase&lt;GameMgr&gt;    &#123;        public int value &#x3D; 10;    &#125;    class Test    &#123;        private static Test instance &#x3D; new Test();        private Test()        &#123;        &#125;        public static Test Instance        &#123;            get            &#123;                return instance;            &#125;        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            GameMgr.Instance.value &#x3D; 10;        &#125;    &#125;&#125;</code></pre></div><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson6_泛型约束&#123;    class ArrayList&lt;T&gt;    &#123;        private T[] array;        private int count;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 获取已存数量        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        public int Count        &#123;            get &#123; return count; &#125;        &#125;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 获取容量        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        public int Capacity &#123; get &#123; return array.Length; &#125; &#125;        public ArrayList()        &#123;            count &#x3D; 0;            &#x2F;&#x2F;一开始的容量为16            array &#x3D; new T[16];        &#125;        &#x2F;&#x2F;增        public void Add(T value)        &#123;            &#x2F;&#x2F;判断是否需要扩容            if(count &gt;&#x3D; Capacity)            &#123;                T[] newArray &#x3D; new T[Capacity &lt;&lt; 1];                for (int i &#x3D; 0; i &lt; Capacity; i++)                &#123;                    newArray[i] &#x3D; array[i];                &#125;                array &#x3D; newArray;            &#125;            &#x2F;&#x2F;不需要扩容            array[count++] &#x3D; value;        &#125;        &#x2F;&#x2F;删        public void Remove(T value)        &#123;            int index &#x3D; -1;            for (int i &#x3D; 0; i &lt; Count; i++)            &#123;                &#x2F;&#x2F;因为不是所有的类型都重载了&#x3D;&#x3D;,所以无法用&#x3D;&#x3D;判断                if(value.Equals(array[i]))                &#123;                    index &#x3D; i;                    break;                &#125;            &#125;            if(index !&#x3D; -1)            &#123;                for (int i &#x3D; index; i &lt; Count; i++)                &#123;                    array[i] &#x3D; array[i + 1];                &#125;                array[Count] &#x3D; default(T);                --count;            &#125;        &#125;        &#x2F;&#x2F;查        public void RemoveAt(int index)        &#123;            if(index &lt; 0 || index &gt;&#x3D; Count)            &#123;                return;            &#125;            for (int i &#x3D; index; i &lt; Count; i++)            &#123;                array[i] &#x3D; array[i + 1];            &#125;            array[Count] &#x3D; default(T);            --count;        &#125;        &#x2F;&#x2F;改        public T this[int index]        &#123;            get             &#123;                if (index &lt; 0 || index &gt;&#x3D; Count)                &#123;                    return default(T);                &#125;                return array[index];             &#125;            set             &#123;                if (index &lt; 0 || index &gt;&#x3D; Count)                &#123;                    return;                &#125;                array[index] &#x3D; value;             &#125;        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            ArrayList&lt;int&gt; array &#x3D; new ArrayList&lt;int&gt;();            Console.WriteLine(&quot;&#123;0&#125;,&#123;1&#125;&quot;, array.Count, array.Capacity);            array.Add(1);            array.Add(2);            array.Add(3);            Console.WriteLine(&quot;&#123;0&#125;,&#123;1&#125;&quot;, array.Count, array.Capacity);            Console.WriteLine(array[1]);            Console.WriteLine(array[-1]);            array.RemoveAt(0);            Console.WriteLine(&quot;&#123;0&#125;,&#123;1&#125;&quot;, array.Count, array.Capacity);            for (int i &#x3D; 0; i &lt; array.Count; i++)            &#123;                Console.WriteLine(array[i]);            &#125;            Console.WriteLine(array[0]);            array[0] &#x3D; 5;            Console.WriteLine(array[0]);        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>泛型</title>
    <link href="/2022/05/30/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E6%B3%9B%E5%9E%8B/"/>
    <url>/2022/05/30/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>泛型</p><span id="more"></span><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>泛型实现了类型参数化，打到代码重用的目的<br>通过类型参数化来实现同一份代码上操作多种类型</p><p>泛型相当于类型占位符<br>定义类或方法时使用替代符代表变量类型<br>当真正使用类或者方法时再具体指定类型</p><h2 id="泛型分类"><a href="#泛型分类" class="headerlink" title="泛型分类"></a>泛型分类</h2><p>泛型类和泛型接口<br>基本语法：</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class 类名&lt;泛型占位字符&gt;interface 接口名&lt;泛型占位字符&gt;</code></pre></div><p>泛型函数<br>基本语法：</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">函数名&lt;泛型占位字符&gt;(参数列表)</code></pre></div><p><strong>注意：</strong><br>泛型占位字母可以有多个，用逗号分开</p><h2 id="泛型分类实例"><a href="#泛型分类实例" class="headerlink" title="泛型分类实例"></a>泛型分类实例</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class TestClass&lt;T&gt;&#123;    public T value;&#125;class TestClass&lt;T1,T2,K,M,Key&gt;&#123;    &#x2F;&#x2F;每个占位符&#125;TestClass&lt;int&gt; t &#x3D; new TestClass&lt;int&gt;();</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">interface TestInterface&lt;T&gt;&#123;    T value    &#123;        get;        set;    &#125;&#125;class Test : TestInterface&lt;int&gt;&#123;    public int value    &#123;        get;        set;    &#125;&#125;</code></pre></div><h2 id="泛型方法实例"><a href="#泛型方法实例" class="headerlink" title="泛型方法实例"></a>泛型方法实例</h2><h3 id="普通类中的泛型方法"><a href="#普通类中的泛型方法" class="headerlink" title="普通类中的泛型方法"></a>普通类中的泛型方法</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Test2&#123;    public void TestFun&lt;T&gt;( T value )    &#123;        Console.WriteLine(value);    &#125;&#125;Test2 test2 &#x3D; new Test2();test2.TestFun&lt;string&gt;(&quot;123123&quot;);</code></pre></div><h3 id="泛型类中的泛型方法"><a href="#泛型类中的泛型方法" class="headerlink" title="泛型类中的泛型方法"></a>泛型类中的泛型方法</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Test2&lt;T&gt;&#123;    public T value;    &#x2F;&#x2F;这不是一个泛型方法，因为T是泛型类声明的时候就指定，在使用这个函数的时候不能动态的改变T    public void TestFun(T t)    &#123;    &#125;    &#x2F;&#x2F;这是一个泛型方法，T已经被泛型类使用，泛型方法中不能用T    public void TestFun&lt;K&gt;( K value )    &#123;        Console.WriteLine(value);    &#125;&#125;Test2 test2 &#x3D; new Test2();test2.TestFun&lt;string&gt;(&quot;123123&quot;);</code></pre></div><h2 id="泛型的作用"><a href="#泛型的作用" class="headerlink" title="泛型的作用"></a>泛型的作用</h2><p>1.不同类型对象的相同逻辑处理就可以选择泛型<br>2.使用泛型可以一定程度避免装箱拆箱</p><p>举例：优化ArrayList</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class ArrayList&lt;T&gt;&#123;    private T[] array;    public void Add(T value)    &#123;    &#125;    public void Remove(T value)    &#123;    &#125;&#125;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/30/CSharp/CSharp%E8%BF%9B%E9%98%B6/%E6%B3%9B%E5%9E%8B/exam.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson5_泛型&#123;    class Type    &#123;        public void WhatType&lt;T&gt; ()        &#123;            if (typeof(T) &#x3D;&#x3D; typeof(int))            &#123;                Console.WriteLine(&quot;整形, 4字节&quot;);            &#125;            else if(typeof(T) &#x3D;&#x3D; typeof(char))            &#123;                Console.WriteLine(&quot;字符, 1字节&quot;);            &#125;            else if (typeof(T) &#x3D;&#x3D; typeof(float))            &#123;                Console.WriteLine(&quot;单精度浮点数, 8字节&quot;);            &#125;            else if (typeof(T) &#x3D;&#x3D; typeof(string))            &#123;                Console.WriteLine(&quot;字符串, 不定字节数&quot;);            &#125;            else            &#123;                Console.WriteLine(&quot;其他类型&quot;);            &#125;        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Type type &#x3D; new Type();            type.WhatType&lt;int&gt;();        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月30日</title>
    <link href="/2022/05/30/diary/2022.5/2022%E5%B9%B45%E6%9C%8830%E6%97%A5/"/>
    <url>/2022/05/30/diary/2022.5/2022%E5%B9%B45%E6%9C%8830%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="7f50a5faf5aa1f555cc0cc3f0e02ec71225da4aee28e2835c2827c7bbedea88f">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50fdd0ca3edc57389bd0e88084b7db2023162afbff53542a89ea79d2bc20a5a460011d779c4a734dae53a0a6590315caa329d41c248858e3439fdfd312079e72ef1122dd3ff3bfdede7e6ce61a85d23b4c6692b6fa4af166de9c4417b8d7ad1606ec540046038eef308ceaf01891fdfbab76bda4bb18d8e952487d4a7b87a5eefbc8cd39cbed02db97b1a54e4a16c6de7955b581a7ae02c259c4fd3194960312e821d0fecde17294e971a68fc8aee2e0638a8e7f0aec2eda62332b823239b70693805e230f376ba3b89130043136bbc9835019b11fd2b1a19d07ca789db8b95bd011333e271235931f70c46c9a8d2e40417072fc2628ccaddc7c78f0ade743d8b4528f2897a19675751e65a9a3e17be9ae4b0795dcb8d54571540fef72b98c76deeaa7f94ce5780c1bbba1b6127c5b675ad755a7df02902fdb41d1b71cf28824c6f081d371e6023848fcd0abcb1ae7656ecb16af96c2b601e74c497dbd0fc3150d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月29日</title>
    <link href="/2022/05/30/diary/2022.5/2022%E5%B9%B45%E6%9C%8829%E6%97%A5/"/>
    <url>/2022/05/30/diary/2022.5/2022%E5%B9%B45%E6%9C%8829%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="0e17085469af6251ac8009fe38cf278000804a29448ff6133bbc02d73d404fd3">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe500369424d0a5d6c91d4929760e488202cf5c260e28b2f7c911f78a16a927e3650be915fff1bb966a7bd9cfa54e7b9bd19abcfcba2f73f70df369bf026f9d13f79f742032eeded394a91a966c343c200c92dc11231e1f605e089d8dc4eeabbca8ae5c0dcbfaf3c5388017f3a408ccc37225cf18c56e419046b4254225c1172e2ff26abfb9f4b7abc732b519e0841e6d6c369a55d1c9996698e241aff4e9af9fbbf345aed4a3a88b92c4192e88a4fea449e199a6324b34199688aa619aca3954ce29f7c7806f7ff91bf82b2c7b320cd049dbabd1822f8e43c4a8d71f7899070a5b7d18900014341ea8ef4852e047a6c6fab3188ad5f9565a2738686832e1ad7e3faab53fa161a517765df3e968d8606bb059bdd9254b9cb4a69ddbce52aecb20c848a03e1743313edc92c2a89aa6387208ebb9e2ddf6ba9056b1f0880fcdacc7752b2e5d17ee5c867b3bde97741e7093364ffabfac9c9aa7bcddc130db77a9363f7126b613b86b3375d0e5d34630249c3e870ded3a07152675953028c4568b91a0e53b7e232ef1f4f31cce705aad189273a914974a701d258745997e5f45f68aed38e3558c5719de77eddf994ed79af6685</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hashtable</title>
    <link href="/2022/05/28/CSharp/CSharp%E8%BF%9B%E9%98%B6/Hashtable/"/>
    <url>/2022/05/28/CSharp/CSharp%E8%BF%9B%E9%98%B6/Hashtable/</url>
    
    <content type="html"><![CDATA[<p>Hashtable</p><span id="more"></span><h1 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h1><p>Hashtable(又称散列表)，表示根据键的哈希代码进行组织的<strong>键&#x2F;值对</strong>的集合。<br>它的主要作用是提高数据查询的效率<br>使用键来访问集合中的元素(object类型)</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System.Collections;    Hashtable hashtable &#x3D; new Hashtable();</code></pre></div><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;往表中加一对(键, 值)hashtable.Add(object, object);&#x2F;&#x2F;不能有相同键</code></pre></div><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;只能通过键去删除hashtable.Remove(object); &#x2F;&#x2F;键&#x2F;&#x2F;删除不存在的键不会报错也不能删除&#x2F;&#x2F;清空hashtable.Clear();</code></pre></div><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;通过键查看对应的值，找不到会返回空hashtable[object]; &#x2F;&#x2F;键&#x2F;&#x2F;查看元素是否存在hashtable中(bool)hashtable.Contains(object); &#x2F;&#x2F;键 hashtable.ContainsKey(object); &#x2F;&#x2F;键hashtable.ContainsValue(object); &#x2F;&#x2F;值</code></pre></div><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><p>只能改键对应的值内容，无法修改键</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">hashtable[object] &#x3D; new object;</code></pre></div><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;键值对的对数hashtable.Count&#x2F;&#x2F;迭代器遍历所有的键foreach (object item in hashtable.Keys)&#123;    &#x2F;&#x2F;需要的逻辑 &#125;&#x2F;&#x2F;迭代器遍历所有的值foreach (object item in hashtable.Values)&#123;    &#x2F;&#x2F;需要的逻辑 &#125;&#x2F;&#x2F;迭代器遍历所有的键值对foreach (DictionaryEntry item in hashtable)&#123;    &#x2F;&#x2F;需要的逻辑 &#125;&#x2F;&#x2F;迭代器遍历法IDictionaryEnumerator myEnumerator &#x3D; hashtable.GetEnumerator();bool flag &#x3D; myEnumerator.MoveNext();while (flag)&#123;    Console.WriteLine(&quot;键&#x3D;&#123;0&#125;，值&#x3D;&#123;1&#125;&quot;, myEnumerator.Key, myEnumerator.Value);    flag &#x3D; myEnumerator.MoveNext();&#125;</code></pre></div><h2 id="装箱拆箱"><a href="#装箱拆箱" class="headerlink" title="装箱拆箱"></a>装箱拆箱</h2><p>hashtable本质上是一个有特殊存储规则的object数组<br>由于用万物之父object来存储数据，自然存在装箱拆箱。<br>当往其中进行值类型存储时即为装箱，当将值类型对象取出来时即为拆箱</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/28/CSharp/CSharp%E8%BF%9B%E9%98%B6/Hashtable/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><p>存的是一对键&#x2F;值，他们都是object类型</p><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections;namespace Lesson4_Hashtable&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;怪物管理器&quot;);            Hashtable hashtable &#x3D; new Hashtable();            string name;            int index &#x3D; 0;                                    while (true)            &#123;                Console.WriteLine(&quot;按q进入创建怪兽模式，按w进入移出怪兽模式，按r退出商店，按a打印现在有的怪兽&quot;);                switch (Console.ReadKey(true).Key)                &#123;                    case ConsoleKey.Q:                        Console.WriteLine(&quot;按e可以退出模式&quot;);                        while (true)                        &#123;                            Console.WriteLine(&quot;请输入怪兽名以创建：&quot;);                            name &#x3D; Console.ReadLine();                            hashtable.Add(name, index++);                            if (Console.ReadKey(true).Key &#x3D;&#x3D; ConsoleKey.E)                            &#123;                                break;                            &#125;                        &#125;                        break;                    case ConsoleKey.W:                        Console.WriteLine(&quot;按e可以退出模式&quot;);                        while (true)                        &#123;                            Console.WriteLine(&quot;请输入想要删除的怪兽：&quot;);                            name &#x3D; Console.ReadLine();                            hashtable.Remove(name);                            if (Console.ReadKey(true).Key &#x3D;&#x3D; ConsoleKey.E)                            &#123;                                break;                            &#125;                        &#125;                        break;                    case ConsoleKey.A:                        NowMonster(hashtable);                        break;                    case ConsoleKey.R:                        Environment.Exit(0);                        break;                &#125;            &#125;        &#125;        static void NowMonster(Hashtable hashtable)        &#123;            IDictionaryEnumerator myEnumerator &#x3D; hashtable.GetEnumerator();            bool flag &#x3D; myEnumerator.MoveNext();            while (flag)            &#123;                Console.WriteLine(&quot;怪兽：&#123;0&#125;，ID&#x3D;&#123;1&#125;&quot;, myEnumerator.Key, myEnumerator.Value);                flag &#x3D; myEnumerator.MoveNext();            &#125;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Queue</title>
    <link href="/2022/05/28/CSharp/CSharp%E8%BF%9B%E9%98%B6/Queue/"/>
    <url>/2022/05/28/CSharp/CSharp%E8%BF%9B%E9%98%B6/Queue/</url>
    
    <content type="html"><![CDATA[<p>Queue</p><span id="more"></span><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p>Queue是C#已经封装好的一个类<br>它的本质是一个object类型的数组,只是封装了特殊的存储规则</p><p>Queue是队列存储容器，<br>队列是一种<strong>先进先出</strong>的数据结构，<br>先存入的数据先获取，后存入的数据后获取</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System.Collections;    Queue queue &#x3D; new Queue();</code></pre></div><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;往队列中存储一个元素queue.Enqueue(object);</code></pre></div><h2 id="取"><a href="#取" class="headerlink" title="取"></a>取</h2><p>队列里不存在删除的概念</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;取出先加入队列的元素object &#x3D; queue.Dequeue();</code></pre></div><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><p>队列无法查看指定位置的元素，只能查看最后加入队列的内容</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;查看最后加入队列的元素object &#x3D; queue.Peek();&#x2F;&#x2F;查看元素是否存在队列中(bool)stack.Contains(object);</code></pre></div><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><p>队列无法改变其中元素，它只能进出队列，但可以清空</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;清空栈stack.Clear();</code></pre></div><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>由于队列里面没有提供索引器来中括号访问的接口，所以无法用for直接进行循环遍历</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;栈长度queue.Count&#x2F;&#x2F;迭代器遍历 顺序栈顶到栈底foreach (object item in queue)&#123;    &#x2F;&#x2F;需要的逻辑 &#125;&#x2F;&#x2F;将栈转换为object数组 顺序栈顶到栈底object[] array &#x3D; queue.ToArray();for( i &#x3D; 0; i &lt; array.Length; i++ )&#123;    &#x2F;&#x2F;需要的逻辑 &#125;&#x2F;&#x2F;循环出列while( queue.Count &gt; 0 )&#123;    object q &#x3D; queue.Dequeue();    Console.WriteLine(q);&#125;Console.WriteLine( queue.Count );</code></pre></div><h2 id="装箱拆箱"><a href="#装箱拆箱" class="headerlink" title="装箱拆箱"></a>装箱拆箱</h2><p>queue本质上是一个有特殊存储规则的object数组<br>由于用万物之父object来存储数据，自然存在装箱拆箱。<br>当往其中进行值类型存储时即为装箱，当将值类型对象取出来时即为拆箱</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">int i &#x3D; 1;queue.Enqueue(i); &#x2F;&#x2F;装箱i &#x3D; (int)queue.Dequeue(); &#x2F;&#x2F;拆箱</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/28/CSharp/CSharp%E8%BF%9B%E9%98%B6/Queue/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><p>先进先出</p><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections;namespace Lesson3_Queue&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Queue queue &#x3D; new Queue();            Console.WriteLine(&quot;请输入你要存储的消息：&quot;);            Input(queue);            Console.WriteLine(&quot;\n已保存您的消息，按回车为您播放\n&quot;);            if( Console.ReadKey(true).Key &#x3D;&#x3D; ConsoleKey.Enter )            &#123;                Output(queue);                Console.WriteLine(&quot;\n已播放完所有您的消息&quot;);                Environment.Exit(0);            &#125;        &#125;        static void Input(Queue queue)        &#123;            object message;            &#x2F;&#x2F;输入10个数停止输入（可以拓展为特殊指令停止输入）            while ((string)(message &#x3D; Console.ReadLine()) !&#x3D; &quot;end&quot;)            &#123;                queue.Enqueue(message);            &#125;        &#125;        static void Output(Queue queue)        &#123;            int updateIndex &#x3D; 0;            while (queue.Count &gt; 0)            &#123;                if (updateIndex++ &#x3D;&#x3D; 500000000)                &#123;                    object q &#x3D; queue.Dequeue();                    Console.WriteLine(q);                    updateIndex &#x3D; 0;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月28日</title>
    <link href="/2022/05/28/diary/2022.5/2022%E5%B9%B45%E6%9C%8828%E6%97%A5/"/>
    <url>/2022/05/28/diary/2022.5/2022%E5%B9%B45%E6%9C%8828%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="84dcb4d42cb9297933669081676b69219e36aa1385f41d37ab53ac4e791d5f6e">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50fdd0ca3edc57389bd0e88084b7db2023864dedcaf29722604466ff56cd1351098391ce02fc05a8d8d5df856d96ca7afe1aee599b47e793590800307447ea37035438f56b30fce5371015d90e9b5283da6b2f2a12ea95f71ccfb89fae65db3524fd4e696adea04efb147fbe8dd0a251a0f0e0aade4a59b33ed6cc4fb6c85862e21e1bd2883d0342693ea1658a84ec69a8e001b9f38ecaf5619391fb8ebff1bc983179255323c94e6f64b0e17b0cb4ab310e9a6be85fa95a081cdde4012672884c3633bdade2bc543b95e7c33d1ac46c586453b834661df1cecc017a3369374519297722edc11d71d205d3b1170c9c42738687e7d9e38c1bcb946131e45cc5291fff1883706597a816269c4700c277bf261ec19290a85f8feddace418a18b75d2c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Stack</title>
    <link href="/2022/05/27/CSharp/CSharp%E8%BF%9B%E9%98%B6/Stack/"/>
    <url>/2022/05/27/CSharp/CSharp%E8%BF%9B%E9%98%B6/Stack/</url>
    
    <content type="html"><![CDATA[<p>Stack</p><span id="more"></span><h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><p>Stack是C#已经封装好的一个类<br>它的本质是一个object类型的数组,只是封装了特殊的存储规则</p><p>Stack是一个栈存储容器，栈是一种<strong>先进后出</strong>的数据结构<br>先存入的数据（栈底）后获取，后存入的数据（栈顶）先获取</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System.Collections;    Stack stack &#x3D; new Stack();</code></pre></div><h2 id="增-压栈"><a href="#增-压栈" class="headerlink" title="增(压栈)"></a>增(压栈)</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;往栈顶压入一个元素stack.Push(object);</code></pre></div><h2 id="取-弹栈"><a href="#取-弹栈" class="headerlink" title="取(弹栈)"></a>取(弹栈)</h2><p>栈里不存在删除的概念</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;弹出栈顶元素object &#x3D; stack.Pop();</code></pre></div><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><p>栈无法查看指定位置的元素，只能查看栈顶的内容</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;查看栈顶的内容(并不弹出来)object &#x3D; stack.Peek();&#x2F;&#x2F;查看元素是否存在与栈中(bool)stack.Contains(object);</code></pre></div><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><p>栈无法改变其中元素，它只能压和弹，但可以清空</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;清空栈stack.Clear();</code></pre></div><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>由于栈里面没有提供索引器来中括号访问的接口，所以无法用for直接进行循环遍历</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;栈长度stack.Count&#x2F;&#x2F;迭代器遍历 顺序栈顶到栈底foreach (object item in stack)&#123;    &#x2F;&#x2F;需要的逻辑 &#125;&#x2F;&#x2F;将栈转换为object数组 顺序栈顶到栈底object[] array &#x3D; stack.ToArray();for( i &#x3D; 0; i &lt; array.Length; i++ )&#123;    &#x2F;&#x2F;需要的逻辑 &#125;&#x2F;&#x2F;循环弹栈while( stack.Count &gt; 0 )&#123;    object o &#x3D; stack.Pop();    Console.WriteLine(o);&#125;Console.WriteLine(stack.Count);</code></pre></div><h2 id="装箱拆箱"><a href="#装箱拆箱" class="headerlink" title="装箱拆箱"></a>装箱拆箱</h2><p>stack本质上是一个有特殊存储规则的object数组<br>由于用万物之父object来存储数据，自然存在装箱拆箱。<br>当往其中进行值类型存储时即为装箱，当将值类型对象取出来时即为拆箱</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">int i &#x3D; 1;stack.Push(i); &#x2F;&#x2F;装箱i &#x3D; (int)stack.Pop(); &#x2F;&#x2F;拆箱</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/27/CSharp/CSharp%E8%BF%9B%E9%98%B6/Stack/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><p>先进后出</p><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections;namespace Lesson2_Stack&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            while (true)            &#123;                Console.Write(&quot;请输入一个十进制数: &quot;);                uint num &#x3D; uint.Parse(Console.ReadLine());                Console.Write(&quot;转换成的二进制数: &quot;);                Calc(num);                Console.WriteLine(&quot;\n&quot;);            &#125;                    &#125;        static void Calc(uint num)        &#123;            Stack stack &#x3D; new Stack();            while(num &gt; 1)            &#123;                stack.Push(num % 2);                num &#x2F;&#x3D; 2;                if(num &#x3D;&#x3D; 1)                &#123;                    stack.Push(num);                    break;                &#125;            &#125;            while(stack.Count &gt; 0)            &#123;                Console.Write(stack.Pop());            &#125;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArrayList</title>
    <link href="/2022/05/27/CSharp/CSharp%E8%BF%9B%E9%98%B6/ArrayList/"/>
    <url>/2022/05/27/CSharp/CSharp%E8%BF%9B%E9%98%B6/ArrayList/</url>
    
    <content type="html"><![CDATA[<p>ArrayList</p><span id="more"></span><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><p>ArrayList是C#已经封装好的一个类<br>它的本质是一个object类型的数组</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System.Collections;    ArrayList array &#x3D; new ArrayList();</code></pre></div><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;增加一个元素array.Add(object);&#x2F;&#x2F;批量增加，把另一个list容器中的元素加到后面array.AddRange(array2);&#x2F;&#x2F;插入元素array.Insert(索引值, object); &#x2F;&#x2F;在该位置插入想要插入的元素</code></pre></div><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;移出指定元素，从头找，找到删array.Remove(object);&#x2F;&#x2F;移除指定位置元素array.RemoveAt(索引值);&#x2F;&#x2F;清空数组array.Clear();</code></pre></div><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;得到指定位置的元素Console.WriteLine(array[0]);&#x2F;&#x2F;查询元素是否存在array.Contains(object); &#x2F;&#x2F;存在为真,不存在为假&#x2F;&#x2F;正向查找元素位置,正向第一个找到的位置array.IndexOf(object); &#x2F;&#x2F;返回索引值,没找到返回-1 &#x2F;&#x2F;正向查找元素位置,反向第一个找到的位置array.LastIndexOf(object); &#x2F;&#x2F;返回索引值,没找到返回-1 </code></pre></div><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;直接改指定位置的元素array[索引值] &#x3D; object;</code></pre></div><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;数组长度array.Count&#x2F;&#x2F;数组容量array.Capacity&#x2F;&#x2F;遍历for( i &#x3D; 0; i &lt; array.Count; i++ )&#123;    &#x2F;&#x2F;需要的逻辑&#125;&#x2F;&#x2F;迭代器遍历 把array里的元素放到item里foreach (object item in array)&#123;    &#x2F;&#x2F;需要的逻辑 &#125;</code></pre></div><h2 id="装箱拆箱"><a href="#装箱拆箱" class="headerlink" title="装箱拆箱"></a>装箱拆箱</h2><p>ArrayList本质上是一个可以自动扩容的object数组<br>由于用万物之父object来存储数据，自然存在装箱拆箱。<br>当往其中进行值类型存储时即为装箱，当将值类型对象取出来时即为拆箱<br>ArrayList尽量少用</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">int i &#x3D; 1;array[0] &#x3D; i; &#x2F;&#x2F;装箱i &#x3D; (int)array[0]; &#x2F;&#x2F;拆箱</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/27/CSharp/CSharp%E8%BF%9B%E9%98%B6/ArrayList/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><p>ArrayList就是一个可以自动扩容的object类型的数组</p><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections;namespace Lesson1_ArrayList&#123;    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 道具种类    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_ItemType    &#123;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 回血药        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        HpRecovery,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 回蓝药        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        MpRecovery,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 复活药        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Revival,    &#125;    class BagManagement    &#123;        &#x2F;&#x2F;初始金币100        private int money &#x3D; 100;        &#x2F;&#x2F;道具        private ArrayList items &#x3D; new ArrayList();        public BagManagement()        &#123;            items.Clear();        &#125;        &#x2F;&#x2F;购买道具方法        public void BuyItem(Item i)        &#123;            if((money - i.price) &gt; 0 )            &#123;                items.Add(i);                money -&#x3D; i.price;                Console.WriteLine(&quot;购买成功\n&quot;);            &#125;            else            &#123;                Console.WriteLine(&quot;金币不够，购买失败\n&quot;);            &#125;                      &#125;        &#x2F;&#x2F;卖出道具方法        public void SellItem(Item i)        &#123;            if(items.Contains(i))            &#123;                items.Remove(i);                money +&#x3D; i.price;                Console.WriteLine(&quot;出售成功\n&quot;);            &#125;            else            &#123;                Console.WriteLine(&quot;出售失败\n&quot;);            &#125;                    &#125;        &#x2F;&#x2F;显示道具方法        public void MyBag()        &#123;            if(items.Count &gt; 0)            &#123;                for (int i &#x3D; 0; i &lt; items.Count; i++)                &#123;                    (items[i] as Item).Show();                 &#125;                Console.WriteLine(&quot;现在还有&#123;0&#125;金币\n&quot;, money);            &#125;            else            &#123;                Console.WriteLine(&quot;背包为空&quot;);            &#125;        &#125;    &#125;    abstract class Item    &#123;        abstract public void Show();        protected E_ItemType type;        public int price;    &#125;    class HpRecovery : Item    &#123;        public HpRecovery()        &#123;            type &#x3D; E_ItemType.HpRecovery;            price &#x3D; 20;        &#125;        public override void Show()        &#123;            Console.Write(&quot;回血药*1,&quot;);        &#125;    &#125;    class MpRecovery : Item    &#123;        public MpRecovery()        &#123;            type &#x3D; E_ItemType.MpRecovery;            price &#x3D; 10;        &#125;        public override void Show()        &#123;            Console.Write(&quot;回蓝药*1,&quot;);        &#125;    &#125;    class Revival : Item    &#123;        public Revival()        &#123;            type &#x3D; E_ItemType.Revival;            price &#x3D; 50;        &#125;        public override void Show()        &#123;            Console.Write(&quot;复活药*1,&quot;);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Item hpRecovery &#x3D; new HpRecovery();            Item mpRecovery &#x3D; new MpRecovery();            Item Revival &#x3D; new Revival();            BagManagement bagManagement &#x3D; new BagManagement();            Console.WriteLine(&quot;进入商店，店里有回血药（20金币）、回蓝药（10金币）、复活药（50）金币&quot;);                        Console.WriteLine(&quot;&quot;);            while (true)            &#123;                                try                &#123;                    Console.WriteLine(&quot;按q进入购买模式，按w进入出售模式，按e显示背包，按r退出商店&quot;);                    switch (Console.ReadKey(true).Key)                    &#123;                        case ConsoleKey.Q:                            Console.WriteLine(&quot;按a选择回血药，按s选择回蓝药，按d选择复活药&quot;);                            try                            &#123;                                switch (Console.ReadKey(true).Key)                                &#123;                                    case ConsoleKey.A:                                        bagManagement.BuyItem(hpRecovery);                                        break;                                    case ConsoleKey.S:                                        bagManagement.BuyItem(mpRecovery);                                        break;                                    case ConsoleKey.D:                                        bagManagement.BuyItem(Revival);                                        break;                                &#125;                            &#125;                            catch &#123; Console.WriteLine(&quot;请输入正确指令\n&quot;); &#125;                            break;                                                case ConsoleKey.W:                            Console.WriteLine(&quot;按a选择回血药，按s选择回蓝药，按d选择复活药&quot;);                            try                            &#123;                                switch (Console.ReadKey(true).Key)                                &#123;                                    case ConsoleKey.A:                                        bagManagement.SellItem(hpRecovery);                                        break;                                    case ConsoleKey.S:                                        bagManagement.SellItem(mpRecovery);                                        break;                                    case ConsoleKey.D:                                        bagManagement.SellItem(Revival);                                        break;                                &#125;                            &#125;                            catch &#123; Console.WriteLine(&quot;请输入正确指令\n&quot;); &#125;                            break;                        case ConsoleKey.E:                            bagManagement.MyBag();                            break;                        case ConsoleKey.R:                            Environment.Exit(0);                            break;                    &#125;                &#125;                catch                &#123;                    Console.WriteLine(&quot;请输入正确指令\n&quot;);                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月27日</title>
    <link href="/2022/05/27/diary/2022.5/2022%E5%B9%B45%E6%9C%8827%E6%97%A5/"/>
    <url>/2022/05/27/diary/2022.5/2022%E5%B9%B45%E6%9C%8827%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="19eaac3c558563ac3af9f901fbf434cc87472ac4271f9c84aa9c8aeeed19ea94">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50c3ac06e6f61fe5887c5b94f65bc78d9466e9c645746ff39fd7764c28fce597a98ef90554385047c8cd380b682d6c36897f111398d792cdf413d3724f0b3487b0d6c4344fdea739a201a15a25e426c48d5f58a20be69bf7d5d8fdd3d0b29ac505df147cdb70bc846113e18e84488305fcab0663b1022f9a134ccc50d562126a63efa205176ddcd837c2d5cd028bf0f2c9f315b524ec0219c08e2dd2ab834e25a4cdad9856964c3048f23fe4e5cc167a37f7c0fae660b9368142d8c848302b5e47d2385eb03c1027fd0cb6e360cd685a4a23ef151e8eaef04ece2dbf4a7e839871</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月26</title>
    <link href="/2022/05/26/diary/2022.5/2022%E5%B9%B45%E6%9C%8826%E6%97%A5/"/>
    <url>/2022/05/26/diary/2022.5/2022%E5%B9%B45%E6%9C%8826%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="a2e468b686d8665f8e4c121eb76bfdc32a3a832dd2f9982da2724c5e78f5e301">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe503619eff7dff6c9b0a85b11a78d93a4051b73d5cd83ebaf35cca5f7643c01abda1af045ea1c1ff179d55eb176e39c95b89f9034bb22a2efc5e4681e7a90646ea4225c005fc0d268cc385e70989933570cc98084e852ec61a8c366e1263c5c896005d2f3251fe37e12578d87a35051b87e1270628f468f5dc8e2570a56e45e9da1444974c84bb000c1b4c091028d2f91620b9fe921f41e5649f05126b8bcdc79c24e2a09c085eb575624c728a388e8fec04d41180b0ba2457b8d47425aecfcd977824db8af4da012a172771720551eacecf8fcd6a892394469f352268d4850de353f2e2fb8cdaae4539ab2bafbbd8adf14758e80b47fedf19533238130a017f31113453ea7b7c1d90d9ab8db545318bf33e92d0d40e88232cdcc1842b14370357e7b3f355e16b80b5f265a3b3391be0a7f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月25日</title>
    <link href="/2022/05/25/diary/2022.5/2022%E5%B9%B45%E6%9C%8825%E6%97%A5/"/>
    <url>/2022/05/25/diary/2022.5/2022%E5%B9%B45%E6%9C%8825%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="e3ceef968f0f28d3f1dd370815788b715c166c276dd39cfbf4d5cd992f210444">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50b9d57857458f6060ad6c9d0947720f2b81966f40a7c8271e7fa31bf05b458e7d5d118009571b608c05167d793a08f412e353aacf5e3e7e9d45bebcd350706970eabdf3e2d7dfb0ffc06ab2719c2acd8a9ff01f455bdf04170a047042455ff83032bf53eabb6ccfed8e48036fa66d621d18ae7e241616c3019fc71f043b6be4461162938138e51cafa90933700a85c22ef29ca91578ee48e4c50f4019f090e479f125a34e04fe1d9ecf2bf102003a9c105535757cfad837d6f5f4b70b9552a614</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贪吃蛇实现</title>
    <link href="/2022/05/24/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E8%B4%AA%E5%90%83%E8%9B%87%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/05/24/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E8%B4%AA%E5%90%83%E8%9B%87%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>贪吃蛇实现</p><span id="more"></span><p>试着在工程里实现多脚本，一个类一个脚本</p><p>UML类图：面向对象程序开发时理清对象关系，养成面向对象编程习惯<br>关联，直接关联，聚合，依赖关系，复合</p><h1 id="七大原则："><a href="#七大原则：" class="headerlink" title="七大原则："></a>七大原则：</h1><p>总体要实现<strong>高内聚，低耦合</strong><br>使程序模块的可重用性、移植性增强</p><h2 id="高内聚，低耦合："><a href="#高内聚，低耦合：" class="headerlink" title="高内聚，低耦合："></a>高内聚，低耦合：</h2><p>1.类的角度：减少类内部，对其他类的调用<br>2.功能块的角度：减少模块之间的交互复杂度</p><h2 id="单一职责原则（SPR-Single-Responsibility-Principle）"><a href="#单一职责原则（SPR-Single-Responsibility-Principle）" class="headerlink" title="单一职责原则（SPR-Single Responsibility Principle）"></a>单一职责原则（SPR-Single Responsibility Principle）</h2><p>类被修改的概率很大，因此应该专注于单一的功能。<br>如果把多个功能放在同一个类中，功能之间就形成了关联，改变其中一个功能，有可能中止另一个功能</p><h2 id="开闭原则（OCP-Open-Closed-Principle）"><a href="#开闭原则（OCP-Open-Closed-Principle）" class="headerlink" title="开闭原则（OCP-Open Closed Principle）"></a>开闭原则（OCP-Open Closed Principle）</h2><p>对扩展开放，对修改关闭<br>拓展开放：模块的行为可以被拓展从而满足新的需求<br>修改关闭：不允许修改模块的源代码（或尽量使修改最小化）</p><h2 id="里式替换原则（LSP-Liskov-Substitution-Principle）"><a href="#里式替换原则（LSP-Liskov-Substitution-Principle）" class="headerlink" title="里式替换原则（LSP-Liskov Substitution Principle）"></a>里式替换原则（LSP-Liskov Substitution Principle）</h2><p>任何父类出现的地方，子类都可以代替</p><h2 id="依赖倒转原则（DIP-Dependence-Inversion-Principle）"><a href="#依赖倒转原则（DIP-Dependence-Inversion-Principle）" class="headerlink" title="依赖倒转原则（DIP-Dependence Inversion Principle）"></a>依赖倒转原则（DIP-Dependence Inversion Principle）</h2><p>要依赖于抽象（接口），不要依赖于具体的实现</p><h2 id="迪米特原则（LoD-Law-of-Demeter）"><a href="#迪米特原则（LoD-Law-of-Demeter）" class="headerlink" title="迪米特原则（LoD-Law of Demeter）"></a>迪米特原则（LoD-Law of Demeter）</h2><p>又称最小知识原则<br>一个对象应该对其他对象尽可能少的了解<br>一个对象中的成员，要尽可能少的直接和其他类建立关系，目的是降低耦合性</p><h2 id="接口分离原则（ISP-Interface-Segregation-Principle）"><a href="#接口分离原则（ISP-Interface-Segregation-Principle）" class="headerlink" title="接口分离原则（ISP-Interface Segregation Principle）"></a>接口分离原则（ISP-Interface Segregation Principle）</h2><p>一个接口不需要提供太多的行为，一个接口应该尽量只提供一个对外的功能，让别人去选择需要实现什么样的行为，而不是把所有的行为封装到一个接口里</p><h2 id="合成复用原则（CRP-Composite-Reuse-Principle）"><a href="#合成复用原则（CRP-Composite-Reuse-Principle）" class="headerlink" title="合成复用原则（CRP-Composite Reuse Principle）"></a>合成复用原则（CRP-Composite Reuse Principle）</h2><p>尽量使用对象组合，而不是继承来达到复用的目的<br>继承是强耦合，组合关系是弱耦合<br>注意：不能盲目的使用合成复用原则，要在遵循迪米特原则的前提下</p><p>在开始做项目之前，整理UML类图时，<br>先按自己的想法把需要的类整理出来<br>再基于七大法则去优化整理自己的设计<br>最后，具体问题具体分析，面向对象的编程能力提升是需要经验积累的。</p><h1 id="贪吃蛇"><a href="#贪吃蛇" class="headerlink" title="贪吃蛇"></a>贪吃蛇</h1><h2 id="Scene"><a href="#Scene" class="headerlink" title="Scene"></a>Scene</h2><h3 id="ISceneUpdate"><a href="#ISceneUpdate" class="headerlink" title="ISceneUpdate"></a>ISceneUpdate</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 贪吃蛇.Scene&#123;    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 场景更新接口    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    internal interface ISceneUpdate    &#123;        void Update();    &#125;&#125;</code></pre></div><h3 id="BeginOrEndBaseScene"><a href="#BeginOrEndBaseScene" class="headerlink" title="BeginOrEndBaseScene"></a>BeginOrEndBaseScene</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 贪吃蛇.Scene&#123;    &#x2F;&#x2F;抽象基类    abstract class BeginOrEndBaseScene:ISceneUpdate    &#123;        protected int nowSelIndex;        protected string strTitle;        protected string strOne;        public abstract void EnterJDoSomething();        public void Update()        &#123;            Console.ForegroundColor &#x3D; ConsoleColor.White;            &#x2F;&#x2F;显示标题            Console.SetCursorPosition( Game.w &#x2F; 2 - strTitle.Length, 5);            Console.WriteLine(strTitle);            &#x2F;&#x2F;显示下方选项            Console.SetCursorPosition(Game.w &#x2F; 2 - strOne.Length, 8);            Console.ForegroundColor &#x3D; nowSelIndex &#x3D;&#x3D; 0 ? ConsoleColor.Red : ConsoleColor.White;            Console.WriteLine(strOne);            Console.SetCursorPosition(Game.w &#x2F; 2 - 4, 10);            Console.ForegroundColor &#x3D; nowSelIndex &#x3D;&#x3D; 1 ? ConsoleColor.Red : ConsoleColor.White;            Console.WriteLine(&quot;结束游戏&quot;);            &#x2F;&#x2F;检测输入            switch(Console.ReadKey(true).Key)            &#123;                case ConsoleKey.W:                    --nowSelIndex;                    if(nowSelIndex &lt; 0)                    &#123;                        nowSelIndex &#x3D; 0;                    &#125;                    break;                case ConsoleKey.S:                    ++nowSelIndex;                    if (nowSelIndex &gt; 1)                    &#123;                        nowSelIndex &#x3D; 1;                    &#125;                    break;                case ConsoleKey.J:                    EnterJDoSomething();                    break;            &#125;        &#125;    &#125;&#125;</code></pre></div><h3 id="BeginScene"><a href="#BeginScene" class="headerlink" title="BeginScene"></a>BeginScene</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 贪吃蛇.Scene&#123;    internal class BeginScene:BeginOrEndBaseScene    &#123;        public BeginScene()        &#123;            strTitle &#x3D; &quot;贪吃蛇&quot;;            strOne &#x3D; &quot;开始游戏&quot;;        &#125;        public override void EnterJDoSomething()        &#123;            if(nowSelIndex &#x3D;&#x3D; 0)            &#123;                Game.ChangeScene(E_SceneType.Game);            &#125;            else            &#123;                Environment.Exit(0);            &#125;        &#125;    &#125;&#125;</code></pre></div><h3 id="EndScene"><a href="#EndScene" class="headerlink" title="EndScene"></a>EndScene</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 贪吃蛇.Scene&#123;    internal class EndScene : BeginOrEndBaseScene    &#123;        public EndScene()        &#123;            strTitle &#x3D; &quot;结束游戏&quot;;            strOne &#x3D; &quot;回到开始界面&quot;;        &#125;        public override void EnterJDoSomething()        &#123;            if (nowSelIndex &#x3D;&#x3D; 0)            &#123;                Game.ChangeScene(E_SceneType.Begin);            &#125;            else            &#123;                Environment.Exit(0);            &#125;        &#125;    &#125;&#125;</code></pre></div><h3 id="GameScene"><a href="#GameScene" class="headerlink" title="GameScene"></a>GameScene</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using 贪吃蛇.Snake;namespace 贪吃蛇.Scene&#123;    class GameScene: ISceneUpdate    &#123;        MapObject map;        SnakeObject snake;        Food food;        &#x2F;&#x2F;延迟计数        int updateIndex &#x3D; 0;        public GameScene()        &#123;            map &#x3D; new MapObject();            snake &#x3D; new SnakeObject(40, 10);            food &#x3D; new Food(snake);            map.Draw();        &#125;        public void Update()        &#123;            if (updateIndex % 5555 &#x3D;&#x3D; 0)            &#123;                food.Draw();                snake.Move();                snake.Draw();                &#x2F;&#x2F;检测是否撞墙                if (snake.CheckEnd(map))                &#123;                    &#x2F;&#x2F;结束逻辑                    Game.ChangeScene(E_SceneType.End);                &#125;                snake.CheckEatFood(food);                updateIndex &#x3D; 0;            &#125;            ++updateIndex;            &#x2F;&#x2F;在控制台中 检测玩家输入 让程序不被检测卡主            &#x2F;&#x2F;判断 有没有键盘输入 如果有 才为true            if (Console.KeyAvailable)            &#123;                &#x2F;&#x2F;检测输入输出 不能再 间隔帧里面去处理 应该每次都检测 这样才准确                switch (Console.ReadKey(true).Key)                &#123;                    case ConsoleKey.W:                        snake.ChangeDir(E_MoveDir.Up);                        break;                    case ConsoleKey.A:                        snake.ChangeDir(E_MoveDir.Left);                        break;                    case ConsoleKey.S:                        snake.ChangeDir(E_MoveDir.Down);                        break;                    case ConsoleKey.D:                        snake.ChangeDir(E_MoveDir.Right);                        break;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div><h3 id="Game"><a href="#Game" class="headerlink" title="Game"></a>Game</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 贪吃蛇.Scene&#123;    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 场景类型枚举    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_SceneType    &#123;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 开始场景        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Begin,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 游戏场景        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Game,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 结束场景        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        End,    &#125;    class Game    &#123;        &#x2F;&#x2F;游戏窗口宽高        public const int w &#x3D; 80;        public const int h &#x3D; 20;        &#x2F;&#x2F;当前选中的场景        public static ISceneUpdate nowScene;        &#x2F;&#x2F;初始化的方法        public Game()        &#123;            Console.CursorVisible &#x3D; false;            Console.SetWindowSize(w, h);            Console.SetBufferSize(w, h);            ChangeScene(E_SceneType.Begin);        &#125;        &#x2F;&#x2F;游戏开始的方法        public void Start()        &#123;            &#x2F;&#x2F;游戏主循环 负责游戏场景的更新            while(true)            &#123;                &#x2F;&#x2F;判断当前游戏场景不为空 就更新                if(nowScene !&#x3D; null)                &#123;                    nowScene.Update();                &#125;            &#125;        &#125;        &#x2F;&#x2F;切换场景的方法        public static void ChangeScene(E_SceneType type)        &#123;            &#x2F;&#x2F;切场景之前，应该清空上一个场景的内容            Console.Clear();            switch (type)            &#123;                case E_SceneType.Begin:                    nowScene &#x3D; new BeginScene();                    break;                case E_SceneType.Game:                    nowScene &#x3D; new GameScene();                    break;                case E_SceneType.End:                    nowScene &#x3D; new EndScene();                    break;            &#125;        &#125;    &#125;&#125;</code></pre></div><h2 id="Snake"><a href="#Snake" class="headerlink" title="Snake"></a>Snake</h2><h3 id="IDraw"><a href="#IDraw" class="headerlink" title="IDraw"></a>IDraw</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 贪吃蛇.Snake&#123;    interface IDraw    &#123;        void Draw();    &#125;&#125;</code></pre></div><p>结构体</p><h3 id="Position"><a href="#Position" class="headerlink" title="Position"></a>Position</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 贪吃蛇.Snake&#123;    struct Position    &#123;        public int x;        public int y;        public Position(int x, int y)        &#123;            this.x &#x3D; x;            this.y &#x3D; y;        &#125;        &#x2F;&#x2F;贪吃蛇中存在位置的比较(头和身体、事物、墙比较)        public static bool operator &#x3D;&#x3D;(Position p1, Position p2)        &#123;            if(p1.x &#x3D;&#x3D; p2.x &amp;&amp; p1.y &#x3D;&#x3D; p2.y)            &#123;                return true;            &#125;            else            &#123;                return false;            &#125;               &#125;        public static bool operator !&#x3D;(Position p1, Position p2)        &#123;            if (p1.x &#x3D;&#x3D; p2.x &amp;&amp; p1.y &#x3D;&#x3D; p2.y)            &#123;                return false;            &#125;            else            &#123;                return true;            &#125;        &#125;    &#125;&#125;</code></pre></div><h3 id="GameObject"><a href="#GameObject" class="headerlink" title="GameObject"></a>GameObject</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 贪吃蛇.Snake&#123;    abstract class GameObject:IDraw    &#123;        &#x2F;&#x2F;继承接口后，把接口中的行为、编程、抽象行为供子类去实现        &#x2F;&#x2F;因为是抽象行为，所以子类中是必须去实现        abstract public void Draw();        public Position pos;    &#125;&#125;</code></pre></div><h3 id="SnakeBody"><a href="#SnakeBody" class="headerlink" title="SnakeBody"></a>SnakeBody</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 贪吃蛇.Snake&#123;    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 蛇身体类型    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_SnakeBody_Type    &#123;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 蛇头        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Head,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 蛇躯        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Body,    &#125;    class SnakeBody:GameObject    &#123;        private E_SnakeBody_Type type;        public SnakeBody(E_SnakeBody_Type type, int x, int y)        &#123;            this.type &#x3D; type;            this.pos &#x3D; new Position(x, y);        &#125;        public override void Draw()        &#123;            Console.SetCursorPosition(pos.x, pos.y);            Console.ForegroundColor &#x3D; type &#x3D;&#x3D; E_SnakeBody_Type.Head ? ConsoleColor.Yellow : ConsoleColor.Green;            Console.Write(type &#x3D;&#x3D; E_SnakeBody_Type.Head ? &quot;●&quot; : &quot;◎&quot;);        &#125;    &#125;&#125;</code></pre></div><h3 id="Wall"><a href="#Wall" class="headerlink" title="Wall"></a>Wall</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 贪吃蛇.Snake&#123;    internal class Wall : GameObject    &#123;        public Wall(int x, int y)        &#123;            pos &#x3D; new Position(x, y);        &#125;        public override void Draw()        &#123;            Console.SetCursorPosition(pos.x, pos.y);            Console.ForegroundColor &#x3D; ConsoleColor.Red;            Console.WriteLine(&quot;■&quot;);        &#125;    &#125;&#125;</code></pre></div><h3 id="MapObject"><a href="#MapObject" class="headerlink" title="MapObject"></a>MapObject</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using 贪吃蛇.Scene;namespace 贪吃蛇.Snake&#123;    class MapObject : IDraw    &#123;        public Wall[] walls;                public MapObject()        &#123;            walls &#x3D; new Wall[ Game.w + (Game.h - 3) * 2 ];            int index &#x3D; 0;            for (int i &#x3D; 0; i &lt; Game.w; i +&#x3D; 2)            &#123;                &#x2F;&#x2F;上面的墙                walls[index++] &#x3D; new Wall(i, 0);            &#125;            for (int i &#x3D; 0; i &lt; Game.w; i +&#x3D; 2)            &#123;                &#x2F;&#x2F;下面的墙                walls[index++] &#x3D; new Wall(i, Game.h - 2);            &#125;            for (int i &#x3D; 1; i &lt; Game.h - 2; i++)            &#123;                &#x2F;&#x2F;左边的墙                walls[index++] &#x3D; new Wall(0, i);            &#125;            for (int i &#x3D; 1; i &lt; Game.h - 2; i++)            &#123;                &#x2F;&#x2F;右边的墙                walls[index++] &#x3D; new Wall(Game.w - 2, i);            &#125;        &#125;        public void Draw()        &#123;            for (int i &#x3D; 0; i &lt; walls.Length; i++)            &#123;                walls[i].Draw();            &#125;        &#125;    &#125;&#125;</code></pre></div><h3 id="Food"><a href="#Food" class="headerlink" title="Food"></a>Food</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using 贪吃蛇.Scene;namespace 贪吃蛇.Snake&#123;    class Food:GameObject    &#123;        public Food(SnakeObject snake)        &#123;            RandomPos(snake);        &#125;        public override void Draw()        &#123;            Console.SetCursorPosition(pos.x, pos.y);            Console.ForegroundColor &#x3D; ConsoleColor.Cyan;            Console.Write(&quot;¤&quot;);        &#125;        &#x2F;&#x2F;随机位置的行为 行为 和蛇的位置 有关系 有了蛇再来考虑        public void RandomPos(SnakeObject snake)        &#123;            &#x2F;&#x2F;随机位置            Random r &#x3D; new Random();            int x &#x3D; r.Next(2, Game.w &#x2F; 2 - 1) * 2;            int y &#x3D; r.Next(1, Game.h - 4);            pos &#x3D; new Position(x, y);            &#x2F;&#x2F;得到蛇            &#x2F;&#x2F;如果重合 就会进if语句            if (snake.CheckSamePos(pos))            &#123;                RandomPos(snake);            &#125;        &#125;    &#125;&#125;</code></pre></div><h3 id="SnakeObject"><a href="#SnakeObject" class="headerlink" title="SnakeObject"></a>SnakeObject</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 贪吃蛇.Snake&#123;    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 蛇的移动方向    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_MoveDir    &#123;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 向上        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Up,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 向下        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Down,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 向左        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Left,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 向右        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Right,    &#125;    class SnakeObject : IDraw    &#123;        SnakeBody[] bodys;        &#x2F;&#x2F;记录蛇的长度        int nowNum;        &#x2F;&#x2F;定义初始移动方向        E_MoveDir dir;        &#x2F;&#x2F;构造函数定义蛇        public SnakeObject(int x, int y)        &#123;            &#x2F;&#x2F;粗暴定义，最多100            bodys &#x3D; new SnakeBody[200];            &#x2F;&#x2F;蛇头            bodys[0] &#x3D; new SnakeBody(E_SnakeBody_Type.Head, x, y);            &#x2F;&#x2F;之后身子从1开始            nowNum &#x3D; 1;            dir &#x3D; E_MoveDir.Right;        &#125;        &#x2F;&#x2F;蛇绘制        public void Draw()        &#123;            for (int i &#x3D; 0; i &lt; nowNum; i++)            &#123;                bodys[i].Draw();            &#125;        &#125;        &#x2F;&#x2F;蛇移动        public void Move()        &#123;            &#x2F;&#x2F;移动前,擦除最后一个位置            SnakeBody lastBody &#x3D; bodys[nowNum - 1];            Console.SetCursorPosition(lastBody.pos.x, lastBody.pos.y);            Console.Write(&quot;  &quot;);            &#x2F;&#x2F;在蛇头移动之前 从蛇尾开始 不停的 让后一个的位置 等于前一个的位置            for (int i &#x3D; nowNum - 1; i &gt; 0; i--)            &#123;                bodys[i].pos &#x3D; bodys[i - 1].pos;            &#125;            &#x2F;&#x2F;再动            switch (dir)            &#123;                case E_MoveDir.Up:                    --bodys[0].pos.y;                    break;                case E_MoveDir.Down:                    ++bodys[0].pos.y;                    break;                case E_MoveDir.Left:                    bodys[0].pos.x -&#x3D; 2;                    break;                case E_MoveDir.Right:                    bodys[0].pos.x +&#x3D; 2;                    break;            &#125;        &#125;        &#x2F;&#x2F;蛇改变移动方向        public void ChangeDir(E_MoveDir dir)        &#123;            &#x2F;&#x2F;只有头时，可以随意移动；有身体时，不能向相反方向移动            &#x2F;&#x2F;判断何时不能转向            if (dir &#x3D;&#x3D; this.dir ||                nowNum &gt; 1 &amp;&amp;                (this.dir &#x3D;&#x3D; E_MoveDir.Up &amp;&amp; dir &#x3D;&#x3D; E_MoveDir.Down ||                this.dir &#x3D;&#x3D; E_MoveDir.Left &amp;&amp; dir &#x3D;&#x3D; E_MoveDir.Right ||                this.dir &#x3D;&#x3D; E_MoveDir.Down &amp;&amp; dir &#x3D;&#x3D; E_MoveDir.Up ||                this.dir &#x3D;&#x3D; E_MoveDir.Right &amp;&amp; dir &#x3D;&#x3D; E_MoveDir.Left)            )            &#123;                return;            &#125;            this.dir &#x3D; dir;        &#125;        &#x2F;&#x2F;蛇吃食物        public void CheckEatFood(Food food)        &#123;            if (bodys[0].pos &#x3D;&#x3D; food.pos)            &#123;                &#x2F;&#x2F;吃到了 就应该让食物 位置再随机 增加蛇身体的长度                food.RandomPos(this);                &#x2F;&#x2F;长身体                AddBody();            &#125;        &#125;        &#x2F;&#x2F;蛇增加长度(与删除类似)        private void AddBody()        &#123;            SnakeBody frontBody &#x3D; bodys[nowNum - 1];            &#x2F;&#x2F;先长             bodys[nowNum] &#x3D; new SnakeBody(E_SnakeBody_Type.Body, frontBody.pos.x, frontBody.pos.y);            &#x2F;&#x2F;再加长度            nowNum++;        &#125;        &#x2F;&#x2F;定义一个判断是否重合的方法用于食物        public bool CheckSamePos(Position p)        &#123;            for (int i &#x3D; 0; i &lt; nowNum; i++)            &#123;                if (bodys[i].pos &#x3D;&#x3D; p)                &#123;                    return true;                &#125;            &#125;            return false;        &#125;        &#x2F;&#x2F;蛇死亡（蛇头碰到墙壁或者身体）        public bool CheckEnd(MapObject map)        &#123;            &#x2F;&#x2F;是否和墙体位置重合            for (int i &#x3D; 0; i &lt; map.walls.Length; i++)            &#123;                if (bodys[0].pos &#x3D;&#x3D; map.walls[i].pos)                &#123;                    return true;                &#125;            &#125;            &#x2F;&#x2F;是否碰到身体            for (int i &#x3D; 1; i &lt; nowNum; i++)            &#123;                if (bodys[0].pos &#x3D;&#x3D; bodys[i].pos)                &#123;                    return true;                &#125;            &#125;            return false;        &#125;    &#125;&#125;</code></pre></div><h2 id="Program"><a href="#Program" class="headerlink" title="Program"></a>Program</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using 贪吃蛇.Scene;namespace 贪吃蛇&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            Game game &#x3D; new Game();            game.Start();        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月24日</title>
    <link href="/2022/05/24/diary/2022.5/2022%E5%B9%B45%E6%9C%8824%E6%97%A5/"/>
    <url>/2022/05/24/diary/2022.5/2022%E5%B9%B45%E6%9C%8824%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="e025f354054dbf333c6c0e34d1ee3890a2cb2413017d2d7f935e1e598332fbba">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50fdd0ca3edc57389bd0e88084b7db20233010ae8a9f793a5fe132f7bcb6ccd39c344c655e0b5e7c424921b90eaa4ed9b05a1b02186b2a24baf684db4aff7c42132fc7a33d8f8a40db72a2c74a06e881fd7dd850006f54959146afd38c673ccc662c808ebd8fb1df6e33e386d017d4d5cb43ba0e72d34c511aa3d14632da3d611b92b72505c71e90f551aff6f154e64c3d8e2677147a6d306e4110043dfd9ecc3b726102a2762e2c7a4b198d46bef3dbe42139b0d06fa841494a5e449aa992a516c3385ba8c8764faba82213fe718901c5c90516328d779d287a494b52b8ffa5599d717c02179f201eb400323b7b126ba5e9197fde3e30f30929e275acbc025c258be40585e29444283a2ab5b8a459380e2644beca9e7e6cdc89935898b40309479e1968036347b0554be89d3717882cdc4c9aa072b6aea27ddb846c2827bfafdbb65f35ac5d0fc3f3b1eaa339f9a8e9266723dce6d933b1839dc2b35fc643e436dbb84402adab4d784e1dc8ba47d5829942e2ff0d4335c766248a7f4371677be042c0ea44ea84b1fe726c37ef043b7328273dfe69b94902acdf92f59412c450db072d765a336da4dc16e27e9e519446c61588c0ae1fd1cedd5135d40ae3ea596cb45f5d43eca1aa6b7b92ee68ae5cdc9e3c71e106b25c15f7ff71e8f3b636a19a87f48f17c6c71507bb9abb4214e4516b0e8776298f1436f1b65b234a31f8758dfba0bb9f27c574f8eb268538eb1a706b06932332a27a64f86aded4377272a1a68cca0f218210389916aaa70a81d6bbf3354bd7ce1eed4c686f9695a14c39652871b777f6ac8e63b752f81585215f31269729cf3b4069d3ba35a036183becc78e8aeff27f62b154c370e6777fe21c918e7e79361ccda3655d5c5b4b49c60dcc211ade1ce3f7813e95acdee4269f6f978afeecaa6d58410f872bc03229c1373cd83478477603990949506acdbbe2273afa85bf3eeb7d3225390e372096b5017c0016c6b1711efb1a83c88b5d65544494ebe4ebf97b1549635c367c8b5b607bb7f1fd04fdf28f3fa74b5d1d1a022bbb7286a01105d542396461149ffeabffef03f9195d0a842459c43588a8a6abd5929826cc6536093b66592dcb13f1810c05e8101f1a0733da939cb1f7bd850fff84fb25c2443f642f09cfe04ff6f46700cab2723b970b31de4618194d28c4169b8b45af2796942067289a47686ad871ad0dbb8d2ea6704409971336287f1073bdab37366a4f29fb3ed81e2e3986da4098df77f3b8d32dd015f3782271214de0314df39887bbd21761e2fb14841741c5210c36ffd793b0b2946c309e79db45ac70827618b8c3b1e5be81bea4fd63a2f042d0577d3294d6a89ac17e2292c73901ecab5b883ffc7656540b870a6572cc26e3f429335cb4c1637ca13c3f847e837e7776d466eb6dc635a66ed0e1901050204715df37</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>抽象类和接口的区别</title>
    <link href="/2022/05/23/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/05/23/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>抽象类和接口的区别</p><span id="more"></span><h1 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h1><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><p>1.都可以被继承<br>2.都可以被实例化<br>3.都可以包含方法声明<br>4.子类必须是实现未实现的方法<br>5.都遵循里式替换原则</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>1.抽象类中可以有构造函数；接口不能<br>2.抽象类只能备单一继承；接口类可以被继承多个<br>3.抽象类中可以有成员变量；接口中不能<br>4.抽象类中可以声明成员方法，虚方法，抽象方法，静态方法；接口中只能声明没有实现的抽象方法<br>5.抽象类方法可以使用访问修饰符；接口中建议不写，默认public</p><h2 id="如何选择抽象类和接口"><a href="#如何选择抽象类和接口" class="headerlink" title="如何选择抽象类和接口"></a>如何选择抽象类和接口</h2><p>表示对象的用抽象类（动物等），表示行为拓展的用接口（飞翔等）<br>不同对象拥有的共同行为，我们往往可以使用接口来实现</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月23日</title>
    <link href="/2022/05/23/diary/2022.5/2022%E5%B9%B45%E6%9C%8823%E6%97%A5/"/>
    <url>/2022/05/23/diary/2022.5/2022%E5%B9%B45%E6%9C%8823%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="638f7a94ae9f94bd977cbdbc5d29c560c560ead633262ea8e276a739e991176a">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50c8bc290f7583a7ed781da721f0adc73ccebdd6e51127fd5055d63ed9483b654136048faba7cf5273ddbf55c1c792351d3a5445e28648adfc311760c649dfa9d6cf4ec3ced3274cd0a77f0c6d97ae266d8eb322573d38c79dcd925eb1023941a3597f2757d301258715bd3581dadfb5f7f0e63bc4bbeadcffb6daaae98457a8053699b8393abaec0f9fb4695f30a2f904869c5bc0803f61cbed0d1b7596578defb2054ca325fc36cba335ca364ae68ba135d7146e7b46f6839726c3bb46e77ed0f5af1de6007d85396215f6a5c86694de52936e28a470900976f79ec0483ed885b44068612035cdad1a005122e1246a8f8664f6ec50ee51bde518d1ba5d6a6d6b952807d224a0a5bd57d7b26284be865d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构体和类的区别</title>
    <link href="/2022/05/23/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94/%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/05/23/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94/%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>结构体和类的区别</p><span id="more"></span><h1 id="结构体和类的区别"><a href="#结构体和类的区别" class="headerlink" title="结构体和类的区别"></a>结构体和类的区别</h1><h2 id="区别概述"><a href="#区别概述" class="headerlink" title="区别概述"></a>区别概述</h2><p>结构体和类最大的区别是在存储空间上的，因为结构体是值，类是引用，<br>因此他们的存储位置一个在栈上，一个在堆上，</p><p>结构体和类在使用上很类似，结构体甚至可以用面向对象的思想来形容一类对象。<br>结构体具备着面向对象思想中封装的特性，但是他不具备继承和多态的特性，因此大大减少了它的使用频率。<br>由于结构体不具备继承的特性，所以它不能够使用protected保护访问修饰符。</p><h2 id="细节区别"><a href="#细节区别" class="headerlink" title="细节区别"></a>细节区别</h2><p>1.结构体是值类型，类是引用类型<br>2.结构体存在栈中，类存在栈中<br>3.结构体成员不能使用protected访问修饰符，而类可以<br>4.结构体成员变量声明不能指定初始值，而类可以<br>5.结构体不能声明无参的构造函数，而类可以<br>6.结构体声明有参构造函数后，无参构造函数不会被顶掉<br>7.结构体不能声明构析函数，而类可以<br>8.结构体不能被继承，而类可以<br>9.结构体需要在构造函数中初始化所有成员变量，而类随意<br>10.结构体不能被静态static修饰（不存在静态结构体），而类可以<br>11.结构体不能在内部声明和自己一样的结构体变量，而类可以</p><h2 id="结构体的特别之处"><a href="#结构体的特别之处" class="headerlink" title="结构体的特别之处"></a>结构体的特别之处</h2><p>结构体可以继承接口<br>因为接口是行为的抽象</p><h2 id="如何选择结构体和类"><a href="#如何选择结构体和类" class="headerlink" title="如何选择结构体和类"></a>如何选择结构体和类</h2><p>1.想要用继承和多态时，直接淘汰结构体，比如玩家、怪物等等<br>2.对象是数据集合时，优先考虑结构体，比如位置、坐标等等<br>3.从值类型和引用类型赋值时的区别上去考虑，比如经常被赋值传递的对象，并且改变赋值对象，原对象不想跟着变化时，就用结构体，比如坐标、向量、旋转等等</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stringBuilder</title>
    <link href="/2022/05/23/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94/stringBulider/"/>
    <url>/2022/05/23/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94/stringBulider/</url>
    
    <content type="html"><![CDATA[<p>stringBuilder</p><span id="more"></span><h1 id="stringBuilder"><a href="#stringBuilder" class="headerlink" title="stringBuilder"></a>stringBuilder</h1><p>C#提供的一个用于处理字符串的公共类<br>主要解决的问题：<br>修改字符串而不创建新的对象，需要频繁修改和拼接字符串可以使用它，可以提升性能<br>使用前 需要引用命名空间 using System.Text;</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>直接指明内容</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">StringBuilder str &#x3D; new StringBuilder(&quot;内容&quot;);StringBuilder str &#x3D; new StringBuilder(&quot;内容&quot;, 容量大小);</code></pre></div><h2 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h2><p>StringBuilder存在一个容量的问题，每次往里面增加时，会自动扩容</p><p>获得容量</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">StringBuilder str &#x3D; new StringBuilder(&quot;内容&quot;);str.Capacity;</code></pre></div><h2 id="增删查改替换"><a href="#增删查改替换" class="headerlink" title="增删查改替换"></a>增删查改替换</h2><p>增</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">str.Append(&quot;要增加的内容&quot;);str.AppendFormat(&quot;&#123;0&#125;&#123;1&#125;&quot;, 内容1, 内容2);</code></pre></div><p>插入</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">str.Insert(插入的位置, &quot;内容&quot;); &#x2F;&#x2F;插在前面</code></pre></div><p>删</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">str.Remove(开始删的位置, 删的数量);</code></pre></div><p>查</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">str.clear();</code></pre></div><p>查</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Console.WriteLine(str[1]);</code></pre></div><p>改</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">str[0] &#x3D; &#39;A&#39;; &#x2F;&#x2F;string不能这样改 StringBuilder可以这样改</code></pre></div><p>替换</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">str.Replace(&quot;你想改的字符&quot;, &quot;你想改成的字符&quot;);</code></pre></div><p>重新赋值 StringBuilder</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">str.clear(); &#x2F;&#x2F;先清空&#x2F;&#x2F;再赋值</code></pre></div><p>判断字符串是否相等</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">if( str.Equals(&quot;想要判断是否相等的字符串&quot;) )</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/23/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94/stringBulider/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><p>1.string相对于stringbuilder更容易产生垃圾 每次修改拼接都会产生垃圾<br>2.string相对stringbuilder更加灵活 因为它提供了更多的方法供使用<br>如何选择：<br>需要频繁修改拼接的字符串可以用stringbuilder<br>需要使用string独特的一些方法来处理一些特殊逻辑时可以使用string</p><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><p>内存优化实际上是两个问题：<br>1.如何节约内存<br>2.如何尽量少的GC</p><p>解决方法：<br>1.少new对象，少产生垃圾<br>2.合理使用static<br>3.合理使用string和stringbuilder</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>string</title>
    <link href="/2022/05/22/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94/string/"/>
    <url>/2022/05/22/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94/string/</url>
    
    <content type="html"><![CDATA[<p>string</p><span id="more"></span><h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><h2 id="字符串指定位置获取"><a href="#字符串指定位置获取" class="headerlink" title="字符串指定位置获取"></a>字符串指定位置获取</h2><p>字符串本质是char数组</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">string str &#x3D; &quot;唐老狮&quot;;Console.WriteLine(str[0]); &#x2F;&#x2F;打印“唐”</code></pre></div><p>可以转换化为char数组</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">char[] chars &#x3D; str.ToCharArray();Console.WriteLine(chars[1]); &#x2F;&#x2F;打印“老”</code></pre></div><h2 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h2><p>Format(); 后接变长参数</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">string str &#x3D; string.Format(&quot;&#123;0&#125;&#123;1&#125;&quot;, 1, 3333);Console.WriteLine(str); &#x2F;&#x2F;打印13333</code></pre></div><h2 id="正向查找字符位置"><a href="#正向查找字符位置" class="headerlink" title="正向查找字符位置"></a>正向查找字符位置</h2><p>IndexOf(); 返回字符位置</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">string str &#x3D; &quot;我是唐老狮！&quot;;int index &#x3D; str.IndexOf(&quot;唐&quot;);Console.WriteLine(index); &#x2F;&#x2F;打印1</code></pre></div><p> 若没找到则返回-1</p><h2 id="反向查找指定字符串位置"><a href="#反向查找指定字符串位置" class="headerlink" title="反向查找指定字符串位置"></a>反向查找指定字符串位置</h2><p>LastIndexOf(); 反向查找并返回字符串位置(字符串第一个字符的位置)</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">string str &#x3D; &quot;我是唐老狮唐老狮&quot;;int index &#x3D; str.IndexOf(&quot;唐老狮&quot;);Console.WriteLine(index); &#x2F;&#x2F;打印5</code></pre></div><p> 若没找到则返回-1</p><h2 id="移除指定位置后的字符"><a href="#移除指定位置后的字符" class="headerlink" title="移除指定位置后的字符"></a>移除指定位置后的字符</h2><p>Remove();  </p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">string str &#x3D; &quot;我是唐老狮唐老狮&quot;;str.Remove(4);  &#x2F;&#x2F;移除4及之后的字符，不会改变原字符串Console.WriteLine(str); &#x2F;&#x2F;打印不变str &#x3D; str.Remove(4);Console.WriteLine(str); &#x2F;&#x2F;打印0-3 “我是唐老”&#x2F;&#x2F;重载 Remove(参数1, 参数2);&#x2F;&#x2F;参数1，开始位置；参数2，字符个数str &#x3D; str.Remove(1, 1);Console.WriteLine(str); &#x2F;&#x2F;打印 “我唐老”</code></pre></div><h2 id="替换指定字符串"><a href="#替换指定字符串" class="headerlink" title="替换指定字符串"></a>替换指定字符串</h2><p>Replace();</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">string str &#x3D; &quot;我是唐老狮唐老狮&quot;;&#x2F;&#x2F;参数一：原字符串；参数2：新字符串str &#x3D; str.Replace(&quot;唐老狮&quot;, &quot;老炮儿&quot;);Console.WriteLine(str); &#x2F;&#x2F;打印“我是老炮儿老炮儿”</code></pre></div><h2 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h2><p>ToUpper();<br>ToLower();</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">string str &#x3D; &quot;asdfasd&quot;;str &#x3D; str.ToUpper(str);Console.WriteLine(str); &#x2F;&#x2F;打印ASDFASD&#x2F;&#x2F;ToLower同理</code></pre></div><h2 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h2><p>Substring();</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">string str &#x3D; &quot;唐老狮唐老狮&quot;;&#x2F;&#x2F;截取从指定位置开始之后的字符str &#x3D; str.Substring(2);Console.WriteLine(str); &#x2F;&#x2F;打印“狮唐老狮”&#x2F;&#x2F;截取从指定位置开始数量为（参数2）的字符 不能超过总长度str &#x3D; str.Substring(2, 2);Console.WriteLine(str); &#x2F;&#x2F;打印“老狮”</code></pre></div><h2 id="字符串切割"><a href="#字符串切割" class="headerlink" title="字符串切割"></a>字符串切割</h2><p>Split();</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">string str &#x3D; &quot;1,2,3,5,6,7,8&quot;;&#x2F;&#x2F;截取从指定位置开始之后的字符string[] strs &#x3D; str.Split(&#39;,&#39;);for ( i &#x3D; 0; i &lt; strs.Length; i++)&#123;    Console.WriteLine(str[i]); &#x2F;&#x2F;打印1\n2\n...&#125;&#x2F;&#x2F;截取从指定位置开始数量为（参数2）的字符 不能超过总长度str &#x3D; str.Substring(2, 2);Console.WriteLine(str); &#x2F;&#x2F;打印“老狮”</code></pre></div><p> 用于商业游戏配置表</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/22/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94/string/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><p>截取：Substring(参数1);    Substring(参数1, 参数2);<br>替换：Replace(参数1);   Replace(参数1, 参数2);</p><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson23_面向对象相关string&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            string str &#x3D; &quot;1|2|3|4|5|6|7&quot;;            string[] strs &#x3D; str.Split(&#39;|&#39;);            str &#x3D; &quot;&quot;;            for (int i &#x3D; 0; i &lt; strs.Length; i++)            &#123;                str +&#x3D; int.Parse(strs[i]) + 1;                if(i !&#x3D; strs.Length - 1)                &#123;                    str +&#x3D; &quot;|&quot;;                &#125;            &#125;            Console.WriteLine(str);        &#125;    &#125;&#125;</code></pre></div><h2 id="题3"><a href="#题3" class="headerlink" title="题3"></a>题3</h2><p>实际上没有区别<br>后者是前者的别名，是程序的关键字<br>String,Int32,Int64,Int16是大的结构体名</p><h2 id="题4"><a href="#题4" class="headerlink" title="题4"></a>题4</h2><p>str &#x3D; null    str2 &#x3D; str<br>这两句没有分配新的堆空间<br>故分配了3个新的堆空间</p><h2 id="题5"><a href="#题5" class="headerlink" title="题5"></a>题5</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson23_面向对象相关string&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;请输入字符串：&quot;);            string str &#x3D; Console.ReadLine();            Console.WriteLine(&quot;反转后的字符串为&quot;);            Reverse(ref str);            Console.WriteLine(str);        &#125;        static void Reverse(ref string str)        &#123;            char[] chars &#x3D; str.ToCharArray();            for (int i &#x3D; 0; i &lt; chars.Length &#x2F; 2; i++)            &#123;                chars[i] &#x3D; (char)(chars[i] + chars[chars.Length - 1 - i]);                chars[chars.Length - 1 - i] &#x3D; (char)(chars[i] - chars[chars.Length - 1 - i]);                chars[i] &#x3D; (char)(chars[i] - chars[chars.Length - 1 - i]);            &#125;            str &#x3D; new string(chars);        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月22日</title>
    <link href="/2022/05/22/diary/2022.5/2022%E5%B9%B45%E6%9C%8822%E6%97%A5/"/>
    <url>/2022/05/22/diary/2022.5/2022%E5%B9%B45%E6%9C%8822%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="4bf608d527a714cdcb55e31925104e25accff7c324af28273fa302865fc865c4">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe505a9ab9e5fb3a8e410d273b8e352ade6990d1ff7f62c3ddfbd1c033abc6958b9bfd385d52cdf1f16001b7f535a7e7d181d1cd83d3db5f03181aa9c4716ca261f7bf645e5c5030f5939dcaac3178fec1960a039b96f77f0cf0f996554b407a6e954aca401f1c91349e68487bc6311a347a3b821abaa1568d869c69f007421db9749127761b0a24e67f89d1846a2484c091991dce8db5a15afe57141906d9a189f80d052b6dc75d441f4df553eafc7f4a143d249eafda1f243dee68f523cd4f8b60fa3ada6f66970216886c108246d43e3fcad05eda685b271b49e3f35bc0074c59b30ea8aa35328c5d319125444d43c19f87f4f9696b8821dfafb6be6be9c1128c2a237aea22532d6fbf42aaae3308b2e637508ceb4e4bec1630e79b457492732643ce4bf5621801a0093f5486ae185c7a576c695a850d00eec4d322c58e50dfd4991ff1590d509271c8013076dc225de45a0c09d573551cb1846bb4181c31c6942a2c437dad7787f26d1df6195ec8e72bf0fa2c389085a74e09fc0f58cb5d376d2820c171ad5d07e6a43fb822e391f5a56830c1778f51f7d9436f40e7683c885bce548704c3cea02b9f9f2a3ab169e99b92070a2a5a0103b5498b301af52b16cd8772766494802ac57495fc024b4be6a0</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>万物之父中的方法</title>
    <link href="/2022/05/22/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94/%E4%B8%87%E7%89%A9%E4%B9%8B%E7%88%B6%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/2022/05/22/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94/%E4%B8%87%E7%89%A9%E4%B9%8B%E7%88%B6%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>万物之父中的方法</p><span id="more"></span><h1 id="万物之父中的方法"><a href="#万物之父中的方法" class="headerlink" title="万物之父中的方法"></a>万物之父中的方法</h1><img src="/2022/05/22/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94/%E4%B8%87%E7%89%A9%E4%B9%8B%E7%88%B6%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/object.png" class=""><h2 id="object中的静态方法"><a href="#object中的静态方法" class="headerlink" title="object中的静态方法"></a>object中的静态方法</h2><p>静态方法 <strong>Equals</strong> 判断两个对象是否相等<br>最终的判断权交给左侧对象的Equals方法<br>值类型 和 引用类型 都会按照左侧对象Equals方法的规则来进行比较<br>值类型比较值<br>引用类型比较指向的地址</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Console.WriteLine(Object.Equals(1, 1)); &#x2F;&#x2F;打印trueTest t1 &#x3D; new Test();Test t2 &#x3D; new Test();Console.WriteLine(Object.Equals(t1, t2)); &#x2F;&#x2F;打印falseTest t3 &#x3D; t1;Console.WriteLine(Object.Equals(t1, t3)); &#x2F;&#x2F;打印true</code></pre></div><p>静态方法 <strong>ReferenceEquals</strong><br>比较两个对象是否是相同的引用，主要是用来比较引用类型的对象<br>值类型对象返回值始终是false</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Console.WriteLine(Object.ReferenceEquals(t1, t2)); &#x2F;&#x2F;打印false</code></pre></div><p>注意：object可不写</p><h2 id="object中的成员方法"><a href="#object中的成员方法" class="headerlink" title="object中的成员方法"></a>object中的成员方法</h2><p>普通方法 GetType<br>该方法在反射相关知识点中是非常重要的方法<br>主要作用是获取对象运行时的类型Type,结合反射相关知识点可以做很多关于对象的操作</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Test t &#x3D; new Test();Type type &#x3D; t.GetType();</code></pre></div><p>普通方法 MemberwiseClone<br>该方法用于获取对象的浅拷贝对象，口语化的意思就是会返回一个新的对象<br>但是新对象中的引用变量会和老对象中一致</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Test&#123;    public int i &#x3D; 1;    public Test2 test2 &#x3D; new Test2();    public Test Clone()    &#123;        return MemberwiseClone() as Test;    &#125;&#125;class Test2&#123;    public int i &#x3D; 2;&#125;internal class Program&#123;    static void Main(string[] args)    &#123;        Test t &#x3D; new Test();        Test t2 &#x3D; t.Clone();        Console.WriteLine(&quot;对象克隆后&quot;);        Console.WriteLine(&quot;t.i &#x3D; &quot; + t.i); &#x2F;&#x2F;1        Console.WriteLine(&quot;t.test2.i &#x3D; &quot; + t.test2.i); &#x2F;&#x2F;2        Console.WriteLine(&quot;t2.i &#x3D; &quot; + t2.i); &#x2F;&#x2F;1        Console.WriteLine(&quot;t2.test2.i &#x3D; &quot; + t2.test2.i); &#x2F;&#x2F;2        t2.i &#x3D; 20;        t2.test2.i &#x3D; 21;        Console.WriteLine(&quot;改变克隆体信息后&quot;);        Console.WriteLine(&quot;t.i &#x3D; &quot; + t.i); &#x2F;&#x2F;1        Console.WriteLine(&quot;t.test2.i &#x3D; &quot; + t.test2.i); &#x2F;&#x2F;21        Console.WriteLine(&quot;t2.i &#x3D; &quot; + t2.i); &#x2F;&#x2F;20        Console.WriteLine(&quot;t2.test2.i &#x3D; &quot; + t2.test2.i); &#x2F;&#x2F;21        &#x2F;&#x2F;值类型拷贝值，引用类型拷贝地址    &#125;&#125;</code></pre></div><h2 id="object中的虚方法"><a href="#object中的虚方法" class="headerlink" title="object中的虚方法"></a>object中的虚方法</h2><p>虚方法 <strong>Equals</strong><br>默认是西安还是比较两者是否为同一个引用，即相当于ReferenceEquals<br>但是微软在所有值类型的基类System.ValueType中重写了该方法，用来比较值相等<br>可以重写，定义自己的比较相等的规则</p><p>虚方法 <strong>GetHashCode</strong><br>该方法是获取对象的哈希码<br>（一种通过算法算出的，表示对象的唯一编码，不同对象哈希码有可能一样，具体值根据哈希算法决定）<br>可以重写，但极少</p><p>虚方法 <strong>ToString</strong><br>该方法用于返回当前对象代表的字符串，可以重写<br>调用打印方法时，默认使用的就是对象的ToString方法后打印出来的内容</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/22/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94/%E4%B8%87%E7%89%A9%E4%B9%8B%E7%88%B6%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson22_万物之父中的方法&#123;    class Player    &#123;        public string name &#x3D; &quot;大逼&quot;;        public int Hp &#x3D; 100;        public int Atk &#x3D; 1000;        public int Def &#x3D; 10000;        public int EvasionRate &#x3D; 5;        public void Property()        &#123;            Console.WriteLine(&quot;玩家&#123;0&#125;,血量&#123;1&#125;,攻击力&#123;2&#125;,防御力&#123;3&#125;,闪避率&#123;4&#125;%&quot;, name, Hp, Atk, Def, EvasionRate);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Player player &#x3D; new Player();            player.Property();        &#125;    &#125;&#125;</code></pre></div><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson22_万物之父中的方法&#123;    class Monster    &#123;        public string name &#x3D; &quot;大逼&quot;;        public int Hp &#x3D; 100;        public int Atk &#x3D; 1000;        public int Def &#x3D; 10000;        public int EvasionRate &#x3D; 5;        public void Property()        &#123;            Console.WriteLine(&quot;玩家&#123;0&#125;,血量&#123;1&#125;,攻击力&#123;2&#125;,防御力&#123;3&#125;,闪避率&#123;4&#125;%&quot;, name, Hp, Atk, Def, EvasionRate);        &#125;        public Monster Clone()        &#123;            return MemberwiseClone() as Monster;        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Monster mA &#x3D; new Monster();            Monster mB &#x3D; mA.Clone();            mB.Atk &#x3D; 500;            mB.Def &#x3D; 5000;            mB.Hp &#x3D; 50;            mA.Property();            mB.Property();        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>命名空间</title>
    <link href="/2022/05/21/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
    <url>/2022/05/21/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p>命名空间</p><span id="more"></span><h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>命名空间是用来组织和重用代码的<br>作用：<br>就像是一个工具包，类就像是一件一件的工具，都是声明在命名空间中的</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">namespace 命名空间名&#123;    class 类名    &#123;    &#125;    class 类名    &#123;    &#125;&#125;</code></pre></div><p>1.可以写成分部形式（同名写多个）以继承<br>2.但在同一命名空间中不能有同名类</p><h2 id="不同命名空间中相互使用，需要引用命名空间或指明出处"><a href="#不同命名空间中相互使用，需要引用命名空间或指明出处" class="headerlink" title="不同命名空间中相互使用，需要引用命名空间或指明出处"></a>不同命名空间中相互使用，需要引用命名空间或指明出处</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;引用命名空间using 命名空间名&#x2F;&#x2F;可以使用该命名空间里的类&#x2F;&#x2F;指明出处命名空间名.类名 &#x3D; new 命名空间名.类名();</code></pre></div><h2 id="不同命名空间中允许有同名类"><a href="#不同命名空间中允许有同名类" class="headerlink" title="不同命名空间中允许有同名类"></a>不同命名空间中允许有同名类</h2><p>在调用同名类时不仅需要引用命名空间，还需要指明出处以实例化</p><h2 id="命名空间可以包裹命名空间"><a href="#命名空间可以包裹命名空间" class="headerlink" title="命名空间可以包裹命名空间"></a>命名空间可以包裹命名空间</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">namespace MyGame&#123;    namespace UI    &#123;        class Image        &#123;        &#125;    &#125;    namespace Game    &#123;        class Image        &#123;                    &#125;    &#125;&#125;&#x2F;&#x2F;调用using MyGame.UI;MyGame.UI.Image img &#x3D; new MyGame.UI.Image();</code></pre></div><h2 id="关于修饰类的访问修饰符"><a href="#关于修饰类的访问修饰符" class="headerlink" title="关于修饰类的访问修饰符"></a>关于修饰类的访问修饰符</h2><p>public - 命名空间中的类 默认为public<br>internal - 只能在该程序集（工程）中使用<br>abstract - 抽象类<br>sealed - 密封类<br>partial - 分部类</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/21/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><p>using可以调用该命名空间中的类，以及类中的方法</p><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using UI;using Graph;namespace UI&#123;    class Image    &#123;            &#125;&#125;namespace Graph&#123;    class Image    &#123;    &#125;&#125;namespace Lesson21_命名空间&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            UI.Image image &#x3D; new UI.Image();            Graph.Image image1 &#x3D; new Graph.Image();        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>密封函数</title>
    <link href="/2022/05/21/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%A4%9A%E6%80%81/%E5%AF%86%E5%B0%81%E5%87%BD%E6%95%B0/"/>
    <url>/2022/05/21/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%A4%9A%E6%80%81/%E5%AF%86%E5%B0%81%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>密封函数</p><span id="more"></span><h1 id="密封函数"><a href="#密封函数" class="headerlink" title="密封函数"></a>密封函数</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>用密封关键字sealed修饰的重写函数<br>作用：让虚方法或者抽象方法之后不能再被重写<br>特点：和override一起出现，不能写在abstract和virtual前</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月21日</title>
    <link href="/2022/05/21/diary/2022.5/2022%E5%B9%B45%E6%9C%8821%E6%97%A5/"/>
    <url>/2022/05/21/diary/2022.5/2022%E5%B9%B45%E6%9C%8821%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="25294449ad5488957ea695c17d0a15bdcae6240f381af4f590fa2131155ecccd">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50016237ab31399f3751c3548491ff8ed0c7517623ada711016ab0ae6da5280084fac8481a0de647ac2a1aac4d29092ab5c8a931972e1bbbd81a8f6e12576ef2be5c58eb692ba2fa896bc13446fb79173797e6addac0ceb52997a9145cf705168b3ebf7ad7b966557db6d276313b29f4882f2c466d2fdf819aa8578ab8226e1828be6ef6735bbf5310168b73763c451a5a0430473271182256454830cba5d299eb6c421d4ecc76d64b584a9f34d0f35eee8f22f2f1d1bd73eb38e39a46f3b892b1d9a27d08cb3090f42085ef2b815d7093e52b696c5c16bb4e23dee4dab55fc9b1335d6929ceaed121f8804226572b01caf71f87b46f2eb7469bba734972a300e9806c77d4bc8b28433568e4e81dd7aaf0540c0afdcf2042671d330db204845a599ba583186539e10380ba6db2ec9726a97bdb7797db4e62a68816cafa759f42520f2a12af1e13acded044b19e1359e17595071343cec63c29c94a263661d6722ec793955c049ac4ff430325d916d452d257830d702c26a9fc80b8b66ee1aee4a4feab3de1e4f0ae939d2552a471e7def37e7f64203384a08e3fb80b13a254876021666a071578565068c29491c6e03b0d38a513ee119226ee71604c9ad087a32fb2f5af1bb3b48fa6d4fb87d37edabdd522f51a327c26b383dc249344728c7e9ee92ee95e081b679b93aa5146d9abfb07a8c5f0ad5b7c3219bb605f2c5b5644a785077efacf1e8cf727e206ae3dec8c893846781fd8150304f7af96fb2b03d8e9b42b8e558279ff8c484e5c72d05c1919dc2e94a01e96e6bcdf70c79b176ac1a6b32e20ac2c7da6ad89b0961939cdef6b3dcfb6b575549908a970c7906711fe7c431ec0fb4770ad7d3767f7131446693310274e6f89da7d380b621bb848b5bf2f17cc38f944393dde3ee81f6095953688f59dff53b6c156bd0ea5e36d1ad292804a37434614357e382b47444190e6f791092aed5d0f393f94e87c12548256f6d22f98ed5e16c9839cefcba4cc249e08e98feb0844f8df4c8f40eda5688f141c008f9596eb9d835186c4e8d1af2c7474a70b1fed2e649b460812bb960ccb91738920d67a87dd045e22d8d48163f551d1b18b3e33ca837ca2c2e060a9568071088b938977d094c1bf77c64f90aa7f81a7276183f6886bcdbd702fae7e0e5ca926ade21ca03632cdfa3ac46718c6e8b5c0cfc3a1c05839e686c9c292ba399e458b1028ae6232dde4450c0b91a3a8a29f1e9112458500767a98eb065b2b96fad368f8783b9c196fb6a6ba1d96329cc04ae9fd6fb56a78ff11f226e25260fc959211df02e75820963478fee3fb842d1dd8c64e9d5ee858543419b4ee2d9e6412274b4cb530dbc02454baf4faf8e6b6e4378f7217f2f4dfda463178e168a2f752373313e8aaeec9fea07e3e57a28105a0e14060e6e62f11208a90fd5e0f8d896f950fe1a1c932a81b9f3f1ab2dee07ce0d3a6f9b197a0210db27ba3487a83624240fbc623a6610c1353049cf98f657a21afe78fe1edca0b850643e7349aa71524394cc55684a6069c691b1ef1083d4103b3e6ced984ef3fbb3305037349862d24f9f86336d29d16ffb4aad2f4667f4710b61365e6effc99e014044995fa4d31f0cd5c5ca24201db45bd1d8a764e6adc59693bc865deded1877fb0e0d814af586beac151bde53d72f13e5a2741b4d3bf6df948c23dd26d5eab68d324bc834ca3c59d32b93d71c53453756fa6ef166ca1d3218d4876a12d62ca433695ac0cd83cd4ac7073df4685143450d4a21b4c47b3881a0b9a74d125f6a540950aa98bcd32c753f7570a6adf728b9e4412aa7dcb8df59a6a764e61b0df145b1b469eb2ed612c4a546c249f3a14dec68d456d28fc8a085cd2133529d9d5107406fbb93badf656a357ac7e1913ea88850b50f66d68f07c6048bb6f42b0c2591ebbcb2ee5887e21ee48b73ff4597781ab4200ebbd84d6b18aa9c1eff6f889b4fcc5c6563d5d9f2eeae46aec89e95a7c9ed1067716d2f4d88875ee55a2f691cb7128d94f141b7a3ddcff50362dd7c22bad4f10dde9a925d0ae6b4fcf0a71ef5ddad81d9be2c1ba6a62bef673d8664ac7c85717775f50f7ae8f5a7e58ca6e824ce0ae55e56a3ee039c303d07c8b6caa5cd71b30b6a61fbcef6b123f6130bc73fe41e16f7d5e2e7310791af690047446a72e72648c11baabdb1868aa54801379f5c0869c2076a870d6234df742c4ac4fc6fa011bdcf93076828d0cdc1187d36d7105b55df6fdb4c07d73bed0ead660ab76c454108190cc3c91259937df90f4834d26b9ef60c1d6849981c1f3e498f7b9ca606b01254f9c47a335f95050266652ff19475c0c346b4a2c03c21d605efdca2c784f7f89d502555d52312cbe2b8178716ef970ba35c49bf5d87d7592958a0457964ad4a3cff1638b5d53b923b6be81531e13c37b9df5165e2c04a1</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月20日</title>
    <link href="/2022/05/19/diary/2022.5/2022%E5%B9%B45%E6%9C%8820%E6%97%A5/"/>
    <url>/2022/05/19/diary/2022.5/2022%E5%B9%B45%E6%9C%8820%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="8fac42808f01149c878ef2f2d7020868436faa65251f25dd5bb26ca1d1e26bba">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50477ff5b269e8ceb0cdcb67073e2e8fa77eb849c556241cfdc6a563d0301ed1d839b944fae7507f15d160de0be980dd1aba9380a4a321b232853b5e08ca31a843573f053791cd1802b784a9e046f70f255a43bca196e25c5f09a0970e507017aee56824e0c2bb418dcb3b5c3e7142b0f32af66cc08ff563c957652db3928e55d98acec026a987db89a5e6e9ea1c98db0f86e0b8b53e55eee67ec2ee0efdb101b2a6d66f6b58c4490983dc7efba61056a9caa977a39fd79c919506d628ad4134882428c79e23591122352382cca2cb9976ac48290e98e71fcbccaeacc401b00f3c3e48b31d522b62549550a3f0548d7a25</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口</title>
    <link href="/2022/05/19/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%A4%9A%E6%80%81/%E6%8E%A5%E5%8F%A3/"/>
    <url>/2022/05/19/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%A4%9A%E6%80%81/%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<p>接口</p><span id="more"></span><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>接口是行为的抽象规范，也是一种自定义类型<br>用于存储不同类的对象之间相同的方法<br>关键字：interface</p><p>声明规范：<br>1.不包含成员变量<br>2.只包含方法、属性、索引器、事件<br>3.成员不能被实现<br>4.成员可以不用写访问修饰符（默认public），不能是private<br>5.接口不能继承类，但是可以继承另一个接口</p><p>使用规范：<br>1.类可以继承多个接口<br>2.类继承接口后，必须实现接口中所有成员</p><h2 id="接口的声明及使用"><a href="#接口的声明及使用" class="headerlink" title="接口的声明及使用"></a>接口的声明及使用</h2><p>一句话记忆：接口是抽象行为的“基类”<br>接口命名规范：帕斯卡命名法前加I</p><p>接口用来继承：<br>1.类可以继承一个类,n个接口<br>2.继承了接口后,必须实现其中的内容,并且必须是public的<br>3.实现的接口函数,可以加virtual再写在子类里重写<br>4.接口也遵循里式替换原则</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;interface 接口名interface IFly&#123;    &#x2F;&#x2F;方法    void Fly();    &#x2F;&#x2F;属性    string Name    &#123;        get; &#x2F;&#x2F;不能有语句块,即默认自动属性        set;    &#125;    &#x2F;&#x2F;索引器    int this[int index]    &#123;        get;        set;    &#125;    &#x2F;&#x2F;事件    event Action doSomething;&#125; class Animal&#123;&#125;&#x2F;&#x2F;1.类可以继承一个类,n个接口class Person : Animal, Ifly&#123;    &#x2F;&#x2F;2.继承了接口后,必须实现其中的内容,并且必须是public的    &#x2F;&#x2F;3.实现的接口函数,可以加virtual再写在子类里重写    public virtual void Fly()    &#123;    &#125;    public string Name    &#123;        get;        set;    &#125;    public int this[int index]    &#123;        get;        set;    &#125;    public event Action doSomething;&#125;internal class Program&#123;    static void Main(string[] args)    &#123;        &#x2F;&#x2F;4.接口也遵循里式替换原则        IFly f &#x3D; new Person();        &#x2F;&#x2F;注意 IFly f &#x3D; new IFly();是错误的,接口是不能实例化的    &#125;&#125;</code></pre></div><h2 id="接口可以继承接口"><a href="#接口可以继承接口" class="headerlink" title="接口可以继承接口"></a>接口可以继承接口</h2><p>接口继承接口时,不需要实现<br>带类继承接口后,类自己要去实现所有内容</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">interface IWalk&#123;    void Walk();&#125;interface IMove : IWalk&#123;&#125;class Test: IMove&#123;    public void Walk();&#125;</code></pre></div><h2 id="显示实现接口"><a href="#显示实现接口" class="headerlink" title="显示实现接口"></a>显示实现接口</h2><p>当一个类继承两个接口,但是接口中存在着同名方法时<br>注意：显示实现接口时,不能写访问修饰符</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">interface IAtk&#123;    void Atk();&#125;interface ISuperAtk&#123;    void Atk();&#125;class Player : IAtk, ISuperAtk&#123;    &#x2F;&#x2F;显示实现接口,就是用接口名.行为名来实现    void IAtk.Atk()    &#123;            &#125;    void ISuperAtk.Atk()    &#123;    &#125;&#125;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/19/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%A4%9A%E6%80%81/%E6%8E%A5%E5%8F%A3/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson19_接口&#123;    interface IRegister    &#123;        void Register();    &#125;    class Person : IRegister    &#123;        public void Register()        &#123;            Console.WriteLine(&quot;个人请到派出所登记&quot;);        &#125;    &#125;    class Car : IRegister    &#123;        public void Register()        &#123;            Console.WriteLine(&quot;车辆请到车管所登记&quot;);        &#125;    &#125;    class House : IRegister    &#123;        public void Register()        &#123;            Console.WriteLine(&quot;房子请到房管局登记&quot;);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            &#x2F;&#x2F;可用数组实例化            IRegister p &#x3D; new Person();            p.Register();            IRegister c &#x3D; new Car();            c.Register();            IRegister h &#x3D; new House();            h.Register();        &#125;    &#125;&#125;</code></pre></div><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson19_接口&#123;    &#x2F;&#x2F;定义三个接口 1.飞 2.游泳    &#x2F;&#x2F;定义一个鸟类(因为鸟类都能走，走就不用接口)    &#x2F;&#x2F;飞    interface IFly    &#123;        void Fly();    &#125;    &#x2F;&#x2F;游泳    interface ISwim    &#123;        void Swim();    &#125;    &#x2F;&#x2F;鸟类，鸟类都能走，用抽象类及抽象方法    abstract class Bird    &#123;        public abstract void Walk();    &#125;    &#x2F;&#x2F;麻雀，能飞，不能游泳    class Sparrow : Bird, IFly    &#123;        public void Fly()        &#123;            Console.WriteLine(&quot;麻雀能飞&quot;);        &#125;        public override void Walk()        &#123;            Console.WriteLine(&quot;麻雀能走&quot;);        &#125;    &#125;    &#x2F;&#x2F;鸵鸟，不能飞，不能游泳    class Ostrich : Bird    &#123;        public override void Walk()        &#123;            Console.WriteLine(&quot;鸵鸟能走&quot;);        &#125;    &#125;    &#x2F;&#x2F;企鹅，不能飞，能游泳    class Penguin : Bird, ISwim    &#123;        public void Swim()        &#123;            Console.WriteLine(&quot;企鹅能游泳&quot;);        &#125;        public override void Walk()        &#123;            Console.WriteLine(&quot;企鹅能走&quot;);        &#125;    &#125;    &#x2F;&#x2F;鹦鹉，能飞，不能游泳    class Parrot : Bird, IFly    &#123;        public void Fly()        &#123;            Console.WriteLine(&quot;鹦鹉能飞&quot;);        &#125;        public override void Walk()        &#123;            Console.WriteLine(&quot;鹦鹉能走&quot;);        &#125;    &#125;    &#x2F;&#x2F;天鹅，能飞，能游泳    class Swan : Bird, IFly, ISwim    &#123;        public void Fly()        &#123;            Console.WriteLine(&quot;天鹅能飞&quot;);        &#125;        public void Swim()        &#123;            Console.WriteLine(&quot;天鹅能游泳&quot;);        &#125;        public override void Walk()        &#123;            Console.WriteLine(&quot;天鹅能走&quot;);        &#125;    &#125;    &#x2F;&#x2F;直升机    class Helicopter : IFly    &#123;        public void Fly()        &#123;            Console.WriteLine(&quot;直升机能飞&quot;);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            &#x2F;&#x2F;请自行实例化            Swan swan &#x3D; new Swan();            swan.Swim();            swan.Walk();            swan.Fly();        &#125;    &#125;&#125;</code></pre></div><h2 id="题3"><a href="#题3" class="headerlink" title="题3"></a>题3</h2><p><strong>本题关键：</strong><br>    public IUSB usb; </p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson19_接口&#123;    &#x2F;&#x2F;定义接口 USB接口    interface IUSB    &#123;        void ReadData();    &#125;    &#x2F;&#x2F;存储设备类,插在USB接口上可以读取设备名    class StorageDevice : IUSB    &#123;        public string name;        public StorageDevice(string name)        &#123;            this.name &#x3D; name;        &#125;        public void ReadData()        &#123;            Console.WriteLine(&quot;&#123;0&#125;正在传输数据&quot;, name);        &#125;    &#125;    &#x2F;&#x2F;MP3属于播放设备    class Mp3 : IUSB    &#123;        public void ReadData()        &#123;            Console.WriteLine(&quot;MP3正在传输数据&quot;);        &#125;    &#125;    &#x2F;&#x2F;用于实例化的电脑类,它有一个USB接口    class Computer    &#123;        &#x2F;&#x2F;声明一个接口成员，用于接口对接        public IUSB usb;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Computer computer &#x3D; new Computer();            StorageDevice mhd &#x3D; new StorageDevice(&quot;移动硬盘&quot;);            StorageDevice usbd &#x3D; new StorageDevice(&quot;U盘&quot;);            Mp3 mp3 &#x3D; new Mp3();            &#x2F;&#x2F;USB接移动硬盘            computer.usb &#x3D; mhd;            computer.usb.ReadData();            &#x2F;&#x2F;USB接U盘            computer.usb &#x3D; usbd;            computer.usb.ReadData();            &#x2F;&#x2F;USB接MP3            computer.usb &#x3D; mp3;            computer.usb.ReadData();        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>抽象类和抽象函数</title>
    <link href="/2022/05/19/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%A4%9A%E6%80%81/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%87%BD%E6%95%B0/"/>
    <url>/2022/05/19/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%A4%9A%E6%80%81/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>抽象类和抽象函数</p><span id="more"></span><h1 id="抽象类和抽象函数"><a href="#抽象类和抽象函数" class="headerlink" title="抽象类和抽象函数"></a>抽象类和抽象函数</h1><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>概念：<br>被抽象关键字abstract修饰的类<br>不希望被实例化的对象,相对比较抽象的类可以使用抽象类（水果等）</p><p>特点：<br>1.不能被实例化的类，但遵循里式替换原则（用父类容器装子类）<br>2.可以包含抽象方法<br>3.继承抽象类必须重写其抽象方法</p><h2 id="抽象函数"><a href="#抽象函数" class="headerlink" title="抽象函数"></a>抽象函数</h2><p>又称 纯虚方法<br>用abstract关键字修饰的方法</p><p>特点：<br>1.只能在抽象类中声明<br>2.没有方法体<br>3.不能是私有的<br>4.继承后必须实现 用override重写</p><p><strong>虚方法</strong>和<strong>抽象方法</strong>的异同：<br>相同点：<br>可以无限被子类重写<br>不同点：<br>1.<strong>抽象方法</strong>需要调用,必须用public或protected修饰,不能有函数体,只能在子类里override重写；<strong>虚方法</strong>一定有函数体,且里面可写可不写逻辑<br>2.<strong>抽象方法</strong>继承后必须实现；<strong>虚方法</strong>是子类里选择性实现的</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">abstract class Fruits&#123;    public string name;    &#x2F;&#x2F;因为抽象函数需要调用,必须用public或protected修饰    &#x2F;&#x2F;不能有函数体,只能在子类里override重写    abstract public void Bad();        public virtual void Test()    &#123;        &#x2F;&#x2F;虚方法一定有函数体,且里面可写可不写逻辑    &#125;&#125;class Apple : Fruits&#123;    &#x2F;&#x2F;虚方法是子类里选择性实现的    &#x2F;&#x2F;抽象方法继承后必须实现    public override void Bad()    &#123;        Console.WriteLine(&quot;苹果坏了&quot;);    &#125;&#125;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/19/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%A4%9A%E6%80%81/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%87%BD%E6%95%B0/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson18_抽象类和抽象函数&#123;    abstract class Animals    &#123;        abstract public void Speak();        &#125;    class People : Animals    &#123;        public override void Speak()        &#123;            Console.WriteLine(&quot;人叫&quot;);        &#125;    &#125;    class Dog : Animals    &#123;        public override void Speak()        &#123;            Console.WriteLine(&quot;狗叫&quot;);        &#125;    &#125;    class Cat : Animals    &#123;        public override void Speak()        &#123;            Console.WriteLine(&quot;猫叫&quot;);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Animals p &#x3D; new People();            p.Speak();            Animals d &#x3D; new Dog();            d.Speak();            Animals c &#x3D; new Cat();            c.Speak();        &#125;    &#125;&#125;</code></pre></div><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson18_抽象类和抽象函数&#123;    &#x2F;&#x2F;图形    abstract class Figure    &#123;        &#x2F;&#x2F;求面积        public abstract void Area();        &#x2F;&#x2F;求周长        public abstract void Perimeter();    &#125;    &#x2F;&#x2F;矩形    class Rectangular : Figure    &#123;        public int l;        public int w;        public Rectangular(int l, int w)        &#123;            this.l &#x3D; l;            this.w &#x3D; w;        &#125;        public override void Area()        &#123;            int s &#x3D; l * w;            Console.WriteLine(&quot;该矩形面积为&#123;0&#125;&quot;, s);        &#125;        public override void Perimeter()        &#123;            int c &#x3D; 2 * (l + w);            Console.WriteLine(&quot;该矩形周长为&#123;0&#125;&quot;, c);        &#125;    &#125;    &#x2F;&#x2F;矩形    class Square : Figure    &#123;        public int a;        public Square(int a)        &#123;            this.a &#x3D; a;        &#125;        public override void Area()        &#123;            int s &#x3D; a * a;            Console.WriteLine(&quot;该矩形面积为&#123;0&#125;&quot;, s);        &#125;        public override void Perimeter()        &#123;            int c &#x3D; 4 * a;            Console.WriteLine(&quot;该矩形周长为&#123;0&#125;&quot;, c);        &#125;    &#125;    &#x2F;&#x2F;圆形    class Circular : Figure    &#123;        public int r;        const float PI &#x3D; 3.1415926f;        public Circular(int r)        &#123;            this.r &#x3D; r;        &#125;        public override void Area()        &#123;            float s &#x3D; PI * r * r;            Console.WriteLine(&quot;该矩形面积为&#123;0&#125;&quot;, s);        &#125;        public override void Perimeter()        &#123;            float c &#x3D; 2 * r * PI;            Console.WriteLine(&quot;该矩形周长为&#123;0&#125;&quot;, c);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Figure r &#x3D; new Rectangular(2, 4);            r.Area();            r.Perimeter();            Figure s &#x3D; new Square(3);            s.Area();            s.Perimeter();            Figure c &#x3D; new Circular(5);            c.Area();            c.Perimeter();        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月19日</title>
    <link href="/2022/05/19/diary/2022.5/2022%E5%B9%B45%E6%9C%8819%E6%97%A5/"/>
    <url>/2022/05/19/diary/2022.5/2022%E5%B9%B45%E6%9C%8819%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="48556d71d8baf9e68f43b7588c0eaf2aa69ecb7fe05f9935211d77410ad8902c">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe507ad714b7d694638672ec89b6453f8a870b5aca629534dc9939024c47076fc51e739c6387f33ebf795ff8acfead750237dcc49917e7acc0ab1df7fa7d157ab40c60b4bd8d422cbc1a057c36715f8088e56f9a264298ce83d6a007eeb71f75eb25a79dab4cbe562ae542922a7cf369024d8217443f1445c3bf334157b3307265385f3c8e05c937977d5736dca1a94106d6366f4c9c7a60df78b9792646bc04efd2825fe45d9a0406c8f8dad3a49806d31918518ee754b8c1bb0963f861c62de92c1a82d5315ee20303e27032803a397fb7503caad7342a564396a134a24bba157a3bc47aa1db6cde81d43f49c1dbf2168409bba3be47e5de6d5dae9ef14fd96865b6c9ef2a47a9644abf121805c9e297fb093c75f68142b456ff6b8b6b11e157230f1d44f077ae942b1c5cb22c20a0cc5e51e6b83e775114368182356a827862f6263957cbf7725c29debaca3c57a27f52f48985792213cbadfb50f404c552f3830127c7aa7e86841c3e84f4f092bda3b8abca508fab6469573dede8c5c38f3dd1398f0e7c3a86ed3802abc8a26550161f7c114dda137c0a7205d1fa677e7d6e2a6f2237c09507e8afa5ad7c3eef4feb768ae2b5d5fc973fec0300c1246fc5d959c5306c32bb025c6edd7b9f5dfdd82b61c61b9820a8d57b50b7da20a132c7eb7bbcdf9998baa361b79abc7238f7b8de27</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VOB</title>
    <link href="/2022/05/18/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%A4%9A%E6%80%81/vob/"/>
    <url>/2022/05/18/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%A4%9A%E6%80%81/vob/</url>
    
    <content type="html"><![CDATA[<p>VOB</p><span id="more"></span><h1 id="VOB"><a href="#VOB" class="headerlink" title="VOB"></a>VOB</h1><h2 id="多态的概念"><a href="#多态的概念" class="headerlink" title="多态的概念"></a>多态的概念</h2><p>多态： 字面意思“多种状态”<br>让继&#x3D;继承同一父类的子类们，在执行相同方法时有不同表现（状态）</p><p>主要目的：<br>同一父类的对象 执行相同行为（方法）有不同的表现</p><p>解决的问题：<br>让同一个对象有唯一行为的特征</p><h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2><p>使同一种方法在不同对象下有不同表现</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Father&#123;    public void SpeakName()    &#123;        Console.WriteLine(&quot;Father的方法&quot;);    &#125;&#125;class Son : Father&#123;    public new void SpeakName()    &#123;        Console.WriteLine(&quot;Son的方法&quot;);    &#125;&#125;internal class Program&#123;    static void Main(string[] args)    &#123;        Father f &#x3D; new Son();        f.SpeakName(); &#x2F;&#x2F;打印Father的方法        (f as Son).SpeakName(); &#x2F;&#x2F;打印Son的方法    &#125;&#125;</code></pre></div><h2 id="多态的实现"><a href="#多态的实现" class="headerlink" title="多态的实现"></a>多态的实现</h2><p>函数重载 就是一种编译时的多态</p><p>运行时的多态：<br>(VOB, 抽象函数, 接口)<br>V:  virtual 虚函数<br>O:  override 重写<br>B:  base 父类</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class GameObject&#123;    public string name;    public GameObject(string name)    &#123;        this.name &#x3D; name;    &#125;    &#x2F;&#x2F;虚函数 可以被子类重写    public virtual void Atk()    &#123;        Console.WriteLine(&quot;游戏对象进行攻击&quot;);    &#125;&#125;class Player : GameObject&#123;    public Player(string name): base (name)    &#123;    &#125;    public override void Atk()    &#123;        &#x2F;&#x2F;base代表父类,可以通过base来保留父类的行为        base.Atk();        Console.WriteLine(&quot;玩家对象进行攻击&quot;);    &#125;&#125;internal class Program&#123;    static void Main(string[] args)    &#123;        GameObject p &#x3D; new Player(&quot;大逼&quot;);        p.Atk(); &#x2F;&#x2F;先打印父类行为&quot;游戏对象进行攻击&quot;,再打印子类行为&quot;玩家对象进行攻击&quot;    &#125;&#125;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/18/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%A4%9A%E6%80%81/vob/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson17_VOB&#123;    &#x2F;&#x2F;鸭子    class Duck    &#123;        public virtual void Quack()        &#123;            Console.WriteLine(&quot;真的鸭子嘎嘎叫&quot;);        &#125;    &#125;        &#x2F;&#x2F;木头鸭子    class WoodDuck : Duck    &#123;        public override void Quack()        &#123;            Console.WriteLine(&quot;木头鸭子吱吱叫&quot;);        &#125;    &#125;    &#x2F;&#x2F;木头鸭子    class RubberDuck : Duck    &#123;        public override void Quack()        &#123;            Console.WriteLine(&quot;橡皮鸭子唧唧叫&quot;);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Duck d &#x3D; new Duck();            d.Quack();            Duck wd &#x3D; new WoodDuck();            wd.Quack();            Duck rd &#x3D; new RubberDuck();            rd.Quack();        &#125;    &#125;&#125;</code></pre></div><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson17_VOB&#123;    &#x2F;&#x2F;员工    class Worker    &#123;        public virtual void ClockIn()        &#123;            Console.WriteLine(&quot;员工9点打卡&quot;);        &#125;    &#125;        &#x2F;&#x2F;经理    class Manager : Worker    &#123;        public override void ClockIn()        &#123;            Console.WriteLine(&quot;经理10点打卡&quot;);        &#125;    &#125;    &#x2F;&#x2F;程序员    class Programmer : Worker    &#123;        public override void ClockIn()        &#123;            Console.WriteLine(&quot;程序员不打卡&quot;);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Worker w &#x3D; new Worker();            w.ClockIn();            Worker m &#x3D; new Manager();            m.ClockIn();            Worker p &#x3D; new Programmer();            p.ClockIn();        &#125;    &#125;&#125;</code></pre></div><h2 id="题3"><a href="#题3" class="headerlink" title="题3"></a>题3</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson17_VOB&#123;    &#x2F;&#x2F;图形    class Figure    &#123;        &#x2F;&#x2F;求面积        public virtual void Area()        &#123;                    &#125;        &#x2F;&#x2F;求周长        public virtual void Perimeter()        &#123;                    &#125;    &#125;        &#x2F;&#x2F;矩形    class Rectangular : Figure    &#123;        public int l;        public int w;        public Rectangular(int l, int w)        &#123;            this.l &#x3D; l;            this.w &#x3D; w;        &#125;        public override void Area()        &#123;            int s &#x3D; l * w;            Console.WriteLine(&quot;该矩形面积为&#123;0&#125;&quot;, s);        &#125;        public override void Perimeter()        &#123;            int c &#x3D; 2 * ( l + w );            Console.WriteLine(&quot;该矩形周长为&#123;0&#125;&quot;, c);        &#125;    &#125;    &#x2F;&#x2F;矩形    class Square : Figure    &#123;        public int a;        public Square(int a)        &#123;            this.a &#x3D; a;        &#125;        public override void Area()        &#123;            int s &#x3D; a * a;            Console.WriteLine(&quot;该矩形面积为&#123;0&#125;&quot;, s);        &#125;        public override void Perimeter()        &#123;            int c &#x3D; 4 * a;            Console.WriteLine(&quot;该矩形周长为&#123;0&#125;&quot;, c);        &#125;    &#125;    &#x2F;&#x2F;圆形    class Circular : Figure    &#123;        public int r;        const float PI &#x3D; 3.1415926f;        public Circular(int r)        &#123;            this.r &#x3D; r;        &#125;        public override void Area()        &#123;            float s &#x3D; PI * r * r;            Console.WriteLine(&quot;该矩形面积为&#123;0&#125;&quot;, s);        &#125;        public override void Perimeter()        &#123;            float c &#x3D; 2 * r * PI;            Console.WriteLine(&quot;该矩形周长为&#123;0&#125;&quot;, c);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Figure r &#x3D; new Rectangular(2, 4);            r.Area();            r.Perimeter();            Figure s &#x3D; new Square(3);            s.Area();            s.Perimeter();             Figure c &#x3D; new Circular(5);            c.Area();            c.Perimeter();        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月18日</title>
    <link href="/2022/05/18/diary/2022.5/2022%E5%B9%B45%E6%9C%8818%E6%97%A5/"/>
    <url>/2022/05/18/diary/2022.5/2022%E5%B9%B45%E6%9C%8818%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="a1e0b094e8144ae808b5fe252e93194749f564d6cb90a8ab16d5e443fa35d2ed">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50fdd0ca3edc57389bd0e88084b7db20234a98291e286b22bc2d9be6b79caf6bf12130a2f5b91531b1c2ee2bef6a4ff1d8c15e8e38553d8e073e69dc788ad2d52a364479e47d567e379b2b5f22a15dd3f53ed0be8d7b7ac692e45812a8642a5013db4da0a2531fb7bef6e2a9fa0e5e808ed727a568dad693f59ed95f6ffe6a7e24ff2ff6967f54ab0f69c8ca23b9c98cd27e876da11d20abca0ca2c245ef90e43ffd9ec833befc129cff54213bf9b7cfa3977a914f7d9c895a44811d12494185a208b05934c2fbe11794024a855b1b8292dffc89e2a5223cda59d9991ef84a05ccb27919e2f95988af7f72a28fc191be507b43da1f47428a47453e846a14cd1e274f02e6ca983f88f4f142e3f2c9343f8075ff1934c861f87ea7a678a7981bc3c19514cae9fa3af4887d16a7da8a568d4fad930f4542bbdf796c578ba19a225b1572572d7dab49843e81a4b6da463d56ed423f11995ab1abf487a51498cff56ad2e6f9ff0b0e53eb19dbf206b70a912c27d680af9d0c42942630d7bf9d507a864f56fd77d1c8d95c0d7ac0629d30dd043d8d6d97a1949c6438f14d3bd667abca6308f4aebc2ccf7a60ac066aad0d1b8e61c929f1b90e970bd20ab752a60425808eb43f6e8e7aef4cb262d4f692ff6a18130ce4cc70e193fd803a9bda42e65a615af7749a391ffd7463696f01b30bb24fa4d9e17ff89549deb07cce53e04e2327172d96fb48ee090e7f34a68a2913bbe2e2a45e95d83d217c7a020ac19ae25559a80f7bcba224f98cce420a63cf3f3292efa71df421d973aba683f860011ee439bee17318f3d49c44da527a6081446bd5e7ece325cf6dd36007629d6e5b095276e3c060ed84fd29830a39aa86a4fd681b3a0491e85bf9f48d0946d71f31ec446342e5792898853d2db62eae8ca66ee2d66176d9352f14780f1801d3bcd9550aae1cc988a96f89805bf6406739bea117900d35834cfc0e8e30de1edf7ff16353ea599f5bf118128db41e7fa6e5947794915fb94a564ce80f9332061b5d8d3eb44caaa8d7d9648e0d1feff08e6711c7fc625661e19f1b42bc19638b8c5a0e28ba2b9523010163f111a7321002c5f5bef758114ffbb1b459e49dfbbb3198c0514b830fbea234508b2a242682d2739da6138e7afe3d13b7f79d97b78e65821f024a6820f8fa65e9e4e9f2984c59a3877023b2ef7d56bc0b3b018ea5bffdbe47b41a4c3cc5165b8067e63fcc8ab842353c385c42eb6c4d86d5bc52f55303f4b1ae4b5f7b8384e2f36ab3b6804427a8abadc8a054754579e3ab6449264f1bdd54125de4f1</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月17日</title>
    <link href="/2022/05/17/diary/2022.5/2022%E5%B9%B45%E6%9C%8817%E6%97%A5/"/>
    <url>/2022/05/17/diary/2022.5/2022%E5%B9%B45%E6%9C%8817%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="18704ebd8b16e1e9d2ad672a38c56040c3530adf64cbb4ba074124c2c9298010">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50fdd0ca3edc57389bd0e88084b7db2023f42eee7650a2032f2b23d7fd0fc253e4226e332027f8095b3a83a4b6176d19d0e1c37b7629e1188d5ac39265ba057e9e1cf18cfe6a7cd96bc3f0901e5db825e9e3f9dbae55f8c66f0ba77b55c50cd309ebcff3e2b6613838ec0a63d0d269441e6bee4ac22ccbb92c2f0cba5b4d195235fc0d1b9f47d5ec7245165cdd15ea9b4a8e6a6472bc511d383f802ed4a5eaf65df3b2528fb45c1e45df243eeb9a98e204775e74bd28b5ff42eeba70b1553e5c75f79e45e2dc818d428521c8ba05d608c96c63632d35f3813c9e8c0867f10f6ba4e2ddb54996ee938beac164f268acc5fd0b444f866bb27bd1c7fffcf4c41eb9407ac14b8c3bd9924dd726607fe2ece45b0aaed379d5aac22bb0e62c6874c4807341a7fb6b3ed22521331f28fafb35c1683e91f33e21d08a7a9fd5d68ab5953690f2294c0cd7152964996a673d7c7b88367ede816d7a6cbdb44b48c4fda4ad489955eb35c717be379f8ca429b15cfaf20c1c1f2f847a82e5519fb9fc4b888024a7a3b87ce5b60f43196a55ff1273e05e4ac26ec482932bc0d61d0c3872efad7b493030cda9a722ad0cd5a956e0883bbb626d9eebb84abbe197885dbd61725dcfa5d47fb2220147677d3b9254f2b8b3af50bb20e941d583ff887a901f1e7b95202a4fed455b6637d1fc89c6b7da80cce79f7131102cf2dd99e95dfaf625d973f63196dee5026d286da82794f1166a43ae014901c4e13422c935fd4d0d9caa72e161ac49c38493761807c49d2aeddfa01036af2d7d1a1c196ba83a311f7443eeb964</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>密封类</title>
    <link href="/2022/05/17/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E5%AF%86%E5%B0%81%E7%B1%BB/"/>
    <url>/2022/05/17/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E5%AF%86%E5%B0%81%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>密封类</p><span id="more"></span><h1 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>密封类：使用sealed密封关键字修饰的类<br>作用：让类无法再被继承</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">sealed class 类名</code></pre></div><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>不允许最底层子类被继承，保证程序的规范性、结构性、安全性</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/17/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E5%AF%86%E5%B0%81%E7%B1%BB/exam.png" class=""><p>没设置自定义乘客数量、途径站点数</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson16_密封类&#123;    sealed class Carrier    &#123;        &#x2F;&#x2F;两站间隔1km        int s &#x3D; 1000;        &#x2F;&#x2F;载具速度        int speed;        &#x2F;&#x2F;最大速度100m&#x2F;min        int speedMax &#x3D; 100;        &#x2F;&#x2F;最大可乘10人,包含司机        int maxNumber &#x3D; 10;                &#x2F;&#x2F;上车人数        public int onNum &#x3D; 0;        &#x2F;&#x2F;下车人数        public int offNum &#x3D; 0;        &#x2F;&#x2F;乘客数组        public bool[] passengers &#x3D; new bool[10];        &#x2F;&#x2F;上下车人数的随机数,载具速度的随机数        Random r &#x3D; new Random();        &#x2F;&#x2F;逻辑上先上车再下车        &#x2F;&#x2F;上车 + 下车        public void GetOnOff(ref int nowNum)        &#123;             &#x2F;&#x2F;上车人数不能超过总人数            onNum &#x3D; r.Next(10 - nowNum);            Console.Write(&quot;上车&#123;0&#125;人  &quot;, onNum);            for (int i &#x3D; nowNum; i &lt; nowNum + onNum; i++)            &#123;                passengers[i] &#x3D; true;            &#125;            &#x2F;&#x2F;下车人数不能超过原已上车人数            offNum &#x3D; r.Next(nowNum);             Console.Write(&quot;下车&#123;0&#125;人  &quot;, offNum);            for (int i &#x3D; nowNum + onNum - 1; i &gt;&#x3D; nowNum + onNum - offNum; i--)            &#123;                passengers[i] &#x3D; false;            &#125;            &#x2F;&#x2F;更新已上车人数            nowNum &#x3D; nowNum + onNum - offNum;        &#125;        &#x2F;&#x2F;行驶 打印多久到下一站 按任意键到下一站        public void Drive()        &#123;            &#x2F;&#x2F;载具速度            speed &#x3D; r.Next(50, speedMax + 1);            Console.WriteLine(&quot;耗时&#123;0&#125;分钟,到达下一站&quot;, s&#x2F;speed);                &#125;        &#x2F;&#x2F;车祸        public void Accident()        &#123;            Console.WriteLine(&quot;很不幸,发生了车祸&quot;);            Environment.Exit(0);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            &#x2F;&#x2F;定义一个随机数,判断是否车祸            Random r &#x3D; new Random();            &#x2F;&#x2F;默认一开始没人上车,即乘客全为false            Carrier c &#x3D; new Carrier();            &#x2F;&#x2F;已上车人数 初始为0            int nowNum &#x3D; 0;            &#x2F;&#x2F;计数到站数,设一共10站            int set &#x3D; 0;            for (int i &#x3D; 0; i &lt; c.passengers.Length; i++)            &#123;                c.passengers[i] &#x3D; false;            &#125;            Console.WriteLine(&quot;现在从始发站开始出发,车上无乘客&quot;);            while(true)            &#123;                Console.WriteLine(&quot;请按任意键前往下一站&quot;);                Console.WriteLine(&quot;&quot;);                Console.ReadKey(true);                                &#x2F;&#x2F;95%的概率正常行驶,5%的概率出车祸                if ( r.Next(101) &lt;&#x3D; 95 )                &#123;                    c.Drive();                    c.GetOnOff(ref nowNum);                    Console.WriteLine(&quot;现在车上有&#123;0&#125;人&quot;, nowNum);                    set++;                &#125;                else                &#123;                    c.Accident();                &#125;                if( set &#x3D;&#x3D; 10 )                &#123;                    Console.WriteLine(&quot;\n已到达终点站&quot;);                    Environment.Exit(0);                &#125;            &#125;         &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>万物之父和装箱拆箱</title>
    <link href="/2022/05/17/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E4%B8%87%E7%89%A9%E4%B9%8B%E7%88%B6%E5%92%8C%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1/"/>
    <url>/2022/05/17/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E4%B8%87%E7%89%A9%E4%B9%8B%E7%88%B6%E5%92%8C%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1/</url>
    
    <content type="html"><![CDATA[<p>万物之父和装箱拆箱</p><span id="more"></span><h1 id="万物之父和装箱拆箱"><a href="#万物之父和装箱拆箱" class="headerlink" title="万物之父和装箱拆箱"></a>万物之父和装箱拆箱</h1><h2 id="万物之父"><a href="#万物之父" class="headerlink" title="万物之父"></a>万物之父</h2><p>关键字： object<br>概念： object是所有类型的基类，它是一个类（引用类型）<br>作用：<br>1.可以利用里式替换原则，用object容器装所有对象<br>2.可以用来表示不确定类型，作为函数参数类型</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Father&#123;&#125;class Son : Father&#123;    public void Speak()    &#123;    &#125;&#125;internal class Program&#123;    static void Main(string[] args)    &#123;        Father f &#x3D; new Son();        if( f is Son )        &#123;            ( f as Son ).Speak();        &#125;        &#x2F;&#x2F;引用类型        object o &#x3D; new Son();        if( o is Son )        &#123;            (o as Son ).Speak();        &#125;        &#x2F;&#x2F;值类型        object o2 &#x3D; 1;        &#x2F;&#x2F;用强转进行数值使用        int i &#x3D; (int)o2;        &#x2F;&#x2F;特殊的string类型        object o3 &#x3D; &quot;123123&quot;;        string s &#x3D; o3 as string; &#x2F;&#x2F;o3.ToString();        &#x2F;&#x2F;数组类型        object o4 &#x3D; new int[10];        int[] arr &#x3D; o4 as int[]; &#x2F;&#x2F;(int[])o4;    &#125;&#125;</code></pre></div><h2 id="拆箱装箱"><a href="#拆箱装箱" class="headerlink" title="拆箱装箱"></a>拆箱装箱</h2><p>发生条件：<br>装箱： object中存入值类型<br>拆箱： object转为值类型</p><p>装箱：<br>把值类型用引用类型存储<br>栈内存会迁移到堆内存中</p><p>拆箱：<br>把引用类型存储的值类型取出来<br>堆内存会迁移到栈内存中</p><p>好处：不确定类型时可以方便参数的存储和传递<br>坏处：存在内存迁移，增加性能消耗</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">internal class Program&#123;    static void Main(string[] args)    &#123;        &#x2F;&#x2F;装箱        object v &#x3D; 3;        &#x2F;&#x2F;拆箱        int intValue &#x3D; (int)v;        &#x2F;&#x2F;传入object类数组        TestFun(1, 1.5f , 2, &quot;123&quot;, new int[10]);    &#125;    static void TestFun( params object[] array )    &#123;    &#125;&#125;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/17/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E4%B8%87%E7%89%A9%E4%B9%8B%E7%88%B6%E5%92%8C%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><p>装箱： object中存入值类型；把值类型用引用类型存储；栈内存会迁移到堆内存中<br>拆箱： object转为值类型；把引用类型存储的值类型取出来；堆内存会迁移到栈内存中</p><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">internal class Program&#123;    &#x2F;&#x2F;装箱    object v &#x3D; 3;    &#x2F;&#x2F;拆箱    int intValue &#x3D; (int)v;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>继承中的构造函数</title>
    <link href="/2022/05/16/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <url>/2022/05/16/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>继承中的构造函数</p><span id="more"></span><h1 id="继承中的构造函数"><a href="#继承中的构造函数" class="headerlink" title="继承中的构造函数"></a>继承中的构造函数</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>特点：</strong><br>当声明一个子类对象时<br>先执行父类的构造函数<br>再执行子类的构造函数</p><p><strong>注意：</strong><br>1.父类的无参构造 很重要<br>2.子类可以通过base关键字 代表父类 调用父类构造</p><h2 id="继承中构造函数的执行顺序"><a href="#继承中构造函数的执行顺序" class="headerlink" title="继承中构造函数的执行顺序"></a>继承中构造函数的执行顺序</h2><p>1.父类的父类的构造函数<br>2.父类的构造函数<br>3.子类的构造函数<br>即<strong>从高到低依次调用</strong></p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class GameObject&#123;    public GameObject()    &#123;        Console.WriteLine(&quot;GameObject的构造函数&quot;);    &#125;&#125;class Player : GameObject&#123;    public Player()    &#123;        Console.WriteLine(&quot;Player的构造函数&quot;);    &#125;&#125;class MainPlayer : Player&#123;    public MainPlayer()    &#123;        Console.WriteLine(&quot;MainPlayer的构造函数&quot;);    &#125;&#125;internal class Program&#123;    static void Main(string[] args)    &#123;        MainPlayer mp &#x3D; new MainPlayer();    &#125;&#125;</code></pre></div><h2 id="父类的无参构造函数很重要"><a href="#父类的无参构造函数很重要" class="headerlink" title="父类的无参构造函数很重要"></a>父类的无参构造函数很重要</h2><p>重点：<br>无参构造函数会被有参构造函数顶替</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Father&#123;    public Father(int i)    &#123;        Console.WriteLine(&quot;Father构造函数&quot;);    &#125;&#125;class Son : Father&#123;    &#x2F;&#x2F;默认调用父类的无参构造函数，但父类中无参构造函数被顶替，所以报错&#125;internal class Program&#123;    static void Main(string[] args)    &#123;        Son s &#x3D; new Son();    &#125;&#125;</code></pre></div><h2 id="通过base调用制定父类构造"><a href="#通过base调用制定父类构造" class="headerlink" title="通过base调用制定父类构造"></a>通过base调用制定父类构造</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Father&#123;    public Father(int i)    &#123;        Console.WriteLine(&quot;Father构造函数&quot;);    &#125;&#125;class Son : Father&#123;    public Son(int i) : base(i)    &#123;        Console.WriteLine(&quot;Son一个参数的构造函数&quot;);    &#125;    public Son(int i, string str) : this (i)    &#x2F;&#x2F;this其实是先调用base(i),是一种间接的方式;如果用base会直接执行父类构造函数    &#123;        Console.WriteLine(&quot;Son两个参数的构造函数&quot;);    &#125;&#125;internal class Program&#123;    static void Main(string[] args)    &#123;        Son s1 &#x3D; new Son(1, &quot;123&quot;);    &#125;&#125;</code></pre></div><p>注意：<br>this和base的区别<br>this:自己的另一个对应构造函数<br>base:父类的对应构造函数</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/16/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/exam.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson14_继承中的构造函数&#123;    enum E_TypeOfWork    &#123;        Programmer,        Planner,        Artist,    &#125;    enum E_WorkContent    &#123;        program,        plan,        paint,    &#125;    class Worker    &#123;        public E_TypeOfWork typeOfWork;        public E_WorkContent workContent;        public Worker(E_TypeOfWork typeOfWork, E_WorkContent workContent)        &#123;            Console.WriteLine(&quot;我是打工人&quot;);        &#125;    &#125;        class Programmer : Worker    &#123;        public Programmer(E_TypeOfWork typeOfWork, E_WorkContent workContent) : base(typeOfWork, workContent)        &#123;            Console.WriteLine(&quot;&#123;0&#125; is &#123;1&#125;ing&quot;, typeOfWork, workContent);        &#125;    &#125;    class Planner : Worker    &#123;        public Planner(E_TypeOfWork typeOfWork, E_WorkContent workContent) : base(typeOfWork, workContent)        &#123;            Console.WriteLine(&quot;&#123;0&#125; is &#123;1&#125;ing&quot;, typeOfWork, workContent);        &#125;    &#125;    class Artist : Worker    &#123;        public Artist(E_TypeOfWork typeOfWork, E_WorkContent workContent) : base(typeOfWork, workContent)        &#123;            Console.WriteLine(&quot;&#123;0&#125; is &#123;1&#125;ing&quot;, typeOfWork, workContent);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Programmer programmer &#x3D; new Programmer(E_TypeOfWork.Programmer, E_WorkContent.program);             Planner planner &#x3D; new Planner(E_TypeOfWork.Planner, E_WorkContent.plan);            Artist artist &#x3D; new Artist(E_TypeOfWork.Artist, E_WorkContent.paint);        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>里式替换原则</title>
    <link href="/2022/05/16/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E9%87%8C%E5%BC%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/"/>
    <url>/2022/05/16/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E9%87%8C%E5%BC%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<p>里式替换原则</p><span id="more"></span><h1 id="里式替换原则"><a href="#里式替换原则" class="headerlink" title="里式替换原则"></a>里式替换原则</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>任何父类出现的地方，子类都可以替代</p><p><strong>重点</strong><br>语法表现： 父类容器装子类对象，因为子类对象包含了父类的所有内容</p><p><strong>作用</strong><br>方便进行对象存储和管理</p><h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class GameObject&#123;&#125;class Player : GameObject&#123;    public void PlayerAtk()    &#123;        Console.WriteLine(&quot;玩家攻击&quot;);    &#125;&#125;class Monster : GameObject&#123;    public void MonsterAtk()    &#123;        Console.WriteLine(&quot;怪物攻击&quot;);    &#125;&#125;class Boss : GameObject&#123;    public void BossAtk()    &#123;        Console.WriteLine(&quot;Boss攻击&quot;);    &#125;&#125;internal class Program&#123;    static void Main(string[] args)    &#123;        &#x2F;&#x2F;里式替换原则 用父类容器 装载子类对象        GameObject player &#x3D; new Player();        GameObject monster &#x3D; new Monster();        GameObject boss &#x3D; new Boss();        GameObject[] objects &#x3D; new GameObject[] &#123; new Player(), new Monster(), new Boss() &#125;;                &#x2F;&#x2F;此时player对象中不存在Playeratk的方法，因为player是在父类容器GameObject中，而GameObject中没有Playeratk的方法        &#x2F;&#x2F;即父类容器装载子类对象不能直接使用子类中的方法    &#125;&#125;</code></pre></div><h2 id="is和as"><a href="#is和as" class="headerlink" title="is和as"></a>is和as</h2><p><strong>基本概念</strong><br>is : 判断一个对象是否是指定类对象<br>返回值： bool 是为true 不是为false</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">if(player is Player)&#123;&#125;else if (player is Monster)&#123;&#125;</code></pre></div><p>as : 将一个对象转换为指定类对象<br>返回值： 指定类型对象<br>成功返回指定类型对象，失败返回null</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Player p &#x3D; player as Player; &#x2F;&#x2F;成功 p 是PlayerPlayer p &#x3D; monster as Player; &#x2F;&#x2F;失败 p &#x3D; null</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">if(player is Player)&#123;    &#x2F;&#x2F;Player p &#x3D; player as Player;    &#x2F;&#x2F;p.Playatk();    (player as Player).PlayerAtk();    &#x2F;&#x2F;上面两种等价&#125;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/16/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E9%87%8C%E5%BC%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><p>is是判断该对象是不是这个类，返回的是bool值<br>as是将该对象转换为指定类型，成功则转换成功，失败则将该对象变为null</p><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson13_里式替换原则&#123;    class Monster    &#123;    &#125;    class Boss : Monster    &#123;        public void Skill()        &#123;            Console.WriteLine(&quot;Boss释放技能&quot;);        &#125;    &#125;    class Goblin : Monster    &#123;        public void Atk()        &#123;            Console.WriteLine(&quot;哥布林攻击&quot;);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Monster[] monsters &#x3D; new Monster[10];            Random rand &#x3D; new Random();            for (int i &#x3D; 0; i &lt; monsters.Length; i++)            &#123;                if(rand.Next(1,101) &lt;&#x3D; 50)                &#123;                    monsters[i] &#x3D; new Boss();                &#125;                else                &#123;                    monsters[i] &#x3D; new Goblin();                &#125;            &#125;            for (int i &#x3D; 0; i &lt; monsters.Length; i++)            &#123;                if(monsters[i] is Boss)                &#123;                    (monsters[i] as Boss).Skill();                &#125;                else if(monsters[i] is Goblin)                &#123;                    (monsters[i] as Goblin).Atk();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div><h2 id="题3"><a href="#题3" class="headerlink" title="题3"></a>题3</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson13_里式替换原则&#123;    &#x2F;&#x2F;玩家类    class Player    &#123;        public void SwitchWeapon(int k)        &#123;            Player[] weapons &#x3D; new Player[4] &#123; new SMG(), new Shotgun(), new Pistol(), new Dagger() &#125;;            if (weapons[k] is SMG)            &#123;                (weapons[k] as SMG).Print();            &#125;            else if (weapons[k] is Shotgun)            &#123;                (weapons[k] as Shotgun).Print();            &#125;            else if (weapons[k] is Pistol)            &#123;                (weapons[k] as Pistol).Print();            &#125;            else if (weapons[k] is Dagger)            &#123;                (weapons[k] as Dagger).Print();            &#125;        &#125;    &#125;    &#x2F;&#x2F;冲锋枪类    class SMG : Player    &#123;        public void Print()        &#123;            Console.WriteLine(&quot;你现在手持冲锋枪&quot;);        &#125;    &#125;    &#x2F;&#x2F;霰弹枪类    class Shotgun : Player    &#123;        public void Print()        &#123;            Console.WriteLine(&quot;你现在手持霰弹枪&quot;);        &#125;    &#125;    &#x2F;&#x2F;手枪类    class Pistol : Player    &#123;        public void Print()        &#123;            Console.WriteLine(&quot;你现在手持手枪&quot;);        &#125;    &#125;    &#x2F;&#x2F;匕首类    class Dagger : Player    &#123;        public void Print()        &#123;            Console.WriteLine(&quot;你现在手持匕首&quot;);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Player p &#x3D; new Player();            &#x2F;&#x2F;默认匕首            p.SwitchWeapon(3);            Console.WriteLine(&quot;按1(冲锋枪),2(霰弹枪),3(手枪),4(匕首)进行切枪&quot; + &quot; &quot; + &quot;按q退出程序&quot;);            while (true)            &#123;                char cmd &#x3D; Console.ReadKey(true).KeyChar;                try                 &#123;                    if(cmd !&#x3D; &#39;q&#39;)                    &#123;                        p.SwitchWeapon(Convert.ToInt32(cmd - &#39;0&#39;) - 1);                    &#125;                    else                    &#123;                        Environment.Exit(0);                    &#125;                &#125;                catch                &#123;                    Console.WriteLine(&quot;请输入正确指令&quot;);                &#125;                           &#125;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月16日</title>
    <link href="/2022/05/16/diary/2022.5/2022%E5%B9%B45%E6%9C%8816%E6%97%A5/"/>
    <url>/2022/05/16/diary/2022.5/2022%E5%B9%B45%E6%9C%8816%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="8ff5085b02db703695eb0573d5e2395718f232387ff5a7bcffab20389c364185">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe505b803b8feaab671cea5ab5e4652ea6c36a02f1947ad70fc2430bd172aca29c6de61259f12fbbd1a4855621ddc3d9d79291f362396f3716bf88727952e141b19141594a62e1e2a1cfce1049c766c052e9189ec318c83d4889671d1206c52a37e925512f04d7e6cf54ff03f5a54a66e4d0f1771bd9a0aa9e6e12bde83af7c4521de6822c6a3c85521d8406e4ee55cc09630a7a3b945f25dbcd29f27aeaa1955a761710f18fbc6df5b1461fe1d5e9ff92b8445f70ec9d16c48ae8eab299ea194cb155a5dbb022d2862dbaabc2f3e4554310341b80c0e38ad644bef9f30ce6c9862b12efd2953531245df513c5ea1e5c94483495f72abfdb32eeec3a1bec1e7f82612dadd133fe3bc11200d8944b1abf9ad0ffba36bc6025ad69f3988ab774dbe96e8d090740736b887dc8998511d9063c9605290758a36a4f6160c28f2e6cc61b2e213a6d6b9ec204ab8d0c2ec0799e9c2677eadc39875b2e663f17c41b31bc971117b9a800d3087acdd0d368d71e4393cb</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月15日</title>
    <link href="/2022/05/15/diary/2022.5/2022%E5%B9%B45%E6%9C%8815%E6%97%A5/"/>
    <url>/2022/05/15/diary/2022.5/2022%E5%B9%B45%E6%9C%8815%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="829ded19b386609cf9ac49cbf1c44b2b04da821bfccef03a6e2c685585e6e71c">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe5016a4faf8194f2f8aa9b1a6144f7333a3892e1f4a31a2d18309e56f20249bd16769e464f7d6eb4a6e4fab04466bd357c63e94ff3c847c3aecee23dd98d9231033f5cf1745aa32f0f11f3731764b767d424ac8e92d145e3b510d2ad55a0294a4cd5d617e36d2284f04ec73f005e7f9611edd4dc41b9fe47cf734c8432125ca2590cee134ac84e982742ceb768e2d0b46d6f68f55bf42afa3adc8113d1c7dcf90cd726885350ddbaa3dd0f3f4e47bc8e6ce71ebbcddee631d3a847d5b94fdf47b7eae9909ede14e84c594d26966b216134c28a72f32366189176140edf5f011107352fcef378e49c52c2f8634d4ceb69ea17eacd5c048fafe1a5ed420aadffa07682696725fa3297c629086715f33d0dfeda09df377c955a225eb8f1bf0be1aa8e377fb0d26fd960c67b6e405a1bde81c51c54cc246071d139ad9f772292fc0260a3d7ab2d9a0c1e545bca15aa7e8537ff71b7ca315bcc1a07aae28f38d577044add5bc085f924bc8b84659dd5fd7cad2ca1588d2a3fc18e5c6659d8dfc4fbb657d6af886ec46f678329afb02a95781c497363c9e0f5b0aa42abbaaf228ef4667d9d5b4fdb4483291c18d999d01718a6f50a85e66bb5e9572ec80da526bee47f920f74ffc4d34d5e0aea04f883ca9b87c231a6c158ea694c2fd9402477c370dee9067d57b934831465f9c4a06e041c7a4e74e04cda4ff80dbe1b730d430c0bad17fc92e2ecc1ef39d60707c523253a050ed1e8609e6cd446778ef9177c15d21cbabc53cef4802f4f22081c8725229a160c3844026dc7262dae8cd0d424306c117c63e98e7542e46002c688f6209043df006d8f2520374946c69590dfe8bd09179572178ee2922783b1e3fabfe43c9aa4750ce54b82ddf39a6233e8c3848b7157825ac303cb81c187e655f37ad05c0f29591027b97f499838cfaf900f752fb4fcadb1942c980476a6d7347c7fe5006e51db3b3c4e601b2f81c939a1958611635f29c2e79d3ba4925a61a69644bed421abef71a39c70e57f3b16f47a5fb85254caa8a602004c6e01d70c63abaf69146a6243882c0cc089b60d764e83d96ac561778711086d1dd7c3f3a3b88d2ec61fb15c2cfc94c68eda9882facb8564ac3949c1145e133e4eb3d4feed6cd809a1f7e7a690d2cfddc19fea4323a107f12975738b2f4ad9d66700b06ca3028706b150318e5802e0175f7022224b9fde1f682fe18ac0f8bc03fee8ef646ca3dbe86367bc1473a17cfdd92d2f66206bc85cdcda7379e45385cbeedfb11987dabc13fb4cd1946f926d03256f0ba26a8f7ed320a2e293a1a222bedf2dde4df4e9afb694fcd4130075c0e9057bc9e7d9f456bc917eec3c8418643f198517ee42fb5b2766c483884d2c21316c4101bba7eb18f0f664c6b52b743217cbb2841c8217e85edb64fff4dbc2675438c138a709a27e5b4d3e214f342e80c3fe12612c775eb35af60812ab78bc5937232116cc0213ce918ab795751af0a40cdd88edb39485100cce6a4af3ee73206065e209eb62cb2f33cbbf34cd061ff68ce136ad467c6863ca6528cc5cd66b11d960a91242d9e1c772699bf2910f3ab77782fe39826e701df2001f30d529b0cf44b4eaaa0011ea88c2eeb85410a60e0d10f215871042cb1b9aed53bb50ad265e2a27139c3e35b1d48e164089d501238a78ff71e86baa180d50ebc88d1d28e09c9153e91a8e837819def61873f41dcaecc3908eac609be37d31975c35ed7b18271e8222c1b8591697310a0db730ad7a7f0227009d827653828c4f36e2b3eb3d658fcbb178e97abc960152228787fd6fb6fe84cb172ea669d1d53efe52f2cce4630cb39c0fda09dc0042ce238133b2eac4eae6107edfbe0b2528013fc7356b63a22cec41e3f466cb2c9e6b8844dafd3aa79234f0f2009463f3471c4d8c5dde2602db028b62998e338afa1f18c28f84ac7789f9a8ebd60dd90045a0cdb45df6984dcda44e2e5f5e923dbabed5cde3e986f77c2968414236383715ef0b20386b1a14c47ba289a3b71647c5cfdbe816ae0c1bf75da080719b6fae2fcfa7b8fcffece1c3771dbfc2d4ac16490c5fec57e07c6488058a8e6636fb1205fd450c4fc195218774497759f86ecb9d177613550359f29ca09e16241559385d710397ab7f7edfa3c65fc974c4be19951dda2a361a58faaf18eb0157dd6f4b3d5913916e8e848f665a816ac6cd4f43a38e6872e1dc5b8d3972daa05107b4a2efd6a4dd9eeb1413b6783a6d81d6587267ab625a04ad4317d3a54c06ab31a632699e27ad109be508037ef5b34dffc376122954d493e5aad2653d11b56f7929050ba6a954c641be9f82c8c0fbed2c1211a7025f1edb5737aabbab7175419f5d52befe987c4d0fb43b04849f4e727446d891953cdd7f4b444a19e516db931198efbe5629f652fe953e1585a4a7311acdecac62e330e280b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月14日</title>
    <link href="/2022/05/14/diary/2022.5/2022%E5%B9%B45%E6%9C%8814%E6%97%A5/"/>
    <url>/2022/05/14/diary/2022.5/2022%E5%B9%B45%E6%9C%8814%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="0d2d3e74c0b88ce0e89374106356adaec4166149c0b200bfcae26f6136b84842">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50eab5a83f549bec176812e5d10b67ba0dcb7ab007c94ce139a456f545dfed2122acee6f64839288f02efb7a0ade81be20e4fcb98a37a126e8c08d3745c9a2c29c5ba00cf3b5d1957d413586b65b4c4ce75dbf344e86c5e5ea5c6ab445d806a2c8516e4b35b8cf1cafbd1ad726fe8c3ef0cd0b399e88e11bf157ec758812cbfe7c43a1221624af8d9cf5aef115f882d51e9d5156e17b1ef31b936994250fa210514b10fd98ddd056e583b10505eada21a85658b5a84db87e7b04735f8dfa27de28576898d03ea61ce2a2e0347248a524f15b85f0228ca1d6e442359173862bb1b2a7521af6b0051d12c0e9903863e9bfcd536f6ab37f0bd9e7f2f5f76578ccc02b780c72109f9b4bd4b2727eb5b4de1270428b49f32edd5387fd3a770463524b7ae3f8f923a0ef0819f1e76f60e6d1a71dbf8814667f68956269c37c16de288a96b64333959bb2db4d4cdb8a64c80082b61c7d457e8cd3385dcca90f4da4064b53879151466b3e9a6dd6835129a0fecd22</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>继承的基本规则</title>
    <link href="/2022/05/14/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99/"/>
    <url>/2022/05/14/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99/</url>
    
    <content type="html"><![CDATA[<p>继承的基本规则</p><span id="more"></span><h1 id="继承的基本规则"><a href="#继承的基本规则" class="headerlink" title="继承的基本规则"></a>继承的基本规则</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>一个类A继承一个类B<br>类A将会继承类B的所有成员<br>类A将拥有类B的所有特征和行为</p><p><strong>被继承的类：</strong><br><em>父类</em> &#x2F; 基类 &#x2F; 超类 </p><p><strong>继承的类：</strong><br><em>子类</em> &#x2F; 派生类</p><p>子类可以有自己的特征和行为</p><p><strong>特点：</strong><br>1.单根性：子类只能有一个父类<br>2.传递性：子类可以简介继承父类的父类</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class 类名 : 被继承的类名&#123;&#125;</code></pre></div><img src="/2022/05/14/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99/%E6%A0%91%E7%8A%B6%E5%9B%BE.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;老师类class Teacher&#123;    &#x2F;&#x2F;姓名    public string name;    &#x2F;&#x2F;职工号    public int number;    &#x2F;&#x2F;介绍名字    public void SpeakName()    &#123;        Console.WriteLine(name);    &#125;&#125;&#x2F;&#x2F;教学老师类 作为 老师类的 子类class TeachingTeacher : Teacher&#123;    &#x2F;&#x2F;科目    public string subject;    &#x2F;&#x2F;介绍科目    public void SpeakSubject()    &#123;        Console.WriteLine(subject + &quot;老师&quot;);    &#125;&#125;&#x2F;&#x2F;语文老师类 class ChineseTeacher : TeachingTeacher&#123;&#125;internal class Program&#123;    static void Main(string[] args)    &#123;        TeachingTeacher tt &#x3D; new TeachingTeacher();        tt.name &#x3D; &quot;季宝&quot;;        tt.number &#x3D; 1;        tt.SpeakName();        tt.subject &#x3D; &quot;Unity&quot;;        tt.SpeakSubject();    &#125;&#125;</code></pre></div><h2 id="访问修饰符的影响"><a href="#访问修饰符的影响" class="headerlink" title="访问修饰符的影响"></a>访问修饰符的影响</h2><p>public - 公共 内外部访问<br>private - 私有 内部访问（子类不能访问）<br>protected - 保护 内部和子类访问<br>internal - 内部的 只有在同一个程序集的文件中，内部类型或者是成员才可以访问</p><h2 id="子类和父类的同名成员"><a href="#子类和父类的同名成员" class="headerlink" title="子类和父类的同名成员"></a>子类和父类的同名成员</h2><p><strong>概念：</strong><br>C#中允许子类存在和父类同名的成员<br>但 极不建议使用</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public new string name;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/14/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E7%BB%A7%E6%89%BF/%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99/exam.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson12_继承的基本规则&#123;    &#x2F;&#x2F;人类类    class Person    &#123;        public string name;        public int age;        public void Speak()        &#123;            Console.WriteLine(&quot;我是&quot; + name);        &#125;    &#125;    &#x2F;&#x2F;战士类    class Warrior : Person    &#123;        public void Attack()        &#123;            Console.WriteLine(&quot;wslnm&quot;);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Warrior warrior &#x3D; new Warrior();            warrior.name &#x3D; &quot;大逼&quot;;            warrior.Speak();             warrior.Attack();        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内部类和分部类</title>
    <link href="/2022/05/13/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%88%86%E9%83%A8%E7%B1%BB/"/>
    <url>/2022/05/13/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%88%86%E9%83%A8%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>内部类和分部类</p><span id="more"></span><h1 id="内部类和分部类"><a href="#内部类和分部类" class="headerlink" title="内部类和分部类"></a>内部类和分部类</h1><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p><strong>基本概念：</strong><br>在一个类中再声明一个类</p><p><strong>特点：</strong><br>使用时要用包裹者点出自己</p><p><strong>作用：</strong><br>亲密关系的表现</p><p><strong>注意：</strong><br>访问修饰符作用很大</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Person &#123;     public int age;     public string name;     public Body body;     public class Body     &#123;         Arm leftArm;         Arm rightArm;         &#x2F;&#x2F;class在内部类里默认private         class Arm         &#123;         &#125;     &#125;      &#125; internal class Program &#123;     static void Main(string[] args)     &#123;         Person p &#x3D; new Person();         Person.Body body &#x3D; new Person.Body();         &#x2F;&#x2F;Person.Body.Arm arm &#x3D; new Person.Body.Arm(); 会报错     &#125; &#125;</code></pre></div><h2 id="分部类"><a href="#分部类" class="headerlink" title="分部类"></a>分部类</h2><p><strong>基本概念：</strong><br>把一个类分成几部分声明</p><p><strong>关键字</strong> <em>partial</em></p><p><strong>作用：</strong><br>1.分布描述一个类<br>2.增加程序的拓展性</p><p><strong>注意：</strong><br>1.分部类可以写在多个脚本文件中<br>2.分部类的访问修饰符要一致<br>3.分部类中不能有重复成员</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">partial class Student&#123;    public bool sex;    public string name;&#125;&#x2F;&#x2F;一个类 分开写partial class Student&#123;    public int number;    public void Speak(string str)    &#123;    &#125;&#125;internal class Program&#123;    static void Main(string[] args)    &#123;        Student student &#x3D; new Student();        student.Speak(string.Empty);    &#125;&#125;</code></pre></div><h2 id="分部方法"><a href="#分部方法" class="headerlink" title="分部方法"></a>分部方法</h2><p><strong>基本概念：</strong><br>将方法的声明和实现分离</p><p><strong>特点：</strong><br>1.不能加访问修饰符  默认private<br>2.只能在分部类中声明<br>3.返回值只能是void<br>4.可以有参数  不能用out关键字</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;声明和实现分到两个分部类里面    partial class Student    &#123;        public bool sex;        public string name;        &#x2F;&#x2F;声明        partial void Speak();    &#125;    &#x2F;&#x2F;一个类 分开写    partial class Student    &#123;        public int number;        &#x2F;&#x2F;实现        partial void Speak()        &#123;            &#x2F;&#x2F;实现逻辑        &#125;    &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运算符重载</title>
    <link href="/2022/05/13/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    <url>/2022/05/13/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<p>运算符重载</p><span id="more"></span><h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>让自定义类和结构体，能够使用运算符<br>关键词 <em>operator</em></p><p><strong>特点：</strong><br>1.一定是一个公共的静态方法<br>2.返回值写在operator前面<br>3.逻辑处理自定义</p><p><strong>作用：</strong><br>让自定义类和结构体对象可以进行运算</p><p><strong>注意：</strong><br>1.条件运算符需要成对实现<br>2.一个符号可以多个重载<br>3.不能使用ref和out</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Point&#123;    public int x;    public int y;    &#x2F;&#x2F;重载+号    public static Point operator +(Point p1, Point p2)    &#x2F;&#x2F;public static 返回类型 operator 运算符(参数列表)    &#123;        Point p &#x3D; new Point();        p.x &#x3D; p1.x + p2.x;        p.y &#x3D; p1.y + p2.y;        return p;    &#125;    &#x2F;&#x2F;+号多个重载    public static Point operator +(Point p1, int value)    &#x2F;&#x2F;public static 返回类型 operator 运算符(参数列表)    &#123;        Point p &#x3D; new Point();        p.x &#x3D; p1.x + value;        p.y &#x3D; p1.y + value;        return p;    &#125;&#125;internal class Program&#123;    static void Main(string[] args)    &#123;        Point p1 &#x3D; new Point();        p1.x &#x3D; 1;        p1.y &#x3D; 1;        Point p2 &#x3D; new Point();        p2.x &#x3D; 2;        p2.y &#x3D; 2;        Point p3 &#x3D; p1 + p2;        Console.WriteLine(&quot;(&#123;0&#125;,&#123;1&#125;)&quot;, p3.x, p3.y);        Point p4 &#x3D; p3 + 2; &#x2F;&#x2F;顺序不能错 一定是先Point类,再int类        Console.WriteLine(&quot;(&#123;0&#125;,&#123;1&#125;)&quot;, p4.x, p4.y);    &#125;&#125;</code></pre></div><h2 id="可重载和不可重载的运算符"><a href="#可重载和不可重载的运算符" class="headerlink" title="可重载和不可重载的运算符"></a>可重载和不可重载的运算符</h2><h3 id="可重载运算符"><a href="#可重载运算符" class="headerlink" title="可重载运算符"></a>可重载运算符</h3><p><strong>算术运算符</strong></p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">+ - * &#x2F; %  ++ --注意: 符号需要两个参数还是一个参数</code></pre></div><p><strong>逻辑运算符</strong></p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;!(逻辑非) &#x2F;&#x2F;注意： &amp;&amp;(逻辑与)和||(逻辑或)不允许重载</code></pre></div><p><strong>位运算符</strong></p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">| &amp; ^ ~ &lt;&lt; &gt;&gt;&#x2F;&#x2F;注意: 符号需要两个参数还是一个参数</code></pre></div><p><strong>条件运算符</strong></p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;&gt; &lt; &#x3D;&gt; &lt;&#x3D; &#x3D;&#x3D; !&#x3D;&#x2F;&#x2F;注意：&#x2F;&#x2F;1.返回值一般是bool值，也可以是其他的&#x2F;&#x2F;2.相关符号必须配对实现(实现了&gt;，就要同时实现&lt;)</code></pre></div><h3 id="不可重载运算符"><a href="#不可重载运算符" class="headerlink" title="不可重载运算符"></a>不可重载运算符</h3><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;逻辑与  &amp;&amp; &#x2F;&#x2F;逻辑或  || &#x2F;&#x2F;索引符  [] &#x2F;&#x2F;强转运算符  () &#x2F;&#x2F;    特殊运算符：&#x2F;&#x2F;    点  .   &#x2F;&#x2F;    三目运算符  ? :   &#x2F;&#x2F;    赋值符号  &#x3D;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/13/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson10_运算符重载&#123;    class Vector2    &#123;        public int x;        public int y;        &#x2F;&#x2F;重载&#x3D;&#x3D;号        public static bool operator &#x3D;&#x3D;(Vector2 v1, Vector2 v2)        &#123;            return v1.x &#x3D;&#x3D; v2.x &amp;&amp; v1.y &#x3D;&#x3D; v2.y;        &#125;        public static bool operator !&#x3D;(Vector2 v1, Vector2 v2)        &#123;            return !(v1.x &#x3D;&#x3D; v2.x &amp;&amp; v1.y &#x3D;&#x3D; v2.y);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Vector2 v1 &#x3D; new Vector2();            v1.x &#x3D; 1;            v1.y &#x3D; 1;            Vector2 v2 &#x3D; new Vector2();            v2.x &#x3D; 1;            v2.y &#x3D; 1;            Console.WriteLine(v1 &#x3D;&#x3D; v2);             &#125;    &#125;&#125;</code></pre></div><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson10_运算符重载&#123;    class Vector3    &#123;        public int x;        public int y;        public int z;        &#x2F;&#x2F;重载&#x3D;&#x3D;号        public static Vector3 operator +(Vector3 v1, Vector3 v2)        &#123;            Vector3 v &#x3D; new Vector3();            v.x &#x3D; v1.x + v2.x;            v.y &#x3D; v1.y + v2.y;            v.z &#x3D; v1.z + v2.z;            return v;        &#125;        public static Vector3 operator -(Vector3 v1, Vector3 v2)        &#123;            Vector3 v &#x3D; new Vector3();            v.x &#x3D; v1.x - v2.x;            v.y &#x3D; v1.y - v2.y;            v.z &#x3D; v1.z - v2.z;            return v;        &#125;        public static Vector3 operator *(Vector3 v1, int num)        &#123;            Vector3 v &#x3D; new Vector3();            v.x &#x3D; v1.x * num;            v.y &#x3D; v1.y * num;            v.z &#x3D; v1.z * num;            return v;        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Vector3 v1 &#x3D; new Vector3();            v1.x &#x3D; 1;            v1.y &#x3D; 1;            v1.z &#x3D; 1;            Vector3 v2 &#x3D; new Vector3();            v2.x &#x3D; 2;            v2.y &#x3D; 3;            v2.z &#x3D; 4;            int num &#x3D; 8;            Vector3 v3 &#x3D; v1 + v2;            Vector3 v4 &#x3D; v2 - v1;            Vector3 v5 &#x3D; v2 * num;            Console.WriteLine(&quot;(&#123;0&#125;,&#123;1&#125;,&#123;2&#125;)&quot;, v3.x, v3.y, v3.z);            Console.WriteLine(&quot;(&#123;0&#125;,&#123;1&#125;,&#123;2&#125;)&quot;, v4.x, v4.y, v4.z);            Console.WriteLine(&quot;(&#123;0&#125;,&#123;1&#125;,&#123;2&#125;)&quot;, v5.x, v5.y, v5.z);        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月13日</title>
    <link href="/2022/05/13/diary/2022.5/2022%E5%B9%B45%E6%9C%8813%E6%97%A5/"/>
    <url>/2022/05/13/diary/2022.5/2022%E5%B9%B45%E6%9C%8813%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="fbbcf625d92544d5df3d44ac542131102feb9fbd15ca0852893ab5901da2fb32">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe506e3bbc3039a6aa643d94bba3c0a5944c3000ff7fa000df3927de73467607197ccec9c66374b92e0f81e072804d501535ac8a7eee38888c5007151c617ed82a1c690e4dc1ef4fb47045f82e89006f717a7fb19e7fefab38085a7c62a562c58058bf9d677ec961e8e15822a354247ec0e624c42d79405ffe28ce71a51aacae688bb936e022fecfb2ecfc36563a50b5f41e97ba7f934c2ca7f5542947fb8d4a938ae8944e924ee5988f12041e8d0a3d134c4a4682d64469a108efbd6aa9dcff6427a92707e97e5beffd53d975af6795abf99626a3245a0775a6b35f8ed7fb4bfa3f30463a3dba02cc1ee1c56eefbc194d89d375241ac45a8092772f7db8b0384232e7162edb46f6c33c653599b2a8128c2e5d223148acbe13645425ee432503346889e5e855cfd087ec0bc1b7b454da62c9a90b1fc994336a1cbc735840d8c98ee5c179c40db6109dbb0c123c5888ddfbe715d767a27721a0bbb9ee40f78c73cff0ee758852160fce56837f4a32e03a7ae9e7b3398acb7478f0a4bf9d7a7c7f1ae3cab150d6706b3859ddac575996a5721ffd7b3930bde3c123bba298a1c6fa98fface1bd4ed49ec04c0241982205786343795dd0482c0d4c80b5691109ca44c4b07d3185f743ec26540bb02060a8126e26f279136fa6f1c74ed4bc41e95b9e434537275a52003e00fd238ef9cb11ea6d459f4c21295d76ab8eebd82be04c1a8d2ef5c46043ff2055d7a45099e20ba75faaf138b11b17b64d0a4b28ba720dca9f1ba7ce739caa825bb45f67b2640ba0abb60d53b70937bdc4bf79f7d76e32dc7fbc0dd50acb69f5af9b7b94b60d5177c23cb9efa1340dc928b561ed3148271b6d878faf99333dbaa728d3faca0d734dc24fd63928bca1d918a25f3f1ff289ba1b2d4a3009ebb7d9d6b6bb8b11792514e5961223a2f8a7c6aa0de8a4073023b171622416a26a79947fa1dd6a4d9c885223d70a243a9e8417c84b7db48fcbf5dfdadc</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拓展方法</title>
    <link href="/2022/05/12/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95/"/>
    <url>/2022/05/12/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>拓展方法</p><span id="more"></span><h1 id="拓展方法"><a href="#拓展方法" class="headerlink" title="拓展方法"></a>拓展方法</h1><p><strong>基本概念：</strong><br>为现有<strong>非静态</strong>的变量类型 添加新方法</p><p><strong>作用：</strong><br>1.提升程序拓展性<br>2.不需要在对象中重新写方法<br>3.不需要继承来添加方法<br>4.为别人封装的类型写额外的方法</p><p><strong>特点：</strong><br>1.一定是写在静态类中<br>2.一定是一个静态函数<br>3.第一个参数为拓展目标<br>4.第一个参数用this修饰</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;声明static class Tools&#123;    &#x2F;&#x2F;访问修饰符 static 返回值 函数名(this 拓展类名 参数名, 参数类型 参数名, 参数类型 参数名, ......)    public static void SpeakValue(this int value)    &#x2F;&#x2F;为int拓展了一个成员方法    &#x2F;&#x2F;成员方法 是需要实例化对象后 才能使用的    &#x2F;&#x2F;value 代表使用该方法的 实例化对象    &#123;        &#x2F;&#x2F;拓展的方法的逻辑        Console.WriteLine(&quot;为int拓展的方法&quot; + value);    &#125;    public static void SpeakStringInfo(this string str, string str2, string str3)    &#x2F;&#x2F;为string拓展了一个成员方法    &#x2F;&#x2F;str 代表使用该方法的 实例化对象    &#x2F;&#x2F;str2, str3 代表传进去的参数    &#123;        Console.WriteLine(&quot;为string拓展的方法&quot;);        Console.WriteLine(&quot;调用方法的对象&quot; + str);        Console.WriteLine(&quot;传的参数&quot; + str2 + str3);    &#125;&#125;&#x2F;&#x2F;使用internal class Program&#123;    static void Main(string[] args)    &#123;        &#x2F;&#x2F;i就是int这一拓展类 实例化的对象        int i &#x3D; 10;        i.SpeakValue();        &#x2F;&#x2F;str就是string这一拓展类 实例化的对象        string str &#x3D; &quot;000&quot;;        str.SpeakStringInfo(&quot;111&quot;, &quot;222&quot;);    &#125;&#125;</code></pre></div><h2 id="为自定义的类型拓展方法"><a href="#为自定义的类型拓展方法" class="headerlink" title="为自定义的类型拓展方法"></a>为自定义的类型拓展方法</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;声明static class Tools&#123;    public static void Fun3(this Test t)    &#x2F;&#x2F;为Test类的t拓展了一个成员方法    &#123;        Console.WriteLine(&quot;为test拓展的方法&quot;);    &#125;&#125;class Test&#123;    public int i &#x3D; 10;    public void Fun1()    &#123;        Console.WriteLine(&quot;123&quot;);    &#125;    public void Fun2()    &#123;        Console.WriteLine(&quot;456&quot;);    &#125;&#125;&#x2F;&#x2F;使用internal class Program&#123;    static void Main(string[] args)    &#123;        Test t &#x3D; new Test();        t.Fun3();    &#125;&#125;</code></pre></div><p><strong>注意：</strong><br>拓展方法名若和原有方法名相同，会默认使用原有方法名</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/12/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson9_拓展方法&#123;    &#x2F;&#x2F;为整形拓展一个求平方的方法    static class Tools    &#123;        &#x2F;&#x2F;平方返回值int        public static int Square(this int value)        &#123;            return value * value;        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Console.Write(&quot;请输入一个整数：&quot;);            int i &#x3D; int.Parse(Console.ReadLine());            Console.WriteLine(&quot;它的平方是&#123;0&#125;&quot;, i.Square());        &#125;    &#125;&#125;</code></pre></div><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson9_拓展方法&#123;    &#x2F;&#x2F;声明一个玩家类    &#x2F;&#x2F;因为没写敌人，逻辑写的简单点    class Player    &#123;        public string Name &#123; get; set; &#125;        public int Hp &#123; get; set; &#125;        public int Atk &#123; get; set; &#125;        public int Def &#123; get; set; &#125;        &#x2F;&#x2F;攻击方法        public void Attack()        &#123;            &#x2F;&#x2F;攻击能提升气势，增加攻击力            Atk +&#x3D; 1;        &#125;        &#x2F;&#x2F;移动方法        public void Move()        &#123;            &#x2F;&#x2F;移动就会找到宝箱打开，要么获得武器，要么获得防具            Random r &#x3D; new Random();            &#x2F;&#x2F;一半概率为武器            if(r.Next(1, 101) &lt;&#x3D; 50)            &#123;                Atk +&#x3D; 50;            &#125;            &#x2F;&#x2F;一半概率为防具            else            &#123;                Def +&#x3D; 50;            &#125;        &#125;        &#x2F;&#x2F;受伤方法        public void Injured()        &#123;            &#x2F;&#x2F;受伤掉5血            Hp -&#x3D; 5;        &#125;    &#125;    &#x2F;&#x2F;为玩家拓展一个自杀的方法    static class Tools    &#123;        public static void Suicide(this Player p)        &#123;            p.Hp &#x3D; 0;        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Player p &#x3D; new Player();            p.Name &#x3D; &quot;大逼&quot;;            p.Hp &#x3D; 100;            p.Atk &#x3D; 10;            p.Def &#x3D; 10;            p.Attack();            p.Move();            p.Injured();            if(p.Hp &gt; 0)            &#123;                Console.WriteLine(&quot;&#123;0&#125;现在的状态为血量&#123;1&#125;,攻击力&#123;2&#125;,防御力&#123;3&#125;&quot;, p.Name, p.Hp, p.Atk, p.Def);            &#125;            else if (p.Hp &lt;&#x3D; 0)            &#123;                Console.WriteLine(&quot;&#123;0&#125;已死亡&quot;, p.Name);            &#125;            p.Suicide();            if (p.Hp &gt; 0)            &#123;                Console.WriteLine(&quot;&#123;0&#125;现在的状态为血量&#123;1&#125;,攻击力&#123;2&#125;,防御力&#123;3&#125;&quot;, p.Name, p.Hp, p.Atk, p.Def);            &#125;            else if (p.Hp &lt;&#x3D; 0)            &#123;                Console.WriteLine(&quot;&#123;0&#125;已死亡&quot;, p.Name);            &#125;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>静态类和静态构造函数</title>
    <link href="/2022/05/12/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E9%9D%99%E6%80%81%E7%B1%BB%E5%92%8C%E9%9D%99%E6%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <url>/2022/05/12/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E9%9D%99%E6%80%81%E7%B1%BB%E5%92%8C%E9%9D%99%E6%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>静态类和静态构造函数</p><span id="more"></span><h1 id="静态类和静态构造函数"><a href="#静态类和静态构造函数" class="headerlink" title="静态类和静态构造函数"></a>静态类和静态构造函数</h1><h2 id="静态类"><a href="#静态类" class="headerlink" title="静态类"></a>静态类</h2><p><strong>基本概念：</strong><br>用static修饰的类</p><p><strong>特点：</strong><br>1.只能包含静态成员<br>2.不能被实例化</p><p><strong>作用：</strong><br>1.将常用的静态成员写在静态类中 方便使用<br>2.静态类不能被实例化，更能体现工具性、唯一性<br>    Console就是一个静态类</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">static class TestStatic&#123;    &#x2F;&#x2F;静态成员变量    public static int testIndex &#x3D; 0;    public static void TestFun()    &#123;    &#125;     public static int TestIndex()    &#123;        get;        set;    &#125; </code></pre></div><h2 id="静态构造函数"><a href="#静态构造函数" class="headerlink" title="静态构造函数"></a>静态构造函数</h2><p><strong>基本概念：</strong><br>在构造函数前加上 static 修饰</p><p><strong>特点：</strong><br>1.静态类和普通类都可以有<br>2.不能使用访问修饰符<br>3.不能有参数<br>4.只会自动调用一次</p><p><strong>作用：</strong><br>在静态构造函数中初始化 静态变量</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F;静态类中的静态构造函数static class StaticClass&#123;    public static int testInt &#x3D; 100;    public static int testInt2 &#x3D; 100;    static StaticClass()    &#123;        &#x2F;&#x2F;只会在初次使用的时候 调用一次        Console.WriteLine(&quot;静态构造函数&quot;);        testInt &#x3D; 200;        testInt2 &#x3D; 200;    &#125; &#125;&#x2F;&#x2F;普通类中的静态构造函数class Test&#123;    public static int testInt &#x3D; 200;    static Test()    &#123;        Console.WriteLine(&quot;静态构造&quot;);    &#125;    &#x2F;&#x2F;这不是重载 这是两个不同的函数    public Test()    &#123;        Console.WriteLine(&quot;普通构造&quot;);    &#125;&#125;</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/12/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E9%9D%99%E6%80%81%E7%B1%BB%E5%92%8C%E9%9D%99%E6%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/exam.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson8_静态类和静态构造函数&#123;    &#x2F;&#x2F;数学计算静态类    static class Calc    &#123;        public static float PI &#x3D;3.145926f;        &#x2F;&#x2F;计算圆的面积        public static float CircleS(int r)        &#123;            return PI * r * r;        &#125;        &#x2F;&#x2F;计算圆的周长        public static float CircleL(int r)        &#123;            return PI * r * 2;        &#125;        &#x2F;&#x2F;计算矩形的面积        public static float RectangleS(int l, int w)        &#123;            return l * w;        &#125;        &#x2F;&#x2F;计算矩形的周长        public static float RectangleL(int l, int w)        &#123;            return 2 * (l + w);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;半径为3的圆面积是&#123;0&#125;&quot;, Calc.CircleS(3));            Console.WriteLine(&quot;半径为3的圆周长是&#123;0&#125;&quot;, Calc.CircleL(3));            Console.WriteLine(&quot;长为3宽为3的矩形面积是&#123;0&#125;&quot;, Calc.RectangleS(3, 3));            Console.WriteLine(&quot;长为3宽为3的矩形周长是&#123;0&#125;&quot;, Calc.RectangleL(3, 3));        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月12日</title>
    <link href="/2022/05/12/diary/2022.5/2022%E5%B9%B45%E6%9C%8812%E6%97%A5/"/>
    <url>/2022/05/12/diary/2022.5/2022%E5%B9%B45%E6%9C%8812%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="47086273676309be83d13ebf8531401cb49a8ccdda44fe7c8408cdc31541cc67">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50d4c0829a8a79ea3b44ecdd1bc8d55452e14aee12c337910927f5586d86733e9c3714b8aa46a90f5ded03e2919eb7614b695a0defcfad29d72d9fcfb60b9a437a5403c1eeec2e3e33f690b3cdb7fe7ae97b097ece43cf2a91a788c9800b918b96c17dd030ffe3e2ee254e2ac8f2f59236a40efc463d7d1d719a71e712b95464d87f3e14cbaee92305d40e4e481607d532adcec9cadd867b270ddef2ed9b5ad73363f75850d84bf94087e64271ad395f78ec0294fcadb5807d41320f2c5a4fc76630450a90fceff0a9351a1edd839bf9c49a772721b3e6b99aa6c4a0bc89feb62302d8cfc53da2668d8273ddc4b64c745112fe1a8e8a6b8f1d4d122b8208c876f98422264e038d11aa0a4704699e55c8ae5cd539cb0d194fbf458de5ec565a98404dd22f79e5625560e96e5da2e55ba40ee78a6d266d650e4a3ba21d1185e923a86bc36f92c6102984f06fc7f47e7dabdb159291fcda490e00e5c7d3e3de468a28a65248959ee48c271e2d95d3f58bae3c4cb98b0c911c8e707dd25c217de9097a64b34a6284a9f65441a293f4916d0ed9b3b4cf2f4056225d69dd940d84056c84aabe61a6ca24c348e4dd1b5d93e781206a6d3f90eb452b423afbd1cd04e4dfcddc793b67a9c86f5e917d82589608211d35814276204742e06b492502b2ae227732d578d7d7978ead2bfdfdab2db230d0ecec5474b7dfc27f8d082b62b0eebae1092b70feb859c5aad66ef15c180e012c3a5a375f4673be58ee2044af07f50fef</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>静态成员</title>
    <link href="/2022/05/11/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/"/>
    <url>/2022/05/11/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/</url>
    
    <content type="html"><![CDATA[<p>静态成员</p><span id="more"></span><h1 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>基本关键字： static<br>用static修饰的成员变量、方法、属性等的成为静态成员</p><p>特点：直接用类名点出使用<br>Console就是一个静态类</p><h2 id="声明静态成员变量-及-使用"><a href="#声明静态成员变量-及-使用" class="headerlink" title="声明静态成员变量 及 使用"></a>声明静态成员变量 及 使用</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Test&#123;    &#x2F;&#x2F;public和static 前后无所谓    public static float PI &#x3D; 3.1415926f;    &#x2F;&#x2F;成员变量    public int testInt &#x3D; 100;    &#x2F;&#x2F;静态成员方法    public static float CalcCricle(float r)    &#123;        return PI * r * r;    &#125;    &#x2F;&#x2F;普通成员方法    public void TestFun()    &#123;        Console.WriteLine(&quot;123&quot;);    &#125;&#125;internal class Program&#123;    static void Main(string[] args)    &#123;        &#x2F;&#x2F;类名.静态成员变量  不需要实例化        Console.WriteLine(Test.PI);        Console.WriteLine(Test.CalcCricle(2));    &#125;&#125;</code></pre></div><h2 id="为什么可以直接点出来使用"><a href="#为什么可以直接点出来使用" class="headerlink" title="为什么可以直接点出来使用"></a>为什么可以直接点出来使用</h2><p><strong>程序中是不能无中生有的</strong><br>需要使用的对象，变量，函数都是要在内存中分配内存空间的<br>之所以要实例化对象，目的就是分配内存空间，在程序中产生一个抽象的对象</p><p><strong>静态成员的特点</strong><br>程序开始运行时，就会分配内存空间，得以直接使用<br>静态成员和程序是同生共死的<br>只要使用了它，知道程序结束时才会被释放<br>所以一个静态成员就会有自己唯一的一个“内存小房间”<br>这让静态成员就有了唯一性<br>在任何地方使用都是用的小房间里的内容，改变了它也是改变小房间里的内容</p><h2 id="静态函数非静态成员-x2F-非静态函数静态成员"><a href="#静态函数非静态成员-x2F-非静态函数静态成员" class="headerlink" title="静态函数非静态成员&#x2F;非静态函数静态成员"></a>静态函数非静态成员&#x2F;非静态函数静态成员</h2><p>成员变量只能将对象实例化出来后，才能点出来使用，不能无中生有<br>不能直接使用非静态函数，否则会报错<br><strong>静态函数中不可以直接使用非静态成员</strong><br><strong>非静态函数中可以直接使用静态成员</strong></p><h2 id="静态成员对于我们的作用"><a href="#静态成员对于我们的作用" class="headerlink" title="静态成员对于我们的作用"></a>静态成员对于我们的作用</h2><p>静态变量：<br>1.常用唯一变量的声明<br>2.方便别人获取的对象声明</p><p>静态方法：<br>常用的唯一的方法声明<br>比如：相同规则的数学计算相关函数</p><h2 id="常量和静态变量"><a href="#常量和静态变量" class="headerlink" title="常量和静态变量"></a>常量和静态变量</h2><p>const 可以理解为特殊的 static<br><strong>相同点：</strong><br>他们都可以通过类名.点出使用<br><strong>不同点：</strong><br>1.const必须初始化，不能修改; static没有这个规则<br>2.const只能修饰变量; static可以修饰很多(成员方法等)<br>3.const一定是写在访问修饰符后面的(3P后面); static没有这个要求</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/11/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/exam.png" class=""><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><p>const与static<br><strong>相同点：</strong><br>他们都可以通过类名.点出使用<br><strong>不同点：</strong><br>1.const必须初始化，不能修改; static没有这个规则<br>2.const只能修饰变量; static可以修饰很多(成员方法等)<br>3.const一定是写在访问修饰符后面的(3P后面); static没有这个要求</p><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson7_静态成员&#123;    class Sign    &#123;        static public float PI &#x3D; 3.1415926f;     &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Console.WriteLine(Sign.PI);        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月11日</title>
    <link href="/2022/05/11/diary/2022.5/2022%E5%B9%B45%E6%9C%8811%E6%97%A5/"/>
    <url>/2022/05/11/diary/2022.5/2022%E5%B9%B45%E6%9C%8811%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="be939b2d46b025fbe51dda7ebc66eb6271595024478834df5326db5e8a7da3dc">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50fdd0ca3edc57389bd0e88084b7db20234fb2de3fa3c9a49542ad620f534d4c6e8804b5584cdb8a3a926d0211e1b7b90f05911c848b71e690820b0e3332e95fad55a6e09296d83f6fd1172e898d38e42fc5120c6e43033e1dc9c18617ad7dba07711204ac566923a7a8304d26e7a85f0d4ab1f4723f9f438238aa5ddac250ed8355d8d3527506f07dfd520b6167bebf871cf18cdd5cf564666be28c4440538f6f79d479958ef3a03f075fe85795cf78c2c12fcc4efa9a49164816d35a9b6372411d9d299dbcc975918b4d7c4da0b245618bab46a297ced7f824309379cc6a17c9aaa6ef3479e43de57e395a27f79b202c193ed0f2be4867cada9a531d21b90b143b1236b0844635a44489d87b697751a511078032a4b7a8fd536a48b596443d23263e3caa7dd54296e15e800906aaa59cfc8e3f00c155bfa37c4ec958a344d1a9679ef17acc595fbeaa39efda24bb6f3a1dde15ba83d0a37cdcfe54f0fc73c6df01b31a90e0fe630e2e12e91d51c77b28f2910f789c5ec86ccd159ae101df43b862dc109a5349722974f72ad943e4c063bc0915fd0832cef7177d7db854a03be58765284c7dce461b8794b9351c6a095b652363351b8e51bd5c6ee525d89e2495d22e1cf1836d8adce598bd290ab8ed8db3faa0a832330ec53822a8cdeabc004a08f534bebdb18aa4c9fd05091dc25187b765091a6af31af5c55cf0cb9c93bd5681fd881235835189265394eeba7d97dd000f1440b6f12fd081a16140c65edc561244f3fa16c584e4e06a5311ab55eebaf19f8c95ee5d640f2887b9ba44b828f3e4237a8b0526729dc9ba67f983f6699337100b0f7fcdbda2a778b1a3dcc5124d6cfbfbb4df9fc1f89d4e359b63bbf8ec80e0fec225b24507cef06a04aa25d7df615b83c5a78caa61402d182e95f9dee72067b1a81afbbb8cbb7045cd7b02445b069008912a6330aedccae24a60475f9ce24c741d5d09366a6472c21e6c65d882b774b2508ca4f85ba854a7199b591093e5946691cd81fb86b491ef34fc95df39ffb5a513764716585dfd60a7bc577c7ce0579ea76b8bf34b866e164d431d6acb2fdc68eb6825257097c80a492fffb411487e4bba652cc0d340dd72ca4e6b2dace8000a7a4dc784f4ecd633bb3b24ade405ae5b499deae99c18b039fc774cdcc825a4b83d59e4a555f60dfaaa69fd211a5c91ae0b15021bf6426ee07b3ac4eff79054ac0153db9710165013fc0b35cc46a6dba8d5b9fce00406d8212b86b4098f431390d59c7cb0e1c19e7289b001b2d334b128771862514bbfc9c12adc676b4f80abc66d81a163786912f2f1f4e7afc23197f74aef80ed5ee42f50ef28bcbe978d9833ac30a2b8c111dc712634d829e8942dfb81d23bd77661e442cde919e1a298a3c891fd14f474b9cb57d809901de545d228c545b46f7d97f7b9f445bca7ecd6b3f3d39f5bc94e8578caa87644f54d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>索引器</title>
    <link href="/2022/05/11/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E7%B4%A2%E5%BC%95%E5%99%A8/"/>
    <url>/2022/05/11/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E7%B4%A2%E5%BC%95%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>索引器</p><span id="more"></span><h1 id="索引器"><a href="#索引器" class="headerlink" title="索引器"></a>索引器</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>让对象可以像数组一样通过索引访问其中元素<br>使程序看起来更直观，更容易编写</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Person&#123;    private string name;    private int age;    private Person[] friends;    &#x2F;&#x2F;访问修饰符 返回值 this[参数类型 参数名, 参数类型 参数名, ......]    public Person this[int index]    &#123;        get        &#123;            return friends[index];        &#125;        set        &#123;            friends[index] &#x3D; value;        &#125;    &#125;&#125;</code></pre></div><h2 id="索引器的使用"><a href="#索引器的使用" class="headerlink" title="索引器的使用"></a>索引器的使用</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Person p &#x3D; new Person();p[0] &#x3D; new Person();</code></pre></div><h2 id="索引器中可以写逻辑"><a href="#索引器中可以写逻辑" class="headerlink" title="索引器中可以写逻辑"></a>索引器中可以写逻辑</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Person&#123;    private string name;    private int age;    private Person[] friends;    public Person this[int index]    &#123;        get        &#123;            if(friends &#x3D;&#x3D; null ||                friends.Length - 1 &lt; index)            &#123;                return null;            &#125;            return friends[index];        &#125;        set        &#123;            if(friends &#x3D;&#x3D; null)            &#123;                friends &#x3D; new Person[] &#123; value &#125;;            &#125;            else if(index &gt; friends.Length - 1)            &#123;                &#x2F;&#x2F;自己定了一个规则 如果索引越界 就默认把最后一个朋友顶掉                friends[friends.Length - 1] &#x3D; value;            &#125;            friends[index] &#x3D; value;        &#125;    &#125;&#125;</code></pre></div><h2 id="索引器可以重载"><a href="#索引器可以重载" class="headerlink" title="索引器可以重载"></a>索引器可以重载</h2><p>重载的概念是：函数名相同，参数类型、数量、顺序不同</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Person&#123;    private string name;    private int age;    private Person[] friends;    private int[,] array;    &#x2F;&#x2F;重载this    public int this[int i, int j]    &#123;        get        &#123;            return array[i, j];        &#125;        set        &#123;            array[i, j] &#x3D; value;        &#125;    &#125;    public int this[string str]    &#123;        get        &#123;            switch(str)            &#123;                case &quot;name&quot;:                    return this.name;                case &quot;age&quot;:                    return age.ToString();            &#125;            return &quot;&quot;;        &#125;    &#125;    public Person this[int index]    &#123;        get        &#123;            return friends[index];        &#125;        set        &#123;            friends[index] &#x3D; value;        &#125;    &#125;&#125;</code></pre></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>索引器的作用：<br>1.以中括号的形式访问自定义类中的元素<br>2.规则自己定，访问时与数组相同<br>3.比较适用于，在类中有数组变量时使用，可以方便地访问和进行逻辑处理</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/11/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E7%B4%A2%E5%BC%95%E5%99%A8/exam.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson6_索引器&#123;    class Num    &#123;        private int[] number &#x3D; new int[5];        &#x2F;&#x2F;用索引器由外部定义数组        public int this[int index]        &#123;            get            &#123;                return number[index];            &#125;            set            &#123;                number[index] &#x3D; value;            &#125;        &#125;        &#x2F;&#x2F;增        public void Add(Num arr, int num)        &#123;            int[] number1 &#x3D; new int[arr.number.Length + 1];            for (int i &#x3D; 0; i &lt; arr.number.Length; i++)            &#123;                number1[i] &#x3D; arr.number[i];            &#125;            number1[number.Length] &#x3D; num;            arr.number &#x3D; number1;            &#x2F;&#x2F;因为number数组是private类型 只能在类内直接打印            for (int i &#x3D; 0; i &lt; arr.number.Length; i++)            &#123;                Console.WriteLine(arr.number[i]);            &#125;        &#125;        &#x2F;&#x2F;查        public int Search(Num arr, int num)        &#123;            &#x2F;&#x2F;暴力遍历寻找            for (int i &#x3D; 0; i &lt; arr.number.Length; i++)            &#123;                if(arr.number[i] &#x3D;&#x3D; num)                &#123;                    &#x2F;&#x2F;找到输出位置                    return i;                &#125;            &#125;            &#x2F;&#x2F;找不到输出-1            return -1;        &#125;        &#x2F;&#x2F;删        public void Del(Num arr, int num)        &#123;                 if(arr.Search(arr, num) !&#x3D; -1)            &#123;                for (int i &#x3D; arr.Search(arr, num); i &lt; arr.number.Length - 1; i++)                &#123;                    arr.number[i] &#x3D; arr.number[i + 1];                &#125;                arr.number[arr.number.Length - 1] &#x3D; 0;                Console.WriteLine(&quot;删除成功&quot;);             &#125;            else            &#123;                Console.WriteLine(&quot;没有您想要删的数，删除失败&quot;);            &#125;        &#125;        &#x2F;&#x2F;改  num1改成num2        public void Change(Num arr, int num1, int num2)        &#123;            if (arr.Search(arr, num1) !&#x3D; -1)            &#123;                arr.number[arr.Search(arr, num1)] &#x3D; num2;                Console.WriteLine(&quot;修改成功&quot;);            &#125;            else            &#123;                Console.WriteLine(&quot;没有您想要改的数，修改失败&quot;);            &#125;        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            &#x2F;&#x2F;初始化数组            Num arr &#x3D; new Num();            arr[0] &#x3D; 1;            arr[1] &#x3D; 15;            arr[2] &#x3D; 8;            arr[3] &#x3D; 11;            arr[4] &#x3D; 7;            &#x2F;&#x2F;增            arr.Add(arr, 9);            &#x2F;&#x2F;删            arr.Del(arr, 1);            arr.Del(arr, 10);            &#x2F;&#x2F;查            int n &#x3D; int.Parse(Console.ReadLine());            Console.WriteLine(&quot;您想找的数&#123;0&#125;在数组的第&#123;1&#125;位&quot;, n, arr.Search(arr, n) + 1);            &#x2F;&#x2F;改            arr.Change(arr, 9, 66);        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月10日</title>
    <link href="/2022/05/10/diary/2022.5/2022%E5%B9%B45%E6%9C%8810%E6%97%A5/"/>
    <url>/2022/05/10/diary/2022.5/2022%E5%B9%B45%E6%9C%8810%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="2ddfa4cdb3dfb32c5fbb8b9cfd6b6cc0eb8d56c4388893dc14dc7b42bd66d8f9">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50dc870b27b76d3b90c48267d59720f330ba0b7dd5ba881f78758bd2db60f83bb0d35cfaad6b2af34092909565a0195bbaf9ddf7e87d31f7e3c318a88e076cd535bc3fd7aef531751c0f5540593857d91bf4f4f42c93a1a325bb77fdff723b1d82ed1ac68e49f561d1a5093b552d4a42666b95c0a5c9d743ebb28ae48ca585f01534d411ce08eef72296f210475df0ca550c05b75f3c1eb74f226d6af71c454bb96a1aba1e58da61afaf8eeaf2907d94fa1e9555a3792ff62334f2a9eaf61c3f027ffed6813cadc0399eadfea2b935a68335d58afe75057d7614f357a4212eef2dc3774a8c9201fdfb665652c7acd463739060ae2cbe6ad90601a3d58a244f934fbe883f30bbb93ef033c2d58595bdc82c7d8306797e04393478f4eb5c9fd1ceca96044ac94374ae50576701164e85cd1f916154344e38cecb6ac6f9b89f2b76e37a32944ade07db98218ed0d4b88aec24ec0bb24f5854b591864e532171f4507fd5db68ed4e036a915717798e230bc24358f992ef8ba87fc956fbf188a8b78eedc631939617f9a1d4a331c792ef8a623914ce541812bcc59cce1dca10cba76641c18337cbe782ff0c553e2ab7c304d7aff49827b2585c8d20568ab64e66294d9f7701d7d4b269f79f2aae01584a72ff7c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>成员属性</title>
    <link href="/2022/05/10/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7/"/>
    <url>/2022/05/10/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>成员属性</p><span id="more"></span><h1 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>1.用于保护成员变量<br>2.为成员属性的获取和赋值添加逻辑处理<br>3.解决3P的局限性<br>    public - 内外访问<br>    private - 内部访问<br>    protected - 内部和子类访问<br>属性可以让成员变量在外部 <strong>只能获取不能修改</strong> 或 <strong>只能修改不能获取</strong></p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Person&#123;    private string name;    &#x2F;&#x2F;属性的命名一般使用 帕斯卡命名法    &#x2F;&#x2F;访问修饰符 属性类型 属性名    public string Name    &#123;        get        &#123;            &#x2F;&#x2F;可以在返回前添加一下逻辑规则（解密）            &#x2F;&#x2F;get意味着这个属性可以获取的内容 需要return内容            return name;        &#125;        set        &#123;            &#x2F;&#x2F;可以在设置前添加一下逻辑规则（加密）            &#x2F;&#x2F; value 关键字 用于表示外部传入的值            name &#x3D; value;                         &#125;    &#125;&#125;  </code></pre></div><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Person p &#x3D; new Person();p.Name &#x3D; &quot;季宝&quot;;</code></pre></div><h2 id="get和set前可以加访问修饰符"><a href="#get和set前可以加访问修饰符" class="headerlink" title="get和set前可以加访问修饰符"></a>get和set前可以加访问修饰符</h2><p><strong>解决3P局限性</strong><br>1.默认不加 会使用属性声明时的访问权限<br>2.加的访问修饰符要低于属性的访问权限（public的访问权限是最高级的）<br>3.不能让get和set的访问权限都低于属性的权限（逻辑上外部的访问修饰符无效，报错）</p><h2 id="get和set只能有一个"><a href="#get和set只能有一个" class="headerlink" title="get和set只能有一个"></a>get和set只能有一个</h2><p>只有一个时 没有必要在前面加访问修饰符<br>且一般只有get 没有set</p><h2 id="自动属性"><a href="#自动属性" class="headerlink" title="自动属性"></a>自动属性</h2><p>属性语句块中只有get和set<br><strong>作用：</strong><br>外部能得不能改的特征<br>如果类中有一个特征是只希望外部能得不能改的 又没有什么特别处理<br>那么可以直接使用自动属性</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Person&#123;    private Height;    &#x2F;&#x2F;不用专门去声明成员变量 直接通过属性来表示特殊的成员变量    public float Height    &#123;        &#x2F;&#x2F;没有在get和set中写逻辑的需求或者想法        get;        set;    &#125;    &#x2F;&#x2F;等价于    public float Height &#123; get; set; &#125;&#125;  </code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/10/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7/exam.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson5_成员属性&#123;    class Student    &#123;        private string name;        private string sex;        private int age;        private int csharpScore;        private int unityScore;        public string Name &#123; get; set; &#125;        public string Sex         &#123;             get            &#123;                if (sex !&#x3D; &quot;男&quot; &amp;&amp; sex !&#x3D; &quot;女&quot;)                &#123;                    Console.WriteLine(&quot;请输入正确的性别,默认男&quot;);                    return &quot;男&quot;;                &#125;                else                &#123;                    return sex;                &#125;                            &#125;            set            &#123;                sex &#x3D; value;            &#125;        &#125;        public int Age         &#123;             get            &#123;                return age;                &#125;            set            &#123;                if (value &gt;&#x3D; 0 &amp;&amp; value &lt;&#x3D; 150)                &#123;                    age &#x3D; value;                &#125;                else                &#123;                    Console.WriteLine(&quot;请输入0~150之间的年龄,默认20&quot;);                    age &#x3D; 20;                &#125;               &#125;        &#125;        public int CSharpScore        &#123;            get            &#123;                if (csharpScore &gt;&#x3D; 0 &amp;&amp; csharpScore &lt;&#x3D; 150)                &#123;                    return csharpScore;                &#125;                else                &#123;                    Console.WriteLine(&quot;请输入0~100之间的成绩,默认60&quot;);                    return 60;                &#125;            &#125;            set            &#123;                csharpScore &#x3D; value;            &#125;        &#125;        public int UnityScore        &#123;            get            &#123;                if (unityScore &gt;&#x3D; 0 &amp;&amp; unityScore &lt;&#x3D; 150)                &#123;                    return unityScore;                &#125;                else                &#123;                    Console.WriteLine(&quot;请输入0~100之间的成绩,默认60&quot;);                    return 60;                &#125;            &#125;            set            &#123;                unityScore &#x3D; value;            &#125;        &#125;        public void Hello1()        &#123;            Console.WriteLine(&quot;我叫&#123;0&#125;,今年&#123;1&#125;岁了&quot;, Name, Age);        &#125;        public void Hello2()        &#123;            Console.WriteLine(&quot;我是&#123;0&#125;生,我的总分是&#123;1&#125;,平均分是&#123;2&#125;&quot;, Sex, CSharpScore + UnityScore, (CSharpScore + UnityScore)&#x2F;2);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Student s1 &#x3D; new Student();            s1.Name &#x3D; &quot;季宝&quot;;            s1.Sex &#x3D; &quot;男&quot;;            s1.Age &#x3D; 170;            s1.CSharpScore &#x3D; 80;            s1.UnityScore &#x3D; 80;            s1.Hello1();            s1.Hello2();            Student s2 &#x3D; new Student();        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>封装_构造函数和析构函数</title>
    <link href="/2022/05/10/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E5%B0%81%E8%A3%85-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
    <url>/2022/05/10/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E5%B0%81%E8%A3%85-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>封装_构造函数和析构函数</p><span id="more"></span><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>在实例化对象时 会调用的用于初始化的函数<br>（如果不写 默认存在一个无参构造函数）</p><h2 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h2><p>1.没有返回值<br>2.函数名和类名必须相同<br>3.没有特殊需求时，一般都是public的<br>4.构造函数可以被重载<br>5.this代表当前调用该函数的对象自己</p><h2 id="特殊写法"><a href="#特殊写法" class="headerlink" title="特殊写法"></a>特殊写法</h2><p>可以通过this 重用构造函数代码</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">访问修饰符 构造函数名(参数列表):this(参数1,参数2......)</code></pre></div><p>即该构造函数会先执行this所代表的构造函数，再执行自己的逻辑</p><p><strong>注意</strong><br>1.类中是允许自己声明无参构造函数的，结构体是不允许的<br>2.如果不自己实现无参构造函数而实现了有参构造函数，会失去默认的无参构造函数</p><h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p>当<strong>引用类型的堆内存被回收</strong>时，会调用该函数<br>对于需要手动管理内存的语言(比如c++)，需要在析构函数中做一些内存回收处理<br>但是c#中存在垃圾回收机制GC<br>所以几乎不会怎么使用析构函数，除非需要对某一个对象被垃圾回收时，做一些特殊处理</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">~类名()&#123;&#125;</code></pre></div><h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><p>垃圾回收(GC,Garbage Collector)<br>1.垃圾回收的过程是遍历堆(Heap)上动态分配的所有对象<br>2.通过识别他们是否被引用来确定哪些对象是垃圾，哪些对象仍要被引用<br>3.所谓的垃圾就是没有被任何变量，对象引用的内容(垃圾就需要被回收释放)</p><p>垃圾回收有多种算法：<br>1.引用计数(Reference Counting)<br>2.标记清楚(Mark Sweep)<br>3.标记整理(Mark Compact)<br>4.复制集合(Copy Collection)</p><p><strong>注意</strong><br>GC只负责堆(Heap)内存的垃圾回收<br>引用类型都是存在堆(Heap)中的，所以它的分配和释放都通过垃圾回收机制来管理</p><p>栈(Stack)上的内存是有系统自动管理的<br>值类型是在栈(Stack)中分配内存的，他们有自己的生命周期，不用对他们进行管理，会自动分配和释放</p><p><strong>C#中内存回收机制的大概原理</strong><br>内存分为： 0代内存 1代内存 2代内存<br><strong>代的概念</strong>：<br>代是垃圾回收机制使用的一种算法(分代算法)<br>新分配的对象都会被配置在第0代内存中<br>每次分配都可能会进行垃圾回收以释放内存(0代内存满时)</p><p>在一次内存回收过程开始时，垃圾回收器会认为堆中全是垃圾，会进行以下两步：<br>1.标记对象，从根（静态字段、方法参数）开始检查引用对象，标记后为可达对象，未标记为不可达对象，不可达对象就认为是垃圾<br>2.搬迁对象压缩堆（挂起执行托管代码线程），释放未标记的对象，搬迁可达对象，修改引用地址</p><p>大对象总被认为是第2代内存，目的是减少性能损耗，提高性能<br>不会对大对象进行搬迁压缩 85000字节（83kb）以上的对象为大对象</p><p>手动触发垃圾回收的方法<br>一般情况下不会频繁调用<br>都是在Loading过场景时才调用</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">GC.Collect();</code></pre></div><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/10/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E5%B0%81%E8%A3%85-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/exam.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson4_封装_构造函数和析构函数&#123;    class Person    &#123;        public string name;        public int age;        public Person()        &#123;            name &#x3D; &quot;大逼&quot;;            age &#x3D; 23;        &#125;        public Person(string name)            &#123; this.name &#x3D; name; &#125;        public Person(int age)            &#123; this.age &#x3D; age; &#125;    &#125;    class Lesson    &#123;        public int ID;        public int num;        public Lesson()        &#123;            ID &#x3D; 1;            num &#x3D; 10;        &#125;        public Lesson(int ID, int num)        &#123;             this.ID &#x3D; ID;             this.num &#x3D; num;        &#125;    &#125;    class Ticket    &#123;        public uint distance;        public float price;        public Ticket(uint distance)        &#123;            this.distance &#x3D; distance;        &#125;        public void GetPrice()        &#123;            if(0 &lt;&#x3D; distance &amp;&amp; distance &lt;&#x3D; 100)            &#123;                price &#x3D; 1.0f * distance;            &#125;            else if(100 &lt; distance &amp;&amp; distance &lt;&#x3D; 200)            &#123;                price &#x3D; 0.95f * (distance - 100) + 100;            &#125;            else if(200 &lt; distance &amp;&amp; distance &lt;&#x3D; 300)            &#123;                price &#x3D; 0.9f * (distance - 200) + 195;            &#125;            else if(distance &gt; 300)            &#123;                price &#x3D; 0.8f * (distance - 300) + 385;            &#125;        &#125;        public void Print()        &#123;            GetPrice();            Console.WriteLine(&quot;&#123;0&#125;公里&#123;1&#125;块钱&quot;, distance, price);        &#125;    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Person p1 &#x3D; new Person();            Person p2 &#x3D; new Person(&quot;季宝&quot;);            Person p3 &#x3D; new Person(22);            Lesson l1 &#x3D; new Lesson();            Lesson l2 &#x3D; new Lesson(2, 46);            try            &#123;                Ticket t1 &#x3D; new Ticket(uint.Parse(Console.ReadLine()));                t1.Print();            &#125;            catch            &#123;                Console.WriteLine(&quot;请输入正数&quot;);            &#125;            &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>成员方法</title>
    <link href="/2022/05/09/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95/"/>
    <url>/2022/05/09/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>成员方法</p><span id="more"></span><h1 id="成员方法的声明"><a href="#成员方法的声明" class="headerlink" title="成员方法的声明"></a>成员方法的声明</h1><p><strong>基本概念</strong>：<br>成员方法（函数） 用来表现对象行为<br>1.声明在语句块中<br>2.是用来描述对象的行为的<br>3.规则和函数声明规则相同<br>4.受到访问修饰符规则影响<br>5.返回值参数不做限制<br>6.方法数量不做限制</p><p><strong>注意</strong>：<br>1.成员方法不要加static关键字<br>2.成员方法必须实例化出对象，再通过对象来使用，相当于该对象执行了某个行为<br>3.成员方法 受到访问修饰符影响</p><h1 id="成员方法的使用"><a href="#成员方法的使用" class="headerlink" title="成员方法的使用"></a>成员方法的使用</h1><p>必须实例化出对象，再通过对象来使用，相当于该对象执行了某个行为</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/09/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95/exam.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson3_成员方法&#123;    #region 练习题1    class Person    &#123;        public string name;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 说话        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;str&quot;&gt;&lt;&#x2F;param&gt;        public void Speak(string str)        &#123;            Console.WriteLine(&quot;&#123;0&#125;说&#123;1&#125;&quot;, name, str);        &#125;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 走路        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;s&quot;&gt;&lt;&#x2F;param&gt;        public void Walk(int s)        &#123;            Console.WriteLine(&quot;&#123;0&#125;走了&#123;1&#125;步&quot;, name, s);        &#125;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 吃饭        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;food&quot;&gt;&lt;&#x2F;param&gt;        public void Eat(Food food)        &#123;            Console.WriteLine(&quot;&#123;0&#125;吃了&#123;1&#125;,吸收了&#123;2&#125;热量&quot;, name, food.name, food.heat);        &#125;    &#125;    #endregion    #region 练习题2    class Student    &#123;        public string name;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 学习        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;subject&quot;&gt;&lt;&#x2F;param&gt;        public void Study(string subject)        &#123;            Console.WriteLine(&quot;&#123;0&#125;在学习&#123;1&#125;&quot;, name, subject);        &#125;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 吃饭        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;food&quot;&gt;&lt;&#x2F;param&gt;        public void Eat(Food food)        &#123;            Console.WriteLine(&quot;&#123;0&#125;吃了&#123;1&#125;,吸收了&#123;2&#125;热量&quot;, name, food.name, food.heat);        &#125;    &#125;    #endregion    #region 练习题3    class Food    &#123;        public E_FoodName name;        public int heat;    &#125;    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 食物种类枚举    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_FoodName    &#123;        Apple &#x3D; 10,        Banana &#x3D; 20,        Mango &#x3D; 30,    &#125;    #endregion        internal class Program    &#123;        static void Main(string[] args)        &#123;            #region 练习题123            Person p &#x3D; new Person();            p.name &#x3D; &quot;大逼&quot;;            Student s &#x3D; new Student();            s.name &#x3D; &quot;季宝&quot;;            Food f &#x3D; new Food();            f.name &#x3D; E_FoodName.Apple;            f.heat &#x3D; (int)f.name;            p.Eat(f);            s.Eat(f);            #endregion        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>成员变量和访问修饰符</title>
    <link href="/2022/05/09/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <url>/2022/05/09/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<p>成员变量  访问修饰符</p><span id="more"></span><h1 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h1><p>基本规则：<br>1.声明在类语句块中 class<br>2.用来描述对象的特征<br>3.可以是任意变量类型<br>4.数量不做限制<br>5.是否赋值根据需求来定<br>6.在类里 可以声明和自己一样的变量类型 但不能对它实例化</p><h1 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h1><p>基本作用： 决定类内部成员的访问权限<br><strong>public</strong>  公共的  自己（内部）和别人（外部）都能访问和使用<br><strong>private</strong>  私有的  自己（内部）才能访问和使用    不写默认为private<br><strong>protected</strong>  保护的  自己（内部）和子类才能访问和使用</p><h1 id="成员变量的初始值"><a href="#成员变量的初始值" class="headerlink" title="成员变量的初始值"></a>成员变量的初始值</h1><p><strong>值类型</strong>：数字类型默认0  bool类型默认false<br><strong>引用类型</strong>：默认为null<br>技巧： Console.WriteLine(default(你想查询初始值的类型名));</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/09/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/exam.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson2_成员变量和访问修饰符&#123;    #region 练习题1    &#x2F;&#x2F; 3P &#x3D; public  private  protected  访问修饰符    #endregion    #region 练习题2    &#x2F;&#x2F;定义人类    class Person    &#123;        &#x2F;&#x2F;特征 成员变量        &#x2F;&#x2F;姓名        public string name;        &#x2F;&#x2F;身高        public int height;        &#x2F;&#x2F;年龄        public int age;         &#x2F;&#x2F;家庭住址        public string location;    &#125;    #endregion    #region 练习题3    &#x2F;&#x2F;定义学生    class Student    &#123;        &#x2F;&#x2F;特征 成员变量        &#x2F;&#x2F;姓名        public string name;        &#x2F;&#x2F;学号        public string ID;        &#x2F;&#x2F;年龄        public int age;         &#x2F;&#x2F;同桌        public Student deskmate;        &#x2F;&#x2F;行为 成员方法            &#125;    #endregion    #region 练习题4    &#x2F;&#x2F;定义班级    class Lesson    &#123;        &#x2F;&#x2F;特征 成员变量        &#x2F;&#x2F;专业名称        public string majorName;        &#x2F;&#x2F;学号        public string ID;        &#x2F;&#x2F;教师容量        public int teacherNum;        &#x2F;&#x2F;学生        public Student[] students;    &#125;    #endregion        internal class Program    &#123;        static void Main(string[] args)        &#123;                     #region 练习题5            Person p &#x3D; new Person();            p.age &#x3D; 10;            Person p2 &#x3D; new Person();            p2.age &#x3D; 20;            Console.WriteLine(p.age);            &#x2F;&#x2F;10            #endregion            #region 练习题6            Person p3 &#x3D; new Person();            p3.age &#x3D; 10;            Person p4 &#x3D; p3;            p4.age &#x3D; 20;            Console.WriteLine(p3.age);            &#x2F;&#x2F;20            #endregion            #region 练习题7            Student s &#x3D; new Student();            s.age &#x3D; 10;            int age &#x3D; s.age;            age &#x3D; 20;            Console.WriteLine(s.age);            &#x2F;&#x2F;10            #endregion            #region 练习题8            Student s1 &#x3D; new Student();            s1.deskmate &#x3D; new Student();            s1.deskmate.age &#x3D; 10;            Student s2 &#x3D; s1.deskmate;            s2.age &#x3D; 20;            Console.WriteLine(s1.deskmate.age);            &#x2F;&#x2F;20            #endregion        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月9日</title>
    <link href="/2022/05/09/diary/2022.5/2022%E5%B9%B45%E6%9C%889%E6%97%A5/"/>
    <url>/2022/05/09/diary/2022.5/2022%E5%B9%B45%E6%9C%889%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="d84eba87eff053a4f05c219966365787260261f4cbb94d56ff5eeb1ec094dde8">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe500d33c330961da8b059aa497902f1d00c4410c00f3db9aa6f2ce9955bc5e104c1a98bc530f4a959a1fa2d4236ca77aae0eb5c5355d7786a3c44af12629597575f747fb04ed906b56e8ad3421784ba17e2c155600383c595fea8bdd189b30477f4b101091a57576294adea8b132d3ae11d1bb2e7f43f487c41678825fe3e100da793400da2af07a6eaa040230bce11743a49ca83f002ce9c69cc4e60b917e2c710fe3b72b5c28dc8cde0ee325f55112d67dd525a484c75817eb7f252fec8cb0fa311f4cdad3d7ec4f88aef74205a2cdcd3534476a7b3177921f983a0661c26a644c5761ba1931b83c6328fdb8cc7918de4da9dcff42de36d825edac9f151f8e7a2b5969d5b34fcfe3e914cca177ee7356e47061ef3c4a45df707867e4e95ce54f4ea9f782f9d0543b5631f22c3652a7caf727bbde4d9cc435c2e836c9ef74b6e6e9fc297fdaeb7fe1d7cf5a961e7cb04a00f34c54a85daa1e9b1573d32ff6c2b9402de755dc71a9357e50ea941b5f5748bb06fef3ee5bfc49db813efa128320352f07240c239607e59b3f619142a101a07a14653e48a88ea02c14322266a11b287216ded8ceddcec4d458448f7ca737ce0186587348816e1b23c8c5a7f7b7db32fc100a3e41e60ecd904d5419b07ae69a51518151ab9ce7aef987328799ca2c0c7</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类和对象</title>
    <link href="/2022/05/08/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <url>/2022/05/08/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>类 对象</p><span id="more"></span><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>基本概念：<br>1.具有相同特征<br>2.具有相同行为<br>3.一类事物的抽象<br>4.类是对象的模板<br>5.可以通过类创建出对象<br>6.类的关键词 class</p><p>一般声明在 <strong>namespace</strong> 语句块中<br>声明语法：<br> <div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">访问修饰符 class 类名&#123;    &#x2F;&#x2F;封装    特征 成员变量    行为 成员方法    保护特征 成员属性    构造函数和析构函数    索引器    运算符重载    静态成员&#125;</code></pre></div></p><h1 id="（类）对象"><a href="#（类）对象" class="headerlink" title="（类）对象"></a>（类）对象</h1><p>基本概念：<br>1.<strong>类的声明</strong>和<strong>类对象（变量）声明</strong>是两个概念<br>2.<strong>类的声明</strong>类似<strong>枚举</strong>和<strong>结构体的声明</strong>（类的声明相当于声明了一个自定义变量类型）<br>3.对象是类创建出来的（相当于声明一个<strong>指定类的变量</strong>）<br>4.类创建对象的过程（一般称为<strong>实例化对象</strong>）<br>5.类对象都是<strong>引用类型</strong>的</p><p>声明语法：</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">类名 变量名;类名 变量名 &#x3D; null; &#x2F;&#x2F;null代表空类名 变量名 &#x3D; new 类名();</code></pre></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1.<strong>类的声明</strong>和<strong>类对象（变量）声明</strong>是两个概念<br>2.<strong>类的声明</strong>是声明对象的模板，用来抽象（形容）显示事物的<br>3.<strong>类对象（变量）声明</strong>是用来表示现实中的对象个体的</p><p>4.<strong>类</strong>是一个自定义的变量类型<br>5.实例化一个<strong>类对象</strong>是在声明变量</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><img src="/2022/05/08/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E5%B0%81%E8%A3%85/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/%E7%BB%83%E4%B9%A0%E9%A2%98.png" class=""><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">练习题1 懒得做练习题2 A保持不变        GameObject A &#x3D; new GameObject(); &#x2F;&#x2F;新建栈 堆        GameObject B &#x3D; A; &#x2F;&#x2F;新建栈 指向A的堆        B &#x3D; null; &#x2F;&#x2F;B的栈 指向null的堆练习题3 A和B没关系        GameObject A &#x3D; new GameObject(); &#x2F;&#x2F;新建栈 堆        GameObject B &#x3D; A; &#x2F;&#x2F;新建栈 指向A的堆        B &#x3D; new GameObject(); &#x2F;&#x2F;B的栈 指向new的堆</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象编程</title>
    <link href="/2022/05/08/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/05/08/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>面向对象编程 面向过程编程</p><span id="more"></span><h1 id="面向过程编程"><a href="#面向过程编程" class="headerlink" title="面向过程编程"></a>面向过程编程</h1><p>一种<strong>以过程为中心</strong>的编程思想<br>分析出解决问题所需要的步骤<br>然后用函数把步骤一步一步实现<br>使用的时候一个一个一次调用</p><h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>面向对象是一种<strong>对现实世界理解和抽象</strong>的编程方法<br><strong>把相关的数据和方法组织为一个整体来看待</strong><br>从更高的层次来进行程序开发<br>更贴近事物的自然运行模式</p><p>万物皆对象  用程序来抽象（形容）对象  用面向对象的思想来编程</p><img src="/2022/05/08/CSharp/CSharp%E6%A0%B8%E5%BF%83/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E5%AF%B9%E8%B1%A1.png" class=""><p><strong>套路：</strong><br>用中文去形容一类对象<br>把一类对象的共同点提取出来<br>然后用程序语言把它翻译过来<br>带着对象的概念在程序中使用他们</p><h1 id="重要知识点"><a href="#重要知识点" class="headerlink" title="重要知识点"></a>重要知识点</h1><h2 id="面向对象关键知识"><a href="#面向对象关键知识" class="headerlink" title="面向对象关键知识"></a>面向对象关键知识</h2><p>类（class 关键词）</p><h2 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h2><p>重点中的重点：<br><strong>封装</strong> + <strong>继承</strong> + <strong>多态</strong><br><strong>封装</strong>：用程序语言来形容对象<br><strong>继承</strong>：复用封装对象的代码；儿子继承父亲，复用现成代码<br><strong>多态</strong>：同样行为的不同表现，儿子继承父亲的基金但是有不同的行为表现</p><h2 id="面向对象七大原则"><a href="#面向对象七大原则" class="headerlink" title="面向对象七大原则"></a>面向对象七大原则</h2><p>开闭原则<br>依赖倒转原则<br><strong>里式替换原则</strong><br>单一职责原则<br>接口隔离原则<br>合成复用原则<br>迪米特法则</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月8日</title>
    <link href="/2022/05/08/diary/2022.5/2022%E5%B9%B45%E6%9C%888%E6%97%A5/"/>
    <url>/2022/05/08/diary/2022.5/2022%E5%B9%B45%E6%9C%888%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="f59f778e162cd4c5575e8011cc98055fa0bff015c3ee6e202e70659d313c6c3d">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50fdd0ca3edc57389bd0e88084b7db202376ed899917c9c6c734af1f7eca42e06ef4ff0890be6f398558796f868b9f06ee655258737f6db070469b46f13f90d490fab7ed262b0674e752644fe7c26987bc8d8f98b1be0f67c09d7ed761c2f39431f9b5bf55e12b69d0873f8ee72fef88a00ffa617ea3d0cee8ec38a28f098431742f50e9fba2bdd55267e5781d681d47c7621c06254e363fd8f450a5b452e550941cb7bde91bee2ad2dadeef67388f660d4325433b8551d5498c44b50ae1c4ce8573f93da15e1bccd0368270193b6e43ec0bbfb7005c8ccad91008f1ba8dd3c2bc3f817203b2b153ed8b0fb3bb47321b923f8a0b40d5129b483c2eb3b3696f83c13570b18ec4f41c0060981769b4fddf506e84496b93e604bec7f5e9eab245635a58312a1db37ddbe9403b347965029d3609cb00b0963c4f7ea247324ba0a1360931d2cf439647cca7b900d9f7cb66f2fc70100efb41f96eaa24a625c2e6819c6988a6e4223414da010942d393cc9cdef09f2d0040e194370d0dae37a88aeeb44071abbc70cab22737f11086352de96310e23c022150e7804fea3160c52121198389667716f56947b839ddf07ce944b0c04dc9156d1e8f54cc2f56e462f7d484d5437ec4beefea3b5e894006f08d6fd290aed03347811ced529b6d5ab340e33887</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>飞行棋逻辑整理</title>
    <link href="/2022/05/07/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86/"/>
    <url>/2022/05/07/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>逻辑整理</p><span id="more"></span><img src="/2022/05/07/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86-1.jpg" class=""><img src="/2022/05/07/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86-2.jpg" class=""><img src="/2022/05/07/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86-3.jpg" class=""><img src="/2022/05/07/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86-4.jpg" class="">]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月7日</title>
    <link href="/2022/05/07/diary/2022.5/2022%E5%B9%B45%E6%9C%887%E6%97%A5/"/>
    <url>/2022/05/07/diary/2022.5/2022%E5%B9%B45%E6%9C%887%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="5b619cf13cf1e47245c9944edb189af53431bf3141868f33b1bc6c8529b0537d">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50fdd0ca3edc57389bd0e88084b7db2023fbfbe4a886cec053b0d69678e9bd693646e6fc5a95475d4199d73cf5baa89d2975c29f552c86b61ceb5cf6b8d828ed6db54c925b71bbee4d09b841d4bb0f64dcdcd9d240b83082bb804938681252d82c205164b429d4b7cc40521c2a1c9eb276a4827086157c40dd08c639db597f33df1d69e5990cbf1f0daa82a5abedef55f7d8553f67c6e8c5a24555e176ef3f138ca04a19a4c7db4590582dc6990c19f05b5144c85453f8460bc83ff67eaf1680acf0114d9671864f166d3b5c439aa618409638f886f77ee08119b5f0214d27e7db732bb546ec23bf3cb89d59bd45dbd52bc0d339aba3a38f0d42f6dfc00529ddf5a7876c11a1abf0629dbb98324236013694a91bf301af802b2c31917c3a2caf8e0ca3a33c9d6bd17e426e6ffd47dcb9f1ba2c7e447f08e50df23274fe72317fd37f824f76fb200e67a34e8bb75444dd5d793240fff557be54c992bffb19e0c39dba5b1470c114cee0d9856a170838db012709c926e9d7fbae7536b89d6d6239c8ad703e7435ec3a78a0fca41e9b75f5fe53ed49cc0670391375262a47344164b57d860bca9e476c35796b53c645e567fb2fd4ade582bab275248ba8483cce6035d594a8b3ce12d2ab35583ffc7fdec4a4b23ad4b03f77bbcbcfddc4a9a0a28504f5e1ba3dd8350ebee7fb69b537d8d1d5f9c76fcd9b97499bb88b13ed17196c3a3e62f4ff4471d017c87edb919258bc5d8a682c3abdeb500e8dea1bf57bc50a5a3afbfd880e5514001cfe65b8acdb8384761abb4e434ea4755fe3d55ede3c0fe47b8bf0197a7270464e8ba29ace47286981ba52e456c2016304385ec6e39603713d4fc571182313a552578017fbb8aa66e5b707c998a6f28ce3009764e5fb992c956cad0e48b08a49d4e3a71e3c4f4cdc5c00d2eb058bc7dbc42a3e95484617e1a3c04a7675745812016613fbd0494458e2b4deead739896655b0361c89b6e62cb1257e829076547d97646a2df3e42a35b79391779b4661e37221ba1ca42c5964ea8caa54673a10f82dd0d670173c0c0bda388f3901c0b73785df5c06bdd3a630</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>飞行棋实现</title>
    <link href="/2022/05/06/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/05/06/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%A3%9E%E8%A1%8C%E6%A3%8B%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>飞行棋</p><span id="more"></span><p><strong># 实现结果</strong></p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=553774900&bvid=BV17v4y1K7i2&cid=713732660&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace CSharp基础实践教学&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            #region 1 控制台初始化            int w &#x3D; 50;            int h &#x3D; 30;            ConsoleInit(w, h);            #endregion            #region 2 场景选择相关            &#x2F;&#x2F;申明一个 表示场景标识的 变量             E_SceneType nowSceneType &#x3D; E_SceneType.Begin;            while (true)            &#123;                switch (nowSceneType)                &#123;                    case E_SceneType.Begin:                        &#x2F;&#x2F;开始场景逻辑                        Console.Clear();                        &#x2F;&#x2F;来书写 开始场景相关的逻辑即可                        BeginOrEndScene(w, h, ref nowSceneType);                        break;                    case E_SceneType.Game:                        &#x2F;&#x2F;游戏场景逻辑                        Console.Clear();                        &#x2F;&#x2F;通过函数来处理游戏场景的逻辑内容                        GameScene(w, h, ref nowSceneType);                        break;                    case E_SceneType.End:                        &#x2F;&#x2F;结束场景逻辑                        Console.Clear();                        BeginOrEndScene(w, h, ref nowSceneType);                        break;                    default:                        break;                &#125;            &#125;            #endregion        &#125;        #region 1 控制台初始化        static void ConsoleInit(int w, int h)        &#123;            &#x2F;&#x2F;基础设置            &#x2F;&#x2F;光标的隐藏            Console.CursorVisible &#x3D; false;            &#x2F;&#x2F;舞台的大小            Console.SetWindowSize(w, h);            Console.SetBufferSize(w, h);        &#125;        #endregion        #region 3 开始场景逻辑 + 8 结束场景逻辑        static void BeginOrEndScene(int w, int h, ref E_SceneType nowSceneType)        &#123;            Console.ForegroundColor &#x3D; ConsoleColor.White;            Console.SetCursorPosition(nowSceneType &#x3D;&#x3D; E_SceneType.Begin ? w &#x2F; 2 - 3 : w &#x2F; 2 - 4, 8);            Console.Write(nowSceneType &#x3D;&#x3D; E_SceneType.Begin ? &quot;飞行棋&quot; : &quot;游戏结束&quot;);            &#x2F;&#x2F;当前选项的编号            int nowSelIndex &#x3D; 0;            bool isQuitBegin &#x3D; false;            &#x2F;&#x2F;开始场景逻辑处理循环            while (true)            &#123;                Console.SetCursorPosition(nowSceneType &#x3D;&#x3D; E_SceneType.Begin ? w &#x2F; 2 - 4 : w &#x2F; 2 - 5, 13);                Console.ForegroundColor &#x3D; nowSelIndex &#x3D;&#x3D; 0 ? ConsoleColor.Red : ConsoleColor.White;                Console.Write(nowSceneType &#x3D;&#x3D; E_SceneType.Begin ? &quot;开始游戏&quot; : &quot;回到主菜单&quot;);                Console.SetCursorPosition(w &#x2F; 2 - 4, 15);                Console.ForegroundColor &#x3D; nowSelIndex &#x3D;&#x3D; 1 ? ConsoleColor.Red : ConsoleColor.White;                Console.Write(&quot;退出游戏&quot;);                &#x2F;&#x2F;通过ReadKey可以得到一个输入的枚举类型                switch (Console.ReadKey(true).Key)                &#123;                    case ConsoleKey.W:                        --nowSelIndex;                        if (nowSelIndex &lt; 0)                        &#123;                            nowSelIndex &#x3D; 0;                        &#125;                        break;                    case ConsoleKey.S:                        ++nowSelIndex;                        if (nowSelIndex &gt; 1)                        &#123;                            nowSelIndex &#x3D; 1;                        &#125;                        break;                    case ConsoleKey.J:                        if (nowSelIndex &#x3D;&#x3D; 0)                        &#123;                            &#x2F;&#x2F;进入游戏场景                            &#x2F;&#x2F;1 改变当前场景ID                            nowSceneType &#x3D; nowSceneType &#x3D;&#x3D; E_SceneType.Begin ? E_SceneType.Game : E_SceneType.Begin;                            &#x2F;&#x2F;2 退出当前循环                            isQuitBegin &#x3D; true;                        &#125;                        else                        &#123;                            &#x2F;&#x2F;退出游戏                            Environment.Exit(0);                        &#125;                        break;                &#125;                &#x2F;&#x2F;通过标识决定 是否跳出 开始场景的循环                if (isQuitBegin)                &#123;                    break;                &#125;            &#125;        &#125;        #endregion        #region 游戏场景逻辑        static void GameScene(int w, int h, ref E_SceneType nowSceneType)        &#123;            &#x2F;&#x2F;绘制不变的基本信息            DrawWall(w, h);            &#x2F;&#x2F;绘制地图            &#x2F;&#x2F;初始化一张地图             Map map &#x3D; new Map(14, 3, 80);            map.Draw();            &#x2F;&#x2F;绘制玩家            Player player &#x3D; new Player(0, E_PlayerType.Player);            Player computer &#x3D; new Player(0, E_PlayerType.Computer);            DrawPlayer(player, computer, map);            bool isGameOver &#x3D; false;            &#x2F;&#x2F;游戏场景循环            while (true)            &#123;                &#x2F;&#x2F;之后的游戏逻辑                &#x2F;&#x2F;玩家扔色子逻辑                &#x2F;&#x2F;检测输入                &#x2F;&#x2F;Console.ReadKey(true);                &#x2F;&#x2F;&#x2F;&#x2F;扔色子的逻辑                &#x2F;&#x2F;isGameOver &#x3D; RandomMove(w, h, ref player, ref computer, map);                &#x2F;&#x2F;&#x2F;&#x2F;绘制地图                &#x2F;&#x2F;map.Draw();                &#x2F;&#x2F;&#x2F;&#x2F;绘制玩家                &#x2F;&#x2F;DrawPlayer(player, computer, map);                &#x2F;&#x2F;&#x2F;&#x2F;判断是否要结束游戏                &#x2F;&#x2F;if( isGameOver )                &#x2F;&#x2F;&#123;                &#x2F;&#x2F;    &#x2F;&#x2F;卡住程序 让顽疾按任意键                 &#x2F;&#x2F;    Console.ReadKey(true);                &#x2F;&#x2F;    &#x2F;&#x2F;改变场景ID                &#x2F;&#x2F;    nowSceneType &#x3D; E_SceneType.End;                &#x2F;&#x2F;    &#x2F;&#x2F;直接跳出循环                &#x2F;&#x2F;    break;                &#x2F;&#x2F;&#125;                &#x2F;&#x2F;玩家扔色子                if (PlayerRandoMove(w, h, ref player, ref computer, map, ref nowSceneType))                &#123;                    break;                &#125;                &#x2F;&#x2F;电脑扔色子                if (PlayerRandoMove(w, h, ref computer, ref player, map, ref nowSceneType))                &#123;                    break;                &#125;                &#x2F;&#x2F;电脑扔色子逻辑                &#x2F;&#x2F;检测输入                &#x2F;&#x2F;Console.ReadKey(true);                &#x2F;&#x2F;&#x2F;&#x2F;扔色子的逻辑                &#x2F;&#x2F;isGameOver &#x3D; RandomMove(w, h, ref computer, ref player, map);                &#x2F;&#x2F;&#x2F;&#x2F;绘制地图                &#x2F;&#x2F;map.Draw();                &#x2F;&#x2F;&#x2F;&#x2F;绘制玩家                &#x2F;&#x2F;DrawPlayer(player, computer, map);                &#x2F;&#x2F;&#x2F;&#x2F;判断是否要结束游戏                &#x2F;&#x2F;if (isGameOver)                &#x2F;&#x2F;&#123;                &#x2F;&#x2F;    &#x2F;&#x2F;卡住程序 让顽疾按任意键                 &#x2F;&#x2F;    Console.ReadKey(true);                &#x2F;&#x2F;    &#x2F;&#x2F;改变场景ID                &#x2F;&#x2F;    nowSceneType &#x3D; E_SceneType.End;                &#x2F;&#x2F;    &#x2F;&#x2F;直接跳出循环                &#x2F;&#x2F;    break;                &#x2F;&#x2F;&#125;            &#125;        &#125;        static bool PlayerRandoMove(int w, int h, ref Player p, ref Player otherP, Map map, ref E_SceneType nowSceneType)        &#123;            &#x2F;&#x2F;之后的游戏逻辑            &#x2F;&#x2F;玩家扔色子逻辑            &#x2F;&#x2F;检测输入            Console.ReadKey(true);            &#x2F;&#x2F;扔色子的逻辑            bool isGameOver &#x3D; RandomMove(w, h, ref p, ref otherP, map);            &#x2F;&#x2F;绘制地图            map.Draw();            &#x2F;&#x2F;绘制玩家            DrawPlayer(p, otherP, map);            &#x2F;&#x2F;判断是否要结束游戏            if (isGameOver)            &#123;                &#x2F;&#x2F;卡住程序 让顽疾按任意键                 Console.ReadKey(true);                &#x2F;&#x2F;改变场景ID                nowSceneType &#x3D; E_SceneType.End;                &#x2F;&#x2F;直接跳出循环            &#125;            return isGameOver;        &#125;        #endregion        #region 4 绘制不变内容（红墙 提示等等）        static void DrawWall(int w, int h)        &#123;            Console.ForegroundColor &#x3D; ConsoleColor.Red;            &#x2F;&#x2F;画墙            &#x2F;&#x2F;横着的墙            for (int i &#x3D; 0; i &lt; w; i +&#x3D; 2)            &#123;                &#x2F;&#x2F;最上方的墙                Console.SetCursorPosition(i, 0);                Console.Write(&quot;■&quot;);                &#x2F;&#x2F;最下方的墙                Console.SetCursorPosition(i, h - 1);                Console.Write(&quot;■&quot;);                &#x2F;&#x2F;中间的墙                Console.SetCursorPosition(i, h - 6);                Console.Write(&quot;■&quot;);                Console.SetCursorPosition(i, h - 11);                Console.Write(&quot;■&quot;);            &#125;            &#x2F;&#x2F;竖着的墙            for (int i &#x3D; 0; i &lt; h; i++)            &#123;                &#x2F;&#x2F;最左边                Console.SetCursorPosition(0, i);                Console.Write(&quot;■&quot;);                &#x2F;&#x2F;最右边                Console.SetCursorPosition(w - 2, i);                Console.Write(&quot;■&quot;);            &#125;            &#x2F;&#x2F;文字信息            Console.ForegroundColor &#x3D; ConsoleColor.White;            Console.SetCursorPosition(2, h - 10);            Console.Write(&quot;□:普通格子&quot;);            Console.ForegroundColor &#x3D; ConsoleColor.Blue;            Console.SetCursorPosition(2, h - 9);            Console.Write(&quot;‖:暂停，一回合不懂&quot;);            Console.ForegroundColor &#x3D; ConsoleColor.Red;            Console.SetCursorPosition(26, h - 9);            Console.Write(&quot;●:炸弹，倒退5格&quot;);            Console.ForegroundColor &#x3D; ConsoleColor.Yellow;            Console.SetCursorPosition(2, h - 8);            Console.Write(&quot;¤:时空隧道，随机倒退，暂停，换位置&quot;);            Console.ForegroundColor &#x3D; ConsoleColor.Cyan;            Console.SetCursorPosition(2, h - 7);            Console.Write(&quot;★:玩家&quot;);            Console.ForegroundColor &#x3D; ConsoleColor.Magenta;            Console.SetCursorPosition(12, h - 7);            Console.Write(&quot;▲:电脑&quot;);            Console.ForegroundColor &#x3D; ConsoleColor.DarkGreen;            Console.SetCursorPosition(22, h - 7);            Console.Write(&quot;◎:玩家和电脑重合&quot;);            Console.ForegroundColor &#x3D; ConsoleColor.White;            Console.SetCursorPosition(2, h - 5);            Console.Write(&quot;按任意键开始扔色子&quot;);        &#125;        #endregion        #region 7 绘制玩家        static void DrawPlayer(Player player, Player computer, Map map)        &#123;            &#x2F;&#x2F;重合时            if (player.nowIndex &#x3D;&#x3D; computer.nowIndex)            &#123;                &#x2F;&#x2F;得到重合的位置                Grid grid &#x3D; map.grids[player.nowIndex];                Console.SetCursorPosition(grid.pos.x, grid.pos.y);                Console.ForegroundColor &#x3D; ConsoleColor.DarkGreen;                Console.Write(&quot;◎&quot;);            &#125;            &#x2F;&#x2F;不重合的时候            else            &#123;                player.Draw(map);                computer.Draw(map);            &#125;        &#125;        #endregion        #region 8 扔色子 函数        &#x2F;&#x2F;擦除提示的函数        static void ClearInfo(int h)        &#123;            Console.SetCursorPosition(2, h - 5);            Console.Write(&quot;                                   &quot;);            Console.SetCursorPosition(2, h - 4);            Console.Write(&quot;                                   &quot;);            Console.SetCursorPosition(2, h - 3);            Console.Write(&quot;                                   &quot;);            Console.SetCursorPosition(2, h - 2);            Console.Write(&quot;                                   &quot;);        &#125;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 扔色子函数        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;w&quot;&gt;窗口的宽&lt;&#x2F;param&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;h&quot;&gt;窗口的高&lt;&#x2F;param&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;p&quot;&gt;扔色子的对象&lt;&#x2F;param&gt;        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;map&quot;&gt;地图信息&lt;&#x2F;param&gt;        &#x2F;&#x2F;&#x2F; &lt;returns&gt;默认返回false 代表没有结束&lt;&#x2F;returns&gt;        static bool RandomMove(int w, int h, ref Player p, ref Player otherP, Map map)        &#123;            &#x2F;&#x2F;擦除之前显示的提示信息            ClearInfo(h);            &#x2F;&#x2F;根据扔色子的玩家类型 决定信息的颜色            Console.ForegroundColor &#x3D; p.type &#x3D;&#x3D; E_PlayerType.Player ? ConsoleColor.Cyan : ConsoleColor.Magenta;            &#x2F;&#x2F;扔色子之前 判断 玩家是否处于暂停状态            if (p.isPause)            &#123;                Console.SetCursorPosition(2, h - 5);                Console.Write(&quot;处于暂停状态，&#123;0&#125;需要暂停一回合&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;你&quot; : &quot;电脑&quot;);                Console.SetCursorPosition(2, h - 4);                Console.Write(&quot;请按任意键，让&#123;0&#125;开始扔色子&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;电脑&quot; : &quot;你&quot;);                &#x2F;&#x2F;停止暂停                p.isPause &#x3D; false;                return false;            &#125;            &#x2F;&#x2F;扔色子目的 是改变 玩家或者电脑的位置  计算位置的变化            &#x2F;&#x2F;扔色子 随机一个1到6的数 加上去            Random r &#x3D; new Random();            int randomNum &#x3D; r.Next(1, 7);            p.nowIndex +&#x3D; randomNum;            &#x2F;&#x2F;打印扔的点数            Console.SetCursorPosition(2, h - 5);            Console.Write(&quot;&#123;0&#125;扔出的点数为:&#123;1&#125;&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;你&quot; : &quot;电脑&quot;, randomNum);            &#x2F;&#x2F;首先判断是否到终点了            if (p.nowIndex &gt;&#x3D; map.grids.Length - 1)            &#123;                p.nowIndex &#x3D; map.grids.Length - 1;                Console.SetCursorPosition(2, h - 4);                if (p.type &#x3D;&#x3D; E_PlayerType.Player)                &#123;                    Console.Write(&quot;恭喜你，你率先到达了终点&quot;);                &#125;                else                &#123;                    Console.Write(&quot;很遗憾，电脑率到达了终点&quot;);                &#125;                Console.SetCursorPosition(2, h - 3);                Console.Write(&quot;请按任意键结束游戏&quot;);                return true;            &#125;            else            &#123;                &#x2F;&#x2F;没有到终点 就判断 当前对象  到了一个怎么样的格子                Grid grid &#x3D; map.grids[p.nowIndex];                switch (grid.type)                &#123;                    case E_Grid_Type.Normal:                        &#x2F;&#x2F;普通格子不用处理                        Console.SetCursorPosition(2, h - 4);                        Console.Write(&quot;&#123;0&#125;到了一个安全位置&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;你&quot; : &quot;电脑&quot;);                        Console.SetCursorPosition(2, h - 3);                        Console.Write(&quot;请按任意键，让&#123;0&#125;开始扔色子&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;电脑&quot; : &quot;你&quot;);                        break;                    case E_Grid_Type.Boom:                        &#x2F;&#x2F;炸弹退格                        p.nowIndex -&#x3D; 5;                        &#x2F;&#x2F;不能比起点还小                        if (p.nowIndex &lt; 0)                        &#123;                            p.nowIndex &#x3D; 0;                        &#125;                        Console.SetCursorPosition(2, h - 4);                        Console.Write(&quot;&#123;0&#125;踩到了炸弹，退后5格&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;你&quot; : &quot;电脑&quot;);                        Console.SetCursorPosition(2, h - 3);                        Console.Write(&quot;请按任意键，让&#123;0&#125;开始扔色子&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;电脑&quot; : &quot;你&quot;);                        break;                    case E_Grid_Type.Pause:                        &#x2F;&#x2F;暂停一回合                        &#x2F;&#x2F;暂停目前 只有加一个对象的暂停标识  才能知道 下一回合它是不是不能扔色子                        &#x2F;&#x2F;下回合要暂停                        p.isPause &#x3D; true;                        Console.SetCursorPosition(2, h - 4);                        Console.Write(&quot;&#123;0&#125;到达了暂停点，你需要暂停一回合&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;你&quot; : &quot;电脑&quot;);                        Console.SetCursorPosition(2, h - 3);                        Console.Write(&quot;请按任意键，让&#123;0&#125;开始扔色子&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;电脑&quot; : &quot;你&quot;);                        break;                    case E_Grid_Type.Tunnel:                        Console.SetCursorPosition(2, h - 4);                        Console.Write(&quot;&#123;0&#125;踩到了时空隧道&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;你&quot; : &quot;电脑&quot;);                        &#x2F;&#x2F;随机                        randomNum &#x3D; r.Next(1, 91);                        &#x2F;&#x2F;触发 倒退                        if (randomNum &lt;&#x3D; 30)                        &#123;                            p.nowIndex -&#x3D; 5;                            if (p.nowIndex &lt; 0)                            &#123;                                p.nowIndex &#x3D; 0;                            &#125;                            Console.SetCursorPosition(2, h - 3);                            Console.Write(&quot;触发倒退5格&quot;);                        &#125;                        &#x2F;&#x2F;触发 暂停                        else if (randomNum &lt;&#x3D; 60)                        &#123;                            p.isPause &#x3D; true;                            Console.SetCursorPosition(2, h - 3);                            Console.Write(&quot;触发暂停一回合&quot;);                        &#125;                        &#x2F;&#x2F;触发换位置                        else                        &#123;                            int temp &#x3D; p.nowIndex;                            p.nowIndex &#x3D; otherP.nowIndex;                            otherP.nowIndex &#x3D; temp;                            Console.SetCursorPosition(2, h - 3);                            Console.Write(&quot;惊喜，惊喜，双方交换位置&quot;);                        &#125;                        Console.SetCursorPosition(2, h - 2);                        Console.Write(&quot;请按任意键，让&#123;0&#125;开始扔色子&quot;, p.type &#x3D;&#x3D; E_PlayerType.Player ? &quot;电脑&quot; : &quot;你&quot;);                        break;                &#125;            &#125;            &#x2F;&#x2F;默认没有结束            return false;        &#125;        #endregion    &#125;    #region 2 场景选择相关    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 游戏场景枚举类型    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_SceneType    &#123;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 开始场景        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Begin,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 游戏场景        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Game,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 结束场景        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        End,    &#125;    #endregion    #region 5 格子结构体和格子枚举    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 格子类型 枚举    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_Grid_Type    &#123;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 普通格子        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Normal,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 炸弹        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Boom,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 暂停        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Pause,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 时空隧道 随机倒退 暂停 换位置        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Tunnel,    &#125;    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 位置信息结构体 包含xy位置    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    struct Vector2    &#123;        public int x;        public int y;        public Vector2(int x, int y)        &#123;            this.x &#x3D; x;            this.y &#x3D; y;        &#125;    &#125;    struct Grid    &#123;        &#x2F;&#x2F;格子的类型        public E_Grid_Type type;        &#x2F;&#x2F;格子的位置        public Vector2 pos;        &#x2F;&#x2F;初始化构造函数        public Grid(int x, int y, E_Grid_Type type)        &#123;            pos.x &#x3D; x;            pos.y &#x3D; y;            this.type &#x3D; type;        &#125;        public void Draw()        &#123;            &#x2F;&#x2F;提出来的目的 就是少写几行代码 因为他们不管哪种类型 都要设置了位置再画            Console.SetCursorPosition(pos.x, pos.y);            switch (type)            &#123;                &#x2F;&#x2F;普通格子 怎么画                case E_Grid_Type.Normal:                    Console.ForegroundColor &#x3D; ConsoleColor.White;                    Console.Write(&quot;□&quot;);                    break;                &#x2F;&#x2F;炸弹 怎么画                case E_Grid_Type.Boom:                    Console.ForegroundColor &#x3D; ConsoleColor.Red;                    Console.Write(&quot;●&quot;);                    break;                &#x2F;&#x2F;暂停 怎么画                case E_Grid_Type.Pause:                    Console.ForegroundColor &#x3D; ConsoleColor.Blue;                    Console.Write(&quot;‖&quot;);                    break;                &#x2F;&#x2F;时空隧道 怎么画                case E_Grid_Type.Tunnel:                    Console.ForegroundColor &#x3D; ConsoleColor.Yellow;                    Console.Write(&quot;¤&quot;);                    break;            &#125;        &#125;    &#125;    #endregion    #region 6 地图结构体    struct Map    &#123;        public Grid[] grids;        &#x2F;&#x2F;初始化中 初始了 各个格子的类型 和 位置        public Map(int x, int y, int num)        &#123;            grids &#x3D; new Grid[num];            &#x2F;&#x2F;用于位置改变计数的变量            &#x2F;&#x2F;表示X变化的次数            int indexX &#x3D; 0;            &#x2F;&#x2F;表示Y变化的次数            int indexY &#x3D; 0;            &#x2F;&#x2F;x的步长            int stepNum &#x3D; 2;            Random r &#x3D; new Random();            int randomNum;            for (int i &#x3D; 0; i &lt; num; i++)            &#123;                &#x2F;&#x2F;应该初始化 格子类型                randomNum &#x3D; r.Next(0, 101);                &#x2F;&#x2F;设置类型 普通格子                &#x2F;&#x2F;有85%几率 是普通自（首尾两个格子 必为普通格子）                if (randomNum &lt; 85 || i &#x3D;&#x3D; 0 || i &#x3D;&#x3D; num - 1)                &#123;                    grids[i].type &#x3D; E_Grid_Type.Normal;                &#125;                &#x2F;&#x2F;有5%的几率 是炸弹                else if (randomNum &gt;&#x3D; 85 &amp;&amp; randomNum &lt; 90)                &#123;                    grids[i].type &#x3D; E_Grid_Type.Boom;                &#125;                &#x2F;&#x2F;有5%的几率 是暂停                else if (randomNum &gt;&#x3D; 90 &amp;&amp; randomNum &lt; 95)                &#123;                    grids[i].type &#x3D; E_Grid_Type.Pause;                &#125;                &#x2F;&#x2F;有5%的几率 是时空隧道                else                &#123;                    grids[i].type &#x3D; E_Grid_Type.Tunnel;                &#125;                &#x2F;&#x2F;位置应该如何设置                grids[i].pos &#x3D; new Vector2(x, y);                &#x2F;&#x2F;每次循环都应该按一定规则去变化位置吧                &#x2F;&#x2F;加十次                if (indexX &#x3D;&#x3D; 10)                &#123;                    y +&#x3D; 1;                    &#x2F;&#x2F;加一次Y记一次数                    ++indexY;                    if (indexY &#x3D;&#x3D; 2)                    &#123;                        &#x2F;&#x2F;y加了2次过后 把x加的次数记0                        indexX &#x3D; 0;                        indexY &#x3D; 0;                        &#x2F;&#x2F;反向步长                        stepNum &#x3D; -stepNum;                    &#125;                &#125;                else                &#123;                    x +&#x3D; stepNum;                    &#x2F;&#x2F;加一次X记一次数                    ++indexX;                &#125;            &#125;        &#125;        public void Draw()        &#123;            for (int i &#x3D; 0; i &lt; grids.Length; i++)            &#123;                grids[i].Draw();            &#125;        &#125;    &#125;    #endregion    #region 7 玩家枚举和玩家结构体    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 玩家类型枚举    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_PlayerType    &#123;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 玩家        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Player,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 电脑        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Computer,    &#125;    struct Player    &#123;        &#x2F;&#x2F;玩家类型        public E_PlayerType type;        &#x2F;&#x2F;当前所在地图哪一个索引的格子        public int nowIndex;        &#x2F;&#x2F;是否暂停的标识        public bool isPause;        public Player(int index, E_PlayerType type)        &#123;            nowIndex &#x3D; index;            this.type &#x3D; type;            isPause &#x3D; false;        &#125;        public void Draw(Map mapInfo)        &#123;            &#x2F;&#x2F;必须要先得到地图 才能够 得到我在地图上的哪一个格子            &#x2F;&#x2F;从传入的地图中 得到 格子信息            Grid grid &#x3D; mapInfo.grids[nowIndex];            &#x2F;&#x2F;设置位置            Console.SetCursorPosition(grid.pos.x, grid.pos.y);            &#x2F;&#x2F;画 设置颜色 设置图标            switch (type)            &#123;                case E_PlayerType.Player:                    Console.ForegroundColor &#x3D; ConsoleColor.Cyan;                    Console.Write(&quot;★&quot;);                    break;                case E_PlayerType.Computer:                    Console.ForegroundColor &#x3D; ConsoleColor.Magenta;                    Console.Write(&quot;▲&quot;);                    break;            &#125;        &#125;    &#125;    #endregion&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月6日</title>
    <link href="/2022/05/06/diary/2022.5/2022%E5%B9%B45%E6%9C%886%E6%97%A5/"/>
    <url>/2022/05/06/diary/2022.5/2022%E5%B9%B45%E6%9C%886%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="66e42836cfa71681c04573568ab08bc0d5f74b441addf158500edc865fa3a5b6">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe509e5becb1c52418d004df21efc8656ad3164443d15e3426aec259f6651c69cb77793aad835379c9a1816cf1931da50b5899e97c2830c05d575a4743b34a35ff32f5a4fa29c0526e8fc982443375e9f8fd6cf277a101133b1272d3407d8f2a19168677137fd3b36ecb1f84c706fbed376ed6d5de7cdb5d9d656bb6126e326b737fa68e7c0373437510d1f392fed4168dc07d44dd069b31dc0c49f82d59730d8c02be06da9af3c2b3658b6e4bd123c1096bf72d2baee1bafdc331802a4cdde10c99339aa83cee8465cdb4214c73d0592d99c3572a9a58df9e20255525c044ef489eb748c5ab5c10e96e542aff20f36d562d56baa07a626b08bc94621d58c633558e65fabc41c2865abbd20076f1e9e2b7cfdb0f3cbabbfafe0f15a857cfe469025fd48e42886964ad80d51c8ee70fdfa8d1153535ed335a7ccd7aea7ca601bf16182c7e336042c92c7e43c7a64d491462e1b3182db1d033cf267647d687a6813e2f72540eaaccd76675fc21dbc5f2674702b1226313c83993f2a5ead960df1de82247f06e378f31be68a95a48b5504a6f783db90fa9f39c1b5fea7f3fc11be210edfcb3f58faccc325cd8a411d229dfc3cea4584c5f9f7637fc5d2c9e0aa59dac55966df62dbcb57c5a41a75f85d202bf4b0de68bf91bba94a41d986725ed6342d8dbacdf19274fa1e839e276af4191113d5033a2b7fbb07e99188b0289c9fc5619e46bb0bd84ad7095f7a431de37c130261578650cce1c5d29f5d6431d88acf65c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月5日</title>
    <link href="/2022/05/05/diary/2022.5/2022%E5%B9%B45%E6%9C%885%E6%97%A5/"/>
    <url>/2022/05/05/diary/2022.5/2022%E5%B9%B45%E6%9C%885%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="e511f33453d7f039779defafc86db8f6daff2f33133f2aff607c515a0d328970">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe50a54d91deb0dd23a86bb3652d32d2d8603260b625ed51d891af3154cdc9e82226531c388ce184435c513a6bdf27303d625affca6eb12412c28000179a1585754fa6ec21d8e8f513522e8041ae60d72b5e464eb336c6cb9fc6271e69b627a3104a757008b0881f597a83821625f0409e9a3ccb67dbff38f2d551d650992fdeb62a40d368772d7320a2fb9bfa83e11bc8e179140c645e130803a6a971388b8d697e657b23739f21b5b3b1179d17b0d04480d65d24f6053a148f3167ea9698cd3b5811ee6e389ba9bf285337c5c643d9ce7f250862304135afb5cc37ee9fa66a39be4ca1c859708e8dc1beb13d004de352b37b1b0e40f61c18bf700a40fa2336fba7516c41ab191c27e86c22676bda861d0e296d91ee18e8c02c1e2417b66392be6c535f732e821a4436c374c5d8db6a170333841f4a9700469aedb6bce63d0f0553e01a782a004bd1157ccf8b033a090473ad734b4dd40916eabf04fe7f7bcaa98d2a7878bd3490632e4f7b9d33106db0db446c72822e848b1e2bf6e370b586743288fd41a4db74420f36101ca7157d1bd72a619372db36cf0d87d775f8a0a3cc7a41e139059cb35c0574c6f4a06fd8cc86830d23a785ecfa36ab81066b288f0efe4b425916390accf22d275216c40a4645e6a58f0790f36cd7a9bac537da2c79eddb817d221a971c55a089d4b3bb08427c298af5a6fa5501daf6eb83463199106dfe1efe1b3215cc3704fef4b1852c65775fb62f05c9be821f1d4e6a8b75123b1e26332e0de47278c5a94a1c3aadcfa12e37fd520d4e85d2125d93b261fde0aa86ca6a51331d9d3f0044b300393bacba389840f4352cdc91df6fffedf7399741c087b18fcb3c475849778d2c49e45a72a477f5a72949c95b155fc6de87de8b13a6b3d6adc150f0757026eb91717a6b800384eb7a1acfe45141cf0c9412ea129963a1e75022cb8f72317ea5185592198377a58464178e933ce316fa183200a7d89c12e1f5551774ca08bf667026c06c6f0e5d2104ddfad6fd51b9cea3c5d9a67e0a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSharp入门实践——简易飞行棋</title>
    <link href="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/CSharp%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%A3%8B/"/>
    <url>/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/CSharp%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%A3%8B/</url>
    
    <content type="html"><![CDATA[<p>控制台实现简易飞行棋</p><span id="more"></span><p><strong># 游戏逻辑流程图</strong><br>游戏逻辑题直接引用唐老狮课程里的流程图</p><p><strong>## 整体逻辑流程图</strong></p><img src="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/CSharp%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%A3%8B/%E6%95%B4%E4%BD%93%E9%80%BB%E8%BE%91%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class=""><p><strong>## 开始场景流程图</strong></p><img src="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/CSharp%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%A3%8B/%E5%BC%80%E5%A7%8B%E5%9C%BA%E6%99%AF%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class=""><p><strong>## 游戏场景流程图</strong></p><img src="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/CSharp%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%A3%8B/%E5%BC%80%E5%A7%8B%E5%9C%BA%E6%99%AF%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class=""><p><strong>## 结束场景流程图</strong></p><img src="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/CSharp%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%A3%8B/%E7%BB%93%E6%9D%9F%E5%9C%BA%E6%99%AF%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class=""><p><strong># 代码实现</strong></p><p>寄 不能实现前一个位置消失 结构体还没搞明白</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace CSharp基础实践教学&#123;    #region 格子结构体（写不来，看答案了）    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 格子类型枚举    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_GridType    &#123;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 普通格子        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Normal,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 炸弹        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Bomb,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 暂停        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Pause,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 时空隧道        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        Tunnel,    &#125;    &#x2F;&#x2F;看答案的 可记住    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 位置信息结构体 包含x y位置    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    struct Vector2    &#123;        public int x;        public int y;        public Vector2(int x, int y)        &#123;            this.x &#x3D; x; this.y &#x3D; y;        &#125;    &#125;    &#x2F;&#x2F;格子结构体    struct Grid    &#123;        public E_GridType gridType; &#x2F;&#x2F;格子类型        public Vector2 position; &#x2F;&#x2F;格子位置        &#x2F;&#x2F;构造函数  输入格子位置  格子初始化        public Grid(E_GridType gridType, int x, int y)        &#123;            this.gridType &#x3D; gridType;            position.x &#x3D; x;             position.y &#x3D; y;        &#125;        &#x2F;&#x2F;画格子        public void Draw()        &#123;            &#x2F;&#x2F;控制光标位置  打印选项            Console.SetCursorPosition(position.x, position.y);            switch (gridType)            &#123;                &#x2F;&#x2F;普通格子                case E_GridType.Normal:                    Console.ForegroundColor &#x3D; ConsoleColor.White;                    Console.Write(&#39;□&#39;);                    break;                &#x2F;&#x2F;炸弹                case E_GridType.Bomb:                    Console.ForegroundColor &#x3D; ConsoleColor.Blue;                    Console.Write(&quot;‖&quot;);                    break;                &#x2F;&#x2F;暂停                case E_GridType.Pause:                    Console.ForegroundColor &#x3D; ConsoleColor.Red;                    Console.Write(&quot;●&quot;);                    break;                &#x2F;&#x2F;时空隧道                case E_GridType.Tunnel:                    Console.ForegroundColor &#x3D; ConsoleColor.White;                    Console.Write(&quot;¤&quot;);                    break;            &#125;        &#125;    &#125;    #endregion    #region 地图结构体（写不来，看答案了）    struct Map    &#123;        &#x2F;&#x2F;用一个格子结构体数组 表示地图里的所有格子        public Grid[] grids;        &#x2F;&#x2F;地图初始化构造函数        &#x2F;&#x2F;x, y为棋盘起始点        public Map(int x, int y)        &#123;            grids &#x3D; new Grid[84];            Random r &#x3D; new Random();            int randomNum;            for (int i &#x3D; 0; i &lt; 84; i++)            &#123;                &#x2F;&#x2F;应该初始化 格子类型                randomNum &#x3D; r.Next(0, 100);                &#x2F;&#x2F;设置类型 普通格子                &#x2F;&#x2F;有85%几率 是普通格子 (首尾两个格子 必为普通格子)                if(randomNum &lt; 85 || i &#x3D;&#x3D; 0 || i &#x3D;&#x3D; 95)                &#123;                    grids[i].gridType &#x3D; E_GridType.Normal;                &#125;                &#x2F;&#x2F;有5%几率 是炸弹                if (randomNum &gt;&#x3D; 85 &amp;&amp; randomNum &lt; 90)                &#123;                    grids[i].gridType &#x3D; E_GridType.Bomb;                &#125;                &#x2F;&#x2F;有5%几率 是暂停                if (randomNum &gt;&#x3D; 90 &amp;&amp; randomNum &lt; 95)                &#123;                    grids[i].gridType &#x3D; E_GridType.Pause;                &#125;                &#x2F;&#x2F;有5%几率 是时空隧道                if (randomNum &gt;&#x3D; 95 &amp;&amp; randomNum &lt; 100)                &#123;                    grids[i].gridType &#x3D; E_GridType.Tunnel;                &#125;                &#x2F;&#x2F;设置位置                grids[i].position &#x3D; new Vector2(x, y);                &#x2F;&#x2F;每次循环都应该一定规则去变化位置(每次少4个步长)                if( i &lt;&#x3D; 12 || (i &gt; 56 &amp;&amp; i &lt;&#x3D; 64)  )                &#123;                    y++;                &#125;                else if( (i &gt; 12 &amp;&amp; i &lt;&#x3D; 30) || (i &gt; 64 &amp;&amp; i &lt;&#x3D; 74) )                &#123;                    x +&#x3D; 2;                &#125;                else if( (i &gt; 30 &amp;&amp; i &lt;&#x3D; 42) || (i &gt; 74 &amp;&amp; i &lt;&#x3D; 78) )                &#123;                    y--;                &#125;                else if(( i &gt; 42 &amp;&amp; i &lt;&#x3D; 56) || (i &gt; 78 &amp;&amp; i &lt;&#x3D; 84) )                &#123;                    x -&#x3D; 2;                &#125;            &#125;        &#125;        public void Draw()        &#123;            for (int i &#x3D; 0; i &lt; grids.Length; i++)            &#123;                grids[i].Draw();            &#125;        &#125;    &#125;    #endregion    #region 玩家结构体    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 玩家类型    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    enum E_PlayerType    &#123;        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 玩家        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        You,        &#x2F;&#x2F;&#x2F; &lt;summary&gt;        &#x2F;&#x2F;&#x2F; 电脑        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;        PC,    &#125;    struct Player    &#123;        public E_PlayerType playerType;        &#x2F;&#x2F;当前位置索引        public int nowIndex;        &#x2F;&#x2F;玩家初始化构造函数        public Player(E_PlayerType playerType, ref int nowIndex)        &#123;            this.playerType &#x3D; playerType;            this.nowIndex &#x3D; nowIndex;        &#125;        &#x2F;&#x2F;画玩家和电脑格子的逻辑 用索引得到所在地图上格子        public void DrawMove( Map mapinfo )        &#123;            &#x2F;&#x2F;从传入的地图得到格子信息            Grid grid &#x3D; mapinfo.grids[nowIndex];            &#x2F;&#x2F;先控制光标位置            Console.SetCursorPosition(grid.position.x, grid.position.y);            &#x2F;&#x2F;判断是画玩家还是电脑            switch(playerType)            &#123;                &#x2F;&#x2F;画玩家                case E_PlayerType.You:                    Console.ForegroundColor &#x3D; ConsoleColor.Cyan;                    Console.WriteLine(&quot;★&quot;);                    break;                case E_PlayerType.PC:                    Console.ForegroundColor &#x3D; ConsoleColor.Magenta;                    Console.WriteLine(&quot;▲&quot;);                    break;            &#125;        &#125;    &#125;    #endregion    internal class Program    &#123;        &#x2F;&#x2F;判断玩家和电脑是否重叠        static void DrawPlayer(Player you, Player PC, Map map)        &#123;            &#x2F;&#x2F;重合的话 Player结构体外部处理            if(you.nowIndex &#x3D;&#x3D; PC.nowIndex)            &#123;                &#x2F;&#x2F;得到重合的位置                Grid grid &#x3D; map.grids[you.nowIndex];                Console.SetCursorPosition(grid.position.x, grid.position.y);                Console.ForegroundColor &#x3D; ConsoleColor.Green;                Console.WriteLine(&quot;◎&quot;);            &#125;            &#x2F;&#x2F;不重合的话 Player结构体内部处理             else            &#123;                you.DrawMove(map);                PC.DrawMove(map);            &#125;        &#125;         static void Main(string[] args)        &#123;            #region 控制台基础设置            &#x2F;&#x2F;控制台大小设置  w表示宽  h表示高            int w &#x3D; 50;            int h &#x3D; 30;            ConsoleInit(w, h);            #endregion            #region 实现多个场景的转换            &#x2F;&#x2F;定义场景ID  初始从开始场景开始            &#x2F;&#x2F;开始场景为0  游戏场景为1  结束场景为2            int nowScene &#x3D; 0; ;            &#x2F;&#x2F;玩家获胜或者电脑获胜的信息            string gameOverInfo;            &#x2F;&#x2F;整体游戏逻辑死循环            while (true)            &#123;                &#x2F;&#x2F;用不同场景ID  进行不同的场景逻辑                &#x2F;&#x2F;用switch实现场景的转换                switch (nowScene)                &#123;                    &#x2F;&#x2F;开始场景                    case 0:                        &#x2F;&#x2F;实现开始场景逻辑                        #region 开始场景逻辑                        &#x2F;&#x2F;清空控制台  以后续添加文字与游戏                        Console.Clear();                        &#x2F;&#x2F;控制光标位置  打印标题                        Console.SetCursorPosition(w &#x2F; 2 - 5, 8);                        Console.Write(&quot;飞行棋小游戏&quot;);                        &#x2F;&#x2F;事先定义想要选择的选项ID 默认初始选择第一个选项(开始游戏)                        &#x2F;&#x2F;开始游戏为0  退出游戏为1                        int nowSelIndex &#x3D; 0;                        &#x2F;&#x2F;开始场景逻辑死循环                        while(true)                        &#123;                            #region 开始场景生成逻辑                                                        &#x2F;&#x2F;控制光标位置  打印选项                            Console.SetCursorPosition(w &#x2F; 2 - 3, 13);                            &#x2F;&#x2F;根据现在选中的选项改变选项的颜色(改变光标前景色)                            &#x2F;&#x2F;选中为红色 未选中为白色                            Console.ForegroundColor &#x3D; nowSelIndex &#x3D;&#x3D; 0 ? ConsoleColor.Red : ConsoleColor.White;                            Console.Write(&quot;开始游戏&quot;);                            &#x2F;&#x2F;逻辑同上                            Console.SetCursorPosition(w &#x2F; 2 - 3, 15);                            Console.ForegroundColor &#x3D; nowSelIndex &#x3D;&#x3D; 1 ? ConsoleColor.Red : ConsoleColor.White;                            Console.Write(&quot;退出游戏&quot;);                            &#x2F;&#x2F;定义玩家输入w为向上选择  输入s为向下选择  输入j为确定选择                            Console.SetCursorPosition(w &#x2F; 2 - 5, 20);                            Console.ForegroundColor &#x3D; ConsoleColor.Yellow;                            Console.Write(&quot;按w向上选择&quot;);                            Console.SetCursorPosition(w &#x2F; 2 - 5, 22);                            Console.ForegroundColor &#x3D; ConsoleColor.Yellow;                            Console.Write(&quot;按s向下选择&quot;);                            Console.SetCursorPosition(w &#x2F; 2 - 3, 24);                            Console.ForegroundColor &#x3D; ConsoleColor.Yellow;                            Console.Write(&quot;按j确定&quot;);                            #endregion                            #region 开始场景跳转逻辑                            &#x2F;&#x2F;因为break只能跳出最近的switch(即下文跳转场景的)  而为结束开始场景逻辑                              &#x2F;&#x2F;需要定义一个标识判断是否跳出开始场景逻辑死循环                            bool isQuitWhile &#x3D; false;                            &#x2F;&#x2F;获取玩家输入  且不显示玩家的输入                            char input &#x3D; Console.ReadKey(true).KeyChar;                            &#x2F;&#x2F;根据玩家输入  转换选中选项  与  确定选择                            switch(input)                            &#123;                                &#x2F;&#x2F;按w的逻辑  大小写Ww均可                                case &#39;W&#39;:                                case &#39;w&#39;:                                    &#x2F;&#x2F;实际上就是让选项ID变为0                                    --nowSelIndex;                                    &#x2F;&#x2F;且若已经是0 不能再减                                    if(nowSelIndex &lt; 0)                                    &#123;                                        nowSelIndex &#x3D; 0;                                    &#125;                                    break;                                &#x2F;&#x2F;按s的逻辑  大小写Ss均可                                case &#39;S&#39;:                                case &#39;s&#39;:                                    &#x2F;&#x2F;实际上就是让选项ID变为0                                    ++nowSelIndex;                                    &#x2F;&#x2F;且若已经是1 不能再加                                    if (nowSelIndex &gt; 1)                                    &#123;                                        nowSelIndex &#x3D; 1;                                    &#125;                                    break;                                &#x2F;&#x2F;按j的逻辑  大小写Jj均可                                case &#39;J&#39;:                                case &#39;j&#39;:                                                                       &#x2F;&#x2F;判断是进入哪个场景                                    &#x2F;&#x2F;进入游戏场景                                    if( nowSelIndex &#x3D;&#x3D; 0)                                    &#123;                                        &#x2F;&#x2F;将场景ID变为1                                        nowScene &#x3D; 1;                                        &#x2F;&#x2F;确定选择后就要进入其他场景  故必须跳出开始场景的死循环                                        &#x2F;&#x2F;即要使判断跳出标识置为true                                        isQuitWhile &#x3D; true;                                    &#125;                                    &#x2F;&#x2F;退出游戏                                    else if(nowSelIndex &#x3D;&#x3D; 1)                                    &#123;                                        &#x2F;&#x2F;关闭控制台(也不需要跳出循环了)                                        Environment.Exit(0);                                    &#125;                                    break;                            &#125;                            &#x2F;&#x2F;若isQuitWhile为true  则跳出开始场景循环                            if (isQuitWhile)                            &#123;                                break;                            &#125;                                #endregion                        &#125;                        #endregion                        break;                    &#x2F;&#x2F;游戏场景                    case 1:                        &#x2F;&#x2F;实现游戏场景逻辑                        #region 游戏场景逻辑                        #region 参数设置                        Console.Clear();                        &#x2F;&#x2F;退出while的标识                        bool isQuitGameWhile &#x3D; false;                        &#x2F;&#x2F;定义骰子的随机数                        Random d &#x3D; new Random();                        int dice;                        &#x2F;&#x2F;设置一个计数位选择是玩家动还是电脑动                        int count &#x3D; 0;                        &#x2F;&#x2F;设置玩家和电脑所在的格数 初始化为0                        int numYou &#x3D; 0;                        int numPC &#x3D; 0;                        &#x2F;&#x2F;设置玩家变量 电脑变量                        Player you &#x3D; new Player(E_PlayerType.You, ref numYou);                        Player PC &#x3D; new Player(E_PlayerType.PC, ref numPC);                        #endregion                        #region 红色墙壁                        DrawWall(w, h);                        #endregion                        #region 绘制棋盘                        Map map &#x3D; new Map(6, 3);                        map.Draw();                        #endregion                        #region 静态信息栏(每种格子类型的含义)                        Console.SetCursorPosition(2, h - 10);                        Console.ForegroundColor &#x3D; ConsoleColor.White;                        Console.WriteLine(&quot;□:普通格子&quot;);                        Console.SetCursorPosition(2, h - 9);                        Console.ForegroundColor &#x3D; ConsoleColor.Blue;                        Console.WriteLine(&quot;‖:暂停,一回合不动&quot;);                        Console.SetCursorPosition(26, h - 9);                        Console.ForegroundColor &#x3D; ConsoleColor.Red;                        Console.WriteLine(&quot;●:炸弹,倒退5格&quot;);                        Console.SetCursorPosition(2, h - 8);                        Console.ForegroundColor &#x3D; ConsoleColor.White;                        Console.WriteLine(&quot;¤:时空隧道,随机倒退,暂停,换位置&quot;);                        Console.SetCursorPosition(2, h - 7);                        Console.ForegroundColor &#x3D; ConsoleColor.Cyan;                        Console.WriteLine(&quot;★:玩家&quot;);                        Console.SetCursorPosition(12, h - 7);                        Console.ForegroundColor &#x3D; ConsoleColor.Magenta;                        Console.WriteLine(&quot;▲:电脑&quot;);                        Console.SetCursorPosition(22, h - 7);                        Console.ForegroundColor &#x3D; ConsoleColor.Green;                        Console.WriteLine(&quot;◎:玩家与电脑重合&quot;);                        #endregion                        #region 动态信息栏(你走几步 电脑走几步)                        Console.SetCursorPosition(2, h - 5);                        Console.ForegroundColor &#x3D; ConsoleColor.White;                        Console.WriteLine(&quot;按任意键开始扔骰子&quot;);                        #endregion                        &#x2F;&#x2F;先打印起始位置                        DrawPlayer(you, PC, map);                        &#x2F;&#x2F;玩家 电脑 是否暂停                        bool youPause &#x3D; false;                        bool PCPause &#x3D; false;                        &#x2F;&#x2F;游戏场景死循环 专门用来检测 玩家输入相关循环                        while (true)                        &#123;                                                            &#x2F;&#x2F;每次输入                            Console.ReadKey(true);                            dice &#x3D; d.Next(1, 7);                            if(youPause)                            &#123;                                &#x2F;&#x2F;玩家暂停一回合 让电脑走                                youPause &#x3D; false;                                count &#x3D; 1;                            &#125;                            if (PCPause)                            &#123;                                &#x2F;&#x2F;电脑暂停一回合 让玩家走                                PCPause &#x3D; false;                                count &#x3D; 0;                            &#125;                            switch (count)                            &#123;                                &#x2F;&#x2F;玩家移动                                case 0:                                    you.nowIndex +&#x3D; dice;                                    &#x2F;&#x2F;玩家的格子先超出地图数                                     if(you.nowIndex &gt; 83)                                    &#123;                                        gameOverInfo &#x3D; &quot;玩家获胜&quot;;                                        isQuitGameWhile &#x3D; true;                                        nowScene &#x3D; 2;                                        break;                                    &#125;                                    Grid grid1 &#x3D; map.grids[you.nowIndex];                                    switch (grid1.gridType)                                    &#123;                                        case E_GridType.Normal:                                            &#x2F;&#x2F;普通格子  切换到电脑移动                                            count++;                                            break;                                        case E_GridType.Bomb:                                            &#x2F;&#x2F;炸弹倒退5格                                            you.nowIndex -&#x3D; 5;                                            &#x2F;&#x2F;不能退出起点                                            if(you.nowIndex &lt; 0)                                            &#123;                                                you.nowIndex &#x3D; 0;                                            &#125;                                            break;                                        case E_GridType.Pause:                                            &#x2F;&#x2F;暂停一回合                                            youPause &#x3D; true;                                            break;                                        case E_GridType.Tunnel:                                            &#x2F;&#x2F;随机 倒退 暂停 和电脑交换位置                                            dice &#x3D; d.Next(1, 91);                                            if(dice &lt; 30) &#x2F;&#x2F;倒退                                            &#123;                                                you.nowIndex -&#x3D; 5;                                            &#125;                                            else if(dice &gt;&#x3D; 30 &amp;&amp; dice &lt;60) &#x2F;&#x2F;暂停                                            &#123;                                                youPause &#x3D; true;                                            &#125;                                            else &#x2F;&#x2F;和电脑交换位置                                            &#123;                                                int t &#x3D; you.nowIndex;                                                you.nowIndex &#x3D; PC.nowIndex;                                                PC.nowIndex &#x3D; t;                                            &#125;                                            break;                                    &#125;                                    DrawPlayer(you, PC, map);                                    &#x2F;&#x2F;切换到电脑移动                                                                    break;                                &#x2F;&#x2F;电脑移动                                case 1:                                    PC.nowIndex +&#x3D; dice;                                    if (PC.nowIndex &gt; 83)                                    &#123;                                        gameOverInfo &#x3D; &quot;电脑获胜&quot;;                                        isQuitGameWhile &#x3D; true;                                        nowScene &#x3D; 2;                                        break;                                    &#125;                                    DrawPlayer(you, PC, map);                                    Grid grid2 &#x3D; map.grids[PC.nowIndex];                                    switch (grid2.gridType)                                    &#123;                                        case E_GridType.Normal:                                            &#x2F;&#x2F;普通格子  切换到玩家移动                                            count--;                                            break;                                        case E_GridType.Bomb:                                            &#x2F;&#x2F;炸弹倒退5格                                            PC.nowIndex -&#x3D; 5;                                            &#x2F;&#x2F;不能退出起点                                            if (PC.nowIndex &lt; 0)                                            &#123;                                                PC.nowIndex &#x3D; 0;                                            &#125;                                            break;                                        case E_GridType.Pause:                                            &#x2F;&#x2F;暂停一回合                                            PCPause &#x3D; true;                                            break;                                        case E_GridType.Tunnel:                                            &#x2F;&#x2F;随机 倒退 暂停 和电脑交换位置                                            dice &#x3D; d.Next(1, 91);                                            if (dice &lt; 30) &#x2F;&#x2F;倒退                                            &#123;                                                PC.nowIndex -&#x3D; 5;                                            &#125;                                            else if (dice &gt;&#x3D; 30 &amp;&amp; dice &lt; 60) &#x2F;&#x2F;暂停                                            &#123;                                                PCPause &#x3D; true;                                            &#125;                                            else &#x2F;&#x2F;和电脑交换位置                                            &#123;                                                int t &#x3D; you.nowIndex;                                                you.nowIndex &#x3D; PC.nowIndex;                                                PC.nowIndex &#x3D; t;                                            &#125;                                            break;                                    &#125;                                    break;                            &#125;                                                        if (isQuitGameWhile)                            &#123;                                break;                            &#125;                        &#125;                        #endregion                            break;                    &#x2F;&#x2F;结束场景                    case 2:                        &#x2F;&#x2F;实现结束场景逻辑                        #region 结束场景逻辑                        &#x2F;&#x2F;清空控制台  以后续添加文字与游戏                        Console.Clear();                        &#x2F;&#x2F;控制光标位置  打印标题                        Console.SetCursorPosition(w &#x2F; 2 - 3, 8);                        Console.Write(&quot;Gameover&quot;);                        &#x2F;&#x2F;可变内容的显示 根据失败或成功 显示内容不同                        Console.ForegroundColor &#x3D; ConsoleColor.Green;                        Console.SetCursorPosition(w &#x2F; 2 - 4, 6);                                                &#x2F;&#x2F;事先定义想要选择的选项ID  默认初始选择第一个选项(重新开始)                        &#x2F;&#x2F;(重新开始为0  退出游戏为1)                        int nowSelEndIndex &#x3D; 0;                        &#x2F;&#x2F;开始场景逻辑死循环                        while (true)                        &#123;                            #region 结束场景生成逻辑                            &#x2F;&#x2F;控制光标位置  打印选项                            Console.SetCursorPosition(w &#x2F; 2 - 3, 13);                            &#x2F;&#x2F;根据现在选中的选项改变选项的颜色(改变光标前景色)                            &#x2F;&#x2F;选中为红色 未选中为白色                            Console.ForegroundColor &#x3D; nowSelEndIndex &#x3D;&#x3D; 0 ? ConsoleColor.Red : ConsoleColor.White;                            Console.Write(&quot;重新开始&quot;);                            &#x2F;&#x2F;逻辑同上                            Console.SetCursorPosition(w &#x2F; 2 - 3, 15);                            Console.ForegroundColor &#x3D; nowSelEndIndex &#x3D;&#x3D; 1 ? ConsoleColor.Red : ConsoleColor.White;                            Console.Write(&quot;退出游戏&quot;);                            &#x2F;&#x2F;定义玩家输入w为向上选择  输入s为向下选择  输入j为确定选择                            Console.SetCursorPosition(w &#x2F; 2 - 5, 20);                            Console.ForegroundColor &#x3D; ConsoleColor.Yellow;                            Console.Write(&quot;按w向上选择&quot;);                            Console.SetCursorPosition(w &#x2F; 2 - 5, 22);                            Console.ForegroundColor &#x3D; ConsoleColor.Yellow;                            Console.Write(&quot;按s向下选择&quot;);                            Console.SetCursorPosition(w &#x2F; 2 - 3, 24);                            Console.ForegroundColor &#x3D; ConsoleColor.Yellow;                            Console.Write(&quot;按j确定&quot;);                            #endregion                            #region 结束场景跳转逻辑                            &#x2F;&#x2F;因为break只能跳出最近的switch(即下文跳转场景的)  而为结束开始场景逻辑                              &#x2F;&#x2F;需要定义一个标识判断是否跳出开始场景逻辑死循环                            bool isQuitEndWhile &#x3D; false;                            &#x2F;&#x2F;获取玩家输入  且不显示玩家的输入                            char input &#x3D; Console.ReadKey(true).KeyChar;                            &#x2F;&#x2F;根据玩家输入  转换选中选项  与  确定选择                            switch (input)                            &#123;                                &#x2F;&#x2F;按w的逻辑  大小写Ww均可                                case &#39;W&#39;:                                case &#39;w&#39;:                                    &#x2F;&#x2F;实际上就是让选项ID变为0                                    --nowSelEndIndex;                                    &#x2F;&#x2F;且若已经是0 不能再减                                    if (nowSelEndIndex &lt; 0)                                    &#123;                                        nowSelEndIndex &#x3D; 0;                                    &#125;                                    break;                                &#x2F;&#x2F;按s的逻辑  大小写Ss均可                                case &#39;S&#39;:                                case &#39;s&#39;:                                    &#x2F;&#x2F;实际上就是让选项ID变为0                                    ++nowSelEndIndex;                                    &#x2F;&#x2F;且若已经是1 不能再加                                    if (nowSelEndIndex &gt; 1)                                    &#123;                                        nowSelEndIndex &#x3D; 1;                                    &#125;                                    break;                                &#x2F;&#x2F;按j的逻辑  大小写Jj均可                                case &#39;J&#39;:                                case &#39;j&#39;:                                    &#x2F;&#x2F;判断是进入哪个场景                                    &#x2F;&#x2F;进入游戏场景                                    if (nowSelEndIndex &#x3D;&#x3D; 0)                                    &#123;                                        &#x2F;&#x2F;将场景ID变为1                                        nowScene &#x3D; 1;                                        &#x2F;&#x2F;确定选择后就要进入其他场景  故必须跳出开始场景的死循环                                        &#x2F;&#x2F;即要使判断跳出标识置为true                                        isQuitEndWhile &#x3D; true;                                    &#125;                                    &#x2F;&#x2F;退出游戏                                    else if (nowSelEndIndex &#x3D;&#x3D; 1)                                    &#123;                                        &#x2F;&#x2F;关闭控制台(也不需要跳出循环了)                                        Environment.Exit(0);                                    &#125;                                    break;                            &#125;                            &#x2F;&#x2F;若isQuitEndWhile为true  则跳出结束场景循环                            if (isQuitEndWhile)                            &#123;                                break;                            &#125;                            #endregion                        &#125;                        #endregion                        break;                &#125;            &#125;            #endregion        &#125;        #region 控制台基础设置        static void ConsoleInit(int w, int h)        &#123;            &#x2F;&#x2F;隐藏光标            Console.CursorVisible &#x3D; false;            &#x2F;&#x2F;设置舞台（控制台）大小            Console.SetWindowSize(w, h);            &#x2F;&#x2F;设置缓冲区大小            Console.SetBufferSize(w, h);        &#125;        #endregion        #region 红色墙壁        static void DrawWall(int w, int h)        &#123;            &#x2F;&#x2F;设置颜色为红色            Console.ForegroundColor &#x3D; ConsoleColor.Red;            &#x2F;&#x2F;画墙            &#x2F;&#x2F;上方墙 下方墙 中间墙1 中间墙2            for (int i &#x3D; 0; i &lt;&#x3D; w - 2; i +&#x3D; 2)            &#123;                Console.SetCursorPosition(i, 0); &#x2F;&#x2F;上方墙                Console.Write(&#39;■&#39;);                Console.SetCursorPosition(i, h - 1); &#x2F;&#x2F;下方墙                Console.Write(&#39;■&#39;);                Console.SetCursorPosition(i, h - 11); &#x2F;&#x2F;中间墙1                Console.Write(&#39;■&#39;);                Console.SetCursorPosition(i, h - 6); &#x2F;&#x2F;中间墙2                Console.Write(&#39;■&#39;);            &#125;            &#x2F;&#x2F;左边墙 右边墙            for (int i &#x3D; 0; i &lt;&#x3D; h - 1; i++)            &#123;                Console.SetCursorPosition(0, i); &#x2F;&#x2F;左边墙                Console.Write(&#39;■&#39;);                Console.SetCursorPosition(w - 2, i); &#x2F;&#x2F;右边墙                Console.Write(&#39;■&#39;);            &#125;        &#125;        #endregion    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSharp入门总结</title>
    <link href="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/CSharp%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/"/>
    <url>/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/CSharp%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>入门总结</p><span id="more"></span><img src="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/CSharp%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/summary.png" class="">]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSharp基础总结</title>
    <link href="/2022/05/04/CSharp/CSharp%E5%9F%BA%E7%A1%80/CSharp%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"/>
    <url>/2022/05/04/CSharp/CSharp%E5%9F%BA%E7%A1%80/CSharp%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>基础总结</p><span id="more"></span><img src="/2022/05/04/CSharp/CSharp%E5%9F%BA%E7%A1%80/CSharp%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/summary.png" class="">]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>选择排序</title>
    <link href="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>2022.5.4</p><span id="more"></span><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>重点知识点：<br><strong>选择排序</strong><br>1.基本概念： 新建中间商 遍历依次比较找出极值 放入目标位置<br>2.套路写法：两层循环（外层轮数 内层寻找 初始索引 记录极值）<br>3.优化： 已经完成比较的不参与比较  加一个bool标识判断是否已经有序</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><img src="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/exam.png" class=""><p>以下是答案：</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson14_选择排序练习题&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;选择排序练习题&quot;);            #region 练习题1               &#x2F;&#x2F;生成随机数组            Random r &#x3D; new Random();            int[] arr &#x3D; new int[20];            for (int i &#x3D; 0; i &lt; arr.Length; i++)            &#123;                arr[i] &#x3D; r.Next(0, 101);            &#125;            &#x2F;&#x2F;选择排序升序排序            Console.WriteLine(&quot;选择排序升序排序结果:&quot;);            for (int m &#x3D; 0; m &lt; arr.Length; m++)            &#123;                int index &#x3D; 0;                int temp;                for (int n &#x3D; 0; n &lt; arr.Length - m; n++)                &#123;                    if (arr[index] &lt; arr[n])                    &#123;                        index &#x3D; n;                    &#125;                &#125;                if(index !&#x3D; arr.Length - m -1 )                &#123;                    temp &#x3D; arr[index];                    arr[index] &#x3D; arr[arr.Length - m - 1];                    arr[arr.Length - m - 1] &#x3D; temp;                &#125;            &#125;            for (int i &#x3D; 0; i &lt; arr.Length; i++)            &#123;                Console.Write(arr[i] + &quot; &quot;);            &#125;            &#x2F;&#x2F;中间间隔            Console.WriteLine();            Console.WriteLine(&quot;*************&quot;);            &#x2F;&#x2F;冒泡排序降序排序            Console.WriteLine(&quot;选择排序降序排序结果:&quot;);            for (int m &#x3D; 0; m &lt; arr.Length; m++)            &#123;                int index &#x3D; 0;                int temp;                for (int n &#x3D; 0; n &lt; arr.Length - m; n++)                &#123;                    if (arr[index] &gt; arr[n])                    &#123;                        index &#x3D; n;                    &#125;                &#125;                if (index !&#x3D; arr.Length - m - 1)                &#123;                    temp &#x3D; arr[index];                    arr[index] &#x3D; arr[arr.Length - m - 1];                    arr[arr.Length - m - 1] &#x3D; temp;                &#125;            &#125;            for (int i &#x3D; 0; i &lt; arr.Length; i++)            &#123;                Console.Write(arr[i] + &quot; &quot;);            &#125;            #endregion        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>冒泡排序</title>
    <link href="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>2022.5.4</p><span id="more"></span><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>重点知识点：<br><strong>冒泡排序</strong><br>1.基本概念： “无序”数组中两两相邻的数不断比较与交换直到“有序”<br>2.套路写法：两层循环（外层轮数 内层比较 满足则交换）<br>3.优化： 已经完成比较的不参与比较  加一个bool标识判断是否已经有序</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><img src="/2022/05/04/CSharp/CSharp%E5%85%A5%E9%97%A8/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/exam.png" class=""><p>以下是答案：</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson13_冒泡排序练习题&#123;    internal class Program    &#123;        #region 练习题2        &#x2F;&#x2F;冒泡排序函数        static void PaiXu( int[] arr, bool upDown)        &#123;            &#x2F;&#x2F;小优化 在循环外声明变量 可以提高一些性能            bool isSort;            int temp;            for (int m &#x3D; 0; m &lt; arr.Length; m++)            &#123;                isSort &#x3D; false;                for (int n &#x3D; 0; n &lt; arr.Length - 1 - m; n++)                &#123;                    if(upDown)                    &#123;                        if (arr[n] &gt; arr[n + 1])                        &#123;                            isSort &#x3D; true;                            temp &#x3D; arr[n];                            arr[n] &#x3D; arr[n + 1];                            arr[n + 1] &#x3D; temp;                        &#125;                    &#125;                    else                    &#123;                        if (arr[n] &lt; arr[n + 1])                        &#123;                            isSort &#x3D; true;                            temp &#x3D; arr[n];                            arr[n] &#x3D; arr[n + 1];                            arr[n + 1] &#x3D; temp;                        &#125;                    &#125;                &#125;                if (!isSort)                &#123;                    break;                &#125;            &#125;            if (upDown)            &#123;                Console.WriteLine(&quot;冒泡排序升序排序结果:&quot;);            &#125;            else            &#123;                Console.WriteLine(&quot;冒泡排序降序排序结果:&quot;);            &#125;            for (int i &#x3D; 0; i &lt; arr.Length; i++)            &#123;                            Console.Write(arr[i] + &quot; &quot;);            &#125;        &#125;        #endregion        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;冒泡排序练习题&quot;);            #region 练习题1            &#x2F;&#x2F;判断是否已经有序 标识符            bool isSort &#x3D; false;            &#x2F;&#x2F;生成随机数组            Random r &#x3D; new Random();            int[] arr1 &#x3D; new int[20];            for (int i &#x3D; 0; i &lt; arr1.Length; i++)            &#123;                arr1[i] &#x3D; r.Next(0, 101);            &#125;            &#x2F;&#x2F;冒泡排序升序排序            Console.WriteLine(&quot;冒泡排序升序排序结果:&quot;);            for(int m &#x3D; 0; m &lt; arr1.Length; m++)            &#123;                isSort &#x3D; false;                for(int n &#x3D; 0; n &lt; arr1.Length - 1 - m; n++)                &#123;                    if(arr1[n] &gt; arr1[n + 1])                    &#123;                        isSort &#x3D; true;                        int temp &#x3D; arr1[n];                        arr1[n] &#x3D; arr1[n + 1];                        arr1[n + 1] &#x3D; temp;                    &#125;                &#125;                if( !isSort )                &#123;                    break;                &#125;            &#125;            for(int i &#x3D; 0; i &lt; arr1.Length; i++)            &#123;                Console.Write(arr1[i] + &quot; &quot;);            &#125;            &#x2F;&#x2F;中间间隔            Console.WriteLine();            Console.WriteLine(&quot;*************&quot;);            &#x2F;&#x2F;冒泡排序降序排序            Console.WriteLine(&quot;冒泡排序降序排序结果:&quot;);            for (int m &#x3D; 0; m &lt; arr1.Length; m++)            &#123;                isSort &#x3D; false;                for (int n &#x3D; 0; n &lt; arr1.Length - 1 - m; n++)                &#123;                    if (arr1[n] &lt; arr1[n + 1])                    &#123;                        isSort &#x3D; true;                        int temp &#x3D; arr1[n];                        arr1[n] &#x3D; arr1[n + 1];                        arr1[n + 1] &#x3D; temp;                    &#125;                &#125;                if (!isSort)                &#123;                    break;                &#125;            &#125;            for (int i &#x3D; 0; i &lt; arr1.Length; i++)            &#123;                Console.Write(arr1[i] + &quot; &quot;);            &#125;            #endregion            &#x2F;&#x2F;中间间隔            Console.WriteLine();            Console.WriteLine(&quot;*************&quot;);            #region 练习题2            &#x2F;&#x2F;生成数组            int[] arr2 &#x3D; new int[20];            for (int i &#x3D; 0; i &lt; arr2.Length; i++)            &#123;                arr2[i] &#x3D; r.Next(0, 101);            &#125;            &#x2F;&#x2F;true代表升序排序 false代表降序排序            PaiXu( arr2, true);            &#x2F;&#x2F;中间间隔            Console.WriteLine();            Console.WriteLine(&quot;*************&quot;);            PaiXu( arr2, false);            #endregion        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月4日</title>
    <link href="/2022/05/04/diary/2022.5/2022%E5%B9%B45%E6%9C%884%E6%97%A5/"/>
    <url>/2022/05/04/diary/2022.5/2022%E5%B9%B45%E6%9C%884%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="ca17d6d80839b79c53b590df5936d99722a2d8593f839772f3c9ff00bcc3861c">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe5022d3d41ced9faff4c414d720080b2e532c1575e70f40aaaa88040ab450a6d1b0981729a275468a2721b3c204a6438005e1b5dd0eda5f210f00659b2455b19b448bfeb7c8941de5e1738392fcd8a90658b21cee475b6f6f7850c67a821be6789a381b5c6361d290687a364526d955099a05abcd6ca8f1caef52449ea73fe9ecc01d01c4dac98b49289d9b265518c538098ab70dfc8a28cb57379f527e9bd0a41b7ed937d545fc2ec58cbcb8e1836d320435d2f561d0b922aeefd20c5a25dd8bd482b3affd7788f1026b0d164a7a1200be4ab783d22b509cc73df2d4a874d0927a13e57e9ec51d570395fa33de0e935b103a40adc0cfe9ff993878099917f32a5a19d88c26393c99c0a4890ce9ff8564a79291510b8245fc819b0234d92ced7002d06feb702682424bbe6ab3322e9c0dbd3577666fb907d3216a13cc3cbd10869f2c9845eac2453c3363f1347ed6930624116787e8057962cc5e876f1a8aa89cd91c6b0f18a816b0ad8802c2c893771c661759aa20f59fadb7f1040662ad22398e09d575ce8ed41d9aeab6db4151b2948e28c5229464590834ddad0a940e32364b2e3c8d14458afbdfc789483484c8f258adb5c3faa2f4d91357f7d6c79ca83bb3ac087144bec966eb987b987ef814a4311ab886fb10d891ec7a453742f3faf3cdbe9545b4e543ed1022974eb5a499fc1d5d4acf78fa639948aa942b79af2d9fb253092f62af74adf84cedc58e522c50d20e8ecfb3e11c34f5edaa8d51de69d203dbe77a37e2178d21bae9e228c01061321d43002bda5dcf3e0a6714af76808dad9a16423791a676c4e6fb251bd2609d5b1adea9a7feb76a4a3fb6abb284b7de4aa2d12819871ef1469d3c4fa40fd7117c4bdd71bcc12738ac3ac2ed6fbb81a546a73511aeb0fda205c809615aec05f7d10edd4a61249d735f01843ea532b2aff4fed3afb9befaf5273192217c3f4dc2b0688271f585c76f41dd161360351247a0120360a70861bc6567d68c936eb575392ac8ccd8d9d37301b545f139307c88d27958347d808655a4bcbd9e524012d1ecf357c9953130f6834dfda6fb569a3b0db2074370860cb42f99fe730320a5549908fb11d3e1ada8913328b09f8910e1b0f9be670d6f16ae41c08ddb2baa5ea8be39be72bef47f792fd312f6a591964a4fcf60ae91793f4da790894159b69ee8eda7d54e722f14ecab819cf37c204f11f609b2201122ff5e24782387000c3e22ae5c1bc01de55aa50a7345e37ab938f3f51990237004b7a81f2e5d7a75ac3b877d9619025b31d1ae3b07c8dd55b60c815f3a320b13854e8c7a3646e7b12a5dc8f6b29c451c03265998681ebce942f031eb2d72354bba0fc68a4f7482ae1d51833f71101d4175e13dfa242bbc4864f067ed446c8526a2449682d90e9ec80760a2ecdcc3018651157b6897825d906c9ddd2d926d9d75121c9ebaf9b4cc8911651a854785d2c17c1f607214a02f0532e9a27700168d4df41faa35855366c4e62864c05f153b16b0496363f215fac5c7c4238c9bbd1cb87567af61ff4f9b4bbc54decb3c5a7cd68ac1ab0c4791acf83d7c521134889163bf5fb9d549103823c9ad35cb00240f06330d3e4ddd534831ca1a61f5efdf96e5b192d1849f61a225db50ba046c62150b561f719fdb8a4b9e53dfae29a476b50442398bdf55d5f2b992b11adf99b1e2a972ff8d3032d37ea4a1b7857396b42e5f4f97327daa6683fa4a0e6967a7a2377b7dda7d678d53b85e993c07d2a475af2152156804da9e6234dd1ff032fa4d4fed908990a59ac9e3e457a5715f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月3日</title>
    <link href="/2022/05/04/diary/2022.5/2022%E5%B9%B45%E6%9C%883%E6%97%A5/"/>
    <url>/2022/05/04/diary/2022.5/2022%E5%B9%B45%E6%9C%883%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="eca6d1fe149299d16fdebff137629187afd2b07ff353739ed1229d83d3640d27">a03af1012de36d86e65bfb0d51f6ff10900603ce8e1feef70407caf928a182bf41b818d5f65dbb1254e9f8e8cd0146ef1a8971be6ac892f2b981ce4dc32dbe5009c12dd1b715f42596ff4c88e24a0cfe8922606d46efa74ddbd9f5d3b426f56687102603786378470a4ecaae8b2313d0c003aaefde25d0f4bfa6cf8adcc4fbaa0a568aa7648f307311400a354664366507492f645fe02049bb0be8437ca7c835fca64706458d6fdd363a529564b60a3b26384e67ab2e038ad4b5d30b6a9c4925856a93271e13ba94afa16c26633b31e9ee540bb1ddb9f30dbc9f02df3101ce70b7d2d6b666fd3296fee8a9d4e1cd30d4e2808d3d23569489143fe1ce520c639063e2260f47b9a0435d49c601b499354313d5749d8dedd8f136d00fe0e3e3c2e078e7d7b8e484c261a9f9daefd65ce671fa990edd217fb86de23e9982edc3d0881d85390fd9fecf94c8b90918bb57a8ba3336b474952f80f1a08fc8634c8bcc0cb6d38bb2402a896db95b4f7356a1e11ada26cd4796de4a3c305847a1a2cab31f9794c08599ff6db9b0c4e89cb8aada39df07c2787d825ab709670194aa34c42a28e6d2b353bc49a39d7206a416b5f9a1db7705a31fd3378793c16f46334dff3101d76794745deaf80cea915eab7185931cce95ed77726e596ed18cd8418533fff97e9920cd9c00a880649087d082db0273ff52138bb8bcd3c7e58f3aac7f95ce6315df7225142d7485580499691c74ab94a1bd67ab7090999d80461c634d04653ce41bf84b6d17cd9af5fb85f31a7f132c467cb8f634b56c0ef59186ec1f561eaa4256804a827ca8f556e7afea92a81664dabaebfb2922af74339be92e7467846da05585de7ea69713758bb31bfb9be3</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构体</title>
    <link href="/2022/05/03/CSharp/CSharp%E5%85%A5%E9%97%A8/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <url>/2022/05/03/CSharp/CSharp%E5%85%A5%E9%97%A8/%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<p>2022.5.3</p><span id="more"></span><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>重点知识点：<br><strong>结构体</strong><br>1.概念： 结构体 struct 是变量和函数的集合 用来表示特定的数据集合<br>2.访问修饰符：用来修饰变量和方法  public-&gt;外部可以调用   private-&gt;只能内部调用   不写默认private<br>3.构造函数：没有返回值 函数名和结构体名相同 可以重载 主要是帮助我们快速初始化结构体对象</p><p>注意：<br>1.在结构体中声明的变量不能初始化  只能在外部或者函数中赋值（初始化）<br>2.在结构体中声明的函数 不用加static</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><img src="/2022/05/03/CSharp/CSharp%E5%85%A5%E9%97%A8/%E7%BB%93%E6%9E%84%E4%BD%93/exam.png" class=""><p>以下是答案：</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson12_结构体练习题&#123;    #region 练习题1    struct Student    &#123;               public string name;        public bool sex;        public int age;        public int lesson;        public string major;        public Student(string name, bool sex, int age, int lesson, string major)        &#123;            this.name &#x3D; name;                       this.sex &#x3D; sex;            this.age &#x3D; age;            this.lesson &#x3D; lesson;            this.major &#x3D; major;        &#125;        public void Information()        &#123;            Console.WriteLine(&quot;学员姓名&#123;0&#125;,性别&#123;1&#125;,年龄&#123;2&#125;,班级&#123;3&#125;,专业&#123;4&#125;&quot;, name, age, age, lesson, major);        &#125;    &#125;    #endregion    #region 练习题2    &#x2F;&#x2F;他们都是访问修饰符 用来修饰变量和方法    &#x2F;&#x2F;private 只能内部调用    &#x2F;&#x2F;public  外部可以调用    #endregion    #region 练习题3    struct Rectangular    &#123;        public int x;        public int y;        public Rectangular(int x, int y)        &#123;            this.x &#x3D; x;            this.y &#x3D; y;        &#125;        public void Information()        &#123;            Console.WriteLine(&quot;矩形的长为&#123;0&#125;,宽为&#123;1&#125;,面积为&#123;2&#125;,周长为&#123;3&#125;&quot;, x, y, x * y, 2 *(x + y));        &#125;    &#125;    #endregion    #region 练习题4    struct PlayerInfo    &#123;        public string name;        public E_Occupation occupation;                public PlayerInfo(string name, E_Occupation occupation)        &#123;            this.name &#x3D; name;            this.occupation &#x3D; occupation;                &#125;        public void AttackInformation()        &#123;            string o &#x3D; &quot;&quot;;            string s &#x3D; &quot;&quot;;            switch (occupation)            &#123;                case E_Occupation.Warrior:                    o &#x3D; &quot;战士&quot;;                    s &#x3D; &quot;冲锋&quot;;                    break;                case E_Occupation.Hunter:                    o &#x3D; &quot;猎人&quot;;                    s &#x3D; &quot;假死&quot;;                    break;                case E_Occupation.Witch:                    o &#x3D; &quot;法师&quot;;                    s &#x3D; &quot;奥术冲击&quot;;                    break;            &#125;            Console.WriteLine(&quot;&#123;0&#125;&#123;1&#125;施放了&#123;2&#125;&quot;, o, name, s);        &#125;    &#125;    enum E_Occupation    &#123;        Warrior,        Hunter,        Witch,    &#125;    #endregion    #region 练习题5    struct Monster    &#123;        public string name;        public int atk;        public Monster(string name)        &#123;            this.name &#x3D; name;            Random r &#x3D; new Random();            atk &#x3D; r.Next( 10, 30 );        &#125;        public void Atk()        &#123;            Console.WriteLine(&quot;&#123;0&#125;的攻击力是&#123;1&#125;&quot;, name, atk);        &#125;    &#125;    #endregion    #region 练习题7    struct UltraMan    &#123;        public string name;        public int atk;        public int def;        public int hp;        public UltraMan(string name, int atk, int def, int hp)        &#123;            this.name &#x3D; name;            this.atk &#x3D; atk;            this.def &#x3D; def;            this.hp &#x3D; hp;                   &#125;        &#x2F;&#x2F;结构体是值类型 想要在函数内部改变值类型信息 外部受影响 一定要用ref或out        public void Attack(ref Boss monster)        &#123;            &#x2F;&#x2F;奥特曼打怪兽的逻辑            monster.hp -&#x3D; atk - monster.def;            Console.WriteLine(&quot;&#123;0&#125;攻击了&#123;1&#125;，造成了&#123;2&#125;点伤害，&#123;1&#125;剩余血量&#123;3&#125;&quot;, name, monster.name, atk - monster.def, monster.hp);        &#125;    &#125;    struct Boss    &#123;        public string name;        public int atk;        public int def;        public int hp;        public Boss(string name, int atk, int def, int hp)        &#123;            this.name &#x3D; name;            this.atk &#x3D; atk;            this.def &#x3D; def;            this.hp &#x3D; hp;        &#125;        public void Attack(ref UltraMan Tiga)        &#123;            &#x2F;&#x2F;怪兽打奥特曼的逻辑            Tiga.hp -&#x3D; atk - Tiga.def;            Console.WriteLine(&quot;&#123;0&#125;攻击了&#123;1&#125;，造成了&#123;2&#125;点伤害，&#123;1&#125;剩余血量&#123;3&#125;&quot;, name, Tiga.name, atk - Tiga.def, Tiga.hp);        &#125;    &#125;    #endregion    internal class Program    &#123;                        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;结构体练习题&quot;);            #region 练习题1            Student s1 &#x3D; new Student(&quot;季宝&quot;, true, 23, 2, &quot;微电子&quot;);            Student s2 &#x3D; new Student(&quot;大逼&quot;, true, 23, 2, &quot;网安&quot;);            s1.Information();            s2.Information();            #endregion            #region 练习题3            Rectangular r1 &#x3D; new Rectangular (5, 4);            r1.Information();            #endregion            #region 练习题4            Console.Write(&quot;请输入玩家名字：&quot;);            string name &#x3D; Console.ReadLine();            Console.Write(&quot;请选择你的职业：（0战士，1猎人，2法师）&quot;);            try             &#123;                E_Occupation o &#x3D; (E_Occupation)int.Parse(Console.ReadLine());                PlayerInfo p1 &#x3D; new PlayerInfo(name ,o);                p1.AttackInformation();            &#125;            catch            &#123;                Console.WriteLine(&quot;请输入数字&quot;);            &#125;            #endregion            #region 练习题6            &#x2F;&#x2F;声明Monster数组            Monster[] monsters &#x3D; new Monster[10];            for (int i &#x3D; 0; i &lt; monsters.Length; i++)            &#123;                monsters[i] &#x3D; new Monster(&quot;怪兽&quot; + i);                monsters[i].Atk();            &#125;            #endregion            #region 练习题7            UltraMan Tiga &#x3D; new UltraMan(&quot;迪迦&quot;, 10, 5, 100);            Boss boss &#x3D; new Boss(&quot;哥斯拉&quot;, 8, 4, 100);            while(true)            &#123;                Tiga.Attack(ref boss);                if( boss.hp &lt;&#x3D; 0)                &#123;                    Console.WriteLine(&quot;迪迦胜利&quot;);                    break;                &#125;                boss.Attack(ref Tiga);                if (Tiga.hp &lt;&#x3D; 0)                &#123;                    Console.WriteLine(&quot;哥斯拉胜利&quot;);                    break;                &#125;                Console.WriteLine(&quot;按任意键继续&quot;);                Console.ReadKey(true);            &#125;            #endregion        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>递归函数</title>
    <link href="/2022/05/03/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/"/>
    <url>/2022/05/03/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>2022.5.3</p><span id="more"></span><h1 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h1><p>重点知识点：<br><strong>递归函数</strong><br>概念： 让函数自己调用自己<br>注意：<br>一个正确的递归函数<br>1.必须有结束调用的条件<br>2.用于条件判断的 这个条件必须改变 能够打到停止的目的</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><img src="/2022/05/03/CSharp/CSharp%E5%85%A5%E9%97%A8/%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/exam.png" class=""><div class="code-wrapper"><pre><code class="csharp">using System;namespace Lesson11_递归函数练习题&#123;    internal class Program    &#123;        #region 练习题1        static void ZeroTen(int a)        &#123;            if(a &gt; 10)            &#123;                return;            &#125;            Console.WriteLine(a);            ZeroTen(++a);        &#125;        #endregion        #region 练习题2        static int Factorial(int a)        &#123;            if(a == 1)            &#123;                return 1;            &#125;            return a * Factorial(--a);//--a应写在后面, 或用a - 1            //若是 Factorial(--a) * a ,后面的a是已经减掉的a,得不到正确结果        &#125;        #endregion        #region 练习题3        static long SumFactorial(int a)        &#123;            if(a == 1)            &#123;                return 1;            &#125;            return Factorial(a) + SumFactorial(--a);        &#125;        #endregion        #region 练习题4        //自己写的        static double ZhuganLength1(int a)        &#123;            if(a == 0)            &#123;                return 100;            &#125;            return 0.5 * ZhuganLength1(--a);        &#125;        //答案        //一是长度 二是天数        static void ZhuganLength2(double length, int day = 0)        &#123;            length /= 2;            ++day;            //第十天砍了后的长度            if (day == 10)            &#123;                Console.WriteLine(&quot;第十天砍后竹竿长&#123;0&#125;米&quot;, length);                return;            &#125;                        ZhuganLength2(length, day);        &#125;        #endregion        #region 练习题5        //看答案的 想不出来短路怎么写        static bool PrintNum(int a)        &#123;            Console.WriteLine(a);                       return a == 200 || PrintNum(a + 1);             //逻辑短路，若逻辑或前面的为真，不执行逻辑或后面的        &#125;                #endregion        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;递归函数练习题&quot;);            //ZeroTen(0);            Console.WriteLine(Factorial(5));            Console.WriteLine(SumFactorial(10));            Console.WriteLine(ZhuganLength1(10));            ZhuganLength2(100, 0);            PrintNum(1);        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏设想(更新中)</title>
    <link href="/2022/05/03/project_game/%E6%B8%B8%E6%88%8F%E8%AE%BE%E6%83%B3-%E6%9B%B4%E6%96%B0%E4%B8%AD/"/>
    <url>/2022/05/03/project_game/%E6%B8%B8%E6%88%8F%E8%AE%BE%E6%83%B3-%E6%9B%B4%E6%96%B0%E4%B8%AD/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="085b8f3c7f5217256b375c6ae6075e8a8adae91a0ade8f8a94c33da807588fd2">1432a7b75e994fca526a11f4c4c29edb5d95ddd08071f06d8e2b1881f40addc49717d4ad2129bf03f288d888dddd593047eece5bda476a758cc60ea414b92c2fde57109810737be6114d7bc1b6b7562288492faa485ce10d9f6299e57b851357b155e4efdd34cbdd97c62497dc707a8984ec16459a2b29863b8efb819d6be55fee9506e4cffd6a89bbbd6344b2f51a0b1deb0385f3209dfde7e16b2730acd43ef49c7653d1401cc12f99952648c7e9fac2e3d036f71ac2a224d882c9eb52b53e8ce41ad4adcb845a1ece03152a88f6b9b4a60f385b7cd2bb197f64876a288ef21ea0f1cd6c1413b5bb87c41430ede2ee3757bf646cb9be07686a61467b31f274ec251a3402c81ab754e4f64b4371f59d3e48b066a9d4374932d26748038e8972751dbd5ccf58182e5c1ffdd89532c2b4d16f4e9e2f1d2ca1aff8bf2b9f1a02ec8cb9b08156183203b1e6d5d9e33805bdfdcf86d2d455b22f3cf0c5256eeeba4ecd62b87719f83f61c86654cd68f2d2cca26593c99c9d37ac15226c4abb48fd006cebb943c3977b2e1e46f10646380aed592825f2f183df4476ec6f707913e8fe88cf823b72bf2aec4dc26fc020a783d26174557db927ca6c764208fa1f0de861d954ea17ba42cba643a0d82b2a34bbe7d1add7f69f822495de81deabf3f37c59366a1ad681568c2d6c73d0fbbe10b4f00148cd62c7e8c8ca89963dfdd89ea0201c6163f7a9d843737c71d4c25a133621e9b429eac7b530ca1162fa2a9c8f83a78239efbf362a28152fd1812b3bd1306bc1ce235d6944e5c6352f6a6d6d14cda004f50ae8f27c35d7eb6ebe68e6246b1766d92f34bbd91f1aafd140c0bdc584aa53d91b49fc7bde567c308953bb3021801af6fcec8d469dd0f7c38b11f9383c63f733c54f7ec71d8221103ac971dd97a1510cb199dad83bda9253e38f3f945571</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数重载</title>
    <link href="/2022/05/03/CSharp/CSharp%E5%85%A5%E9%97%A8/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/"/>
    <url>/2022/05/03/CSharp/CSharp%E5%85%A5%E9%97%A8/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<p>2022.5.2</p><span id="more"></span><h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><p>重点知识点：<br><strong>函数重载</strong><br>概念： 同一个语句块中，函数名相同，参数数量、类型、顺序不同的函数 就称为函数重载<br>注意： 和返回值无关<br>作用： 一般用来处理不同参数的同一类型的逻辑处理</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><img src="/2022/05/03/CSharp/CSharp%E5%85%A5%E9%97%A8/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/exam.jpg" class=""><p>以下是答案：</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson10_函数重载练习题&#123;    internal class Program    &#123;        #region 练习题1        static int CompareNum(int a, int b)        &#123;            return a &gt; b ? a : b;        &#125;        static float CompareNum(float a, float b)        &#123;            return a &gt; b ? a : b;        &#125;        static double CompareNum(double a, double b)        &#123;            return a &gt; b ? a : b;        &#125;        #endregion        #region 练习题2        static int CompareArray(int[] arr)        &#123;            int max &#x3D; arr[0];            for (int i &#x3D; 1; i &lt; arr.Length; i++)            &#123;                if (arr[i] &gt; max)                    max &#x3D; arr[i];            &#125;            return max;        &#125;        static float CompareArray(float[] arr)        &#123;            float max &#x3D; arr[0];            for (int i &#x3D; 1; i &lt; arr.Length; i++)            &#123;               if (arr[i] &gt; max)                   max &#x3D; arr[i];            &#125;            return max;        &#125;        static double CompareArray(double[] arr)        &#123;            double max &#x3D; arr[0];            for (int i &#x3D; 1; i &lt; arr.Length; i++)            &#123;                f (arr[i] &gt; max)                   max &#x3D; arr[i];            &#125;            return max;        &#125;        #endregion        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;函数重载练习题&quot;);            #region 练习题1            Console.WriteLine(CompareNum(5, 7));            Console.WriteLine(CompareNum(10.9f, 4.5f));            Console.WriteLine(CompareNum(20.975, 100.45));            #endregion            #region 练习题2            int[] arrInt &#x3D; &#123; 1, 4, 5, 8, 6 &#125;;            Console.WriteLine(CompareArray(arrInt));            float[] arrFloat &#x3D; &#123; 2.1f, 4.5f, 5.9f, 8.1f, 5.8f &#125;;            Console.WriteLine(CompareArray(arrFloat));            double[] arrDouble &#x3D; &#123; 1.2, 4.5, 5.8, 8.4, 6.6, 8.5 &#125;;            Console.WriteLine(CompareArray(arrDouble));            #endregion        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月2日</title>
    <link href="/2022/05/02/diary/2022.5/2022%E5%B9%B45%E6%9C%882%E6%97%A5/"/>
    <url>/2022/05/02/diary/2022.5/2022%E5%B9%B45%E6%9C%882%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="491f82e74d100b7c0ea7a128893e0938270b929bd3c36f691cdf1082d62df28d">a03af1012de36d86e65bfb0d51f6ff10488d28acf4ffb3e9d40e31ff66292b18d63fe0d726a396877e15d0f45ea8c4d0fca64270b3af481bbf674539be9d74ef68c82a089e06187f209c1d9148866c6889149615508e1920a0ba4dfede99cd4f1c78d484984659bc16451c78231727151c61eb8e511e88202c667f6492a364b4675af00dab110af61f89478fb7bf1e08ab42759f2346284503e36031ddd429d25b0534f43dda5bdafe4e506c1c70035c6cadad563a3c2357e939054059579347b9934247a362a556c365ea249a8dc505ce1d6d8ca02cfccd72b2a108d0eb68d21f51ea413ffdda474e96f5fc9814f7bcc309066ecda23a2402bfb054e09fd25585ec506d740893f0a92fefe328df54c6c5e30ccee78c493458af915a8bd62d591845f1826a4e9bb303d3f4ffa2a0a630ea2eeca8a0aa24bf1fac84529eca1eca00b428e66ee56674f67df6893fb3b6638bf6072f6e9a9070d033dbce154ec5f4f8cf9a7a4f71745f97e5632413ce634d8752541d453cc1f8efc43cb6e55f4f5387885b68fb16745bbfeab5b3f794bfcf28fa185ee8184906a049f0af8ad88ad4f440aa03d10017a143f7f5d6205e3de25d9d59cfa3851b9f2e81f5696c8a2a346b46a76c157a9c2ec305a56e0d7731f4171170433961c676df299d8c595faf5781699895fd001cb183f0542a53f04e059eb4aa707eb1ebec51596a61e4214457d3198eed0cd1c0fe925ad8fc6bcd34e0e0461ee7011d206c6498b0d22654c77579c9cad6d84edd07b81589b80dead8c40e53fffe3640728be6c57f1adecc1adae8789b3531cecd41f4e7f4fdba0c51531d5582c3f825cc4baf81d38a72ab443582fd97b24a4ac9d6c1678f5112c39bfa42e025e83c92e477964c88db0c102230ac7f4629e91dcb511bb7ade9fd16c786601f7194bf912cbed763641345d003c7f4b338765e3cdddfa403c98b5c030f06481f4598c8aa5a297abeb1492047cf5ad3c8496b451b942ff3336266c3b224372060d667f3d6346ba3004f5b9a598335fbc69ab72aa78c648cbf86d34d7d87a21e3675b42c696d20f83b50d8dc483eaa7a111f3b1534d4e39bc38e09196cc7d43fa342fa1233c4f07e63b8a1b464e3d7e0129d364e1556e6087b43e6dced704a2f793fe41e9f717c15c74c85b78c76b947e4ce7bb47e343b6ac8217d74f905bbdf1fee49a8beb58026eb33f2767416d12bc9838b2d1f102cbd24687614dd3a6e17f1367e92340e9641400d3882c9cd747a9447b4ccf8ebb10700132e285d8abc7b51413191a46b696898772325468360fef28752ae0335b0cff4d8aa52466cfc1ce30fd9ee0f7636af2696c47d23e8c8cdeddd2c9d3909f2e3f8d8538a1c26a9fb47e56892a3d0d4e1c9ceb9112a9dca53101795505354efe7a809cb4af82ea138c98c207b9900c5c9ed067cc8f724ee174489e410bb86821f0862bae558c20657a113c556316f8222ff65e9859371f0cf0c759ecf953da0cda9f4b302962e44</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>变长参数和参数默认值</title>
    <link href="/2022/05/02/CSharp/CSharp%E5%85%A5%E9%97%A8/%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC/"/>
    <url>/2022/05/02/CSharp/CSharp%E5%85%A5%E9%97%A8/%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>2022.5.2</p><span id="more"></span><h1 id="变长参数和参数默认值"><a href="#变长参数和参数默认值" class="headerlink" title="变长参数和参数默认值"></a>变长参数和参数默认值</h1><p>重点知识点：<br><strong>1 变长参数关键字 params</strong><br>作用： 可以传入n个同类型参数 n可以是0<br>注意：<br>    1.params 后面必须是数组 意味着只能是同一类型的可变参数<br>    2.变长参数只能有一个<br>    3.必须在所有参数后面写变长参数</p><p><strong>2 参数默认值（可选参数）</strong><br>作用：可以给参数默认值 使用时可以不传参 不传用默认的 传了用传的<br>注意：<br>    1.可选参数可以有多个<br>    2.正常参数必须写在可选参数前面，可选参数只能写在所有参数的后面</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><img src="/2022/05/02/CSharp/CSharp%E5%85%A5%E9%97%A8/%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC/exam.jpg" class=""><p>以下是答案：</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;namespace Lesson9_变长参数和参数默认值练习题&#123;    internal class Program    &#123;        #region 练习题1        static void SumAndAvg(params int[] arr)        &#123;            int sum &#x3D; 0;            for (int i &#x3D; 0; i &lt; arr.Length; i++)            &#123;                sum +&#x3D; arr[i];            &#125;            double avg &#x3D; sum &#x2F; (double)arr.Length;            Console.WriteLine(&quot;它们的和为&#123;0&#125;,平均数为&#123;1&#125;&quot;, sum, avg);        &#125;        #endregion        #region 练习题2        static void OddEven(params int[] arr)        &#123;            int odd &#x3D; 0, even &#x3D; 0;            for (int i &#x3D; 0; i &lt; arr.Length; i++)            &#123;                if(arr[i] % 2 &#x3D;&#x3D; 0)                &#123;                    even +&#x3D; arr[i];                &#125;                else                &#123;                    odd +&#x3D; arr[i];                &#125;            &#125;            Console.WriteLine(&quot;奇数和为&#123;0&#125;,偶数和为&#123;1&#125;&quot;, odd, even);        &#125;        #endregion        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;变长参数和参数默认值练习题&quot;);            #region 练习题1            SumAndAvg(5, 9, 11, 52);            #endregion            #region 练习题2            OddEven(10, 11, 12);            #endregion        &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ref和out</title>
    <link href="/2022/05/02/CSharp/CSharp%E5%85%A5%E9%97%A8/ref%E5%92%8Cout/"/>
    <url>/2022/05/02/CSharp/CSharp%E5%85%A5%E9%97%A8/ref%E5%92%8Cout/</url>
    
    <content type="html"><![CDATA[<p>2022.5.1</p><span id="more"></span><p>#ref和out</p><p>重点知识点：<br>1.ref和out的作用: 解决值类型和引用类型 在函数内部 改值 或者 重新声明 能够影响外部传入的变量 让其也被修改<br>2.使用上: 就是在声明参数的时候 前面加上ref和out的 关键字即可 使用时同上<br>3.区别：<br> 1.ref传入的变量必须初始化  out不用<br> 2.out传入的变量必须在内部赋值  ref不用</p><p>#练习题</p><img src="/2022/05/02/CSharp/CSharp%E5%85%A5%E9%97%A8/ref%E5%92%8Cout/exam.jpg" class=""><p>以下是答案：</p><div class="code-wrapper"><pre class="language-none"><code class="language-none">static bool Login(int user, int key, ref string info)    &#123;        if(user == 0)        &#123;            //用户名正确的逻辑            if(key == 0)            &#123;                //用户名正确且密码正确的逻辑                info = &quot;登录成功&quot;;            &#125;            else            &#123;                //密码错误的逻辑                info = &quot;密码错误&quot;;                return false;            &#125;        &#125;        else        &#123;            //用户名错误的逻辑            info = &quot;用户名错误&quot;;            return false;        &#125;               return true;    &#125;static void Main(string[] args)    &#123;        Console.WriteLine(&quot;请输入用户名和密码&quot;);            int user = int.Parse(Console.ReadLine());            int key = int.Parse(Console.ReadLine());            string info = &quot;&quot;; //ref需要初始化            while (!Login(user, key, ref info)) //若登录失败继续尝试            &#123;                Console.WriteLine(info); //登录失败直接进入循环 打印登陆失败                Console.WriteLine(&quot;请输入用户名和密码&quot;);                user = int.Parse(Console.ReadLine()); //不需要再声明                key = int.Parse(Console.ReadLine());            &#125;            Console.WriteLine(info);    &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年5月1日</title>
    <link href="/2022/05/01/diary/2022.5/2022%E5%B9%B45%E6%9C%881%E6%97%A5/"/>
    <url>/2022/05/01/diary/2022.5/2022%E5%B9%B45%E6%9C%881%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="速爬." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="8231443e481bad21d3be8c11f026cef33b9d2ec10d2c75db8a6a3fc9353e6db7">a03af1012de36d86e65bfb0d51f6ff1082829027e374e7685fe9ab85e3524a611ae1849435e4e7a720cff75f6e0c69420b45613e2699125232dbe72ca80048bebea598f361ba86018511cca15b95988dc0cfaef36e0d9831c314d5a5c0c42027b37202a638339207f929734f64e08597cbddc5ea522252e2e02962224d8f2610c567a9905f51b07d0b9ecc25ce9b92d845f910467ef77166d775f3ecd0d5e21bf953b08187237aa313add55b1c228dd7d053f127c9a6a47c0c5a7938ac994063ac4002df1fa06e05aafb90d8bc2640f6cd006d7ed7c8863170e64e1bd6245c77b0fa8e735e224b950e1f54e78b0133b701d1403fb2cfdf2d386b43e9fbaa1451076e4191f3d354e3fffc715fac93c09b38122dd8cb11d8342dc0c89192430adca4b08219e517801151b2a0f8c9d9db1c25359477c00a5f8a9d1f4dde7f15395f067821cdc6c518b824eb6db732a6f9509e2879bd5d893c34ef5dd9fb4feedd57143b5d8aaf6a95442b8ceaff1b20ed7a0103ef67d68f97923d95e97146672a06d3dbddf62d8d0308409f487798bfb2890628acb6da93b261a2be6b203fc5941ccf4602858ff06456f1cd8549bb19df0507e01adc30cf1edc3cf2ec7b1df2a01b64cbd75040011043907e573076bddaa0b8a1fd0278e802bee90f5473a88a8c185022aba3ed8be34c76a5f6841409c505a1b3068b32090cb5b1185e0bf33fc4b5a25b6b0dd4bbf90f8dbe9dcd98b38b25733197162851b604f16a5d7772dc986f3421c043d218bb4333b43d9982b085bbab19f29923bf644069879a756156a5ec5b6d9ac660e35e9544558afb91261123bcc30f7e00c6a468fe4f57c4a11fc966a618fc6f22037b00a3579d3f3ed4935bf7fa8ea29659083c3065e01531f9ca0aa7c185eb275f06844f98e1d86241cec7c6516f3c1490ef92db64b4894aa8b258b0ba055d641c53dbc0ac122fcf5d310d795b7943c3d1894ebd7906d91214d99dddb8546ee1ffc8f85958f09c8cde59fe895fc0b50b36ec620446c4ddc9685f8caccdebeca493bfe948808fb00921585db583e011fd37c3d175b970b75715e00d4b7e12ec96c492a95b96e523bb5e176bb0f49b3ff8ca86fdb500a752bda74eee760803b291021a3b9f0126cd7bb23dd1e72f470659f85b746c63aacba02862c6854f0b1ed71aad37a7828628896f1d5102453015e7769e691b07182728455dafcbc3e954aac72ef8a611d29a2392426ab51e80c901b6d0f46356365fa9660c731b71e7105a4a38d26fbffc6e804be1de7dafd2888b15a688c5d0b44b925821bb280a6ad0b3e82e48cec923663f4c22edb27946f90144f4df62e0c193bfa4186c0436989434570289d5a8a70a5823b41e640d330234ebaee4eceb1523b43b168b8a107765dd1b102c41cd200d3899fa241b87e8473e40b0d49ac9044249d8f74419b7507518041f3d7aad9e2152b0f8f425906095dd601697acd1a70bf3f5f2f64a0d38118e03282f3ae2a9ab8c9cc695c9f64a8cc722703e6e6805e21245b11f8f26228b91e66bd1b6f8d3ded0181491370dad82bdd46863138d11c8c6e4c70811bbb0afa15a450570fba043e2aa477441cf006111f916f0f80445a7ce1780af01a2b8688c4f70a758f6e7579d5d3cf9ddcc6a1dc3a83744c3ceb40f10fb072cb04940867ea5d2e7d7373bc2201d1c30a976745440597f87dd867d870c146ef3d4277dea046a21e2c758895343dde22f37061758a16095030c3f2664f9abb1f771ac28e2f55925974c7771f54557e447ebb7bee6449d22e52053925b248b05ba706590eedf6e24c1ea9f3685b83fd21e20dc9a8fdd87bb65266ddf72d99eaca5f7786afca9b98817f3c1a32ff87f776475024dd53cdbabc996921be1a50d5478a6f92cbd1f05885dce23af78eb58979c608fc64d3adf796861c673610fd9bf47793893da8bfcc7d0c9217244cb8768e699c45fb85d0658640db520170b1a420b72d890b4d056ef168bba17bd957af12f5239e8ae0687848c2e630234b4b46f680c1bce2cbd9711dabba8425ab03056c3a5f9592d7745499784fd25ade98ca511819ce01db178db801b75528f8dddb4aaf68cfbd76889f8720f774514aff1ef12734bf07f573b716d746e1ac572d62c788de740b599cfd6705a91db8c2d0974f2fafa47072dc231e1634008624e648489d915542f3bf2343b56b8b41482638b9cff93a60fd1d221550bfe947e4fafc8f7666803db2210081228e94e2e143133f3b851c8a2f5524e0c612da970f01576fd2f2c704bb10d79e52c7b75d8ca01c7a7f1aae45e43de5b208a64c4006038a8cb</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
